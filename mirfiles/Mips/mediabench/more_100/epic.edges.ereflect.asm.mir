--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/epic/epic.edges.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.EDGE_HANDLER = type { i8*, i32 (...)* }
  
  @edge_foos = internal unnamed_addr constant [9 x %struct.EDGE_HANDLER] [%struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect2 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @repeat to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @zero to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @extend to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @nocompute to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @predict to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @ereflect to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }], align 4
  @.str.1 = private unnamed_addr constant [9 x i8] c"reflect1\00", align 1
  @.str.2 = private unnamed_addr constant [9 x i8] c"reflect2\00", align 1
  @.str.3 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
  @.str.4 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
  @.str.5 = private unnamed_addr constant [7 x i8] c"extend\00", align 1
  @.str.6 = private unnamed_addr constant [13 x i8] c"dont-compute\00", align 1
  @.str.7 = private unnamed_addr constant [8 x i8] c"predict\00", align 1
  @.str.8 = private unnamed_addr constant [9 x i8] c"ereflect\00", align 1
  @.str.9 = private unnamed_addr constant [9 x i8] c"treflect\00", align 1
  @str = private unnamed_addr constant [30 x i8] c"No such edge handler routine!\00"
  
  ; Function Attrs: nounwind
  define i32 (...)* @edge_function(i8* nocapture readonly %edges) #0 {
    %1 = tail call i32 @strcmp(i8* %edges, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0))
    %2 = icmp eq i32 %1, 0
    br i1 %2, label %3, label %6
  
  ; <label>:3                                       ; preds = %28, %25, %22, %19, %16, %13, %10, %6, %0
    %i.02.lcssa = phi i32 [ 0, %0 ], [ 1, %6 ], [ 2, %10 ], [ 3, %13 ], [ 4, %16 ], [ 5, %19 ], [ 6, %22 ], [ 7, %25 ], [ 8, %28 ]
    %4 = getelementptr inbounds [9 x %struct.EDGE_HANDLER], [9 x %struct.EDGE_HANDLER]* @edge_foos, i32 0, i32 %i.02.lcssa, i32 1
    %5 = load i32 (...)*, i32 (...)** %4, align 4, !tbaa !1
    br label %9
  
  ; <label>:6                                       ; preds = %0
    %7 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
    %8 = icmp eq i32 %7, 0
    br i1 %8, label %3, label %10
  
  ; <label>:9                                       ; preds = %31, %3
    %.0 = phi i32 (...)* [ %5, %3 ], [ null, %31 ]
    ret i32 (...)* %.0
  
  ; <label>:10                                      ; preds = %6
    %11 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0))
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %3, label %13
  
  ; <label>:13                                      ; preds = %10
    %14 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
    %15 = icmp eq i32 %14, 0
    br i1 %15, label %3, label %16
  
  ; <label>:16                                      ; preds = %13
    %17 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0))
    %18 = icmp eq i32 %17, 0
    br i1 %18, label %3, label %19
  
  ; <label>:19                                      ; preds = %16
    %20 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0))
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %3, label %22
  
  ; <label>:22                                      ; preds = %19
    %23 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0))
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %3, label %25
  
  ; <label>:25                                      ; preds = %22
    %26 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
    %27 = icmp eq i32 %26, 0
    br i1 %27, label %3, label %28
  
  ; <label>:28                                      ; preds = %25
    %29 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0))
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %3, label %31
  
  ; <label>:31                                      ; preds = %28
    %puts = tail call i32 @puts(i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @str, i32 0, i32 0))
    br label %9
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #1
  
  ; Function Attrs: norecurse nounwind
  define i32 @zero(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph7.preheader, label %._crit_edge
  
  .lr.ph7.preheader:                                ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep6 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph7
  
  .lr.ph7:                                          ; preds = %.loopexit, %.lr.ph7.preheader
    %lsr.iv7 = phi float* [ %43, %.loopexit ], [ %scevgep6, %.lr.ph7.preheader ]
    %lsr.iv1 = phi float* [ %42, %.loopexit ], [ %filt, %.lr.ph7.preheader ]
    %y_filt.06 = phi i32 [ %27, %.loopexit ], [ 0, %.lr.ph7.preheader ]
    %y_res.05 = phi i32 [ %41, %.loopexit ], [ %22, %.lr.ph7.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.06, %x_dim
    %notlhs = icmp slt i32 %y_res.05, 0
    %notrhs = icmp sge i32 %y_res.05, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph7, %36
    %lsr.iv10 = phi float* [ %scevgep11, %36 ], [ %lsr.iv7, %.lr.ph7 ]
    %lsr.iv3 = phi float* [ %scevgep4, %36 ], [ %lsr.iv1, %.lr.ph7 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %36 ], [ 0, %.lr.ph7 ]
    %28 = add i32 %10, %lsr.iv
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %36
  
  ; <label>:32                                      ; preds = %.lr.ph
    %33 = bitcast float* %lsr.iv3 to i32*
    %34 = bitcast float* %lsr.iv10 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    br label %36
  
  ; <label>:36                                      ; preds = %32, %.lr.ph
    %lsr.iv.next = add i32 %lsr.iv, 1
    %37 = add i32 %y_filt.06, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %scevgep11 = getelementptr float, float* %lsr.iv10, i32 1
    %38 = icmp slt i32 %37, %27
    br i1 %38, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %36, %.lr.ph7
    %39 = bitcast float* %lsr.iv1 to i1*
    %40 = bitcast float* %lsr.iv7 to i1*
    %41 = add nsw i32 %y_res.05, %x_dim
    %scevgep = getelementptr i1, i1* %39, i32 %24
    %42 = bitcast i1* %scevgep to float*
    %scevgep9 = getelementptr i1, i1* %40, i32 %24
    %43 = bitcast i1* %scevgep9 to float*
    %44 = icmp slt i32 %27, %1
    br i1 %44, label %.lr.ph7, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @repeat(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.preheader.lr.ph, label %._crit_edge6
  
  .preheader.lr.ph:                                 ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = sub nsw i32 %1, %x_dim
    %25 = add nsw i32 %x_dim, -1
    %26 = shl i32 %x_dim, 2
    br label %.preheader
  
  .preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
    %lsr.iv1 = phi float* [ %48, %._crit_edge ], [ %filt, %.preheader.lr.ph ]
    %y_filt.05 = phi i32 [ 0, %.preheader.lr.ph ], [ %28, %._crit_edge ]
    %y_res.04 = phi i32 [ %22, %.preheader.lr.ph ], [ %47, %._crit_edge ]
    %27 = icmp sgt i32 %x_dim, 0
    %28 = add nsw i32 %y_filt.05, %x_dim
    br i1 %27, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader
    %29 = icmp sgt i32 %y_res.04, -1
    %30 = icmp slt i32 %y_res.04, %1
    %y_res.0. = select i1 %30, i32 %y_res.04, i32 %24
    %y_res.0.. = select i1 %29, i32 %y_res.0., i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %31, %.lr.ph
    %lsr.iv3 = phi float* [ %scevgep4, %31 ], [ %lsr.iv1, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %31 ], [ 0, %.lr.ph ]
    %32 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %33 = add i32 %10, %lsr.iv
    %34 = icmp sgt i32 %33, -1
    %35 = add i32 %10, %lsr.iv
    %36 = icmp slt i32 %35, %x_dim
    %37 = add i32 %10, %lsr.iv
    %38 = select i1 %36, i32 %37, i32 %25
    %39 = select i1 %34, i32 %38, i32 0
    %40 = add nsw i32 %39, %y_res.0..
    %41 = getelementptr inbounds float, float* %result, i32 %40
    %42 = load float, float* %41, align 4, !tbaa !6
    %43 = fadd float %32, %42
    store float %43, float* %41, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, 1
    %44 = add i32 %y_filt.05, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %45 = icmp slt i32 %44, %28
    br i1 %45, label %31, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %31, %.preheader
    %46 = bitcast float* %lsr.iv1 to i1*
    %47 = add nsw i32 %y_res.04, %x_dim
    %scevgep = getelementptr i1, i1* %46, i32 %26
    %48 = bitcast i1* %scevgep to float*
    %49 = icmp slt i32 %28, %1
    br i1 %49, label %.preheader, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect2(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = mul nsw i32 %5, %x_dim
    %7 = select i1 %4, i32 %6, i32 0
    %8 = mul i32 %y_dim, %x_dim
    %9 = xor i32 %x_dim, -1
    %.v = select i1 %1, i32 %9, i32 1
    %10 = add i32 %.v, %x_pos
    %11 = icmp sgt i32 %8, 0
    br i1 %11, label %.lr.ph5.preheader, label %._crit_edge6
  
  .lr.ph5.preheader:                                ; preds = %0
    %12 = icmp sgt i32 %y_pos, 0
    %13 = xor i32 %y_dim, -1
    %.v10 = select i1 %12, i32 %13, i32 1
    %14 = add i32 %.v10, %y_pos
    %15 = mul nsw i32 %14, %x_dim
    %result11 = bitcast float* %result to i8*
    %16 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %result11, i8 0, i32 %16, i32 4, i1 false)
    %17 = shl i32 %x_dim, 2
    br label %.lr.ph5
  
  .lr.ph5:                                          ; preds = %._crit_edge, %.lr.ph5.preheader
    %lsr.iv = phi float* [ %51, %._crit_edge ], [ %filt, %.lr.ph5.preheader ]
    %y_filt.04 = phi i32 [ %21, %._crit_edge ], [ 0, %.lr.ph5.preheader ]
    %y_edge.03 = phi i32 [ %50, %._crit_edge ], [ %15, %.lr.ph5.preheader ]
    %18 = icmp sgt i32 %x_dim, 0
    %19 = icmp eq i32 %y_edge.03, 0
    %20 = select i1 %19, i32 %x_dim, i32 0
    %.y_edge.0 = add nsw i32 %20, %y_edge.03
    %21 = add nsw i32 %y_filt.04, %x_dim
    br i1 %18, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.lr.ph5
    %22 = icmp sgt i32 %.y_edge.0, -1
    %23 = sub nsw i32 0, %.y_edge.0
    %24 = select i1 %22, i32 %.y_edge.0, i32 %23
    %25 = sub nsw i32 %7, %24
    %26 = add nsw i32 %25, %x_dim
    %27 = icmp sgt i32 %26, -1
    %28 = sub nsw i32 0, %26
    %29 = select i1 %27, i32 %26, i32 %28
    br label %30
  
  ; <label>:30                                      ; preds = %30, %.lr.ph
    %lsr.iv2 = phi float* [ %scevgep3, %30 ], [ %lsr.iv, %.lr.ph ]
    %x_filt.02 = phi i32 [ %y_filt.04, %.lr.ph ], [ %46, %30 ]
    %x_edge.01 = phi i32 [ %10, %.lr.ph ], [ %47, %30 ]
    %31 = icmp eq i32 %x_edge.01, 0
    %32 = zext i1 %31 to i32
    %.x_edge.0 = add nsw i32 %32, %x_edge.01
    %33 = load float, float* %lsr.iv2, align 4, !tbaa !6
    %34 = icmp sgt i32 %.x_edge.0, -1
    %35 = sub nsw i32 0, %.x_edge.0
    %36 = select i1 %34, i32 %.x_edge.0, i32 %35
    %37 = sub nsw i32 %3, %36
    %38 = add nsw i32 %37, 1
    %39 = icmp sgt i32 %37, -2
    %40 = xor i32 %37, -1
    %41 = select i1 %39, i32 %38, i32 %40
    %42 = add nsw i32 %41, %29
    %43 = getelementptr inbounds float, float* %result, i32 %42
    %44 = load float, float* %43, align 4, !tbaa !6
    %45 = fadd float %33, %44
    store float %45, float* %43, align 4, !tbaa !6
    %46 = add nsw i32 %x_filt.02, 1
    %47 = add nsw i32 %.x_edge.0, 1
    %scevgep3 = getelementptr float, float* %lsr.iv2, i32 1
    %48 = icmp slt i32 %46, %21
    br i1 %48, label %30, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %30, %.lr.ph5
    %49 = bitcast float* %lsr.iv to i1*
    %50 = add nsw i32 %.y_edge.0, %x_dim
    %scevgep = getelementptr i1, i1* %49, i32 %17
    %51 = bitcast i1* %scevgep to float*
    %52 = icmp slt i32 %21, %8
    br i1 %52, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %0
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect1(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph22.preheader, label %._crit_edge23
  
  .lr.ph22.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %.lr.ph22.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge23
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.4 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.4, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.5 = select i1 %51, i32 0, i32 %26
    %.6 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge23
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge23 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge23 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge23 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge23 ], [ %.5, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge23 ], [ %.6, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge23 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph18.preheader, label %._crit_edge19
  
  .lr.ph18.preheader:                               ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep9 = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %.lr.ph18
  
  .lr.ph18:                                         ; preds = %._crit_edge, %.lr.ph18.preheader
    %lsr.iv10 = phi float* [ %85, %._crit_edge ], [ %scevgep9, %.lr.ph18.preheader ]
    %y_edge.016 = phi i32 [ %y_edge_dist.0, %.lr.ph18.preheader ], [ %84, %._crit_edge ]
    %y_filt.015 = phi i32 [ %y_start.0, %.lr.ph18.preheader ], [ %83, %._crit_edge ]
    %59 = add nsw i32 %y_filt.015, %x_start.1
    %60 = add nsw i32 %y_filt.015, %x_stop.1
    %61 = icmp slt i32 %59, %60
    br i1 %61, label %.lr.ph14, label %._crit_edge
  
  .lr.ph14:                                         ; preds = %.lr.ph18
    %62 = icmp sgt i32 %y_edge.016, -1
    %63 = sub nsw i32 0, %y_edge.016
    %64 = select i1 %62, i32 %y_edge.016, i32 %63
    %65 = sub nsw i32 %8, %64
    %66 = icmp sgt i32 %65, -1
    %67 = sub nsw i32 0, %65
    %68 = select i1 %66, i32 %65, i32 %67
    br label %69
  
  ; <label>:69                                      ; preds = %69, %.lr.ph14
    %lsr.iv13 = phi float* [ %scevgep14, %69 ], [ %lsr.iv10, %.lr.ph14 ]
    %lsr.iv7 = phi i32 [ %lsr.iv.next8, %69 ], [ %56, %.lr.ph14 ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next, %69 ], [ %55, %.lr.ph14 ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph14 ], [ %81, %69 ]
    %70 = load float, float* %lsr.iv13, align 4, !tbaa !6
    %71 = icmp sgt i32 %x_edge.013, -1
    %72 = select i1 %71, i32 %x_edge.013, i32 %lsr.iv6
    %73 = sub nsw i32 %4, %72
    %74 = icmp sgt i32 %73, -1
    %75 = sub nsw i32 0, %73
    %76 = select i1 %74, i32 %73, i32 %75
    %77 = add nsw i32 %76, %68
    %78 = getelementptr inbounds float, float* %result, i32 %77
    %79 = load float, float* %78, align 4, !tbaa !6
    %80 = fadd float %70, %79
    store float %80, float* %78, align 4, !tbaa !6
    %81 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv6, -1
    %lsr.iv.next8 = add i32 %lsr.iv7, -1
    %scevgep14 = getelementptr float, float* %lsr.iv13, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next8, 0
    br i1 %exitcond, label %._crit_edge, label %69
  
  ._crit_edge:                                      ; preds = %69, %.lr.ph18
    %82 = bitcast float* %lsr.iv10 to i1*
    %83 = add nsw i32 %y_filt.015, %x_dim
    %84 = add nsw i32 %y_edge.016, %x_dim
    %scevgep12 = getelementptr i1, i1* %82, i32 %58
    %85 = bitcast i1* %scevgep12 to float*
    %86 = icmp slt i32 %83, %y_stop.0
    br i1 %86, label %.lr.ph18, label %._crit_edge19
  
  ._crit_edge19:                                    ; preds = %._crit_edge, %53
    %87 = icmp eq i32 %f_or_e, 1
    br i1 %87, label %88, label %.loopexit
  
  ; <label>:88                                      ; preds = %._crit_edge19
    %89 = icmp sgt i32 %x_pos, -1
    %90 = sub nsw i32 0, %x_pos
    %91 = select i1 %89, i32 %x_pos, i32 %90
    %92 = icmp ne i32 %91, %28
    %93 = icmp ne i32 %x_pos, 0
    %or.cond = and i1 %93, %92
    %94 = icmp slt i32 %4, %1
    %or.cond24 = and i1 %or.cond, %94
    br i1 %or.cond24, label %.lr.ph11.preheader, label %.loopexit8
  
  .lr.ph11.preheader:                               ; preds = %88
    %scevgep2 = getelementptr float, float* %result, i32 %4
    %95 = shl i32 %x_dim, 2
    br label %.lr.ph11
  
  .lr.ph11:                                         ; preds = %.lr.ph11, %.lr.ph11.preheader
    %lsr.iv3 = phi float* [ %99, %.lr.ph11 ], [ %scevgep2, %.lr.ph11.preheader ]
    %y_filt.110 = phi i32 [ %98, %.lr.ph11 ], [ %4, %.lr.ph11.preheader ]
    %lsr.iv34 = bitcast float* %lsr.iv3 to i1*
    %96 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %97 = fadd float %96, %96
    store float %97, float* %lsr.iv3, align 4, !tbaa !6
    %98 = add nsw i32 %y_filt.110, %x_dim
    %scevgep5 = getelementptr i1, i1* %lsr.iv34, i32 %95
    %99 = bitcast i1* %scevgep5 to float*
    %100 = icmp slt i32 %98, %1
    br i1 %100, label %.lr.ph11, label %.loopexit8
  
  .loopexit8:                                       ; preds = %.lr.ph11, %88
    %101 = icmp sgt i32 %y_pos, -1
    %102 = sub nsw i32 0, %y_pos
    %103 = select i1 %101, i32 %y_pos, i32 %102
    %104 = icmp ne i32 %103, %30
    %105 = icmp ne i32 %y_pos, 0
    %or.cond3 = and i1 %105, %104
    br i1 %or.cond3, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %.loopexit8
    %106 = add nsw i32 %8, %x_dim
    %107 = icmp sgt i32 %x_dim, 0
    br i1 %107, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %scevgep = getelementptr float, float* %result, i32 %8
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv = phi float* [ %scevgep1, %.lr.ph ], [ %scevgep, %.lr.ph.preheader ]
    %x_filt.19 = phi i32 [ %110, %.lr.ph ], [ %8, %.lr.ph.preheader ]
    %108 = load float, float* %lsr.iv, align 4, !tbaa !6
    %109 = fadd float %108, %108
    store float %109, float* %lsr.iv, align 4, !tbaa !6
    %110 = add nsw i32 %x_filt.19, 1
    %scevgep1 = getelementptr float, float* %lsr.iv, i32 1
    %111 = icmp slt i32 %110, %106
    br i1 %111, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %.preheader, %.loopexit8, %._crit_edge19
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @extend(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph21.preheader, label %._crit_edge22
  
  .lr.ph21.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge22
  
  ._crit_edge22:                                    ; preds = %.lr.ph21.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge22
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.3 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.3, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.4 = select i1 %51, i32 0, i32 %26
    %.5 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge22
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge22 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge22 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge22 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge22 ], [ %.4, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge22 ], [ %.5, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge22 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph17, label %._crit_edge18
  
  .lr.ph17:                                         ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %59
  
  ; <label>:59                                      ; preds = %._crit_edge, %.lr.ph17
    %lsr.iv3 = phi float* [ %117, %._crit_edge ], [ %scevgep, %.lr.ph17 ]
    %y_edge.015 = phi i32 [ %y_edge_dist.0, %.lr.ph17 ], [ %116, %._crit_edge ]
    %y_filt.014 = phi i32 [ %y_start.0, %.lr.ph17 ], [ %115, %._crit_edge ]
    %60 = add nsw i32 %y_filt.014, %x_start.1
    %61 = add nsw i32 %y_filt.014, %x_stop.1
    %62 = icmp slt i32 %60, %61
    br i1 %62, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %59
    %63 = icmp ne i32 %8, 0
    %64 = icmp sgt i32 %y_edge.015, 0
    %65 = icmp slt i32 %y_edge.015, 0
    %not. = xor i1 %64, true
    %66 = and i1 %65, %not.
    %67 = select i1 %63, i1 %64, i1 %66
    %68 = icmp sgt i32 %y_edge.015, -1
    %69 = sub nsw i32 0, %y_edge.015
    %70 = select i1 %68, i32 %y_edge.015, i32 %69
    %71 = sub nsw i32 %8, %70
    %72 = icmp sgt i32 %71, -1
    %73 = sub nsw i32 0, %71
    %74 = select i1 %72, i32 %71, i32 %73
    %75 = add nsw i32 %y_edge.015, %8
    %76 = icmp slt i32 %75, 0
    %77 = icmp slt i32 %75, %y_dim
    %.10 = select i1 %77, i32 %75, i32 %6
    %78 = select i1 %76, i32 0, i32 %.10
    br label %79
  
  ; <label>:79                                      ; preds = %112, %.lr.ph
    %lsr.iv6 = phi float* [ %scevgep7, %112 ], [ %lsr.iv3, %.lr.ph ]
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %112 ], [ %56, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %112 ], [ %55, %.lr.ph ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph ], [ %113, %112 ]
    %80 = icmp ne i32 %4, 0
    %81 = icmp sgt i32 %x_edge.013, 0
    %82 = icmp slt i32 %x_edge.013, 0
    %not.11 = xor i1 %81, true
    %83 = and i1 %82, %not.11
    %84 = select i1 %80, i1 %81, i1 %83
    %85 = xor i1 %67, %84
    %86 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %87 = icmp sgt i32 %x_edge.013, -1
    %88 = select i1 %87, i32 %x_edge.013, i32 %lsr.iv
    %89 = sub nsw i32 %4, %88
    %90 = icmp sgt i32 %89, -1
    %91 = sub nsw i32 0, %89
    %92 = select i1 %90, i32 %89, i32 %91
    %93 = add nsw i32 %92, %74
    %94 = getelementptr inbounds float, float* %result, i32 %93
    %95 = load float, float* %94, align 4, !tbaa !6
    br i1 %85, label %96, label %110
  
  ; <label>:96                                      ; preds = %79
    %97 = fsub float %95, %86
    store float %97, float* %94, align 4, !tbaa !6
    %98 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %99 = fadd float %98, %98
    %100 = add i32 %4, %x_edge.013
    %101 = icmp slt i32 %100, 0
    %102 = add i32 %4, %x_edge.013
    %103 = icmp slt i32 %102, %x_dim
    %104 = add i32 %4, %x_edge.013
    %.9 = select i1 %103, i32 %104, i32 %3
    %105 = select i1 %101, i32 0, i32 %.9
    %106 = add nsw i32 %105, %78
    %107 = getelementptr inbounds float, float* %result, i32 %106
    %108 = load float, float* %107, align 4, !tbaa !6
    %109 = fadd float %108, %99
    store float %109, float* %107, align 4, !tbaa !6
    br label %112
  
  ; <label>:110                                     ; preds = %79
    %111 = fadd float %86, %95
    store float %111, float* %94, align 4, !tbaa !6
    br label %112
  
  ; <label>:112                                     ; preds = %110, %96
    %113 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv, -1
    %lsr.iv.next2 = add i32 %lsr.iv1, -1
    %scevgep7 = getelementptr float, float* %lsr.iv6, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next2, 0
    br i1 %exitcond, label %._crit_edge, label %79
  
  ._crit_edge:                                      ; preds = %112, %59
    %114 = bitcast float* %lsr.iv3 to i1*
    %115 = add nsw i32 %y_filt.014, %x_dim
    %116 = add nsw i32 %y_edge.015, %x_dim
    %scevgep5 = getelementptr i1, i1* %114, i32 %58
    %117 = bitcast i1* %scevgep5 to float*
    %118 = icmp slt i32 %115, %y_stop.0
    br i1 %118, label %59, label %._crit_edge18
  
  ._crit_edge18:                                    ; preds = %._crit_edge, %53
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @nocompute(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %x_pos.off = add i32 %x_pos, 1
    %2 = icmp ugt i32 %x_pos.off, 2
    %y_pos.off = add i32 %y_pos, 1
    %3 = icmp ugt i32 %y_pos.off, 2
    %4 = or i1 %2, %3
    br i1 %4, label %.preheader, label %.preheader6
  
  .preheader6:                                      ; preds = %0
    %5 = icmp sgt i32 %1, 0
    br i1 %5, label %.lr.ph10.preheader, label %.loopexit
  
  .lr.ph10.preheader:                               ; preds = %.preheader6
    %6 = mul i32 %y_dim, %x_dim
    br label %.lr.ph10
  
  .preheader:                                       ; preds = %0
    %7 = icmp sgt i32 %1, 0
    br i1 %7, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %8 = bitcast float* %result to i8*
    %9 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %8, i8 0, i32 %9, i32 4, i1 false)
    br label %.loopexit
  
  .lr.ph10:                                         ; preds = %.lr.ph10, %.lr.ph10.preheader
    %lsr.iv3 = phi float* [ %scevgep4, %.lr.ph10 ], [ %filt, %.lr.ph10.preheader ]
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph10 ], [ %result, %.lr.ph10.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph10 ], [ %6, %.lr.ph10.preheader ]
    %lsr.iv35 = bitcast float* %lsr.iv3 to i32*
    %lsr.iv12 = bitcast float* %lsr.iv1 to i32*
    %10 = load i32, i32* %lsr.iv35, align 4, !tbaa !6
    store i32 %10, i32* %lsr.iv12, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %exitcond12 = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond12, label %.loopexit, label %.lr.ph10
  
  .loopexit:                                        ; preds = %.lr.ph10, %.lr.ph.preheader, %.preheader, %.preheader6
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  define i32 @ereflect(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #0 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = select i1 %4, i32 %5, i32 0
    %7 = mul nsw i32 %6, %x_dim
    %8 = mul i32 %y_dim, %x_dim
    %9 = icmp sgt i32 %x_pos, 1
    br i1 %9, label %10, label %12
  
  ; <label>:10                                      ; preds = %0
    %11 = sub nsw i32 %x_pos, %x_dim
    br label %16
  
  ; <label>:12                                      ; preds = %0
    %13 = icmp slt i32 %x_pos, -1
    %14 = add nsw i32 %x_pos, 1
    %15 = select i1 %13, i32 %14, i32 0
    br label %16
  
  ; <label>:16                                      ; preds = %12, %10
    %17 = phi i32 [ %11, %10 ], [ %15, %12 ]
    %18 = icmp sgt i32 %y_pos, 1
    br i1 %18, label %19, label %21
  
  ; <label>:19                                      ; preds = %16
    %20 = sub nsw i32 %y_pos, %y_dim
    br label %25
  
  ; <label>:21                                      ; preds = %16
    %22 = icmp slt i32 %y_pos, -1
    %23 = add nsw i32 %y_pos, 1
    %24 = select i1 %22, i32 %23, i32 0
    br label %25
  
  ; <label>:25                                      ; preds = %21, %19
    %26 = phi i32 [ %20, %19 ], [ %24, %21 ]
    %27 = icmp sgt i32 %8, 0
    br i1 %27, label %.preheader3.preheader, label %._crit_edge27
  
  .preheader3.preheader:                            ; preds = %25
    %28 = bitcast float* %result to i8*
    %29 = mul nsw i32 %26, %x_dim
    %30 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %28, i8 0, i32 %30, i32 4, i1 false)
    %31 = shl i32 %x_dim, 2
    %32 = sub i32 0, %17
    br label %.preheader3
  
  .preheader3:                                      ; preds = %._crit_edge23, %.preheader3.preheader
    %lsr.iv19 = phi float* [ %60, %._crit_edge23 ], [ %filt, %.preheader3.preheader ]
    %y_filt.026 = phi i32 [ %34, %._crit_edge23 ], [ 0, %.preheader3.preheader ]
    %y_edge.025 = phi i32 [ %59, %._crit_edge23 ], [ %29, %.preheader3.preheader ]
    %33 = icmp sgt i32 %x_dim, 0
    %34 = add nsw i32 %y_filt.026, %x_dim
    br i1 %33, label %.lr.ph22, label %._crit_edge23
  
  .lr.ph22:                                         ; preds = %.preheader3
    %35 = icmp sgt i32 %y_edge.025, -1
    %36 = sub nsw i32 0, %y_edge.025
    %37 = select i1 %35, i32 %y_edge.025, i32 %36
    %38 = sub nsw i32 %7, %37
    %39 = icmp sgt i32 %38, -1
    %40 = sub nsw i32 0, %38
    %41 = select i1 %39, i32 %38, i32 %40
    br label %42
  
  ; <label>:42                                      ; preds = %42, %.lr.ph22
    %lsr.iv24 = phi i32 [ %lsr.iv.next25, %42 ], [ %32, %.lr.ph22 ]
    %lsr.iv22 = phi float* [ %scevgep23, %42 ], [ %lsr.iv19, %.lr.ph22 ]
    %lsr.iv17 = phi i32 [ %lsr.iv.next18, %42 ], [ 0, %.lr.ph22 ]
    %43 = load float, float* %lsr.iv22, align 4, !tbaa !6
    %44 = add i32 %17, %lsr.iv17
    %45 = icmp sgt i32 %44, -1
    %46 = add i32 %17, %lsr.iv17
    %47 = select i1 %45, i32 %46, i32 %lsr.iv24
    %48 = sub nsw i32 %3, %47
    %49 = icmp sgt i32 %48, -1
    %50 = sub nsw i32 0, %48
    %51 = select i1 %49, i32 %48, i32 %50
    %52 = add nsw i32 %51, %41
    %53 = getelementptr inbounds float, float* %result, i32 %52
    %54 = load float, float* %53, align 4, !tbaa !6
    %55 = fadd float %43, %54
    store float %55, float* %53, align 4, !tbaa !6
    %lsr.iv.next18 = add i32 %lsr.iv17, 1
    %56 = add i32 %y_filt.026, %lsr.iv.next18
    %scevgep23 = getelementptr float, float* %lsr.iv22, i32 1
    %lsr.iv.next25 = add i32 %lsr.iv24, -1
    %57 = icmp slt i32 %56, %34
    br i1 %57, label %42, label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %42, %.preheader3
    %58 = bitcast float* %lsr.iv19 to i1*
    %59 = add nsw i32 %y_edge.025, %x_dim
    %scevgep21 = getelementptr i1, i1* %58, i32 %31
    %60 = bitcast i1* %scevgep21 to float*
    %61 = icmp slt i32 %34, %8
    br i1 %61, label %.preheader3, label %._crit_edge27
  
  ._crit_edge27:                                    ; preds = %._crit_edge23, %25
    %62 = icmp ne i32 %x_pos, 0
    %63 = icmp slt i32 %3, %8
    %or.cond = and i1 %62, %63
    br i1 %or.cond, label %.lr.ph19.preheader, label %.loopexit
  
  .lr.ph19.preheader:                               ; preds = %._crit_edge27
    %scevgep13 = getelementptr float, float* %result, i32 %3
    %64 = shl i32 %x_dim, 2
    br label %.lr.ph19
  
  .lr.ph19:                                         ; preds = %.lr.ph19, %.lr.ph19.preheader
    %lsr.iv14 = phi float* [ %70, %.lr.ph19 ], [ %scevgep13, %.lr.ph19.preheader ]
    %y_filt.118 = phi i32 [ %69, %.lr.ph19 ], [ %3, %.lr.ph19.preheader ]
    %lsr.iv1415 = bitcast float* %lsr.iv14 to i1*
    %65 = load float, float* %lsr.iv14, align 4, !tbaa !6
    %66 = fpext float %65 to double
    %67 = fmul double %66, 0x3FF6A09E667F3BCD
    %68 = fptrunc double %67 to float
    store float %68, float* %lsr.iv14, align 4, !tbaa !6
    %69 = add nsw i32 %y_filt.118, %x_dim
    %scevgep16 = getelementptr i1, i1* %lsr.iv1415, i32 %64
    %70 = bitcast i1* %scevgep16 to float*
    %71 = icmp slt i32 %69, %8
    br i1 %71, label %.lr.ph19, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph19, %._crit_edge27
    %72 = icmp eq i32 %y_pos, 0
    br i1 %72, label %.preheader, label %.preheader1
  
  .preheader1:                                      ; preds = %.loopexit
    %73 = add nsw i32 %7, %x_dim
    %74 = icmp sgt i32 %x_dim, 0
    br i1 %74, label %.lr.ph17.preheader, label %.preheader
  
  .lr.ph17.preheader:                               ; preds = %.preheader1
    %75 = mul i32 %6, %x_dim
    %scevgep10 = getelementptr float, float* %result, i32 %75
    br label %.lr.ph17
  
  .preheader:                                       ; preds = %.lr.ph17, %.preheader1, %.loopexit
    %76 = icmp sgt i32 %8, 0
    br i1 %76, label %.lr.ph13.preheader, label %._crit_edge14.thread
  
  .lr.ph13.preheader:                               ; preds = %.preheader
    %77 = mul i32 %y_dim, %x_dim
    br label %.lr.ph13
  
  ._crit_edge14.thread:                             ; preds = %.preheader
    %78 = tail call double @sqrt(double 0.000000e+00) #5
    %79 = fcmp oeq double %78, %78
    br i1 %79, label %._crit_edge10.thread, label %call.sqrt
  
  call.sqrt:                                        ; preds = %._crit_edge14.thread
    %80 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge10.thread
  
  .lr.ph17:                                         ; preds = %.lr.ph17, %.lr.ph17.preheader
    %lsr.iv11 = phi float* [ %scevgep12, %.lr.ph17 ], [ %scevgep10, %.lr.ph17.preheader ]
    %x_filt.116 = phi i32 [ %85, %.lr.ph17 ], [ %7, %.lr.ph17.preheader ]
    %81 = load float, float* %lsr.iv11, align 4, !tbaa !6
    %82 = fpext float %81 to double
    %83 = fmul double %82, 0x3FF6A09E667F3BCD
    %84 = fptrunc double %83 to float
    store float %84, float* %lsr.iv11, align 4, !tbaa !6
    %85 = add nsw i32 %x_filt.116, 1
    %scevgep12 = getelementptr float, float* %lsr.iv11, i32 1
    %86 = icmp slt i32 %85, %73
    br i1 %86, label %.lr.ph17, label %.preheader
  
  .lr.ph13:                                         ; preds = %.lr.ph13, %.lr.ph13.preheader
    %lsr.iv8 = phi float* [ %scevgep9, %.lr.ph13 ], [ %result, %.lr.ph13.preheader ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next7, %.lr.ph13 ], [ %77, %.lr.ph13.preheader ]
    %norm.012 = phi double [ %90, %.lr.ph13 ], [ 0.000000e+00, %.lr.ph13.preheader ]
    %87 = load float, float* %lsr.iv8, align 4, !tbaa !6
    %88 = fmul float %87, %87
    %89 = fpext float %88 to double
    %90 = fadd double %norm.012, %89
    %lsr.iv.next7 = add i32 %lsr.iv6, -1
    %scevgep9 = getelementptr float, float* %lsr.iv8, i32 1
    %exitcond33 = icmp eq i32 %lsr.iv.next7, 0
    br i1 %exitcond33, label %._crit_edge14, label %.lr.ph13
  
  ._crit_edge14:                                    ; preds = %.lr.ph13
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %._crit_edge14.split, label %call.sqrt26
  
  call.sqrt26:                                      ; preds = %._crit_edge14
    %93 = tail call double @sqrt(double %90) #6
    br label %._crit_edge14.split
  
  ._crit_edge14.split:                              ; preds = %._crit_edge14, %call.sqrt26
    %94 = phi double [ %91, %._crit_edge14 ], [ %93, %call.sqrt26 ]
    %95 = icmp sgt i32 %8, 0
    br i1 %95, label %.lr.ph9.preheader, label %._crit_edge10.thread
  
  .lr.ph9.preheader:                                ; preds = %._crit_edge14.split
    %96 = mul i32 %y_dim, %x_dim
    br label %.lr.ph9
  
  .lr.ph9:                                          ; preds = %.lr.ph9, %.lr.ph9.preheader
    %lsr.iv4 = phi float* [ %scevgep5, %.lr.ph9 ], [ %filt, %.lr.ph9.preheader ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %.lr.ph9 ], [ %96, %.lr.ph9.preheader ]
    %onorm.07 = phi double [ %100, %.lr.ph9 ], [ 0.000000e+00, %.lr.ph9.preheader ]
    %97 = load float, float* %lsr.iv4, align 4, !tbaa !6
    %98 = fmul float %97, %97
    %99 = fpext float %98 to double
    %100 = fadd double %onorm.07, %99
    %lsr.iv.next3 = add i32 %lsr.iv2, -1
    %scevgep5 = getelementptr float, float* %lsr.iv4, i32 1
    %exitcond32 = icmp eq i32 %lsr.iv.next3, 0
    br i1 %exitcond32, label %._crit_edge10, label %.lr.ph9
  
  ._crit_edge10.thread:                             ; preds = %call.sqrt, %._crit_edge14.thread, %._crit_edge14.split
    %101 = tail call double @sqrt(double 0.000000e+00) #5
    %102 = fcmp oeq double %101, %101
    br i1 %102, label %._crit_edge, label %call.sqrt27
  
  call.sqrt27:                                      ; preds = %._crit_edge10.thread
    %103 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge
  
  ._crit_edge10:                                    ; preds = %.lr.ph9
    %104 = tail call double @sqrt(double %100) #5
    %105 = fcmp oeq double %104, %104
    br i1 %105, label %._crit_edge10.split, label %call.sqrt28
  
  call.sqrt28:                                      ; preds = %._crit_edge10
    %106 = tail call double @sqrt(double %100) #6
    br label %._crit_edge10.split
  
  ._crit_edge10.split:                              ; preds = %._crit_edge10, %call.sqrt28
    %107 = phi double [ %104, %._crit_edge10 ], [ %106, %call.sqrt28 ]
    %108 = icmp sgt i32 %8, 0
    %109 = fdiv double %94, %107
    br i1 %108, label %.lr.ph.preheader, label %._crit_edge
  
  .lr.ph.preheader:                                 ; preds = %._crit_edge10.split
    %110 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %110, %.lr.ph.preheader ]
    %111 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %112 = fpext float %111 to double
    %113 = fdiv double %112, %109
    %114 = fptrunc double %113 to float
    store float %114, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %call.sqrt27, %._crit_edge10.thread, %._crit_edge10.split
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  ; Function Attrs: norecurse nounwind
  define i32 @predict(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph12.preheader, label %._crit_edge
  
  .lr.ph12.preheader:                               ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep10 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph12
  
  .lr.ph12:                                         ; preds = %.loopexit2, %.lr.ph12.preheader
    %lsr.iv11 = phi float* [ %45, %.loopexit2 ], [ %scevgep10, %.lr.ph12.preheader ]
    %lsr.iv4 = phi float* [ %44, %.loopexit2 ], [ %filt, %.lr.ph12.preheader ]
    %y_filt.011 = phi i32 [ %27, %.loopexit2 ], [ 0, %.lr.ph12.preheader ]
    %y_res.010 = phi i32 [ %43, %.loopexit2 ], [ %22, %.lr.ph12.preheader ]
    %taps_used.09 = phi float [ %taps_used.3, %.loopexit2 ], [ 0.000000e+00, %.lr.ph12.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.011, %x_dim
    %notlhs = icmp slt i32 %y_res.010, 0
    %notrhs = icmp sge i32 %y_res.010, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit2, label %.lr.ph8
  
  .lr.ph8:                                          ; preds = %.lr.ph12, %38
    %lsr.iv14 = phi float* [ %scevgep15, %38 ], [ %lsr.iv11, %.lr.ph12 ]
    %lsr.iv7 = phi float* [ %scevgep8, %38 ], [ %lsr.iv4, %.lr.ph12 ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %38 ], [ 0, %.lr.ph12 ]
    %taps_used.15 = phi float [ %taps_used.2, %38 ], [ %taps_used.09, %.lr.ph12 ]
    %28 = add i32 %10, %lsr.iv2
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv2
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %38
  
  ; <label>:32                                      ; preds = %.lr.ph8
    %33 = bitcast float* %lsr.iv7 to i32*
    %34 = bitcast float* %lsr.iv14 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    %36 = load float, float* %lsr.iv7, align 4, !tbaa !6
    %37 = fadd float %taps_used.15, %36
    br label %38
  
  ; <label>:38                                      ; preds = %32, %.lr.ph8
    %taps_used.2 = phi float [ %37, %32 ], [ %taps_used.15, %.lr.ph8 ]
    %lsr.iv.next3 = add i32 %lsr.iv2, 1
    %39 = add i32 %y_filt.011, %lsr.iv.next3
    %scevgep8 = getelementptr float, float* %lsr.iv7, i32 1
    %scevgep15 = getelementptr float, float* %lsr.iv14, i32 1
    %40 = icmp slt i32 %39, %27
    br i1 %40, label %.lr.ph8, label %.loopexit2
  
  .loopexit2:                                       ; preds = %38, %.lr.ph12
    %taps_used.3 = phi float [ %taps_used.09, %.lr.ph12 ], [ %taps_used.2, %38 ]
    %41 = bitcast float* %lsr.iv4 to i1*
    %42 = bitcast float* %lsr.iv11 to i1*
    %43 = add nsw i32 %y_res.010, %x_dim
    %scevgep6 = getelementptr i1, i1* %41, i32 %24
    %44 = bitcast i1* %scevgep6 to float*
    %scevgep13 = getelementptr i1, i1* %42, i32 %24
    %45 = bitcast i1* %scevgep13 to float*
    %46 = icmp slt i32 %27, %1
    br i1 %46, label %.lr.ph12, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit2, %18
    %taps_used.0.lcssa = phi float [ 0.000000e+00, %18 ], [ %taps_used.3, %.loopexit2 ]
    %47 = icmp eq i32 %f_or_e, 0
    br i1 %47, label %48, label %.loopexit
  
  ; <label>:48                                      ; preds = %._crit_edge
    %49 = icmp sgt i32 %1, 0
    %50 = fdiv float 2.000000e+00, %taps_used.0.lcssa
    br i1 %49, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %48
    %51 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %51, %.lr.ph.preheader ]
    %52 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %53 = fmul float %50, %52
    store float %53, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %.lr.ph, %48, %._crit_edge
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare i32 @puts(i8* nocapture) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #4
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { nounwind "target-cpu"="mips32" }
  attributes #4 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #5 = { nounwind readnone }
  attributes #6 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"", !3, i64 0, !3, i64 4}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !7, i64 0}
  !7 = !{!"float", !4, i64 0}

...
---
name:            ereflect
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           false
tracksRegLiveness: false
tracksSubRegLiveness: false
liveins:         
  - { reg: '%a0' }
  - { reg: '%a1' }
  - { reg: '%a2' }
  - { reg: '%a3' }
  - { reg: '%t9' }
  - { reg: '%v0' }
calleeSavedRegisters: [ '%fp', '%ra', '%d10', '%d11', '%d12', '%d13', '%d14', 
                        '%d15', '%f20', '%f21', '%f22', '%f23', '%f24', 
                        '%f25', '%f26', '%f27', '%f28', '%f29', '%f30', 
                        '%f31', '%s0', '%s1', '%s2', '%s3', '%s4', '%s5', 
                        '%s6', '%s7' ]
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       88
  offsetAdjustment: 0
  maxAlignment:    8
  adjustsStack:    true
  hasCalls:        true
  maxCallFrameSize: 16
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 24, size: 4, alignment: 8, isImmutable: true, isAliased: false }
  - { id: 1, offset: 20, size: 4, alignment: 4, isImmutable: true, isAliased: false }
  - { id: 2, offset: 16, size: 4, alignment: 8, isImmutable: true, isAliased: false }
stack:           
  - { id: 0, type: spill-slot, offset: -52, size: 4, alignment: 4 }
  - { id: 1, type: spill-slot, offset: -56, size: 4, alignment: 4 }
  - { id: 2, type: spill-slot, offset: -60, size: 4, alignment: 4 }
  - { id: 3, type: spill-slot, offset: -64, size: 4, alignment: 4 }
  - { id: 4, type: spill-slot, offset: -68, size: 4, alignment: 4 }
  - { id: 5, type: spill-slot, offset: -8, size: 8, alignment: 8, callee-saved-register: '%d10' }
  - { id: 6, type: spill-slot, offset: -12, size: 4, alignment: 4, callee-saved-register: '%ra' }
  - { id: 7, type: spill-slot, offset: -16, size: 4, alignment: 4, callee-saved-register: '%fp' }
  - { id: 8, type: spill-slot, offset: -20, size: 4, alignment: 4, callee-saved-register: '%s7' }
  - { id: 9, type: spill-slot, offset: -24, size: 4, alignment: 4, callee-saved-register: '%s6' }
  - { id: 10, type: spill-slot, offset: -28, size: 4, alignment: 4, callee-saved-register: '%s5' }
  - { id: 11, type: spill-slot, offset: -32, size: 4, alignment: 4, callee-saved-register: '%s4' }
  - { id: 12, type: spill-slot, offset: -36, size: 4, alignment: 4, callee-saved-register: '%s3' }
  - { id: 13, type: spill-slot, offset: -40, size: 4, alignment: 4, callee-saved-register: '%s2' }
  - { id: 14, type: spill-slot, offset: -44, size: 4, alignment: 4, callee-saved-register: '%s1' }
  - { id: 15, type: spill-slot, offset: -48, size: 4, alignment: 4, callee-saved-register: '%s0' }
constants:       
  - id:              0
    value:           double 0x3FF6A09E667F3BCD
    alignment:       8
body:             |
  bb.0 (%ir-block.0, freq 56):
    successors: %bb.1(50), %bb.2(50)
    liveins: %a0, %a1, %a2, %a3, %t9, %d10, %ra, %fp, %s7, %s6, %s5, %s4, %s3, %s2, %s1, %s0
  
    %v0 = LUi target-flags(<unknown>) $_gp_disp
    %v0 = ADDiu %v0, target-flags(<unknown>) $_gp_disp
    %sp = ADDiu %sp, -88
    CFI_INSTRUCTION .cfi_def_cfa_offset 88
    SDC1 killed %d10, %sp, 80 :: (store 8 into stack)
    SW killed %ra, %sp, 76 :: (store 4 into stack)
    SW killed %fp, %sp, 72 :: (store 4 into stack)
    SW killed %s7, %sp, 68 :: (store 4 into stack)
    SW killed %s6, %sp, 64 :: (store 4 into stack)
    SW killed %s5, %sp, 60 :: (store 4 into stack)
    SW killed %s4, %sp, 56 :: (store 4 into stack)
    SW killed %s3, %sp, 52 :: (store 4 into stack)
    SW killed %s2, %sp, 48 :: (store 4 into stack)
    SW killed %s1, %sp, 44 :: (store 4 into stack)
    SW killed %s0, %sp, 40 :: (store 4 into stack)
    CFI_INSTRUCTION .cfi_offset %d21_64, -8
    CFI_INSTRUCTION .cfi_offset %d20_64, -4
    CFI_INSTRUCTION .cfi_offset %ra_64, -12
    CFI_INSTRUCTION .cfi_offset %fp_64, -16
    CFI_INSTRUCTION .cfi_offset %s7_64, -20
    CFI_INSTRUCTION .cfi_offset %s6_64, -24
    CFI_INSTRUCTION .cfi_offset %s5_64, -28
    CFI_INSTRUCTION .cfi_offset %s4_64, -32
    CFI_INSTRUCTION .cfi_offset %s3_64, -36
    CFI_INSTRUCTION .cfi_offset %s2_64, -40
    CFI_INSTRUCTION .cfi_offset %s1_64, -44
    CFI_INSTRUCTION .cfi_offset %s0_64, -48
    %s5 = ADDu %v0, %t9
    %s2 = OR %a1, %zero
    %s4 = OR %a0, %zero
    %v1 = ADDiu %a2, -1
    %t6 = LW %sp, 104 :: (load 4 from stack, align 8)
    %at = SLTi %a3, 2
    BNE %at, %zero, %bb.2, implicit-def %at {
      %v0 = SLTi %t6, 1
    }
  
  bb.1 (%ir-block.10, freq 28):
    successors: %bb.3(100)
    liveins: %a2, %a3, %s2, %s4, %s5, %t6, %v0, %v1
  
    B %bb.3, implicit-def dead %at {
      %s7 = SUBu %a3, %s2
    }
  
  bb.2 (%ir-block.12, freq 28):
    successors: %bb.3(100)
    liveins: %a2, %a3, %s2, %s4, %s5, %t6, %v0, %v1
  
    %s7 = ADDiu %a3, 1
    %at = SLTi %a3, -1
    %s7 = MOVZ_I_I %zero, killed %at, killed %s7
  
  bb.3 (%ir-block.16, freq 56):
    successors: %bb.4(50), %bb.5(50)
    liveins: %a2, %a3, %s2, %s4, %s5, %s7, %t6, %v0, %v1
  
    %v1 = MOVN_I_I %zero, killed %v0, killed %v1
    %s0 = ADDiu %s2, -1
    %v0 = SLTi %a3, 1
    %at = SLTi %t6, 2
    BNE %at, %zero, %bb.5, implicit-def %at {
      %s6 = MUL %a2, %s2, implicit-def dead %hi0, implicit-def dead %lo0
    }
  
  bb.4 (%ir-block.19, freq 28):
    successors: %bb.6(100)
    liveins: %a2, %a3, %s0, %s2, %s4, %s5, %s6, %s7, %t6, %v0, %v1
  
    SW killed %a3, %sp, 36 :: (store 4 into stack)
    %at = SUBu %t6, %a2
    SW killed %at, %sp, 28 :: (store 4 into stack)
    B %bb.6, implicit-def dead %at {
      SW killed %a2, %sp, 32 :: (store 4 into stack)
    }
  
  bb.5 (%ir-block.21, freq 28):
    successors: %bb.6(100)
    liveins: %a2, %a3, %s0, %s2, %s4, %s5, %s6, %s7, %t6, %v0, %v1
  
    SW killed %a3, %sp, 36 :: (store 4 into stack)
    SW killed %a2, %sp, 32 :: (store 4 into stack)
    %a0 = ADDiu %t6, 1
    %at = SLTi %t6, -1
    %a0 = MOVZ_I_I %zero, killed %at, killed %a0
    SW killed %a0, %sp, 28 :: (store 4 into stack)
  
  bb.6 (%ir-block.25, freq 56):
    successors: %bb.7..preheader3.preheader(62), %bb.12.._crit_edge27(37)
    liveins: %s0, %s2, %s4, %s5, %s6, %s7, %t6, %v0, %v1
  
    SW %v1, %sp, 24 :: (store 4 into stack)
    %s1 = MUL killed %v1, %s2, implicit-def dead %hi0, implicit-def dead %lo0
    %s3 = LW %sp, 108 :: (load 4 from stack)
    BLEZ %s6, %bb.12.._crit_edge27, implicit-def %at {
      %s0 = MOVN_I_I %zero, killed %v0, killed %s0
    }
  
  bb.7..preheader3.preheader (freq 35):
    successors: %bb.8..preheader3(100)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %t6
  
    %a2 = SLL %s6, 2
    %t9 = LW %s5, target-flags(<unknown>) $memset :: (load 4 from call-entry $memset)
    %fp = ADDiu %zero, 0
    %a0 = OR %s3, %zero
    %a1 = ADDiu %zero, 0
    %gp = OR %s5, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp {
      SW killed %t6, %sp, 20 :: (store 4 into stack)
    }
    %t6 = LW %sp, 20 :: (load 4 from stack)
    %at = LW %sp, 28 :: (load 4 from stack)
    %v0 = MUL killed %at, %s2, implicit-def dead %hi0, implicit-def dead %lo0
    %v1 = SUBu %zero, %s7
    %a0 = SLL %s2, 2
    %a1 = OR %s4, %zero
  
  bb.8..preheader3 (freq 1137):
    successors: %bb.9..lr.ph22(62), %bb.11.._crit_edge23(37)
    liveins: %fp, %a0, %a1, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %t6, %v0, %v1
  
    BLEZ %s2, %bb.11.._crit_edge23, implicit-def %at {
      %a2 = ADDu %fp, %s2
    }
  
  bb.9..lr.ph22 (freq 711):
    successors: %bb.10(100)
    liveins: %fp, %a0, %a1, %a2, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %t6, %v0, %v1
  
    %at = SRA %v0, 31
    %a3 = ADDu %v0, %at
    %at = XOR killed %a3, killed %at
    %at = SUBu %s1, killed %at
    %a3 = SRA %at, 31
    %at = ADDu killed %at, %a3
    %a3 = XOR killed %at, killed %a3
    %t0 = ADDiu %zero, 0
    %t2 = OR %v1, %zero
    %t1 = OR %a1, %zero
  
  bb.10 (%ir-block.42, freq 22755):
    successors: %bb.10(96), %bb.11.._crit_edge23(3)
    liveins: %fp, %a0, %a1, %a2, %a3, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %t0, %t1, %t2, %t6, %v0, %v1
  
    %at = ADDu %s7, %t0
    %t3 = SLTi %at, 0
    %t4 = ADDiu %t2, -1
    %t2 = MOVZ_I_I killed %at, killed %t3, killed %t2
    %at = SUBu %s0, killed %t2
    %t2 = SRA %at, 31
    %at = ADDu killed %at, %t2
    %at = XOR killed %at, killed %t2
    %at = ADDu killed %at, %a3
    %t3 = ADDiu %t1, 4
    %t0 = ADDiu killed %t0, 1
    %f0 = LWC1 killed %t1, 0 :: (load 4 from %ir.lsr.iv22, !tbaa !6)
    %at = SLL killed %at, 2
    %t1 = ADDu %fp, %t0
    %t5 = SLT killed %t1, %a2
    %f1 = LWXC1 %s3, %at :: (load 4 from %ir.53, !tbaa !6)
    %f0 = FADD_S killed %f0, killed %f1
    SWXC1 killed %f0, %s3, killed %at :: (store 4 into %ir.53, !tbaa !6)
    %t2 = OR killed %t4, %zero
    BNE %t5, %zero, %bb.10, implicit-def %at {
      %t1 = OR killed %t3, %zero
    }
  
  bb.11.._crit_edge23 (freq 1137):
    successors: %bb.8..preheader3(96), %bb.12.._crit_edge27(3)
    liveins: %a0, %a1, %a2, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %t6, %v0, %v1
  
    %a1 = ADDu killed %a1, %a0
    %v0 = ADDu killed %v0, %s2
    %at = SLT %a2, %s6
    BNE %at, %zero, %bb.8..preheader3, implicit-def %at {
      %fp = OR killed %a2, %zero
    }
  
  bb.12.._crit_edge27 (freq 56):
    successors: %bb.13.._crit_edge27(75), %bb.16..loopexit(25)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %t6
  
    %at = LW %sp, 36 :: (load 4 from stack)
    BEQ %at, %zero, %bb.16..loopexit, implicit-def %at {
      NOP
    }
  
  bb.13.._crit_edge27 (freq 42):
    successors: %bb.14..lr.ph19.preheader(66), %bb.16..loopexit(33)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %t6
  
    %at = SLT %s0, %s6
    BEQ %at, %zero, %bb.16..loopexit, implicit-def %at {
      NOP
    }
  
  bb.14..lr.ph19.preheader (freq 28):
    successors: %bb.15..lr.ph19(100)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %t6
  
    %at = SLL %s0, 2
    %v1 = ADDu %s3, killed %at
    %v0 = SLL %s2, 2
    %at = LW %s5, target-flags(<unknown>) %const.0 :: (load 4 from got)
    %d0 = LDC1 killed %at, target-flags(<unknown>) %const.0 :: (load 8 from constant-pool)
  
  bb.15..lr.ph19 (freq 910):
    successors: %bb.15..lr.ph19(96), %bb.16..loopexit(3)
    liveins: %d0, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %t6, %v0, %v1
  
    %f2 = LWC1 %v1, 0 :: (load 4 from %ir.lsr.iv14, !tbaa !6)
    %at = ADDu %v1, %v0
    %d1 = CVT_D32_S killed %f2
    %d1 = FMUL_D32 killed %d1, %d0
    %s0 = ADDu killed %s0, %s2
    %a0 = SLT %s0, %s6
    %f2 = CVT_S_D32 killed %d1
    SWC1 killed %f2, killed %v1, 0 :: (store 4 into %ir.lsr.iv14, !tbaa !6)
    BNE %a0, %zero, %bb.15..lr.ph19, implicit-def %at {
      %v1 = OR killed %at, %zero
    }
  
  bb.16..loopexit (freq 56):
    successors: %bb.20..preheader(37), %bb.17..preheader1(62)
    liveins: %s1, %s2, %s3, %s4, %s5, %s6, %t6
  
    BEQ %t6, %zero, %bb.20..preheader, implicit-def %at {
      NOP
    }
  
  bb.17..preheader1 (freq 35):
    successors: %bb.18..lr.ph17.preheader(62), %bb.20..preheader(37)
    liveins: %s1, %s2, %s3, %s4, %s5, %s6
  
    BLEZ %s2, %bb.20..preheader, implicit-def %at {
      NOP
    }
  
  bb.18..lr.ph17.preheader (freq 22):
    successors: %bb.19..lr.ph17(100)
    liveins: %s1, %s2, %s3, %s4, %s5, %s6
  
    %v0 = ADDu %s1, %s2
    %at = LW %sp, 24 :: (load 4 from stack)
    %at = MUL killed %at, %s2, implicit-def dead %hi0, implicit-def dead %lo0
    %at = SLL killed %at, 2
    %v1 = ADDu %s3, killed %at
    %at = LW %s5, target-flags(<unknown>) %const.0 :: (load 4 from got)
    %d0 = LDC1 killed %at, target-flags(<unknown>) %const.0 :: (load 8 from constant-pool)
  
  bb.19..lr.ph17 (freq 711):
    successors: %bb.19..lr.ph17(96), %bb.20..preheader(3)
    liveins: %d0, %s1, %s2, %s3, %s4, %s5, %s6, %v0, %v1
  
    %f2 = LWC1 %v1, 0 :: (load 4 from %ir.lsr.iv11, !tbaa !6)
    %d1 = CVT_D32_S killed %f2
    %d1 = FMUL_D32 killed %d1, %d0
    %s1 = ADDiu killed %s1, 1
    %at = SLT %s1, %v0
    %a0 = ADDiu %v1, 4
    %f2 = CVT_S_D32 killed %d1
    SWC1 killed %f2, killed %v1, 0 :: (store 4 into %ir.lsr.iv11, !tbaa !6)
    BNE %at, %zero, %bb.19..lr.ph17, implicit-def %at {
      %v1 = OR killed %a0, %zero
    }
  
  bb.20..preheader (freq 56):
    successors: %bb.21..lr.ph13.preheader(62), %bb.34.._crit_edge14.thread(37)
    liveins: %s2, %s3, %s4, %s5, %s6
  
    BLEZ %s6, %bb.34.._crit_edge14.thread, implicit-def %at {
      NOP
    }
  
  bb.21..lr.ph13.preheader (freq 35):
    successors: %bb.22..lr.ph13(100)
    liveins: %s2, %s3, %s4, %s5, %s6
  
    %f12 = MTC1 %zero
    %d6 = MTHC1_D32 %d6, %zero
    %v1 = OR %s3, %zero
    %v0 = OR %s6, %zero
  
  bb.22..lr.ph13 (freq 1137):
    successors: %bb.23.._crit_edge14(3), %bb.22..lr.ph13(96)
    liveins: %d6, %s2, %s3, %s4, %s5, %s6, %v0, %v1
  
    %at = ADDiu %v1, 4
    %f0 = LWC1 killed %v1, 0 :: (load 4 from %ir.lsr.iv8, !tbaa !6)
    %v0 = ADDiu killed %v0, -1
    %f0 = FMUL_S killed %f0, %f0
    %d0 = CVT_D32_S killed %f0
    %d6 = FADD_D32 killed %d6, killed %d0
    BNE %v0, %zero, %bb.22..lr.ph13, implicit-def %at {
      %v1 = OR killed %at, %zero
    }
  
  bb.23.._crit_edge14 (freq 35):
    successors: %bb.25.._crit_edge14.split(62), %bb.24.call.sqrt26(37)
    liveins: %d6, %s2, %s3, %s4, %s5, %s6
  
    %d10 = FSQRT_D32 %d6
    FCMP_D32 %d10, %d10, 17, implicit-def %fcc0
    %s1 = LW %sp, 32 :: (load 4 from stack)
    BC1F %fcc0, %bb.25.._crit_edge14.split, implicit-def %at {
      NOP
    }
  
  bb.24.call.sqrt26 (freq 13):
    successors: %bb.25.._crit_edge14.split(100)
    liveins: %d6, %s1, %s2, %s3, %s4, %s5, %s6
  
    %t9 = LW %s5, target-flags(<unknown>) @sqrt :: (load 4 from call-entry @sqrt)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit %gp, implicit-def %sp, implicit-def %d0 {
      %gp = OR %s5, %zero
    }
    %d10 = FMOV_D32 %d0
  
  bb.25.._crit_edge14.split (freq 35):
    successors: %bb.26..lr.ph9.preheader(62), %bb.36.._crit_edge10.thread(37)
    liveins: %d10, %s1, %s2, %s3, %s4, %s5, %s6
  
    BLEZ %s6, %bb.36.._crit_edge10.thread, implicit-def %at {
      NOP
    }
  
  bb.26..lr.ph9.preheader (freq 22):
    successors: %bb.27..lr.ph9(100)
    liveins: %d10, %s1, %s2, %s3, %s4, %s5, %s6
  
    %v0 = MUL %s1, %s2, implicit-def dead %hi0, implicit-def dead %lo0
    %f12 = MTC1 %zero
    %d6 = MTHC1_D32 %d6, %zero
  
  bb.27..lr.ph9 (freq 711):
    successors: %bb.28.._crit_edge10(3), %bb.27..lr.ph9(96)
    liveins: %d6, %d10, %s1, %s2, %s3, %s4, %s5, %s6, %v0
  
    %at = ADDiu %s4, 4
    %f0 = LWC1 killed %s4, 0 :: (load 4 from %ir.lsr.iv4, !tbaa !6)
    %v0 = ADDiu killed %v0, -1
    %f0 = FMUL_S killed %f0, %f0
    %d0 = CVT_D32_S killed %f0
    %d6 = FADD_D32 killed %d6, killed %d0
    BNE %v0, %zero, %bb.27..lr.ph9, implicit-def %at {
      %s4 = OR killed %at, %zero
    }
  
  bb.28.._crit_edge10 (freq 22):
    successors: %bb.30.._crit_edge10.split(62), %bb.29.call.sqrt28(37)
    liveins: %d6, %d10, %s1, %s2, %s3, %s5, %s6
  
    %d0 = FSQRT_D32 %d6
    FCMP_D32 %d0, %d0, 17, implicit-def %fcc0
    BC1F %fcc0, %bb.30.._crit_edge10.split, implicit-def %at {
      NOP
    }
  
  bb.29.call.sqrt28 (freq 8):
    successors: %bb.30.._crit_edge10.split(100)
    liveins: %d6, %d10, %s1, %s2, %s3, %s5, %s6
  
    %t9 = LW %s5, target-flags(<unknown>) @sqrt :: (load 4 from call-entry @sqrt)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit %gp, implicit-def %sp, implicit-def %d0 {
      %gp = OR killed %s5, %zero
    }
  
  bb.30.._crit_edge10.split (freq 22):
    successors: %bb.31..lr.ph.preheader(62), %bb.38.._crit_edge(37)
    liveins: %d0, %d10, %s1, %s2, %s3, %s6
  
    BLEZ %s6, %bb.38.._crit_edge, implicit-def %at {
      NOP
    }
  
  bb.31..lr.ph.preheader (freq 13):
    successors: %bb.32..lr.ph(100)
    liveins: %d0, %d10, %s1, %s2, %s3
  
    %d0 = FDIV_D32 killed %d10, killed %d0
    %v0 = MUL killed %s1, killed %s2, implicit-def dead %hi0, implicit-def dead %lo0
  
  bb.32..lr.ph (freq 27):
    successors: %bb.33..lr.ph(50), %bb.32..lr.ph(50)
    liveins: %d0, %s3, %v0
  
    %f2 = LWC1 %s3, 0 :: (load 4 from %ir.lsr.iv1, !tbaa !6)
    %d1 = CVT_D32_S killed %f2
    %d1 = FDIV_D32 killed %d1, %d0
    %at = ADDiu %s3, 4
    %v0 = ADDiu killed %v0, -1
    %f2 = CVT_S_D32 killed %d1
    SWC1 killed %f2, killed %s3, 0 :: (store 4 into %ir.lsr.iv1, !tbaa !6)
    BNE %v0, %zero, %bb.32..lr.ph, implicit-def %at {
      %s3 = OR killed %at, %zero
    }
  
  bb.33..lr.ph (freq 13):
    successors: %bb.38.._crit_edge(100)
  
    B %bb.38.._crit_edge, implicit-def %at {
      NOP
    }
  
  bb.34.._crit_edge14.thread (freq 21):
    successors: %bb.36.._crit_edge10.thread(62), %bb.35.call.sqrt(37)
    liveins: %s5
  
    %f0 = MTC1 %zero
    %d0 = MTHC1_D32 %d0, %zero
    %d0 = FSQRT_D32 killed %d0
    FCMP_D32 killed %d0, %d0, 17, implicit-def %fcc0
    BC1F %fcc0, %bb.36.._crit_edge10.thread, implicit-def %at {
      NOP
    }
  
  bb.35.call.sqrt (freq 8):
    successors: %bb.36.._crit_edge10.thread(100)
    liveins: %s5
  
    %f12 = MTC1 %zero
    %d6 = MTHC1_D32 %d6, %zero
    %t9 = LW %s5, target-flags(<unknown>) @sqrt :: (load 4 from call-entry @sqrt)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit %gp, implicit-def %sp, implicit-def dead %d0 {
      %gp = OR %s5, %zero
    }
  
  bb.36.._crit_edge10.thread (freq 34):
    successors: %bb.38.._crit_edge(62), %bb.37.call.sqrt27(37)
    liveins: %s5
  
    %f0 = MTC1 %zero
    %d0 = MTHC1_D32 %d0, %zero
    %d0 = FSQRT_D32 killed %d0
    FCMP_D32 killed %d0, %d0, 17, implicit-def %fcc0
    BC1F %fcc0, %bb.38.._crit_edge, implicit-def %at {
      NOP
    }
  
  bb.37.call.sqrt27 (freq 13):
    successors: %bb.38.._crit_edge(100)
    liveins: %s5
  
    %f12 = MTC1 %zero
    %d6 = MTHC1_D32 %d6, %zero
    %t9 = LW %s5, target-flags(<unknown>) @sqrt :: (load 4 from call-entry @sqrt)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit %gp, implicit-def %sp, implicit-def dead %d0 {
      %gp = OR killed %s5, %zero
    }
  
  bb.38.._crit_edge (freq 56):
    liveouts:
  
    %s0 = LW %sp, 40 :: (load 4 from stack)
    %s1 = LW %sp, 44 :: (load 4 from stack)
    %s2 = LW %sp, 48 :: (load 4 from stack)
    %s3 = LW %sp, 52 :: (load 4 from stack)
    %s4 = LW %sp, 56 :: (load 4 from stack)
    %s5 = LW %sp, 60 :: (load 4 from stack)
    %s6 = LW %sp, 64 :: (load 4 from stack)
    %s7 = LW %sp, 68 :: (load 4 from stack)
    %fp = LW %sp, 72 :: (load 4 from stack)
    %ra = LW %sp, 76 :: (load 4 from stack)
    %d10 = LDC1 %sp, 80 :: (load 8 from stack)
    PseudoReturn %ra {
      %sp = ADDiu %sp, 88
    }

...
