--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/epic/epic.edges.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.EDGE_HANDLER = type { i8*, i32 (...)* }
  
  @edge_foos = internal unnamed_addr constant [9 x %struct.EDGE_HANDLER] [%struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect2 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @repeat to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @zero to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @extend to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @nocompute to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @predict to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @ereflect to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }], align 4
  @.str.1 = private unnamed_addr constant [9 x i8] c"reflect1\00", align 1
  @.str.2 = private unnamed_addr constant [9 x i8] c"reflect2\00", align 1
  @.str.3 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
  @.str.4 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
  @.str.5 = private unnamed_addr constant [7 x i8] c"extend\00", align 1
  @.str.6 = private unnamed_addr constant [13 x i8] c"dont-compute\00", align 1
  @.str.7 = private unnamed_addr constant [8 x i8] c"predict\00", align 1
  @.str.8 = private unnamed_addr constant [9 x i8] c"ereflect\00", align 1
  @.str.9 = private unnamed_addr constant [9 x i8] c"treflect\00", align 1
  @str = private unnamed_addr constant [30 x i8] c"No such edge handler routine!\00"
  
  ; Function Attrs: nounwind
  define i32 (...)* @edge_function(i8* nocapture readonly %edges) #0 {
    %1 = tail call i32 @strcmp(i8* %edges, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0))
    %2 = icmp eq i32 %1, 0
    br i1 %2, label %3, label %6
  
  ; <label>:3                                       ; preds = %28, %25, %22, %19, %16, %13, %10, %6, %0
    %i.02.lcssa = phi i32 [ 0, %0 ], [ 1, %6 ], [ 2, %10 ], [ 3, %13 ], [ 4, %16 ], [ 5, %19 ], [ 6, %22 ], [ 7, %25 ], [ 8, %28 ]
    %4 = getelementptr inbounds [9 x %struct.EDGE_HANDLER], [9 x %struct.EDGE_HANDLER]* @edge_foos, i32 0, i32 %i.02.lcssa, i32 1
    %5 = load i32 (...)*, i32 (...)** %4, align 4, !tbaa !1
    br label %9
  
  ; <label>:6                                       ; preds = %0
    %7 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
    %8 = icmp eq i32 %7, 0
    br i1 %8, label %3, label %10
  
  ; <label>:9                                       ; preds = %31, %3
    %.0 = phi i32 (...)* [ %5, %3 ], [ null, %31 ]
    ret i32 (...)* %.0
  
  ; <label>:10                                      ; preds = %6
    %11 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0))
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %3, label %13
  
  ; <label>:13                                      ; preds = %10
    %14 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
    %15 = icmp eq i32 %14, 0
    br i1 %15, label %3, label %16
  
  ; <label>:16                                      ; preds = %13
    %17 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0))
    %18 = icmp eq i32 %17, 0
    br i1 %18, label %3, label %19
  
  ; <label>:19                                      ; preds = %16
    %20 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0))
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %3, label %22
  
  ; <label>:22                                      ; preds = %19
    %23 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0))
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %3, label %25
  
  ; <label>:25                                      ; preds = %22
    %26 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
    %27 = icmp eq i32 %26, 0
    br i1 %27, label %3, label %28
  
  ; <label>:28                                      ; preds = %25
    %29 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0))
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %3, label %31
  
  ; <label>:31                                      ; preds = %28
    %puts = tail call i32 @puts(i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @str, i32 0, i32 0))
    br label %9
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #1
  
  ; Function Attrs: norecurse nounwind
  define i32 @zero(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph7.preheader, label %._crit_edge
  
  .lr.ph7.preheader:                                ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep6 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph7
  
  .lr.ph7:                                          ; preds = %.loopexit, %.lr.ph7.preheader
    %lsr.iv7 = phi float* [ %43, %.loopexit ], [ %scevgep6, %.lr.ph7.preheader ]
    %lsr.iv1 = phi float* [ %42, %.loopexit ], [ %filt, %.lr.ph7.preheader ]
    %y_filt.06 = phi i32 [ %27, %.loopexit ], [ 0, %.lr.ph7.preheader ]
    %y_res.05 = phi i32 [ %41, %.loopexit ], [ %22, %.lr.ph7.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.06, %x_dim
    %notlhs = icmp slt i32 %y_res.05, 0
    %notrhs = icmp sge i32 %y_res.05, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph7, %36
    %lsr.iv10 = phi float* [ %scevgep11, %36 ], [ %lsr.iv7, %.lr.ph7 ]
    %lsr.iv3 = phi float* [ %scevgep4, %36 ], [ %lsr.iv1, %.lr.ph7 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %36 ], [ 0, %.lr.ph7 ]
    %28 = add i32 %10, %lsr.iv
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %36
  
  ; <label>:32                                      ; preds = %.lr.ph
    %33 = bitcast float* %lsr.iv3 to i32*
    %34 = bitcast float* %lsr.iv10 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    br label %36
  
  ; <label>:36                                      ; preds = %32, %.lr.ph
    %lsr.iv.next = add i32 %lsr.iv, 1
    %37 = add i32 %y_filt.06, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %scevgep11 = getelementptr float, float* %lsr.iv10, i32 1
    %38 = icmp slt i32 %37, %27
    br i1 %38, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %36, %.lr.ph7
    %39 = bitcast float* %lsr.iv1 to i1*
    %40 = bitcast float* %lsr.iv7 to i1*
    %41 = add nsw i32 %y_res.05, %x_dim
    %scevgep = getelementptr i1, i1* %39, i32 %24
    %42 = bitcast i1* %scevgep to float*
    %scevgep9 = getelementptr i1, i1* %40, i32 %24
    %43 = bitcast i1* %scevgep9 to float*
    %44 = icmp slt i32 %27, %1
    br i1 %44, label %.lr.ph7, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @repeat(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.preheader.lr.ph, label %._crit_edge6
  
  .preheader.lr.ph:                                 ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = sub nsw i32 %1, %x_dim
    %25 = add nsw i32 %x_dim, -1
    %26 = shl i32 %x_dim, 2
    br label %.preheader
  
  .preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
    %lsr.iv1 = phi float* [ %48, %._crit_edge ], [ %filt, %.preheader.lr.ph ]
    %y_filt.05 = phi i32 [ 0, %.preheader.lr.ph ], [ %28, %._crit_edge ]
    %y_res.04 = phi i32 [ %22, %.preheader.lr.ph ], [ %47, %._crit_edge ]
    %27 = icmp sgt i32 %x_dim, 0
    %28 = add nsw i32 %y_filt.05, %x_dim
    br i1 %27, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader
    %29 = icmp sgt i32 %y_res.04, -1
    %30 = icmp slt i32 %y_res.04, %1
    %y_res.0. = select i1 %30, i32 %y_res.04, i32 %24
    %y_res.0.. = select i1 %29, i32 %y_res.0., i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %31, %.lr.ph
    %lsr.iv3 = phi float* [ %scevgep4, %31 ], [ %lsr.iv1, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %31 ], [ 0, %.lr.ph ]
    %32 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %33 = add i32 %10, %lsr.iv
    %34 = icmp sgt i32 %33, -1
    %35 = add i32 %10, %lsr.iv
    %36 = icmp slt i32 %35, %x_dim
    %37 = add i32 %10, %lsr.iv
    %38 = select i1 %36, i32 %37, i32 %25
    %39 = select i1 %34, i32 %38, i32 0
    %40 = add nsw i32 %39, %y_res.0..
    %41 = getelementptr inbounds float, float* %result, i32 %40
    %42 = load float, float* %41, align 4, !tbaa !6
    %43 = fadd float %32, %42
    store float %43, float* %41, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, 1
    %44 = add i32 %y_filt.05, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %45 = icmp slt i32 %44, %28
    br i1 %45, label %31, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %31, %.preheader
    %46 = bitcast float* %lsr.iv1 to i1*
    %47 = add nsw i32 %y_res.04, %x_dim
    %scevgep = getelementptr i1, i1* %46, i32 %26
    %48 = bitcast i1* %scevgep to float*
    %49 = icmp slt i32 %28, %1
    br i1 %49, label %.preheader, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect2(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = mul nsw i32 %5, %x_dim
    %7 = select i1 %4, i32 %6, i32 0
    %8 = mul i32 %y_dim, %x_dim
    %9 = xor i32 %x_dim, -1
    %.v = select i1 %1, i32 %9, i32 1
    %10 = add i32 %.v, %x_pos
    %11 = icmp sgt i32 %8, 0
    br i1 %11, label %.lr.ph5.preheader, label %._crit_edge6
  
  .lr.ph5.preheader:                                ; preds = %0
    %12 = icmp sgt i32 %y_pos, 0
    %13 = xor i32 %y_dim, -1
    %.v10 = select i1 %12, i32 %13, i32 1
    %14 = add i32 %.v10, %y_pos
    %15 = mul nsw i32 %14, %x_dim
    %result11 = bitcast float* %result to i8*
    %16 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %result11, i8 0, i32 %16, i32 4, i1 false)
    %17 = shl i32 %x_dim, 2
    br label %.lr.ph5
  
  .lr.ph5:                                          ; preds = %._crit_edge, %.lr.ph5.preheader
    %lsr.iv = phi float* [ %51, %._crit_edge ], [ %filt, %.lr.ph5.preheader ]
    %y_filt.04 = phi i32 [ %21, %._crit_edge ], [ 0, %.lr.ph5.preheader ]
    %y_edge.03 = phi i32 [ %50, %._crit_edge ], [ %15, %.lr.ph5.preheader ]
    %18 = icmp sgt i32 %x_dim, 0
    %19 = icmp eq i32 %y_edge.03, 0
    %20 = select i1 %19, i32 %x_dim, i32 0
    %.y_edge.0 = add nsw i32 %20, %y_edge.03
    %21 = add nsw i32 %y_filt.04, %x_dim
    br i1 %18, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.lr.ph5
    %22 = icmp sgt i32 %.y_edge.0, -1
    %23 = sub nsw i32 0, %.y_edge.0
    %24 = select i1 %22, i32 %.y_edge.0, i32 %23
    %25 = sub nsw i32 %7, %24
    %26 = add nsw i32 %25, %x_dim
    %27 = icmp sgt i32 %26, -1
    %28 = sub nsw i32 0, %26
    %29 = select i1 %27, i32 %26, i32 %28
    br label %30
  
  ; <label>:30                                      ; preds = %30, %.lr.ph
    %lsr.iv2 = phi float* [ %scevgep3, %30 ], [ %lsr.iv, %.lr.ph ]
    %x_filt.02 = phi i32 [ %y_filt.04, %.lr.ph ], [ %46, %30 ]
    %x_edge.01 = phi i32 [ %10, %.lr.ph ], [ %47, %30 ]
    %31 = icmp eq i32 %x_edge.01, 0
    %32 = zext i1 %31 to i32
    %.x_edge.0 = add nsw i32 %32, %x_edge.01
    %33 = load float, float* %lsr.iv2, align 4, !tbaa !6
    %34 = icmp sgt i32 %.x_edge.0, -1
    %35 = sub nsw i32 0, %.x_edge.0
    %36 = select i1 %34, i32 %.x_edge.0, i32 %35
    %37 = sub nsw i32 %3, %36
    %38 = add nsw i32 %37, 1
    %39 = icmp sgt i32 %37, -2
    %40 = xor i32 %37, -1
    %41 = select i1 %39, i32 %38, i32 %40
    %42 = add nsw i32 %41, %29
    %43 = getelementptr inbounds float, float* %result, i32 %42
    %44 = load float, float* %43, align 4, !tbaa !6
    %45 = fadd float %33, %44
    store float %45, float* %43, align 4, !tbaa !6
    %46 = add nsw i32 %x_filt.02, 1
    %47 = add nsw i32 %.x_edge.0, 1
    %scevgep3 = getelementptr float, float* %lsr.iv2, i32 1
    %48 = icmp slt i32 %46, %21
    br i1 %48, label %30, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %30, %.lr.ph5
    %49 = bitcast float* %lsr.iv to i1*
    %50 = add nsw i32 %.y_edge.0, %x_dim
    %scevgep = getelementptr i1, i1* %49, i32 %17
    %51 = bitcast i1* %scevgep to float*
    %52 = icmp slt i32 %21, %8
    br i1 %52, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %0
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect1(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph22.preheader, label %._crit_edge23
  
  .lr.ph22.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %.lr.ph22.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge23
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.4 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.4, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.5 = select i1 %51, i32 0, i32 %26
    %.6 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge23
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge23 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge23 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge23 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge23 ], [ %.5, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge23 ], [ %.6, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge23 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph18.preheader, label %._crit_edge19
  
  .lr.ph18.preheader:                               ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep9 = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %.lr.ph18
  
  .lr.ph18:                                         ; preds = %._crit_edge, %.lr.ph18.preheader
    %lsr.iv10 = phi float* [ %85, %._crit_edge ], [ %scevgep9, %.lr.ph18.preheader ]
    %y_edge.016 = phi i32 [ %y_edge_dist.0, %.lr.ph18.preheader ], [ %84, %._crit_edge ]
    %y_filt.015 = phi i32 [ %y_start.0, %.lr.ph18.preheader ], [ %83, %._crit_edge ]
    %59 = add nsw i32 %y_filt.015, %x_start.1
    %60 = add nsw i32 %y_filt.015, %x_stop.1
    %61 = icmp slt i32 %59, %60
    br i1 %61, label %.lr.ph14, label %._crit_edge
  
  .lr.ph14:                                         ; preds = %.lr.ph18
    %62 = icmp sgt i32 %y_edge.016, -1
    %63 = sub nsw i32 0, %y_edge.016
    %64 = select i1 %62, i32 %y_edge.016, i32 %63
    %65 = sub nsw i32 %8, %64
    %66 = icmp sgt i32 %65, -1
    %67 = sub nsw i32 0, %65
    %68 = select i1 %66, i32 %65, i32 %67
    br label %69
  
  ; <label>:69                                      ; preds = %69, %.lr.ph14
    %lsr.iv13 = phi float* [ %scevgep14, %69 ], [ %lsr.iv10, %.lr.ph14 ]
    %lsr.iv7 = phi i32 [ %lsr.iv.next8, %69 ], [ %56, %.lr.ph14 ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next, %69 ], [ %55, %.lr.ph14 ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph14 ], [ %81, %69 ]
    %70 = load float, float* %lsr.iv13, align 4, !tbaa !6
    %71 = icmp sgt i32 %x_edge.013, -1
    %72 = select i1 %71, i32 %x_edge.013, i32 %lsr.iv6
    %73 = sub nsw i32 %4, %72
    %74 = icmp sgt i32 %73, -1
    %75 = sub nsw i32 0, %73
    %76 = select i1 %74, i32 %73, i32 %75
    %77 = add nsw i32 %76, %68
    %78 = getelementptr inbounds float, float* %result, i32 %77
    %79 = load float, float* %78, align 4, !tbaa !6
    %80 = fadd float %70, %79
    store float %80, float* %78, align 4, !tbaa !6
    %81 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv6, -1
    %lsr.iv.next8 = add i32 %lsr.iv7, -1
    %scevgep14 = getelementptr float, float* %lsr.iv13, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next8, 0
    br i1 %exitcond, label %._crit_edge, label %69
  
  ._crit_edge:                                      ; preds = %69, %.lr.ph18
    %82 = bitcast float* %lsr.iv10 to i1*
    %83 = add nsw i32 %y_filt.015, %x_dim
    %84 = add nsw i32 %y_edge.016, %x_dim
    %scevgep12 = getelementptr i1, i1* %82, i32 %58
    %85 = bitcast i1* %scevgep12 to float*
    %86 = icmp slt i32 %83, %y_stop.0
    br i1 %86, label %.lr.ph18, label %._crit_edge19
  
  ._crit_edge19:                                    ; preds = %._crit_edge, %53
    %87 = icmp eq i32 %f_or_e, 1
    br i1 %87, label %88, label %.loopexit
  
  ; <label>:88                                      ; preds = %._crit_edge19
    %89 = icmp sgt i32 %x_pos, -1
    %90 = sub nsw i32 0, %x_pos
    %91 = select i1 %89, i32 %x_pos, i32 %90
    %92 = icmp ne i32 %91, %28
    %93 = icmp ne i32 %x_pos, 0
    %or.cond = and i1 %93, %92
    %94 = icmp slt i32 %4, %1
    %or.cond24 = and i1 %or.cond, %94
    br i1 %or.cond24, label %.lr.ph11.preheader, label %.loopexit8
  
  .lr.ph11.preheader:                               ; preds = %88
    %scevgep2 = getelementptr float, float* %result, i32 %4
    %95 = shl i32 %x_dim, 2
    br label %.lr.ph11
  
  .lr.ph11:                                         ; preds = %.lr.ph11, %.lr.ph11.preheader
    %lsr.iv3 = phi float* [ %99, %.lr.ph11 ], [ %scevgep2, %.lr.ph11.preheader ]
    %y_filt.110 = phi i32 [ %98, %.lr.ph11 ], [ %4, %.lr.ph11.preheader ]
    %lsr.iv34 = bitcast float* %lsr.iv3 to i1*
    %96 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %97 = fadd float %96, %96
    store float %97, float* %lsr.iv3, align 4, !tbaa !6
    %98 = add nsw i32 %y_filt.110, %x_dim
    %scevgep5 = getelementptr i1, i1* %lsr.iv34, i32 %95
    %99 = bitcast i1* %scevgep5 to float*
    %100 = icmp slt i32 %98, %1
    br i1 %100, label %.lr.ph11, label %.loopexit8
  
  .loopexit8:                                       ; preds = %.lr.ph11, %88
    %101 = icmp sgt i32 %y_pos, -1
    %102 = sub nsw i32 0, %y_pos
    %103 = select i1 %101, i32 %y_pos, i32 %102
    %104 = icmp ne i32 %103, %30
    %105 = icmp ne i32 %y_pos, 0
    %or.cond3 = and i1 %105, %104
    br i1 %or.cond3, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %.loopexit8
    %106 = add nsw i32 %8, %x_dim
    %107 = icmp sgt i32 %x_dim, 0
    br i1 %107, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %scevgep = getelementptr float, float* %result, i32 %8
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv = phi float* [ %scevgep1, %.lr.ph ], [ %scevgep, %.lr.ph.preheader ]
    %x_filt.19 = phi i32 [ %110, %.lr.ph ], [ %8, %.lr.ph.preheader ]
    %108 = load float, float* %lsr.iv, align 4, !tbaa !6
    %109 = fadd float %108, %108
    store float %109, float* %lsr.iv, align 4, !tbaa !6
    %110 = add nsw i32 %x_filt.19, 1
    %scevgep1 = getelementptr float, float* %lsr.iv, i32 1
    %111 = icmp slt i32 %110, %106
    br i1 %111, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %.preheader, %.loopexit8, %._crit_edge19
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @extend(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph21.preheader, label %._crit_edge22
  
  .lr.ph21.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge22
  
  ._crit_edge22:                                    ; preds = %.lr.ph21.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge22
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.3 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.3, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.4 = select i1 %51, i32 0, i32 %26
    %.5 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge22
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge22 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge22 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge22 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge22 ], [ %.4, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge22 ], [ %.5, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge22 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph17, label %._crit_edge18
  
  .lr.ph17:                                         ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %59
  
  ; <label>:59                                      ; preds = %._crit_edge, %.lr.ph17
    %lsr.iv3 = phi float* [ %117, %._crit_edge ], [ %scevgep, %.lr.ph17 ]
    %y_edge.015 = phi i32 [ %y_edge_dist.0, %.lr.ph17 ], [ %116, %._crit_edge ]
    %y_filt.014 = phi i32 [ %y_start.0, %.lr.ph17 ], [ %115, %._crit_edge ]
    %60 = add nsw i32 %y_filt.014, %x_start.1
    %61 = add nsw i32 %y_filt.014, %x_stop.1
    %62 = icmp slt i32 %60, %61
    br i1 %62, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %59
    %63 = icmp ne i32 %8, 0
    %64 = icmp sgt i32 %y_edge.015, 0
    %65 = icmp slt i32 %y_edge.015, 0
    %not. = xor i1 %64, true
    %66 = and i1 %65, %not.
    %67 = select i1 %63, i1 %64, i1 %66
    %68 = icmp sgt i32 %y_edge.015, -1
    %69 = sub nsw i32 0, %y_edge.015
    %70 = select i1 %68, i32 %y_edge.015, i32 %69
    %71 = sub nsw i32 %8, %70
    %72 = icmp sgt i32 %71, -1
    %73 = sub nsw i32 0, %71
    %74 = select i1 %72, i32 %71, i32 %73
    %75 = add nsw i32 %y_edge.015, %8
    %76 = icmp slt i32 %75, 0
    %77 = icmp slt i32 %75, %y_dim
    %.10 = select i1 %77, i32 %75, i32 %6
    %78 = select i1 %76, i32 0, i32 %.10
    br label %79
  
  ; <label>:79                                      ; preds = %112, %.lr.ph
    %lsr.iv6 = phi float* [ %scevgep7, %112 ], [ %lsr.iv3, %.lr.ph ]
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %112 ], [ %56, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %112 ], [ %55, %.lr.ph ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph ], [ %113, %112 ]
    %80 = icmp ne i32 %4, 0
    %81 = icmp sgt i32 %x_edge.013, 0
    %82 = icmp slt i32 %x_edge.013, 0
    %not.11 = xor i1 %81, true
    %83 = and i1 %82, %not.11
    %84 = select i1 %80, i1 %81, i1 %83
    %85 = xor i1 %67, %84
    %86 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %87 = icmp sgt i32 %x_edge.013, -1
    %88 = select i1 %87, i32 %x_edge.013, i32 %lsr.iv
    %89 = sub nsw i32 %4, %88
    %90 = icmp sgt i32 %89, -1
    %91 = sub nsw i32 0, %89
    %92 = select i1 %90, i32 %89, i32 %91
    %93 = add nsw i32 %92, %74
    %94 = getelementptr inbounds float, float* %result, i32 %93
    %95 = load float, float* %94, align 4, !tbaa !6
    br i1 %85, label %96, label %110
  
  ; <label>:96                                      ; preds = %79
    %97 = fsub float %95, %86
    store float %97, float* %94, align 4, !tbaa !6
    %98 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %99 = fadd float %98, %98
    %100 = add i32 %4, %x_edge.013
    %101 = icmp slt i32 %100, 0
    %102 = add i32 %4, %x_edge.013
    %103 = icmp slt i32 %102, %x_dim
    %104 = add i32 %4, %x_edge.013
    %.9 = select i1 %103, i32 %104, i32 %3
    %105 = select i1 %101, i32 0, i32 %.9
    %106 = add nsw i32 %105, %78
    %107 = getelementptr inbounds float, float* %result, i32 %106
    %108 = load float, float* %107, align 4, !tbaa !6
    %109 = fadd float %108, %99
    store float %109, float* %107, align 4, !tbaa !6
    br label %112
  
  ; <label>:110                                     ; preds = %79
    %111 = fadd float %86, %95
    store float %111, float* %94, align 4, !tbaa !6
    br label %112
  
  ; <label>:112                                     ; preds = %110, %96
    %113 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv, -1
    %lsr.iv.next2 = add i32 %lsr.iv1, -1
    %scevgep7 = getelementptr float, float* %lsr.iv6, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next2, 0
    br i1 %exitcond, label %._crit_edge, label %79
  
  ._crit_edge:                                      ; preds = %112, %59
    %114 = bitcast float* %lsr.iv3 to i1*
    %115 = add nsw i32 %y_filt.014, %x_dim
    %116 = add nsw i32 %y_edge.015, %x_dim
    %scevgep5 = getelementptr i1, i1* %114, i32 %58
    %117 = bitcast i1* %scevgep5 to float*
    %118 = icmp slt i32 %115, %y_stop.0
    br i1 %118, label %59, label %._crit_edge18
  
  ._crit_edge18:                                    ; preds = %._crit_edge, %53
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @nocompute(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %x_pos.off = add i32 %x_pos, 1
    %2 = icmp ugt i32 %x_pos.off, 2
    %y_pos.off = add i32 %y_pos, 1
    %3 = icmp ugt i32 %y_pos.off, 2
    %4 = or i1 %2, %3
    br i1 %4, label %.preheader, label %.preheader6
  
  .preheader6:                                      ; preds = %0
    %5 = icmp sgt i32 %1, 0
    br i1 %5, label %.lr.ph10.preheader, label %.loopexit
  
  .lr.ph10.preheader:                               ; preds = %.preheader6
    %6 = mul i32 %y_dim, %x_dim
    br label %.lr.ph10
  
  .preheader:                                       ; preds = %0
    %7 = icmp sgt i32 %1, 0
    br i1 %7, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %8 = bitcast float* %result to i8*
    %9 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %8, i8 0, i32 %9, i32 4, i1 false)
    br label %.loopexit
  
  .lr.ph10:                                         ; preds = %.lr.ph10, %.lr.ph10.preheader
    %lsr.iv3 = phi float* [ %scevgep4, %.lr.ph10 ], [ %filt, %.lr.ph10.preheader ]
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph10 ], [ %result, %.lr.ph10.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph10 ], [ %6, %.lr.ph10.preheader ]
    %lsr.iv35 = bitcast float* %lsr.iv3 to i32*
    %lsr.iv12 = bitcast float* %lsr.iv1 to i32*
    %10 = load i32, i32* %lsr.iv35, align 4, !tbaa !6
    store i32 %10, i32* %lsr.iv12, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %exitcond12 = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond12, label %.loopexit, label %.lr.ph10
  
  .loopexit:                                        ; preds = %.lr.ph10, %.lr.ph.preheader, %.preheader, %.preheader6
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  define i32 @ereflect(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #0 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = select i1 %4, i32 %5, i32 0
    %7 = mul nsw i32 %6, %x_dim
    %8 = mul i32 %y_dim, %x_dim
    %9 = icmp sgt i32 %x_pos, 1
    br i1 %9, label %10, label %12
  
  ; <label>:10                                      ; preds = %0
    %11 = sub nsw i32 %x_pos, %x_dim
    br label %16
  
  ; <label>:12                                      ; preds = %0
    %13 = icmp slt i32 %x_pos, -1
    %14 = add nsw i32 %x_pos, 1
    %15 = select i1 %13, i32 %14, i32 0
    br label %16
  
  ; <label>:16                                      ; preds = %12, %10
    %17 = phi i32 [ %11, %10 ], [ %15, %12 ]
    %18 = icmp sgt i32 %y_pos, 1
    br i1 %18, label %19, label %21
  
  ; <label>:19                                      ; preds = %16
    %20 = sub nsw i32 %y_pos, %y_dim
    br label %25
  
  ; <label>:21                                      ; preds = %16
    %22 = icmp slt i32 %y_pos, -1
    %23 = add nsw i32 %y_pos, 1
    %24 = select i1 %22, i32 %23, i32 0
    br label %25
  
  ; <label>:25                                      ; preds = %21, %19
    %26 = phi i32 [ %20, %19 ], [ %24, %21 ]
    %27 = icmp sgt i32 %8, 0
    br i1 %27, label %.preheader3.preheader, label %._crit_edge27
  
  .preheader3.preheader:                            ; preds = %25
    %28 = bitcast float* %result to i8*
    %29 = mul nsw i32 %26, %x_dim
    %30 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %28, i8 0, i32 %30, i32 4, i1 false)
    %31 = shl i32 %x_dim, 2
    %32 = sub i32 0, %17
    br label %.preheader3
  
  .preheader3:                                      ; preds = %._crit_edge23, %.preheader3.preheader
    %lsr.iv19 = phi float* [ %60, %._crit_edge23 ], [ %filt, %.preheader3.preheader ]
    %y_filt.026 = phi i32 [ %34, %._crit_edge23 ], [ 0, %.preheader3.preheader ]
    %y_edge.025 = phi i32 [ %59, %._crit_edge23 ], [ %29, %.preheader3.preheader ]
    %33 = icmp sgt i32 %x_dim, 0
    %34 = add nsw i32 %y_filt.026, %x_dim
    br i1 %33, label %.lr.ph22, label %._crit_edge23
  
  .lr.ph22:                                         ; preds = %.preheader3
    %35 = icmp sgt i32 %y_edge.025, -1
    %36 = sub nsw i32 0, %y_edge.025
    %37 = select i1 %35, i32 %y_edge.025, i32 %36
    %38 = sub nsw i32 %7, %37
    %39 = icmp sgt i32 %38, -1
    %40 = sub nsw i32 0, %38
    %41 = select i1 %39, i32 %38, i32 %40
    br label %42
  
  ; <label>:42                                      ; preds = %42, %.lr.ph22
    %lsr.iv24 = phi i32 [ %lsr.iv.next25, %42 ], [ %32, %.lr.ph22 ]
    %lsr.iv22 = phi float* [ %scevgep23, %42 ], [ %lsr.iv19, %.lr.ph22 ]
    %lsr.iv17 = phi i32 [ %lsr.iv.next18, %42 ], [ 0, %.lr.ph22 ]
    %43 = load float, float* %lsr.iv22, align 4, !tbaa !6
    %44 = add i32 %17, %lsr.iv17
    %45 = icmp sgt i32 %44, -1
    %46 = add i32 %17, %lsr.iv17
    %47 = select i1 %45, i32 %46, i32 %lsr.iv24
    %48 = sub nsw i32 %3, %47
    %49 = icmp sgt i32 %48, -1
    %50 = sub nsw i32 0, %48
    %51 = select i1 %49, i32 %48, i32 %50
    %52 = add nsw i32 %51, %41
    %53 = getelementptr inbounds float, float* %result, i32 %52
    %54 = load float, float* %53, align 4, !tbaa !6
    %55 = fadd float %43, %54
    store float %55, float* %53, align 4, !tbaa !6
    %lsr.iv.next18 = add i32 %lsr.iv17, 1
    %56 = add i32 %y_filt.026, %lsr.iv.next18
    %scevgep23 = getelementptr float, float* %lsr.iv22, i32 1
    %lsr.iv.next25 = add i32 %lsr.iv24, -1
    %57 = icmp slt i32 %56, %34
    br i1 %57, label %42, label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %42, %.preheader3
    %58 = bitcast float* %lsr.iv19 to i1*
    %59 = add nsw i32 %y_edge.025, %x_dim
    %scevgep21 = getelementptr i1, i1* %58, i32 %31
    %60 = bitcast i1* %scevgep21 to float*
    %61 = icmp slt i32 %34, %8
    br i1 %61, label %.preheader3, label %._crit_edge27
  
  ._crit_edge27:                                    ; preds = %._crit_edge23, %25
    %62 = icmp ne i32 %x_pos, 0
    %63 = icmp slt i32 %3, %8
    %or.cond = and i1 %62, %63
    br i1 %or.cond, label %.lr.ph19.preheader, label %.loopexit
  
  .lr.ph19.preheader:                               ; preds = %._crit_edge27
    %scevgep13 = getelementptr float, float* %result, i32 %3
    %64 = shl i32 %x_dim, 2
    br label %.lr.ph19
  
  .lr.ph19:                                         ; preds = %.lr.ph19, %.lr.ph19.preheader
    %lsr.iv14 = phi float* [ %70, %.lr.ph19 ], [ %scevgep13, %.lr.ph19.preheader ]
    %y_filt.118 = phi i32 [ %69, %.lr.ph19 ], [ %3, %.lr.ph19.preheader ]
    %lsr.iv1415 = bitcast float* %lsr.iv14 to i1*
    %65 = load float, float* %lsr.iv14, align 4, !tbaa !6
    %66 = fpext float %65 to double
    %67 = fmul double %66, 0x3FF6A09E667F3BCD
    %68 = fptrunc double %67 to float
    store float %68, float* %lsr.iv14, align 4, !tbaa !6
    %69 = add nsw i32 %y_filt.118, %x_dim
    %scevgep16 = getelementptr i1, i1* %lsr.iv1415, i32 %64
    %70 = bitcast i1* %scevgep16 to float*
    %71 = icmp slt i32 %69, %8
    br i1 %71, label %.lr.ph19, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph19, %._crit_edge27
    %72 = icmp eq i32 %y_pos, 0
    br i1 %72, label %.preheader, label %.preheader1
  
  .preheader1:                                      ; preds = %.loopexit
    %73 = add nsw i32 %7, %x_dim
    %74 = icmp sgt i32 %x_dim, 0
    br i1 %74, label %.lr.ph17.preheader, label %.preheader
  
  .lr.ph17.preheader:                               ; preds = %.preheader1
    %75 = mul i32 %6, %x_dim
    %scevgep10 = getelementptr float, float* %result, i32 %75
    br label %.lr.ph17
  
  .preheader:                                       ; preds = %.lr.ph17, %.preheader1, %.loopexit
    %76 = icmp sgt i32 %8, 0
    br i1 %76, label %.lr.ph13.preheader, label %._crit_edge14.thread
  
  .lr.ph13.preheader:                               ; preds = %.preheader
    %77 = mul i32 %y_dim, %x_dim
    br label %.lr.ph13
  
  ._crit_edge14.thread:                             ; preds = %.preheader
    %78 = tail call double @sqrt(double 0.000000e+00) #5
    %79 = fcmp oeq double %78, %78
    br i1 %79, label %._crit_edge10.thread, label %call.sqrt
  
  call.sqrt:                                        ; preds = %._crit_edge14.thread
    %80 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge10.thread
  
  .lr.ph17:                                         ; preds = %.lr.ph17, %.lr.ph17.preheader
    %lsr.iv11 = phi float* [ %scevgep12, %.lr.ph17 ], [ %scevgep10, %.lr.ph17.preheader ]
    %x_filt.116 = phi i32 [ %85, %.lr.ph17 ], [ %7, %.lr.ph17.preheader ]
    %81 = load float, float* %lsr.iv11, align 4, !tbaa !6
    %82 = fpext float %81 to double
    %83 = fmul double %82, 0x3FF6A09E667F3BCD
    %84 = fptrunc double %83 to float
    store float %84, float* %lsr.iv11, align 4, !tbaa !6
    %85 = add nsw i32 %x_filt.116, 1
    %scevgep12 = getelementptr float, float* %lsr.iv11, i32 1
    %86 = icmp slt i32 %85, %73
    br i1 %86, label %.lr.ph17, label %.preheader
  
  .lr.ph13:                                         ; preds = %.lr.ph13, %.lr.ph13.preheader
    %lsr.iv8 = phi float* [ %scevgep9, %.lr.ph13 ], [ %result, %.lr.ph13.preheader ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next7, %.lr.ph13 ], [ %77, %.lr.ph13.preheader ]
    %norm.012 = phi double [ %90, %.lr.ph13 ], [ 0.000000e+00, %.lr.ph13.preheader ]
    %87 = load float, float* %lsr.iv8, align 4, !tbaa !6
    %88 = fmul float %87, %87
    %89 = fpext float %88 to double
    %90 = fadd double %norm.012, %89
    %lsr.iv.next7 = add i32 %lsr.iv6, -1
    %scevgep9 = getelementptr float, float* %lsr.iv8, i32 1
    %exitcond33 = icmp eq i32 %lsr.iv.next7, 0
    br i1 %exitcond33, label %._crit_edge14, label %.lr.ph13
  
  ._crit_edge14:                                    ; preds = %.lr.ph13
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %._crit_edge14.split, label %call.sqrt26
  
  call.sqrt26:                                      ; preds = %._crit_edge14
    %93 = tail call double @sqrt(double %90) #6
    br label %._crit_edge14.split
  
  ._crit_edge14.split:                              ; preds = %._crit_edge14, %call.sqrt26
    %94 = phi double [ %91, %._crit_edge14 ], [ %93, %call.sqrt26 ]
    %95 = icmp sgt i32 %8, 0
    br i1 %95, label %.lr.ph9.preheader, label %._crit_edge10.thread
  
  .lr.ph9.preheader:                                ; preds = %._crit_edge14.split
    %96 = mul i32 %y_dim, %x_dim
    br label %.lr.ph9
  
  .lr.ph9:                                          ; preds = %.lr.ph9, %.lr.ph9.preheader
    %lsr.iv4 = phi float* [ %scevgep5, %.lr.ph9 ], [ %filt, %.lr.ph9.preheader ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %.lr.ph9 ], [ %96, %.lr.ph9.preheader ]
    %onorm.07 = phi double [ %100, %.lr.ph9 ], [ 0.000000e+00, %.lr.ph9.preheader ]
    %97 = load float, float* %lsr.iv4, align 4, !tbaa !6
    %98 = fmul float %97, %97
    %99 = fpext float %98 to double
    %100 = fadd double %onorm.07, %99
    %lsr.iv.next3 = add i32 %lsr.iv2, -1
    %scevgep5 = getelementptr float, float* %lsr.iv4, i32 1
    %exitcond32 = icmp eq i32 %lsr.iv.next3, 0
    br i1 %exitcond32, label %._crit_edge10, label %.lr.ph9
  
  ._crit_edge10.thread:                             ; preds = %call.sqrt, %._crit_edge14.thread, %._crit_edge14.split
    %101 = tail call double @sqrt(double 0.000000e+00) #5
    %102 = fcmp oeq double %101, %101
    br i1 %102, label %._crit_edge, label %call.sqrt27
  
  call.sqrt27:                                      ; preds = %._crit_edge10.thread
    %103 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge
  
  ._crit_edge10:                                    ; preds = %.lr.ph9
    %104 = tail call double @sqrt(double %100) #5
    %105 = fcmp oeq double %104, %104
    br i1 %105, label %._crit_edge10.split, label %call.sqrt28
  
  call.sqrt28:                                      ; preds = %._crit_edge10
    %106 = tail call double @sqrt(double %100) #6
    br label %._crit_edge10.split
  
  ._crit_edge10.split:                              ; preds = %._crit_edge10, %call.sqrt28
    %107 = phi double [ %104, %._crit_edge10 ], [ %106, %call.sqrt28 ]
    %108 = icmp sgt i32 %8, 0
    %109 = fdiv double %94, %107
    br i1 %108, label %.lr.ph.preheader, label %._crit_edge
  
  .lr.ph.preheader:                                 ; preds = %._crit_edge10.split
    %110 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %110, %.lr.ph.preheader ]
    %111 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %112 = fpext float %111 to double
    %113 = fdiv double %112, %109
    %114 = fptrunc double %113 to float
    store float %114, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %call.sqrt27, %._crit_edge10.thread, %._crit_edge10.split
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  ; Function Attrs: norecurse nounwind
  define i32 @predict(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph12.preheader, label %._crit_edge
  
  .lr.ph12.preheader:                               ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep10 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph12
  
  .lr.ph12:                                         ; preds = %.loopexit2, %.lr.ph12.preheader
    %lsr.iv11 = phi float* [ %45, %.loopexit2 ], [ %scevgep10, %.lr.ph12.preheader ]
    %lsr.iv4 = phi float* [ %44, %.loopexit2 ], [ %filt, %.lr.ph12.preheader ]
    %y_filt.011 = phi i32 [ %27, %.loopexit2 ], [ 0, %.lr.ph12.preheader ]
    %y_res.010 = phi i32 [ %43, %.loopexit2 ], [ %22, %.lr.ph12.preheader ]
    %taps_used.09 = phi float [ %taps_used.3, %.loopexit2 ], [ 0.000000e+00, %.lr.ph12.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.011, %x_dim
    %notlhs = icmp slt i32 %y_res.010, 0
    %notrhs = icmp sge i32 %y_res.010, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit2, label %.lr.ph8
  
  .lr.ph8:                                          ; preds = %.lr.ph12, %38
    %lsr.iv14 = phi float* [ %scevgep15, %38 ], [ %lsr.iv11, %.lr.ph12 ]
    %lsr.iv7 = phi float* [ %scevgep8, %38 ], [ %lsr.iv4, %.lr.ph12 ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %38 ], [ 0, %.lr.ph12 ]
    %taps_used.15 = phi float [ %taps_used.2, %38 ], [ %taps_used.09, %.lr.ph12 ]
    %28 = add i32 %10, %lsr.iv2
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv2
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %38
  
  ; <label>:32                                      ; preds = %.lr.ph8
    %33 = bitcast float* %lsr.iv7 to i32*
    %34 = bitcast float* %lsr.iv14 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    %36 = load float, float* %lsr.iv7, align 4, !tbaa !6
    %37 = fadd float %taps_used.15, %36
    br label %38
  
  ; <label>:38                                      ; preds = %32, %.lr.ph8
    %taps_used.2 = phi float [ %37, %32 ], [ %taps_used.15, %.lr.ph8 ]
    %lsr.iv.next3 = add i32 %lsr.iv2, 1
    %39 = add i32 %y_filt.011, %lsr.iv.next3
    %scevgep8 = getelementptr float, float* %lsr.iv7, i32 1
    %scevgep15 = getelementptr float, float* %lsr.iv14, i32 1
    %40 = icmp slt i32 %39, %27
    br i1 %40, label %.lr.ph8, label %.loopexit2
  
  .loopexit2:                                       ; preds = %38, %.lr.ph12
    %taps_used.3 = phi float [ %taps_used.09, %.lr.ph12 ], [ %taps_used.2, %38 ]
    %41 = bitcast float* %lsr.iv4 to i1*
    %42 = bitcast float* %lsr.iv11 to i1*
    %43 = add nsw i32 %y_res.010, %x_dim
    %scevgep6 = getelementptr i1, i1* %41, i32 %24
    %44 = bitcast i1* %scevgep6 to float*
    %scevgep13 = getelementptr i1, i1* %42, i32 %24
    %45 = bitcast i1* %scevgep13 to float*
    %46 = icmp slt i32 %27, %1
    br i1 %46, label %.lr.ph12, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit2, %18
    %taps_used.0.lcssa = phi float [ 0.000000e+00, %18 ], [ %taps_used.3, %.loopexit2 ]
    %47 = icmp eq i32 %f_or_e, 0
    br i1 %47, label %48, label %.loopexit
  
  ; <label>:48                                      ; preds = %._crit_edge
    %49 = icmp sgt i32 %1, 0
    %50 = fdiv float 2.000000e+00, %taps_used.0.lcssa
    br i1 %49, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %48
    %51 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %51, %.lr.ph.preheader ]
    %52 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %53 = fmul float %50, %52
    store float %53, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %.lr.ph, %48, %._crit_edge
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare i32 @puts(i8* nocapture) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #4
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { nounwind "target-cpu"="mips32" }
  attributes #4 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #5 = { nounwind readnone }
  attributes #6 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"", !3, i64 0, !3, i64 4}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !7, i64 0}
  !7 = !{!"float", !4, i64 0}

...
---
name:            edge_function
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%3' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 549):
    successors: %bb.1(37), %bb.2(62)
    liveins: %a0, %t9, %v0
  
    %4 = ADDu %v0, %t9
    %3 = COPY %a0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %6 = LW %4, target-flags(<unknown>) @.str.1, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %7 = ADDiu killed %6, target-flags(<unknown>) @.str.1
    %8 = LW %4, target-flags(<unknown>) @strcmp, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %3
    %a1 = COPY %7
    %gp = COPY %4
    %t9 = COPY %8
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %9 = COPY %v0
    %5 = ADDiu %zero, 0
    BNE %9, %zero, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.3, freq 541):
    successors: %bb.3(100)
  
    %0 = PHI %5, %bb.0, %10, %bb.2, %15, %bb.4, %20, %bb.5, %25, %bb.6, %30, %bb.7, %35, %bb.8, %40, %bb.9, %45, %bb.10
    %55 = SLL %0, 3
    %56 = LW %4, target-flags(<unknown>) @edge_foos, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %57 = ADDiu killed %56, target-flags(<unknown>) @edge_foos
    %58 = ADDu killed %57, killed %55
    %1 = LW killed %58, 4, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.4, !tbaa !1)
    B %bb.3, implicit-def dead %at
  
  bb.2 (%ir-block.6, freq 343):
    successors: %bb.1(37), %bb.4(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %11 = LW %4, target-flags(<unknown>) @.str.2, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %12 = ADDiu killed %11, target-flags(<unknown>) @.str.2
    %13 = LW %4, target-flags(<unknown>) @strcmp, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %3
    %a1 = COPY %12
    %t9 = COPY %13
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %14 = COPY %v0
    %10 = ADDiu %zero, 1
    BEQ %14, %zero, %bb.1, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.3 (%ir-block.9, freq 549):
    liveouts: %v0
  
    %2 = PHI %50, %bb.11, %1, %bb.1
    %v0 = COPY %2
    RetRA implicit %v0
  
  bb.4 (%ir-block.10, freq 214):
    successors: %bb.1(37), %bb.5(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %16 = LW %4, target-flags(<unknown>) @.str.3, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %17 = ADDiu killed %16, target-flags(<unknown>) @.str.3
    %18 = LW %4, target-flags(<unknown>) @strcmp, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %3
    %a1 = COPY %17
    %t9 = COPY %18
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %19 = COPY %v0
    %15 = ADDiu %zero, 2
    BEQ %19, %zero, %bb.1, implicit-def dead %at
    B %bb.5, implicit-def dead %at
  
  bb.5 (%ir-block.13, freq 134):
    successors: %bb.1(37), %bb.6(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %21 = LW %4, target-flags(<unknown>) @.str.4, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %22 = ADDiu killed %21, target-flags(<unknown>) @.str.4
    %23 = LW %4, target-flags(<unknown>) @strcmp, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %3
    %a1 = COPY %22
    %t9 = COPY %23
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %24 = COPY %v0
    %20 = ADDiu %zero, 3
    BEQ %24, %zero, %bb.1, implicit-def dead %at
    B %bb.6, implicit-def dead %at
  
  bb.6 (%ir-block.16, freq 83):
    successors: %bb.1(37), %bb.7(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %26 = LW %4, target-flags(<unknown>) @.str.5, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %27 = ADDiu killed %26, target-flags(<unknown>) @.str.5
    %28 = LW %4, target-flags(<unknown>) @strcmp, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %3
    %a1 = COPY %27
    %t9 = COPY %28
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %29 = COPY %v0
    %25 = ADDiu %zero, 4
    BEQ %29, %zero, %bb.1, implicit-def dead %at
    B %bb.7, implicit-def dead %at
  
  bb.7 (%ir-block.19, freq 52):
    successors: %bb.1(37), %bb.8(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %31 = LW %4, target-flags(<unknown>) @.str.6, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %32 = ADDiu killed %31, target-flags(<unknown>) @.str.6
    %33 = LW %4, target-flags(<unknown>) @strcmp, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %3
    %a1 = COPY %32
    %t9 = COPY %33
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %34 = COPY %v0
    %30 = ADDiu %zero, 5
    BEQ %34, %zero, %bb.1, implicit-def dead %at
    B %bb.8, implicit-def dead %at
  
  bb.8 (%ir-block.22, freq 32):
    successors: %bb.1(37), %bb.9(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %36 = LW %4, target-flags(<unknown>) @.str.7, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %37 = ADDiu killed %36, target-flags(<unknown>) @.str.7
    %38 = LW %4, target-flags(<unknown>) @strcmp, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %3
    %a1 = COPY %37
    %t9 = COPY %38
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %39 = COPY %v0
    %35 = ADDiu %zero, 6
    BEQ %39, %zero, %bb.1, implicit-def dead %at
    B %bb.9, implicit-def dead %at
  
  bb.9 (%ir-block.25, freq 20):
    successors: %bb.1(37), %bb.10(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %41 = LW %4, target-flags(<unknown>) @.str.8, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %42 = ADDiu killed %41, target-flags(<unknown>) @.str.8
    %43 = LW %4, target-flags(<unknown>) @strcmp, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %3
    %a1 = COPY %42
    %t9 = COPY %43
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %44 = COPY %v0
    %40 = ADDiu %zero, 7
    BEQ %44, %zero, %bb.1, implicit-def dead %at
    B %bb.10, implicit-def dead %at
  
  bb.10 (%ir-block.28, freq 12):
    successors: %bb.1(37), %bb.11(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %46 = LW %4, target-flags(<unknown>) @.str.9, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %47 = ADDiu killed %46, target-flags(<unknown>) @.str.9
    %48 = LW %4, target-flags(<unknown>) @strcmp, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %3
    %a1 = COPY %47
    %t9 = COPY %48
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %49 = COPY %v0
    %45 = ADDiu %zero, 8
    BEQ %49, %zero, %bb.1, implicit-def dead %at
    B %bb.11, implicit-def dead %at
  
  bb.11 (%ir-block.31, freq 8):
    successors: %bb.3(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %51 = LW %4, target-flags(<unknown>) @str, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %52 = ADDiu killed %51, target-flags(<unknown>) @str
    %53 = LW %4, target-flags(<unknown>) @puts, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @puts)
    %a0 = COPY %52
    %gp = COPY %4
    %t9 = COPY %53
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %50 = ADDiu %zero, 0
    B %bb.3, implicit-def dead %at

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/epic/epic.edges.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.EDGE_HANDLER = type { i8*, i32 (...)* }
  
  @edge_foos = internal unnamed_addr constant [9 x %struct.EDGE_HANDLER] [%struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect2 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @repeat to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @zero to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @extend to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @nocompute to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @predict to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @ereflect to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }], align 4
  @.str.1 = private unnamed_addr constant [9 x i8] c"reflect1\00", align 1
  @.str.2 = private unnamed_addr constant [9 x i8] c"reflect2\00", align 1
  @.str.3 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
  @.str.4 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
  @.str.5 = private unnamed_addr constant [7 x i8] c"extend\00", align 1
  @.str.6 = private unnamed_addr constant [13 x i8] c"dont-compute\00", align 1
  @.str.7 = private unnamed_addr constant [8 x i8] c"predict\00", align 1
  @.str.8 = private unnamed_addr constant [9 x i8] c"ereflect\00", align 1
  @.str.9 = private unnamed_addr constant [9 x i8] c"treflect\00", align 1
  @str = private unnamed_addr constant [30 x i8] c"No such edge handler routine!\00"
  
  ; Function Attrs: nounwind
  define i32 (...)* @edge_function(i8* nocapture readonly %edges) #0 {
    %1 = tail call i32 @strcmp(i8* %edges, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0))
    %2 = icmp eq i32 %1, 0
    br i1 %2, label %3, label %6
  
  ; <label>:3                                       ; preds = %28, %25, %22, %19, %16, %13, %10, %6, %0
    %i.02.lcssa = phi i32 [ 0, %0 ], [ 1, %6 ], [ 2, %10 ], [ 3, %13 ], [ 4, %16 ], [ 5, %19 ], [ 6, %22 ], [ 7, %25 ], [ 8, %28 ]
    %4 = getelementptr inbounds [9 x %struct.EDGE_HANDLER], [9 x %struct.EDGE_HANDLER]* @edge_foos, i32 0, i32 %i.02.lcssa, i32 1
    %5 = load i32 (...)*, i32 (...)** %4, align 4, !tbaa !1
    br label %9
  
  ; <label>:6                                       ; preds = %0
    %7 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
    %8 = icmp eq i32 %7, 0
    br i1 %8, label %3, label %10
  
  ; <label>:9                                       ; preds = %31, %3
    %.0 = phi i32 (...)* [ %5, %3 ], [ null, %31 ]
    ret i32 (...)* %.0
  
  ; <label>:10                                      ; preds = %6
    %11 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0))
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %3, label %13
  
  ; <label>:13                                      ; preds = %10
    %14 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
    %15 = icmp eq i32 %14, 0
    br i1 %15, label %3, label %16
  
  ; <label>:16                                      ; preds = %13
    %17 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0))
    %18 = icmp eq i32 %17, 0
    br i1 %18, label %3, label %19
  
  ; <label>:19                                      ; preds = %16
    %20 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0))
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %3, label %22
  
  ; <label>:22                                      ; preds = %19
    %23 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0))
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %3, label %25
  
  ; <label>:25                                      ; preds = %22
    %26 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
    %27 = icmp eq i32 %26, 0
    br i1 %27, label %3, label %28
  
  ; <label>:28                                      ; preds = %25
    %29 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0))
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %3, label %31
  
  ; <label>:31                                      ; preds = %28
    %puts = tail call i32 @puts(i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @str, i32 0, i32 0))
    br label %9
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #1
  
  ; Function Attrs: norecurse nounwind
  define i32 @zero(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph7.preheader, label %._crit_edge
  
  .lr.ph7.preheader:                                ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep6 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph7
  
  .lr.ph7:                                          ; preds = %.loopexit, %.lr.ph7.preheader
    %lsr.iv7 = phi float* [ %43, %.loopexit ], [ %scevgep6, %.lr.ph7.preheader ]
    %lsr.iv1 = phi float* [ %42, %.loopexit ], [ %filt, %.lr.ph7.preheader ]
    %y_filt.06 = phi i32 [ %27, %.loopexit ], [ 0, %.lr.ph7.preheader ]
    %y_res.05 = phi i32 [ %41, %.loopexit ], [ %22, %.lr.ph7.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.06, %x_dim
    %notlhs = icmp slt i32 %y_res.05, 0
    %notrhs = icmp sge i32 %y_res.05, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph7, %36
    %lsr.iv10 = phi float* [ %scevgep11, %36 ], [ %lsr.iv7, %.lr.ph7 ]
    %lsr.iv3 = phi float* [ %scevgep4, %36 ], [ %lsr.iv1, %.lr.ph7 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %36 ], [ 0, %.lr.ph7 ]
    %28 = add i32 %10, %lsr.iv
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %36
  
  ; <label>:32                                      ; preds = %.lr.ph
    %33 = bitcast float* %lsr.iv3 to i32*
    %34 = bitcast float* %lsr.iv10 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    br label %36
  
  ; <label>:36                                      ; preds = %32, %.lr.ph
    %lsr.iv.next = add i32 %lsr.iv, 1
    %37 = add i32 %y_filt.06, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %scevgep11 = getelementptr float, float* %lsr.iv10, i32 1
    %38 = icmp slt i32 %37, %27
    br i1 %38, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %36, %.lr.ph7
    %39 = bitcast float* %lsr.iv1 to i1*
    %40 = bitcast float* %lsr.iv7 to i1*
    %41 = add nsw i32 %y_res.05, %x_dim
    %scevgep = getelementptr i1, i1* %39, i32 %24
    %42 = bitcast i1* %scevgep to float*
    %scevgep9 = getelementptr i1, i1* %40, i32 %24
    %43 = bitcast i1* %scevgep9 to float*
    %44 = icmp slt i32 %27, %1
    br i1 %44, label %.lr.ph7, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @repeat(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.preheader.lr.ph, label %._crit_edge6
  
  .preheader.lr.ph:                                 ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = sub nsw i32 %1, %x_dim
    %25 = add nsw i32 %x_dim, -1
    %26 = shl i32 %x_dim, 2
    br label %.preheader
  
  .preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
    %lsr.iv1 = phi float* [ %48, %._crit_edge ], [ %filt, %.preheader.lr.ph ]
    %y_filt.05 = phi i32 [ 0, %.preheader.lr.ph ], [ %28, %._crit_edge ]
    %y_res.04 = phi i32 [ %22, %.preheader.lr.ph ], [ %47, %._crit_edge ]
    %27 = icmp sgt i32 %x_dim, 0
    %28 = add nsw i32 %y_filt.05, %x_dim
    br i1 %27, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader
    %29 = icmp sgt i32 %y_res.04, -1
    %30 = icmp slt i32 %y_res.04, %1
    %y_res.0. = select i1 %30, i32 %y_res.04, i32 %24
    %y_res.0.. = select i1 %29, i32 %y_res.0., i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %31, %.lr.ph
    %lsr.iv3 = phi float* [ %scevgep4, %31 ], [ %lsr.iv1, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %31 ], [ 0, %.lr.ph ]
    %32 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %33 = add i32 %10, %lsr.iv
    %34 = icmp sgt i32 %33, -1
    %35 = add i32 %10, %lsr.iv
    %36 = icmp slt i32 %35, %x_dim
    %37 = add i32 %10, %lsr.iv
    %38 = select i1 %36, i32 %37, i32 %25
    %39 = select i1 %34, i32 %38, i32 0
    %40 = add nsw i32 %39, %y_res.0..
    %41 = getelementptr inbounds float, float* %result, i32 %40
    %42 = load float, float* %41, align 4, !tbaa !6
    %43 = fadd float %32, %42
    store float %43, float* %41, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, 1
    %44 = add i32 %y_filt.05, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %45 = icmp slt i32 %44, %28
    br i1 %45, label %31, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %31, %.preheader
    %46 = bitcast float* %lsr.iv1 to i1*
    %47 = add nsw i32 %y_res.04, %x_dim
    %scevgep = getelementptr i1, i1* %46, i32 %26
    %48 = bitcast i1* %scevgep to float*
    %49 = icmp slt i32 %28, %1
    br i1 %49, label %.preheader, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect2(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = mul nsw i32 %5, %x_dim
    %7 = select i1 %4, i32 %6, i32 0
    %8 = mul i32 %y_dim, %x_dim
    %9 = xor i32 %x_dim, -1
    %.v = select i1 %1, i32 %9, i32 1
    %10 = add i32 %.v, %x_pos
    %11 = icmp sgt i32 %8, 0
    br i1 %11, label %.lr.ph5.preheader, label %._crit_edge6
  
  .lr.ph5.preheader:                                ; preds = %0
    %12 = icmp sgt i32 %y_pos, 0
    %13 = xor i32 %y_dim, -1
    %.v10 = select i1 %12, i32 %13, i32 1
    %14 = add i32 %.v10, %y_pos
    %15 = mul nsw i32 %14, %x_dim
    %result11 = bitcast float* %result to i8*
    %16 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %result11, i8 0, i32 %16, i32 4, i1 false)
    %17 = shl i32 %x_dim, 2
    br label %.lr.ph5
  
  .lr.ph5:                                          ; preds = %._crit_edge, %.lr.ph5.preheader
    %lsr.iv = phi float* [ %51, %._crit_edge ], [ %filt, %.lr.ph5.preheader ]
    %y_filt.04 = phi i32 [ %21, %._crit_edge ], [ 0, %.lr.ph5.preheader ]
    %y_edge.03 = phi i32 [ %50, %._crit_edge ], [ %15, %.lr.ph5.preheader ]
    %18 = icmp sgt i32 %x_dim, 0
    %19 = icmp eq i32 %y_edge.03, 0
    %20 = select i1 %19, i32 %x_dim, i32 0
    %.y_edge.0 = add nsw i32 %20, %y_edge.03
    %21 = add nsw i32 %y_filt.04, %x_dim
    br i1 %18, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.lr.ph5
    %22 = icmp sgt i32 %.y_edge.0, -1
    %23 = sub nsw i32 0, %.y_edge.0
    %24 = select i1 %22, i32 %.y_edge.0, i32 %23
    %25 = sub nsw i32 %7, %24
    %26 = add nsw i32 %25, %x_dim
    %27 = icmp sgt i32 %26, -1
    %28 = sub nsw i32 0, %26
    %29 = select i1 %27, i32 %26, i32 %28
    br label %30
  
  ; <label>:30                                      ; preds = %30, %.lr.ph
    %lsr.iv2 = phi float* [ %scevgep3, %30 ], [ %lsr.iv, %.lr.ph ]
    %x_filt.02 = phi i32 [ %y_filt.04, %.lr.ph ], [ %46, %30 ]
    %x_edge.01 = phi i32 [ %10, %.lr.ph ], [ %47, %30 ]
    %31 = icmp eq i32 %x_edge.01, 0
    %32 = zext i1 %31 to i32
    %.x_edge.0 = add nsw i32 %32, %x_edge.01
    %33 = load float, float* %lsr.iv2, align 4, !tbaa !6
    %34 = icmp sgt i32 %.x_edge.0, -1
    %35 = sub nsw i32 0, %.x_edge.0
    %36 = select i1 %34, i32 %.x_edge.0, i32 %35
    %37 = sub nsw i32 %3, %36
    %38 = add nsw i32 %37, 1
    %39 = icmp sgt i32 %37, -2
    %40 = xor i32 %37, -1
    %41 = select i1 %39, i32 %38, i32 %40
    %42 = add nsw i32 %41, %29
    %43 = getelementptr inbounds float, float* %result, i32 %42
    %44 = load float, float* %43, align 4, !tbaa !6
    %45 = fadd float %33, %44
    store float %45, float* %43, align 4, !tbaa !6
    %46 = add nsw i32 %x_filt.02, 1
    %47 = add nsw i32 %.x_edge.0, 1
    %scevgep3 = getelementptr float, float* %lsr.iv2, i32 1
    %48 = icmp slt i32 %46, %21
    br i1 %48, label %30, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %30, %.lr.ph5
    %49 = bitcast float* %lsr.iv to i1*
    %50 = add nsw i32 %.y_edge.0, %x_dim
    %scevgep = getelementptr i1, i1* %49, i32 %17
    %51 = bitcast i1* %scevgep to float*
    %52 = icmp slt i32 %21, %8
    br i1 %52, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %0
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect1(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph22.preheader, label %._crit_edge23
  
  .lr.ph22.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %.lr.ph22.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge23
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.4 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.4, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.5 = select i1 %51, i32 0, i32 %26
    %.6 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge23
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge23 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge23 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge23 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge23 ], [ %.5, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge23 ], [ %.6, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge23 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph18.preheader, label %._crit_edge19
  
  .lr.ph18.preheader:                               ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep9 = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %.lr.ph18
  
  .lr.ph18:                                         ; preds = %._crit_edge, %.lr.ph18.preheader
    %lsr.iv10 = phi float* [ %85, %._crit_edge ], [ %scevgep9, %.lr.ph18.preheader ]
    %y_edge.016 = phi i32 [ %y_edge_dist.0, %.lr.ph18.preheader ], [ %84, %._crit_edge ]
    %y_filt.015 = phi i32 [ %y_start.0, %.lr.ph18.preheader ], [ %83, %._crit_edge ]
    %59 = add nsw i32 %y_filt.015, %x_start.1
    %60 = add nsw i32 %y_filt.015, %x_stop.1
    %61 = icmp slt i32 %59, %60
    br i1 %61, label %.lr.ph14, label %._crit_edge
  
  .lr.ph14:                                         ; preds = %.lr.ph18
    %62 = icmp sgt i32 %y_edge.016, -1
    %63 = sub nsw i32 0, %y_edge.016
    %64 = select i1 %62, i32 %y_edge.016, i32 %63
    %65 = sub nsw i32 %8, %64
    %66 = icmp sgt i32 %65, -1
    %67 = sub nsw i32 0, %65
    %68 = select i1 %66, i32 %65, i32 %67
    br label %69
  
  ; <label>:69                                      ; preds = %69, %.lr.ph14
    %lsr.iv13 = phi float* [ %scevgep14, %69 ], [ %lsr.iv10, %.lr.ph14 ]
    %lsr.iv7 = phi i32 [ %lsr.iv.next8, %69 ], [ %56, %.lr.ph14 ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next, %69 ], [ %55, %.lr.ph14 ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph14 ], [ %81, %69 ]
    %70 = load float, float* %lsr.iv13, align 4, !tbaa !6
    %71 = icmp sgt i32 %x_edge.013, -1
    %72 = select i1 %71, i32 %x_edge.013, i32 %lsr.iv6
    %73 = sub nsw i32 %4, %72
    %74 = icmp sgt i32 %73, -1
    %75 = sub nsw i32 0, %73
    %76 = select i1 %74, i32 %73, i32 %75
    %77 = add nsw i32 %76, %68
    %78 = getelementptr inbounds float, float* %result, i32 %77
    %79 = load float, float* %78, align 4, !tbaa !6
    %80 = fadd float %70, %79
    store float %80, float* %78, align 4, !tbaa !6
    %81 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv6, -1
    %lsr.iv.next8 = add i32 %lsr.iv7, -1
    %scevgep14 = getelementptr float, float* %lsr.iv13, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next8, 0
    br i1 %exitcond, label %._crit_edge, label %69
  
  ._crit_edge:                                      ; preds = %69, %.lr.ph18
    %82 = bitcast float* %lsr.iv10 to i1*
    %83 = add nsw i32 %y_filt.015, %x_dim
    %84 = add nsw i32 %y_edge.016, %x_dim
    %scevgep12 = getelementptr i1, i1* %82, i32 %58
    %85 = bitcast i1* %scevgep12 to float*
    %86 = icmp slt i32 %83, %y_stop.0
    br i1 %86, label %.lr.ph18, label %._crit_edge19
  
  ._crit_edge19:                                    ; preds = %._crit_edge, %53
    %87 = icmp eq i32 %f_or_e, 1
    br i1 %87, label %88, label %.loopexit
  
  ; <label>:88                                      ; preds = %._crit_edge19
    %89 = icmp sgt i32 %x_pos, -1
    %90 = sub nsw i32 0, %x_pos
    %91 = select i1 %89, i32 %x_pos, i32 %90
    %92 = icmp ne i32 %91, %28
    %93 = icmp ne i32 %x_pos, 0
    %or.cond = and i1 %93, %92
    %94 = icmp slt i32 %4, %1
    %or.cond24 = and i1 %or.cond, %94
    br i1 %or.cond24, label %.lr.ph11.preheader, label %.loopexit8
  
  .lr.ph11.preheader:                               ; preds = %88
    %scevgep2 = getelementptr float, float* %result, i32 %4
    %95 = shl i32 %x_dim, 2
    br label %.lr.ph11
  
  .lr.ph11:                                         ; preds = %.lr.ph11, %.lr.ph11.preheader
    %lsr.iv3 = phi float* [ %99, %.lr.ph11 ], [ %scevgep2, %.lr.ph11.preheader ]
    %y_filt.110 = phi i32 [ %98, %.lr.ph11 ], [ %4, %.lr.ph11.preheader ]
    %lsr.iv34 = bitcast float* %lsr.iv3 to i1*
    %96 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %97 = fadd float %96, %96
    store float %97, float* %lsr.iv3, align 4, !tbaa !6
    %98 = add nsw i32 %y_filt.110, %x_dim
    %scevgep5 = getelementptr i1, i1* %lsr.iv34, i32 %95
    %99 = bitcast i1* %scevgep5 to float*
    %100 = icmp slt i32 %98, %1
    br i1 %100, label %.lr.ph11, label %.loopexit8
  
  .loopexit8:                                       ; preds = %.lr.ph11, %88
    %101 = icmp sgt i32 %y_pos, -1
    %102 = sub nsw i32 0, %y_pos
    %103 = select i1 %101, i32 %y_pos, i32 %102
    %104 = icmp ne i32 %103, %30
    %105 = icmp ne i32 %y_pos, 0
    %or.cond3 = and i1 %105, %104
    br i1 %or.cond3, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %.loopexit8
    %106 = add nsw i32 %8, %x_dim
    %107 = icmp sgt i32 %x_dim, 0
    br i1 %107, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %scevgep = getelementptr float, float* %result, i32 %8
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv = phi float* [ %scevgep1, %.lr.ph ], [ %scevgep, %.lr.ph.preheader ]
    %x_filt.19 = phi i32 [ %110, %.lr.ph ], [ %8, %.lr.ph.preheader ]
    %108 = load float, float* %lsr.iv, align 4, !tbaa !6
    %109 = fadd float %108, %108
    store float %109, float* %lsr.iv, align 4, !tbaa !6
    %110 = add nsw i32 %x_filt.19, 1
    %scevgep1 = getelementptr float, float* %lsr.iv, i32 1
    %111 = icmp slt i32 %110, %106
    br i1 %111, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %.preheader, %.loopexit8, %._crit_edge19
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @extend(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph21.preheader, label %._crit_edge22
  
  .lr.ph21.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge22
  
  ._crit_edge22:                                    ; preds = %.lr.ph21.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge22
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.3 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.3, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.4 = select i1 %51, i32 0, i32 %26
    %.5 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge22
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge22 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge22 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge22 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge22 ], [ %.4, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge22 ], [ %.5, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge22 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph17, label %._crit_edge18
  
  .lr.ph17:                                         ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %59
  
  ; <label>:59                                      ; preds = %._crit_edge, %.lr.ph17
    %lsr.iv3 = phi float* [ %117, %._crit_edge ], [ %scevgep, %.lr.ph17 ]
    %y_edge.015 = phi i32 [ %y_edge_dist.0, %.lr.ph17 ], [ %116, %._crit_edge ]
    %y_filt.014 = phi i32 [ %y_start.0, %.lr.ph17 ], [ %115, %._crit_edge ]
    %60 = add nsw i32 %y_filt.014, %x_start.1
    %61 = add nsw i32 %y_filt.014, %x_stop.1
    %62 = icmp slt i32 %60, %61
    br i1 %62, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %59
    %63 = icmp ne i32 %8, 0
    %64 = icmp sgt i32 %y_edge.015, 0
    %65 = icmp slt i32 %y_edge.015, 0
    %not. = xor i1 %64, true
    %66 = and i1 %65, %not.
    %67 = select i1 %63, i1 %64, i1 %66
    %68 = icmp sgt i32 %y_edge.015, -1
    %69 = sub nsw i32 0, %y_edge.015
    %70 = select i1 %68, i32 %y_edge.015, i32 %69
    %71 = sub nsw i32 %8, %70
    %72 = icmp sgt i32 %71, -1
    %73 = sub nsw i32 0, %71
    %74 = select i1 %72, i32 %71, i32 %73
    %75 = add nsw i32 %y_edge.015, %8
    %76 = icmp slt i32 %75, 0
    %77 = icmp slt i32 %75, %y_dim
    %.10 = select i1 %77, i32 %75, i32 %6
    %78 = select i1 %76, i32 0, i32 %.10
    br label %79
  
  ; <label>:79                                      ; preds = %112, %.lr.ph
    %lsr.iv6 = phi float* [ %scevgep7, %112 ], [ %lsr.iv3, %.lr.ph ]
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %112 ], [ %56, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %112 ], [ %55, %.lr.ph ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph ], [ %113, %112 ]
    %80 = icmp ne i32 %4, 0
    %81 = icmp sgt i32 %x_edge.013, 0
    %82 = icmp slt i32 %x_edge.013, 0
    %not.11 = xor i1 %81, true
    %83 = and i1 %82, %not.11
    %84 = select i1 %80, i1 %81, i1 %83
    %85 = xor i1 %67, %84
    %86 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %87 = icmp sgt i32 %x_edge.013, -1
    %88 = select i1 %87, i32 %x_edge.013, i32 %lsr.iv
    %89 = sub nsw i32 %4, %88
    %90 = icmp sgt i32 %89, -1
    %91 = sub nsw i32 0, %89
    %92 = select i1 %90, i32 %89, i32 %91
    %93 = add nsw i32 %92, %74
    %94 = getelementptr inbounds float, float* %result, i32 %93
    %95 = load float, float* %94, align 4, !tbaa !6
    br i1 %85, label %96, label %110
  
  ; <label>:96                                      ; preds = %79
    %97 = fsub float %95, %86
    store float %97, float* %94, align 4, !tbaa !6
    %98 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %99 = fadd float %98, %98
    %100 = add i32 %4, %x_edge.013
    %101 = icmp slt i32 %100, 0
    %102 = add i32 %4, %x_edge.013
    %103 = icmp slt i32 %102, %x_dim
    %104 = add i32 %4, %x_edge.013
    %.9 = select i1 %103, i32 %104, i32 %3
    %105 = select i1 %101, i32 0, i32 %.9
    %106 = add nsw i32 %105, %78
    %107 = getelementptr inbounds float, float* %result, i32 %106
    %108 = load float, float* %107, align 4, !tbaa !6
    %109 = fadd float %108, %99
    store float %109, float* %107, align 4, !tbaa !6
    br label %112
  
  ; <label>:110                                     ; preds = %79
    %111 = fadd float %86, %95
    store float %111, float* %94, align 4, !tbaa !6
    br label %112
  
  ; <label>:112                                     ; preds = %110, %96
    %113 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv, -1
    %lsr.iv.next2 = add i32 %lsr.iv1, -1
    %scevgep7 = getelementptr float, float* %lsr.iv6, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next2, 0
    br i1 %exitcond, label %._crit_edge, label %79
  
  ._crit_edge:                                      ; preds = %112, %59
    %114 = bitcast float* %lsr.iv3 to i1*
    %115 = add nsw i32 %y_filt.014, %x_dim
    %116 = add nsw i32 %y_edge.015, %x_dim
    %scevgep5 = getelementptr i1, i1* %114, i32 %58
    %117 = bitcast i1* %scevgep5 to float*
    %118 = icmp slt i32 %115, %y_stop.0
    br i1 %118, label %59, label %._crit_edge18
  
  ._crit_edge18:                                    ; preds = %._crit_edge, %53
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @nocompute(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %x_pos.off = add i32 %x_pos, 1
    %2 = icmp ugt i32 %x_pos.off, 2
    %y_pos.off = add i32 %y_pos, 1
    %3 = icmp ugt i32 %y_pos.off, 2
    %4 = or i1 %2, %3
    br i1 %4, label %.preheader, label %.preheader6
  
  .preheader6:                                      ; preds = %0
    %5 = icmp sgt i32 %1, 0
    br i1 %5, label %.lr.ph10.preheader, label %.loopexit
  
  .lr.ph10.preheader:                               ; preds = %.preheader6
    %6 = mul i32 %y_dim, %x_dim
    br label %.lr.ph10
  
  .preheader:                                       ; preds = %0
    %7 = icmp sgt i32 %1, 0
    br i1 %7, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %8 = bitcast float* %result to i8*
    %9 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %8, i8 0, i32 %9, i32 4, i1 false)
    br label %.loopexit
  
  .lr.ph10:                                         ; preds = %.lr.ph10, %.lr.ph10.preheader
    %lsr.iv3 = phi float* [ %scevgep4, %.lr.ph10 ], [ %filt, %.lr.ph10.preheader ]
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph10 ], [ %result, %.lr.ph10.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph10 ], [ %6, %.lr.ph10.preheader ]
    %lsr.iv35 = bitcast float* %lsr.iv3 to i32*
    %lsr.iv12 = bitcast float* %lsr.iv1 to i32*
    %10 = load i32, i32* %lsr.iv35, align 4, !tbaa !6
    store i32 %10, i32* %lsr.iv12, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %exitcond12 = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond12, label %.loopexit, label %.lr.ph10
  
  .loopexit:                                        ; preds = %.lr.ph10, %.lr.ph.preheader, %.preheader, %.preheader6
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  define i32 @ereflect(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #0 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = select i1 %4, i32 %5, i32 0
    %7 = mul nsw i32 %6, %x_dim
    %8 = mul i32 %y_dim, %x_dim
    %9 = icmp sgt i32 %x_pos, 1
    br i1 %9, label %10, label %12
  
  ; <label>:10                                      ; preds = %0
    %11 = sub nsw i32 %x_pos, %x_dim
    br label %16
  
  ; <label>:12                                      ; preds = %0
    %13 = icmp slt i32 %x_pos, -1
    %14 = add nsw i32 %x_pos, 1
    %15 = select i1 %13, i32 %14, i32 0
    br label %16
  
  ; <label>:16                                      ; preds = %12, %10
    %17 = phi i32 [ %11, %10 ], [ %15, %12 ]
    %18 = icmp sgt i32 %y_pos, 1
    br i1 %18, label %19, label %21
  
  ; <label>:19                                      ; preds = %16
    %20 = sub nsw i32 %y_pos, %y_dim
    br label %25
  
  ; <label>:21                                      ; preds = %16
    %22 = icmp slt i32 %y_pos, -1
    %23 = add nsw i32 %y_pos, 1
    %24 = select i1 %22, i32 %23, i32 0
    br label %25
  
  ; <label>:25                                      ; preds = %21, %19
    %26 = phi i32 [ %20, %19 ], [ %24, %21 ]
    %27 = icmp sgt i32 %8, 0
    br i1 %27, label %.preheader3.preheader, label %._crit_edge27
  
  .preheader3.preheader:                            ; preds = %25
    %28 = bitcast float* %result to i8*
    %29 = mul nsw i32 %26, %x_dim
    %30 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %28, i8 0, i32 %30, i32 4, i1 false)
    %31 = shl i32 %x_dim, 2
    %32 = sub i32 0, %17
    br label %.preheader3
  
  .preheader3:                                      ; preds = %._crit_edge23, %.preheader3.preheader
    %lsr.iv19 = phi float* [ %60, %._crit_edge23 ], [ %filt, %.preheader3.preheader ]
    %y_filt.026 = phi i32 [ %34, %._crit_edge23 ], [ 0, %.preheader3.preheader ]
    %y_edge.025 = phi i32 [ %59, %._crit_edge23 ], [ %29, %.preheader3.preheader ]
    %33 = icmp sgt i32 %x_dim, 0
    %34 = add nsw i32 %y_filt.026, %x_dim
    br i1 %33, label %.lr.ph22, label %._crit_edge23
  
  .lr.ph22:                                         ; preds = %.preheader3
    %35 = icmp sgt i32 %y_edge.025, -1
    %36 = sub nsw i32 0, %y_edge.025
    %37 = select i1 %35, i32 %y_edge.025, i32 %36
    %38 = sub nsw i32 %7, %37
    %39 = icmp sgt i32 %38, -1
    %40 = sub nsw i32 0, %38
    %41 = select i1 %39, i32 %38, i32 %40
    br label %42
  
  ; <label>:42                                      ; preds = %42, %.lr.ph22
    %lsr.iv24 = phi i32 [ %lsr.iv.next25, %42 ], [ %32, %.lr.ph22 ]
    %lsr.iv22 = phi float* [ %scevgep23, %42 ], [ %lsr.iv19, %.lr.ph22 ]
    %lsr.iv17 = phi i32 [ %lsr.iv.next18, %42 ], [ 0, %.lr.ph22 ]
    %43 = load float, float* %lsr.iv22, align 4, !tbaa !6
    %44 = add i32 %17, %lsr.iv17
    %45 = icmp sgt i32 %44, -1
    %46 = add i32 %17, %lsr.iv17
    %47 = select i1 %45, i32 %46, i32 %lsr.iv24
    %48 = sub nsw i32 %3, %47
    %49 = icmp sgt i32 %48, -1
    %50 = sub nsw i32 0, %48
    %51 = select i1 %49, i32 %48, i32 %50
    %52 = add nsw i32 %51, %41
    %53 = getelementptr inbounds float, float* %result, i32 %52
    %54 = load float, float* %53, align 4, !tbaa !6
    %55 = fadd float %43, %54
    store float %55, float* %53, align 4, !tbaa !6
    %lsr.iv.next18 = add i32 %lsr.iv17, 1
    %56 = add i32 %y_filt.026, %lsr.iv.next18
    %scevgep23 = getelementptr float, float* %lsr.iv22, i32 1
    %lsr.iv.next25 = add i32 %lsr.iv24, -1
    %57 = icmp slt i32 %56, %34
    br i1 %57, label %42, label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %42, %.preheader3
    %58 = bitcast float* %lsr.iv19 to i1*
    %59 = add nsw i32 %y_edge.025, %x_dim
    %scevgep21 = getelementptr i1, i1* %58, i32 %31
    %60 = bitcast i1* %scevgep21 to float*
    %61 = icmp slt i32 %34, %8
    br i1 %61, label %.preheader3, label %._crit_edge27
  
  ._crit_edge27:                                    ; preds = %._crit_edge23, %25
    %62 = icmp ne i32 %x_pos, 0
    %63 = icmp slt i32 %3, %8
    %or.cond = and i1 %62, %63
    br i1 %or.cond, label %.lr.ph19.preheader, label %.loopexit
  
  .lr.ph19.preheader:                               ; preds = %._crit_edge27
    %scevgep13 = getelementptr float, float* %result, i32 %3
    %64 = shl i32 %x_dim, 2
    br label %.lr.ph19
  
  .lr.ph19:                                         ; preds = %.lr.ph19, %.lr.ph19.preheader
    %lsr.iv14 = phi float* [ %70, %.lr.ph19 ], [ %scevgep13, %.lr.ph19.preheader ]
    %y_filt.118 = phi i32 [ %69, %.lr.ph19 ], [ %3, %.lr.ph19.preheader ]
    %lsr.iv1415 = bitcast float* %lsr.iv14 to i1*
    %65 = load float, float* %lsr.iv14, align 4, !tbaa !6
    %66 = fpext float %65 to double
    %67 = fmul double %66, 0x3FF6A09E667F3BCD
    %68 = fptrunc double %67 to float
    store float %68, float* %lsr.iv14, align 4, !tbaa !6
    %69 = add nsw i32 %y_filt.118, %x_dim
    %scevgep16 = getelementptr i1, i1* %lsr.iv1415, i32 %64
    %70 = bitcast i1* %scevgep16 to float*
    %71 = icmp slt i32 %69, %8
    br i1 %71, label %.lr.ph19, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph19, %._crit_edge27
    %72 = icmp eq i32 %y_pos, 0
    br i1 %72, label %.preheader, label %.preheader1
  
  .preheader1:                                      ; preds = %.loopexit
    %73 = add nsw i32 %7, %x_dim
    %74 = icmp sgt i32 %x_dim, 0
    br i1 %74, label %.lr.ph17.preheader, label %.preheader
  
  .lr.ph17.preheader:                               ; preds = %.preheader1
    %75 = mul i32 %6, %x_dim
    %scevgep10 = getelementptr float, float* %result, i32 %75
    br label %.lr.ph17
  
  .preheader:                                       ; preds = %.lr.ph17, %.preheader1, %.loopexit
    %76 = icmp sgt i32 %8, 0
    br i1 %76, label %.lr.ph13.preheader, label %._crit_edge14.thread
  
  .lr.ph13.preheader:                               ; preds = %.preheader
    %77 = mul i32 %y_dim, %x_dim
    br label %.lr.ph13
  
  ._crit_edge14.thread:                             ; preds = %.preheader
    %78 = tail call double @sqrt(double 0.000000e+00) #5
    %79 = fcmp oeq double %78, %78
    br i1 %79, label %._crit_edge10.thread, label %call.sqrt
  
  call.sqrt:                                        ; preds = %._crit_edge14.thread
    %80 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge10.thread
  
  .lr.ph17:                                         ; preds = %.lr.ph17, %.lr.ph17.preheader
    %lsr.iv11 = phi float* [ %scevgep12, %.lr.ph17 ], [ %scevgep10, %.lr.ph17.preheader ]
    %x_filt.116 = phi i32 [ %85, %.lr.ph17 ], [ %7, %.lr.ph17.preheader ]
    %81 = load float, float* %lsr.iv11, align 4, !tbaa !6
    %82 = fpext float %81 to double
    %83 = fmul double %82, 0x3FF6A09E667F3BCD
    %84 = fptrunc double %83 to float
    store float %84, float* %lsr.iv11, align 4, !tbaa !6
    %85 = add nsw i32 %x_filt.116, 1
    %scevgep12 = getelementptr float, float* %lsr.iv11, i32 1
    %86 = icmp slt i32 %85, %73
    br i1 %86, label %.lr.ph17, label %.preheader
  
  .lr.ph13:                                         ; preds = %.lr.ph13, %.lr.ph13.preheader
    %lsr.iv8 = phi float* [ %scevgep9, %.lr.ph13 ], [ %result, %.lr.ph13.preheader ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next7, %.lr.ph13 ], [ %77, %.lr.ph13.preheader ]
    %norm.012 = phi double [ %90, %.lr.ph13 ], [ 0.000000e+00, %.lr.ph13.preheader ]
    %87 = load float, float* %lsr.iv8, align 4, !tbaa !6
    %88 = fmul float %87, %87
    %89 = fpext float %88 to double
    %90 = fadd double %norm.012, %89
    %lsr.iv.next7 = add i32 %lsr.iv6, -1
    %scevgep9 = getelementptr float, float* %lsr.iv8, i32 1
    %exitcond33 = icmp eq i32 %lsr.iv.next7, 0
    br i1 %exitcond33, label %._crit_edge14, label %.lr.ph13
  
  ._crit_edge14:                                    ; preds = %.lr.ph13
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %._crit_edge14.split, label %call.sqrt26
  
  call.sqrt26:                                      ; preds = %._crit_edge14
    %93 = tail call double @sqrt(double %90) #6
    br label %._crit_edge14.split
  
  ._crit_edge14.split:                              ; preds = %._crit_edge14, %call.sqrt26
    %94 = phi double [ %91, %._crit_edge14 ], [ %93, %call.sqrt26 ]
    %95 = icmp sgt i32 %8, 0
    br i1 %95, label %.lr.ph9.preheader, label %._crit_edge10.thread
  
  .lr.ph9.preheader:                                ; preds = %._crit_edge14.split
    %96 = mul i32 %y_dim, %x_dim
    br label %.lr.ph9
  
  .lr.ph9:                                          ; preds = %.lr.ph9, %.lr.ph9.preheader
    %lsr.iv4 = phi float* [ %scevgep5, %.lr.ph9 ], [ %filt, %.lr.ph9.preheader ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %.lr.ph9 ], [ %96, %.lr.ph9.preheader ]
    %onorm.07 = phi double [ %100, %.lr.ph9 ], [ 0.000000e+00, %.lr.ph9.preheader ]
    %97 = load float, float* %lsr.iv4, align 4, !tbaa !6
    %98 = fmul float %97, %97
    %99 = fpext float %98 to double
    %100 = fadd double %onorm.07, %99
    %lsr.iv.next3 = add i32 %lsr.iv2, -1
    %scevgep5 = getelementptr float, float* %lsr.iv4, i32 1
    %exitcond32 = icmp eq i32 %lsr.iv.next3, 0
    br i1 %exitcond32, label %._crit_edge10, label %.lr.ph9
  
  ._crit_edge10.thread:                             ; preds = %call.sqrt, %._crit_edge14.thread, %._crit_edge14.split
    %101 = tail call double @sqrt(double 0.000000e+00) #5
    %102 = fcmp oeq double %101, %101
    br i1 %102, label %._crit_edge, label %call.sqrt27
  
  call.sqrt27:                                      ; preds = %._crit_edge10.thread
    %103 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge
  
  ._crit_edge10:                                    ; preds = %.lr.ph9
    %104 = tail call double @sqrt(double %100) #5
    %105 = fcmp oeq double %104, %104
    br i1 %105, label %._crit_edge10.split, label %call.sqrt28
  
  call.sqrt28:                                      ; preds = %._crit_edge10
    %106 = tail call double @sqrt(double %100) #6
    br label %._crit_edge10.split
  
  ._crit_edge10.split:                              ; preds = %._crit_edge10, %call.sqrt28
    %107 = phi double [ %104, %._crit_edge10 ], [ %106, %call.sqrt28 ]
    %108 = icmp sgt i32 %8, 0
    %109 = fdiv double %94, %107
    br i1 %108, label %.lr.ph.preheader, label %._crit_edge
  
  .lr.ph.preheader:                                 ; preds = %._crit_edge10.split
    %110 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %110, %.lr.ph.preheader ]
    %111 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %112 = fpext float %111 to double
    %113 = fdiv double %112, %109
    %114 = fptrunc double %113 to float
    store float %114, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %call.sqrt27, %._crit_edge10.thread, %._crit_edge10.split
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  ; Function Attrs: norecurse nounwind
  define i32 @predict(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph12.preheader, label %._crit_edge
  
  .lr.ph12.preheader:                               ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep10 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph12
  
  .lr.ph12:                                         ; preds = %.loopexit2, %.lr.ph12.preheader
    %lsr.iv11 = phi float* [ %45, %.loopexit2 ], [ %scevgep10, %.lr.ph12.preheader ]
    %lsr.iv4 = phi float* [ %44, %.loopexit2 ], [ %filt, %.lr.ph12.preheader ]
    %y_filt.011 = phi i32 [ %27, %.loopexit2 ], [ 0, %.lr.ph12.preheader ]
    %y_res.010 = phi i32 [ %43, %.loopexit2 ], [ %22, %.lr.ph12.preheader ]
    %taps_used.09 = phi float [ %taps_used.3, %.loopexit2 ], [ 0.000000e+00, %.lr.ph12.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.011, %x_dim
    %notlhs = icmp slt i32 %y_res.010, 0
    %notrhs = icmp sge i32 %y_res.010, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit2, label %.lr.ph8
  
  .lr.ph8:                                          ; preds = %.lr.ph12, %38
    %lsr.iv14 = phi float* [ %scevgep15, %38 ], [ %lsr.iv11, %.lr.ph12 ]
    %lsr.iv7 = phi float* [ %scevgep8, %38 ], [ %lsr.iv4, %.lr.ph12 ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %38 ], [ 0, %.lr.ph12 ]
    %taps_used.15 = phi float [ %taps_used.2, %38 ], [ %taps_used.09, %.lr.ph12 ]
    %28 = add i32 %10, %lsr.iv2
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv2
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %38
  
  ; <label>:32                                      ; preds = %.lr.ph8
    %33 = bitcast float* %lsr.iv7 to i32*
    %34 = bitcast float* %lsr.iv14 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    %36 = load float, float* %lsr.iv7, align 4, !tbaa !6
    %37 = fadd float %taps_used.15, %36
    br label %38
  
  ; <label>:38                                      ; preds = %32, %.lr.ph8
    %taps_used.2 = phi float [ %37, %32 ], [ %taps_used.15, %.lr.ph8 ]
    %lsr.iv.next3 = add i32 %lsr.iv2, 1
    %39 = add i32 %y_filt.011, %lsr.iv.next3
    %scevgep8 = getelementptr float, float* %lsr.iv7, i32 1
    %scevgep15 = getelementptr float, float* %lsr.iv14, i32 1
    %40 = icmp slt i32 %39, %27
    br i1 %40, label %.lr.ph8, label %.loopexit2
  
  .loopexit2:                                       ; preds = %38, %.lr.ph12
    %taps_used.3 = phi float [ %taps_used.09, %.lr.ph12 ], [ %taps_used.2, %38 ]
    %41 = bitcast float* %lsr.iv4 to i1*
    %42 = bitcast float* %lsr.iv11 to i1*
    %43 = add nsw i32 %y_res.010, %x_dim
    %scevgep6 = getelementptr i1, i1* %41, i32 %24
    %44 = bitcast i1* %scevgep6 to float*
    %scevgep13 = getelementptr i1, i1* %42, i32 %24
    %45 = bitcast i1* %scevgep13 to float*
    %46 = icmp slt i32 %27, %1
    br i1 %46, label %.lr.ph12, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit2, %18
    %taps_used.0.lcssa = phi float [ 0.000000e+00, %18 ], [ %taps_used.3, %.loopexit2 ]
    %47 = icmp eq i32 %f_or_e, 0
    br i1 %47, label %48, label %.loopexit
  
  ; <label>:48                                      ; preds = %._crit_edge
    %49 = icmp sgt i32 %1, 0
    %50 = fdiv float 2.000000e+00, %taps_used.0.lcssa
    br i1 %49, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %48
    %51 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %51, %.lr.ph.preheader ]
    %52 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %53 = fmul float %50, %52
    store float %53, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %.lr.ph, %48, %._crit_edge
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare i32 @puts(i8* nocapture) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #4
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { nounwind "target-cpu"="mips32" }
  attributes #4 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #5 = { nounwind readnone }
  attributes #6 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"", !3, i64 0, !3, i64 4}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !7, i64 0}
  !7 = !{!"float", !4, i64 0}

...
---
name:            zero
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%24' }
  - { reg: '%a1', virtual-reg: '%25' }
  - { reg: '%a2', virtual-reg: '%26' }
  - { reg: '%a3', virtual-reg: '%27' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 24, size: 4, alignment: 8, isImmutable: true, isAliased: false }
  - { id: 1, offset: 20, size: 4, alignment: 4, isImmutable: true, isAliased: false }
  - { id: 2, offset: 16, size: 4, alignment: 8, isImmutable: true, isAliased: false }
body:             |
  bb.0 (%ir-block.0, freq 21):
    successors: %bb.1(62), %bb.2(37)
    liveins: %a0, %a1, %a2, %a3, %t9, %v0
  
    %34 = ADDu %v0, %t9
    %27 = COPY %a3
    %26 = COPY %a2
    %25 = COPY %a1
    %24 = COPY %a0
    %28 = LW %fixed-stack.2, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    BLEZ %27, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.3, freq 13):
    successors: %bb.3(100)
  
    %1 = ADDiu %27, -1
    B %bb.3, implicit-def dead %at
  
  bb.2 (%ir-block.5, freq 8):
    successors: %bb.3(100)
  
    %30 = ADDiu %27, 1
    %31 = SRA %27, 31
    %2 = AND killed %31, killed %30
  
  bb.3 (%ir-block.9, freq 21):
    successors: %bb.4(62), %bb.5(37)
  
    %3 = PHI %2, %bb.2, %1, %bb.1
    %0 = MUL %26, %25, implicit-def dead %hi0, implicit-def dead %lo0
    BLEZ %28, %bb.5, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.12, freq 13):
    successors: %bb.6(100)
  
    %4 = ADDiu %28, -1
    B %bb.6, implicit-def dead %at
  
  bb.5 (%ir-block.14, freq 8):
    successors: %bb.6(100)
  
    %32 = ADDiu %28, 1
    %33 = SRA %28, 31
    %5 = AND killed %33, killed %32
  
  bb.6 (%ir-block.18, freq 21):
    successors: %bb.7..lr.ph7.preheader(62), %bb.13.._crit_edge(37)
  
    %6 = PHI %5, %bb.5, %4, %bb.4
    BLEZ %0, %bb.13.._crit_edge, implicit-def dead %at
    B %bb.7..lr.ph7.preheader, implicit-def dead %at
  
  bb.7..lr.ph7.preheader (freq 13):
    successors: %bb.8..lr.ph7(100)
  
    %29 = LW %fixed-stack.1, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %36 = SLL %0, 2
    %37 = LW %34, target-flags(<unknown>) $memset, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry $memset)
    %35 = ADDiu %zero, 0
    %a0 = COPY %29
    %a1 = COPY %35
    %a2 = COPY %36
    %gp = COPY %34
    %t9 = COPY %37
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %7 = MUL %6, %25, implicit-def dead %hi0, implicit-def dead %lo0
    %8 = SLL %25, 2
    %38 = ADDu %3, %7
    %39 = SLL killed %38, 2
    %9 = ADDu %29, killed %39
  
  bb.8..lr.ph7 (freq 426):
    successors: %bb.12..loopexit(12), %bb.15..lr.ph7(87)
  
    %10 = PHI %9, %bb.7..lr.ph7.preheader, %23, %bb.12..loopexit
    %11 = PHI %24, %bb.7..lr.ph7.preheader, %22, %bb.12..loopexit
    %12 = PHI %35, %bb.7..lr.ph7.preheader, %14, %bb.12..loopexit
    %13 = PHI %7, %bb.7..lr.ph7.preheader, %21, %bb.12..loopexit
    %14 = ADDu %12, %25
    %41 = SLT %13, %0
    BEQ killed %41, %zero, %bb.12..loopexit, implicit-def dead %at
    B %bb.15..lr.ph7, implicit-def dead %at
  
  bb.15..lr.ph7 (freq 373):
    successors: %bb.12..loopexit(14), %bb.14..lr.ph7(85)
  
    BLTZ %13, %bb.12..loopexit, implicit-def dead %at
    B %bb.14..lr.ph7, implicit-def dead %at
  
  bb.14..lr.ph7 (freq 320):
    successors: %bb.12..loopexit(33), %bb.9..lr.ph(66)
  
    BLEZ %25, %bb.12..loopexit, implicit-def dead %at
    B %bb.9..lr.ph, implicit-def dead %at
  
  bb.9..lr.ph (freq 6826):
    successors: %bb.16..lr.ph(75), %bb.11(25)
  
    %15 = PHI %10, %bb.14..lr.ph7, %20, %bb.11
    %16 = PHI %11, %bb.14..lr.ph7, %19, %bb.11
    %17 = PHI %35, %bb.14..lr.ph7, %18, %bb.11
    %42 = ADDu %3, %17
    BLTZ %42, %bb.11, implicit-def dead %at
    B %bb.16..lr.ph, implicit-def dead %at
  
  bb.16..lr.ph (freq 5119):
    successors: %bb.10(66), %bb.11(33)
  
    %43 = SLT %42, %25
    BEQ killed %43, %zero, %bb.11, implicit-def dead %at
    B %bb.10, implicit-def dead %at
  
  bb.10 (%ir-block.32, freq 3413):
    successors: %bb.11(100)
  
    %44 = LW %16, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.33, !tbaa !6)
    SW killed %44, %15, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.34, !tbaa !6)
  
  bb.11 (%ir-block.36, freq 6826):
    successors: %bb.9..lr.ph(96), %bb.12..loopexit(3)
  
    %18 = ADDiu %17, 1
    %45 = ADDu %12, %18
    %46 = SLT killed %45, %14
    %20 = ADDiu %15, 4
    %19 = ADDiu %16, 4
    BNE killed %46, %zero, %bb.9..lr.ph, implicit-def dead %at
    B %bb.12..loopexit, implicit-def dead %at
  
  bb.12..loopexit (freq 426):
    successors: %bb.8..lr.ph7(96), %bb.13.._crit_edge(3)
  
    %23 = ADDu %10, %8
    %22 = ADDu %11, %8
    %21 = ADDu %13, %25
    %47 = SLT %14, %0
    BNE killed %47, %zero, %bb.8..lr.ph7, implicit-def dead %at
    B %bb.13.._crit_edge, implicit-def dead %at
  
  bb.13.._crit_edge (freq 21):
    liveouts: %v0
  
    %48 = IMPLICIT_DEF
    %v0 = COPY %48
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/epic/epic.edges.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.EDGE_HANDLER = type { i8*, i32 (...)* }
  
  @edge_foos = internal unnamed_addr constant [9 x %struct.EDGE_HANDLER] [%struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect2 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @repeat to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @zero to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @extend to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @nocompute to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @predict to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @ereflect to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }], align 4
  @.str.1 = private unnamed_addr constant [9 x i8] c"reflect1\00", align 1
  @.str.2 = private unnamed_addr constant [9 x i8] c"reflect2\00", align 1
  @.str.3 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
  @.str.4 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
  @.str.5 = private unnamed_addr constant [7 x i8] c"extend\00", align 1
  @.str.6 = private unnamed_addr constant [13 x i8] c"dont-compute\00", align 1
  @.str.7 = private unnamed_addr constant [8 x i8] c"predict\00", align 1
  @.str.8 = private unnamed_addr constant [9 x i8] c"ereflect\00", align 1
  @.str.9 = private unnamed_addr constant [9 x i8] c"treflect\00", align 1
  @str = private unnamed_addr constant [30 x i8] c"No such edge handler routine!\00"
  
  ; Function Attrs: nounwind
  define i32 (...)* @edge_function(i8* nocapture readonly %edges) #0 {
    %1 = tail call i32 @strcmp(i8* %edges, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0))
    %2 = icmp eq i32 %1, 0
    br i1 %2, label %3, label %6
  
  ; <label>:3                                       ; preds = %28, %25, %22, %19, %16, %13, %10, %6, %0
    %i.02.lcssa = phi i32 [ 0, %0 ], [ 1, %6 ], [ 2, %10 ], [ 3, %13 ], [ 4, %16 ], [ 5, %19 ], [ 6, %22 ], [ 7, %25 ], [ 8, %28 ]
    %4 = getelementptr inbounds [9 x %struct.EDGE_HANDLER], [9 x %struct.EDGE_HANDLER]* @edge_foos, i32 0, i32 %i.02.lcssa, i32 1
    %5 = load i32 (...)*, i32 (...)** %4, align 4, !tbaa !1
    br label %9
  
  ; <label>:6                                       ; preds = %0
    %7 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
    %8 = icmp eq i32 %7, 0
    br i1 %8, label %3, label %10
  
  ; <label>:9                                       ; preds = %31, %3
    %.0 = phi i32 (...)* [ %5, %3 ], [ null, %31 ]
    ret i32 (...)* %.0
  
  ; <label>:10                                      ; preds = %6
    %11 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0))
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %3, label %13
  
  ; <label>:13                                      ; preds = %10
    %14 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
    %15 = icmp eq i32 %14, 0
    br i1 %15, label %3, label %16
  
  ; <label>:16                                      ; preds = %13
    %17 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0))
    %18 = icmp eq i32 %17, 0
    br i1 %18, label %3, label %19
  
  ; <label>:19                                      ; preds = %16
    %20 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0))
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %3, label %22
  
  ; <label>:22                                      ; preds = %19
    %23 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0))
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %3, label %25
  
  ; <label>:25                                      ; preds = %22
    %26 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
    %27 = icmp eq i32 %26, 0
    br i1 %27, label %3, label %28
  
  ; <label>:28                                      ; preds = %25
    %29 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0))
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %3, label %31
  
  ; <label>:31                                      ; preds = %28
    %puts = tail call i32 @puts(i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @str, i32 0, i32 0))
    br label %9
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #1
  
  ; Function Attrs: norecurse nounwind
  define i32 @zero(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph7.preheader, label %._crit_edge
  
  .lr.ph7.preheader:                                ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep6 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph7
  
  .lr.ph7:                                          ; preds = %.loopexit, %.lr.ph7.preheader
    %lsr.iv7 = phi float* [ %43, %.loopexit ], [ %scevgep6, %.lr.ph7.preheader ]
    %lsr.iv1 = phi float* [ %42, %.loopexit ], [ %filt, %.lr.ph7.preheader ]
    %y_filt.06 = phi i32 [ %27, %.loopexit ], [ 0, %.lr.ph7.preheader ]
    %y_res.05 = phi i32 [ %41, %.loopexit ], [ %22, %.lr.ph7.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.06, %x_dim
    %notlhs = icmp slt i32 %y_res.05, 0
    %notrhs = icmp sge i32 %y_res.05, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph7, %36
    %lsr.iv10 = phi float* [ %scevgep11, %36 ], [ %lsr.iv7, %.lr.ph7 ]
    %lsr.iv3 = phi float* [ %scevgep4, %36 ], [ %lsr.iv1, %.lr.ph7 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %36 ], [ 0, %.lr.ph7 ]
    %28 = add i32 %10, %lsr.iv
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %36
  
  ; <label>:32                                      ; preds = %.lr.ph
    %33 = bitcast float* %lsr.iv3 to i32*
    %34 = bitcast float* %lsr.iv10 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    br label %36
  
  ; <label>:36                                      ; preds = %32, %.lr.ph
    %lsr.iv.next = add i32 %lsr.iv, 1
    %37 = add i32 %y_filt.06, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %scevgep11 = getelementptr float, float* %lsr.iv10, i32 1
    %38 = icmp slt i32 %37, %27
    br i1 %38, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %36, %.lr.ph7
    %39 = bitcast float* %lsr.iv1 to i1*
    %40 = bitcast float* %lsr.iv7 to i1*
    %41 = add nsw i32 %y_res.05, %x_dim
    %scevgep = getelementptr i1, i1* %39, i32 %24
    %42 = bitcast i1* %scevgep to float*
    %scevgep9 = getelementptr i1, i1* %40, i32 %24
    %43 = bitcast i1* %scevgep9 to float*
    %44 = icmp slt i32 %27, %1
    br i1 %44, label %.lr.ph7, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @repeat(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.preheader.lr.ph, label %._crit_edge6
  
  .preheader.lr.ph:                                 ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = sub nsw i32 %1, %x_dim
    %25 = add nsw i32 %x_dim, -1
    %26 = shl i32 %x_dim, 2
    br label %.preheader
  
  .preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
    %lsr.iv1 = phi float* [ %48, %._crit_edge ], [ %filt, %.preheader.lr.ph ]
    %y_filt.05 = phi i32 [ 0, %.preheader.lr.ph ], [ %28, %._crit_edge ]
    %y_res.04 = phi i32 [ %22, %.preheader.lr.ph ], [ %47, %._crit_edge ]
    %27 = icmp sgt i32 %x_dim, 0
    %28 = add nsw i32 %y_filt.05, %x_dim
    br i1 %27, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader
    %29 = icmp sgt i32 %y_res.04, -1
    %30 = icmp slt i32 %y_res.04, %1
    %y_res.0. = select i1 %30, i32 %y_res.04, i32 %24
    %y_res.0.. = select i1 %29, i32 %y_res.0., i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %31, %.lr.ph
    %lsr.iv3 = phi float* [ %scevgep4, %31 ], [ %lsr.iv1, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %31 ], [ 0, %.lr.ph ]
    %32 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %33 = add i32 %10, %lsr.iv
    %34 = icmp sgt i32 %33, -1
    %35 = add i32 %10, %lsr.iv
    %36 = icmp slt i32 %35, %x_dim
    %37 = add i32 %10, %lsr.iv
    %38 = select i1 %36, i32 %37, i32 %25
    %39 = select i1 %34, i32 %38, i32 0
    %40 = add nsw i32 %39, %y_res.0..
    %41 = getelementptr inbounds float, float* %result, i32 %40
    %42 = load float, float* %41, align 4, !tbaa !6
    %43 = fadd float %32, %42
    store float %43, float* %41, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, 1
    %44 = add i32 %y_filt.05, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %45 = icmp slt i32 %44, %28
    br i1 %45, label %31, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %31, %.preheader
    %46 = bitcast float* %lsr.iv1 to i1*
    %47 = add nsw i32 %y_res.04, %x_dim
    %scevgep = getelementptr i1, i1* %46, i32 %26
    %48 = bitcast i1* %scevgep to float*
    %49 = icmp slt i32 %28, %1
    br i1 %49, label %.preheader, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect2(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = mul nsw i32 %5, %x_dim
    %7 = select i1 %4, i32 %6, i32 0
    %8 = mul i32 %y_dim, %x_dim
    %9 = xor i32 %x_dim, -1
    %.v = select i1 %1, i32 %9, i32 1
    %10 = add i32 %.v, %x_pos
    %11 = icmp sgt i32 %8, 0
    br i1 %11, label %.lr.ph5.preheader, label %._crit_edge6
  
  .lr.ph5.preheader:                                ; preds = %0
    %12 = icmp sgt i32 %y_pos, 0
    %13 = xor i32 %y_dim, -1
    %.v10 = select i1 %12, i32 %13, i32 1
    %14 = add i32 %.v10, %y_pos
    %15 = mul nsw i32 %14, %x_dim
    %result11 = bitcast float* %result to i8*
    %16 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %result11, i8 0, i32 %16, i32 4, i1 false)
    %17 = shl i32 %x_dim, 2
    br label %.lr.ph5
  
  .lr.ph5:                                          ; preds = %._crit_edge, %.lr.ph5.preheader
    %lsr.iv = phi float* [ %51, %._crit_edge ], [ %filt, %.lr.ph5.preheader ]
    %y_filt.04 = phi i32 [ %21, %._crit_edge ], [ 0, %.lr.ph5.preheader ]
    %y_edge.03 = phi i32 [ %50, %._crit_edge ], [ %15, %.lr.ph5.preheader ]
    %18 = icmp sgt i32 %x_dim, 0
    %19 = icmp eq i32 %y_edge.03, 0
    %20 = select i1 %19, i32 %x_dim, i32 0
    %.y_edge.0 = add nsw i32 %20, %y_edge.03
    %21 = add nsw i32 %y_filt.04, %x_dim
    br i1 %18, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.lr.ph5
    %22 = icmp sgt i32 %.y_edge.0, -1
    %23 = sub nsw i32 0, %.y_edge.0
    %24 = select i1 %22, i32 %.y_edge.0, i32 %23
    %25 = sub nsw i32 %7, %24
    %26 = add nsw i32 %25, %x_dim
    %27 = icmp sgt i32 %26, -1
    %28 = sub nsw i32 0, %26
    %29 = select i1 %27, i32 %26, i32 %28
    br label %30
  
  ; <label>:30                                      ; preds = %30, %.lr.ph
    %lsr.iv2 = phi float* [ %scevgep3, %30 ], [ %lsr.iv, %.lr.ph ]
    %x_filt.02 = phi i32 [ %y_filt.04, %.lr.ph ], [ %46, %30 ]
    %x_edge.01 = phi i32 [ %10, %.lr.ph ], [ %47, %30 ]
    %31 = icmp eq i32 %x_edge.01, 0
    %32 = zext i1 %31 to i32
    %.x_edge.0 = add nsw i32 %32, %x_edge.01
    %33 = load float, float* %lsr.iv2, align 4, !tbaa !6
    %34 = icmp sgt i32 %.x_edge.0, -1
    %35 = sub nsw i32 0, %.x_edge.0
    %36 = select i1 %34, i32 %.x_edge.0, i32 %35
    %37 = sub nsw i32 %3, %36
    %38 = add nsw i32 %37, 1
    %39 = icmp sgt i32 %37, -2
    %40 = xor i32 %37, -1
    %41 = select i1 %39, i32 %38, i32 %40
    %42 = add nsw i32 %41, %29
    %43 = getelementptr inbounds float, float* %result, i32 %42
    %44 = load float, float* %43, align 4, !tbaa !6
    %45 = fadd float %33, %44
    store float %45, float* %43, align 4, !tbaa !6
    %46 = add nsw i32 %x_filt.02, 1
    %47 = add nsw i32 %.x_edge.0, 1
    %scevgep3 = getelementptr float, float* %lsr.iv2, i32 1
    %48 = icmp slt i32 %46, %21
    br i1 %48, label %30, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %30, %.lr.ph5
    %49 = bitcast float* %lsr.iv to i1*
    %50 = add nsw i32 %.y_edge.0, %x_dim
    %scevgep = getelementptr i1, i1* %49, i32 %17
    %51 = bitcast i1* %scevgep to float*
    %52 = icmp slt i32 %21, %8
    br i1 %52, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %0
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect1(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph22.preheader, label %._crit_edge23
  
  .lr.ph22.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %.lr.ph22.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge23
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.4 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.4, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.5 = select i1 %51, i32 0, i32 %26
    %.6 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge23
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge23 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge23 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge23 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge23 ], [ %.5, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge23 ], [ %.6, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge23 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph18.preheader, label %._crit_edge19
  
  .lr.ph18.preheader:                               ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep9 = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %.lr.ph18
  
  .lr.ph18:                                         ; preds = %._crit_edge, %.lr.ph18.preheader
    %lsr.iv10 = phi float* [ %85, %._crit_edge ], [ %scevgep9, %.lr.ph18.preheader ]
    %y_edge.016 = phi i32 [ %y_edge_dist.0, %.lr.ph18.preheader ], [ %84, %._crit_edge ]
    %y_filt.015 = phi i32 [ %y_start.0, %.lr.ph18.preheader ], [ %83, %._crit_edge ]
    %59 = add nsw i32 %y_filt.015, %x_start.1
    %60 = add nsw i32 %y_filt.015, %x_stop.1
    %61 = icmp slt i32 %59, %60
    br i1 %61, label %.lr.ph14, label %._crit_edge
  
  .lr.ph14:                                         ; preds = %.lr.ph18
    %62 = icmp sgt i32 %y_edge.016, -1
    %63 = sub nsw i32 0, %y_edge.016
    %64 = select i1 %62, i32 %y_edge.016, i32 %63
    %65 = sub nsw i32 %8, %64
    %66 = icmp sgt i32 %65, -1
    %67 = sub nsw i32 0, %65
    %68 = select i1 %66, i32 %65, i32 %67
    br label %69
  
  ; <label>:69                                      ; preds = %69, %.lr.ph14
    %lsr.iv13 = phi float* [ %scevgep14, %69 ], [ %lsr.iv10, %.lr.ph14 ]
    %lsr.iv7 = phi i32 [ %lsr.iv.next8, %69 ], [ %56, %.lr.ph14 ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next, %69 ], [ %55, %.lr.ph14 ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph14 ], [ %81, %69 ]
    %70 = load float, float* %lsr.iv13, align 4, !tbaa !6
    %71 = icmp sgt i32 %x_edge.013, -1
    %72 = select i1 %71, i32 %x_edge.013, i32 %lsr.iv6
    %73 = sub nsw i32 %4, %72
    %74 = icmp sgt i32 %73, -1
    %75 = sub nsw i32 0, %73
    %76 = select i1 %74, i32 %73, i32 %75
    %77 = add nsw i32 %76, %68
    %78 = getelementptr inbounds float, float* %result, i32 %77
    %79 = load float, float* %78, align 4, !tbaa !6
    %80 = fadd float %70, %79
    store float %80, float* %78, align 4, !tbaa !6
    %81 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv6, -1
    %lsr.iv.next8 = add i32 %lsr.iv7, -1
    %scevgep14 = getelementptr float, float* %lsr.iv13, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next8, 0
    br i1 %exitcond, label %._crit_edge, label %69
  
  ._crit_edge:                                      ; preds = %69, %.lr.ph18
    %82 = bitcast float* %lsr.iv10 to i1*
    %83 = add nsw i32 %y_filt.015, %x_dim
    %84 = add nsw i32 %y_edge.016, %x_dim
    %scevgep12 = getelementptr i1, i1* %82, i32 %58
    %85 = bitcast i1* %scevgep12 to float*
    %86 = icmp slt i32 %83, %y_stop.0
    br i1 %86, label %.lr.ph18, label %._crit_edge19
  
  ._crit_edge19:                                    ; preds = %._crit_edge, %53
    %87 = icmp eq i32 %f_or_e, 1
    br i1 %87, label %88, label %.loopexit
  
  ; <label>:88                                      ; preds = %._crit_edge19
    %89 = icmp sgt i32 %x_pos, -1
    %90 = sub nsw i32 0, %x_pos
    %91 = select i1 %89, i32 %x_pos, i32 %90
    %92 = icmp ne i32 %91, %28
    %93 = icmp ne i32 %x_pos, 0
    %or.cond = and i1 %93, %92
    %94 = icmp slt i32 %4, %1
    %or.cond24 = and i1 %or.cond, %94
    br i1 %or.cond24, label %.lr.ph11.preheader, label %.loopexit8
  
  .lr.ph11.preheader:                               ; preds = %88
    %scevgep2 = getelementptr float, float* %result, i32 %4
    %95 = shl i32 %x_dim, 2
    br label %.lr.ph11
  
  .lr.ph11:                                         ; preds = %.lr.ph11, %.lr.ph11.preheader
    %lsr.iv3 = phi float* [ %99, %.lr.ph11 ], [ %scevgep2, %.lr.ph11.preheader ]
    %y_filt.110 = phi i32 [ %98, %.lr.ph11 ], [ %4, %.lr.ph11.preheader ]
    %lsr.iv34 = bitcast float* %lsr.iv3 to i1*
    %96 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %97 = fadd float %96, %96
    store float %97, float* %lsr.iv3, align 4, !tbaa !6
    %98 = add nsw i32 %y_filt.110, %x_dim
    %scevgep5 = getelementptr i1, i1* %lsr.iv34, i32 %95
    %99 = bitcast i1* %scevgep5 to float*
    %100 = icmp slt i32 %98, %1
    br i1 %100, label %.lr.ph11, label %.loopexit8
  
  .loopexit8:                                       ; preds = %.lr.ph11, %88
    %101 = icmp sgt i32 %y_pos, -1
    %102 = sub nsw i32 0, %y_pos
    %103 = select i1 %101, i32 %y_pos, i32 %102
    %104 = icmp ne i32 %103, %30
    %105 = icmp ne i32 %y_pos, 0
    %or.cond3 = and i1 %105, %104
    br i1 %or.cond3, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %.loopexit8
    %106 = add nsw i32 %8, %x_dim
    %107 = icmp sgt i32 %x_dim, 0
    br i1 %107, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %scevgep = getelementptr float, float* %result, i32 %8
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv = phi float* [ %scevgep1, %.lr.ph ], [ %scevgep, %.lr.ph.preheader ]
    %x_filt.19 = phi i32 [ %110, %.lr.ph ], [ %8, %.lr.ph.preheader ]
    %108 = load float, float* %lsr.iv, align 4, !tbaa !6
    %109 = fadd float %108, %108
    store float %109, float* %lsr.iv, align 4, !tbaa !6
    %110 = add nsw i32 %x_filt.19, 1
    %scevgep1 = getelementptr float, float* %lsr.iv, i32 1
    %111 = icmp slt i32 %110, %106
    br i1 %111, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %.preheader, %.loopexit8, %._crit_edge19
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @extend(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph21.preheader, label %._crit_edge22
  
  .lr.ph21.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge22
  
  ._crit_edge22:                                    ; preds = %.lr.ph21.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge22
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.3 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.3, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.4 = select i1 %51, i32 0, i32 %26
    %.5 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge22
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge22 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge22 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge22 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge22 ], [ %.4, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge22 ], [ %.5, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge22 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph17, label %._crit_edge18
  
  .lr.ph17:                                         ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %59
  
  ; <label>:59                                      ; preds = %._crit_edge, %.lr.ph17
    %lsr.iv3 = phi float* [ %117, %._crit_edge ], [ %scevgep, %.lr.ph17 ]
    %y_edge.015 = phi i32 [ %y_edge_dist.0, %.lr.ph17 ], [ %116, %._crit_edge ]
    %y_filt.014 = phi i32 [ %y_start.0, %.lr.ph17 ], [ %115, %._crit_edge ]
    %60 = add nsw i32 %y_filt.014, %x_start.1
    %61 = add nsw i32 %y_filt.014, %x_stop.1
    %62 = icmp slt i32 %60, %61
    br i1 %62, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %59
    %63 = icmp ne i32 %8, 0
    %64 = icmp sgt i32 %y_edge.015, 0
    %65 = icmp slt i32 %y_edge.015, 0
    %not. = xor i1 %64, true
    %66 = and i1 %65, %not.
    %67 = select i1 %63, i1 %64, i1 %66
    %68 = icmp sgt i32 %y_edge.015, -1
    %69 = sub nsw i32 0, %y_edge.015
    %70 = select i1 %68, i32 %y_edge.015, i32 %69
    %71 = sub nsw i32 %8, %70
    %72 = icmp sgt i32 %71, -1
    %73 = sub nsw i32 0, %71
    %74 = select i1 %72, i32 %71, i32 %73
    %75 = add nsw i32 %y_edge.015, %8
    %76 = icmp slt i32 %75, 0
    %77 = icmp slt i32 %75, %y_dim
    %.10 = select i1 %77, i32 %75, i32 %6
    %78 = select i1 %76, i32 0, i32 %.10
    br label %79
  
  ; <label>:79                                      ; preds = %112, %.lr.ph
    %lsr.iv6 = phi float* [ %scevgep7, %112 ], [ %lsr.iv3, %.lr.ph ]
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %112 ], [ %56, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %112 ], [ %55, %.lr.ph ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph ], [ %113, %112 ]
    %80 = icmp ne i32 %4, 0
    %81 = icmp sgt i32 %x_edge.013, 0
    %82 = icmp slt i32 %x_edge.013, 0
    %not.11 = xor i1 %81, true
    %83 = and i1 %82, %not.11
    %84 = select i1 %80, i1 %81, i1 %83
    %85 = xor i1 %67, %84
    %86 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %87 = icmp sgt i32 %x_edge.013, -1
    %88 = select i1 %87, i32 %x_edge.013, i32 %lsr.iv
    %89 = sub nsw i32 %4, %88
    %90 = icmp sgt i32 %89, -1
    %91 = sub nsw i32 0, %89
    %92 = select i1 %90, i32 %89, i32 %91
    %93 = add nsw i32 %92, %74
    %94 = getelementptr inbounds float, float* %result, i32 %93
    %95 = load float, float* %94, align 4, !tbaa !6
    br i1 %85, label %96, label %110
  
  ; <label>:96                                      ; preds = %79
    %97 = fsub float %95, %86
    store float %97, float* %94, align 4, !tbaa !6
    %98 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %99 = fadd float %98, %98
    %100 = add i32 %4, %x_edge.013
    %101 = icmp slt i32 %100, 0
    %102 = add i32 %4, %x_edge.013
    %103 = icmp slt i32 %102, %x_dim
    %104 = add i32 %4, %x_edge.013
    %.9 = select i1 %103, i32 %104, i32 %3
    %105 = select i1 %101, i32 0, i32 %.9
    %106 = add nsw i32 %105, %78
    %107 = getelementptr inbounds float, float* %result, i32 %106
    %108 = load float, float* %107, align 4, !tbaa !6
    %109 = fadd float %108, %99
    store float %109, float* %107, align 4, !tbaa !6
    br label %112
  
  ; <label>:110                                     ; preds = %79
    %111 = fadd float %86, %95
    store float %111, float* %94, align 4, !tbaa !6
    br label %112
  
  ; <label>:112                                     ; preds = %110, %96
    %113 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv, -1
    %lsr.iv.next2 = add i32 %lsr.iv1, -1
    %scevgep7 = getelementptr float, float* %lsr.iv6, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next2, 0
    br i1 %exitcond, label %._crit_edge, label %79
  
  ._crit_edge:                                      ; preds = %112, %59
    %114 = bitcast float* %lsr.iv3 to i1*
    %115 = add nsw i32 %y_filt.014, %x_dim
    %116 = add nsw i32 %y_edge.015, %x_dim
    %scevgep5 = getelementptr i1, i1* %114, i32 %58
    %117 = bitcast i1* %scevgep5 to float*
    %118 = icmp slt i32 %115, %y_stop.0
    br i1 %118, label %59, label %._crit_edge18
  
  ._crit_edge18:                                    ; preds = %._crit_edge, %53
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @nocompute(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %x_pos.off = add i32 %x_pos, 1
    %2 = icmp ugt i32 %x_pos.off, 2
    %y_pos.off = add i32 %y_pos, 1
    %3 = icmp ugt i32 %y_pos.off, 2
    %4 = or i1 %2, %3
    br i1 %4, label %.preheader, label %.preheader6
  
  .preheader6:                                      ; preds = %0
    %5 = icmp sgt i32 %1, 0
    br i1 %5, label %.lr.ph10.preheader, label %.loopexit
  
  .lr.ph10.preheader:                               ; preds = %.preheader6
    %6 = mul i32 %y_dim, %x_dim
    br label %.lr.ph10
  
  .preheader:                                       ; preds = %0
    %7 = icmp sgt i32 %1, 0
    br i1 %7, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %8 = bitcast float* %result to i8*
    %9 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %8, i8 0, i32 %9, i32 4, i1 false)
    br label %.loopexit
  
  .lr.ph10:                                         ; preds = %.lr.ph10, %.lr.ph10.preheader
    %lsr.iv3 = phi float* [ %scevgep4, %.lr.ph10 ], [ %filt, %.lr.ph10.preheader ]
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph10 ], [ %result, %.lr.ph10.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph10 ], [ %6, %.lr.ph10.preheader ]
    %lsr.iv35 = bitcast float* %lsr.iv3 to i32*
    %lsr.iv12 = bitcast float* %lsr.iv1 to i32*
    %10 = load i32, i32* %lsr.iv35, align 4, !tbaa !6
    store i32 %10, i32* %lsr.iv12, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %exitcond12 = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond12, label %.loopexit, label %.lr.ph10
  
  .loopexit:                                        ; preds = %.lr.ph10, %.lr.ph.preheader, %.preheader, %.preheader6
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  define i32 @ereflect(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #0 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = select i1 %4, i32 %5, i32 0
    %7 = mul nsw i32 %6, %x_dim
    %8 = mul i32 %y_dim, %x_dim
    %9 = icmp sgt i32 %x_pos, 1
    br i1 %9, label %10, label %12
  
  ; <label>:10                                      ; preds = %0
    %11 = sub nsw i32 %x_pos, %x_dim
    br label %16
  
  ; <label>:12                                      ; preds = %0
    %13 = icmp slt i32 %x_pos, -1
    %14 = add nsw i32 %x_pos, 1
    %15 = select i1 %13, i32 %14, i32 0
    br label %16
  
  ; <label>:16                                      ; preds = %12, %10
    %17 = phi i32 [ %11, %10 ], [ %15, %12 ]
    %18 = icmp sgt i32 %y_pos, 1
    br i1 %18, label %19, label %21
  
  ; <label>:19                                      ; preds = %16
    %20 = sub nsw i32 %y_pos, %y_dim
    br label %25
  
  ; <label>:21                                      ; preds = %16
    %22 = icmp slt i32 %y_pos, -1
    %23 = add nsw i32 %y_pos, 1
    %24 = select i1 %22, i32 %23, i32 0
    br label %25
  
  ; <label>:25                                      ; preds = %21, %19
    %26 = phi i32 [ %20, %19 ], [ %24, %21 ]
    %27 = icmp sgt i32 %8, 0
    br i1 %27, label %.preheader3.preheader, label %._crit_edge27
  
  .preheader3.preheader:                            ; preds = %25
    %28 = bitcast float* %result to i8*
    %29 = mul nsw i32 %26, %x_dim
    %30 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %28, i8 0, i32 %30, i32 4, i1 false)
    %31 = shl i32 %x_dim, 2
    %32 = sub i32 0, %17
    br label %.preheader3
  
  .preheader3:                                      ; preds = %._crit_edge23, %.preheader3.preheader
    %lsr.iv19 = phi float* [ %60, %._crit_edge23 ], [ %filt, %.preheader3.preheader ]
    %y_filt.026 = phi i32 [ %34, %._crit_edge23 ], [ 0, %.preheader3.preheader ]
    %y_edge.025 = phi i32 [ %59, %._crit_edge23 ], [ %29, %.preheader3.preheader ]
    %33 = icmp sgt i32 %x_dim, 0
    %34 = add nsw i32 %y_filt.026, %x_dim
    br i1 %33, label %.lr.ph22, label %._crit_edge23
  
  .lr.ph22:                                         ; preds = %.preheader3
    %35 = icmp sgt i32 %y_edge.025, -1
    %36 = sub nsw i32 0, %y_edge.025
    %37 = select i1 %35, i32 %y_edge.025, i32 %36
    %38 = sub nsw i32 %7, %37
    %39 = icmp sgt i32 %38, -1
    %40 = sub nsw i32 0, %38
    %41 = select i1 %39, i32 %38, i32 %40
    br label %42
  
  ; <label>:42                                      ; preds = %42, %.lr.ph22
    %lsr.iv24 = phi i32 [ %lsr.iv.next25, %42 ], [ %32, %.lr.ph22 ]
    %lsr.iv22 = phi float* [ %scevgep23, %42 ], [ %lsr.iv19, %.lr.ph22 ]
    %lsr.iv17 = phi i32 [ %lsr.iv.next18, %42 ], [ 0, %.lr.ph22 ]
    %43 = load float, float* %lsr.iv22, align 4, !tbaa !6
    %44 = add i32 %17, %lsr.iv17
    %45 = icmp sgt i32 %44, -1
    %46 = add i32 %17, %lsr.iv17
    %47 = select i1 %45, i32 %46, i32 %lsr.iv24
    %48 = sub nsw i32 %3, %47
    %49 = icmp sgt i32 %48, -1
    %50 = sub nsw i32 0, %48
    %51 = select i1 %49, i32 %48, i32 %50
    %52 = add nsw i32 %51, %41
    %53 = getelementptr inbounds float, float* %result, i32 %52
    %54 = load float, float* %53, align 4, !tbaa !6
    %55 = fadd float %43, %54
    store float %55, float* %53, align 4, !tbaa !6
    %lsr.iv.next18 = add i32 %lsr.iv17, 1
    %56 = add i32 %y_filt.026, %lsr.iv.next18
    %scevgep23 = getelementptr float, float* %lsr.iv22, i32 1
    %lsr.iv.next25 = add i32 %lsr.iv24, -1
    %57 = icmp slt i32 %56, %34
    br i1 %57, label %42, label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %42, %.preheader3
    %58 = bitcast float* %lsr.iv19 to i1*
    %59 = add nsw i32 %y_edge.025, %x_dim
    %scevgep21 = getelementptr i1, i1* %58, i32 %31
    %60 = bitcast i1* %scevgep21 to float*
    %61 = icmp slt i32 %34, %8
    br i1 %61, label %.preheader3, label %._crit_edge27
  
  ._crit_edge27:                                    ; preds = %._crit_edge23, %25
    %62 = icmp ne i32 %x_pos, 0
    %63 = icmp slt i32 %3, %8
    %or.cond = and i1 %62, %63
    br i1 %or.cond, label %.lr.ph19.preheader, label %.loopexit
  
  .lr.ph19.preheader:                               ; preds = %._crit_edge27
    %scevgep13 = getelementptr float, float* %result, i32 %3
    %64 = shl i32 %x_dim, 2
    br label %.lr.ph19
  
  .lr.ph19:                                         ; preds = %.lr.ph19, %.lr.ph19.preheader
    %lsr.iv14 = phi float* [ %70, %.lr.ph19 ], [ %scevgep13, %.lr.ph19.preheader ]
    %y_filt.118 = phi i32 [ %69, %.lr.ph19 ], [ %3, %.lr.ph19.preheader ]
    %lsr.iv1415 = bitcast float* %lsr.iv14 to i1*
    %65 = load float, float* %lsr.iv14, align 4, !tbaa !6
    %66 = fpext float %65 to double
    %67 = fmul double %66, 0x3FF6A09E667F3BCD
    %68 = fptrunc double %67 to float
    store float %68, float* %lsr.iv14, align 4, !tbaa !6
    %69 = add nsw i32 %y_filt.118, %x_dim
    %scevgep16 = getelementptr i1, i1* %lsr.iv1415, i32 %64
    %70 = bitcast i1* %scevgep16 to float*
    %71 = icmp slt i32 %69, %8
    br i1 %71, label %.lr.ph19, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph19, %._crit_edge27
    %72 = icmp eq i32 %y_pos, 0
    br i1 %72, label %.preheader, label %.preheader1
  
  .preheader1:                                      ; preds = %.loopexit
    %73 = add nsw i32 %7, %x_dim
    %74 = icmp sgt i32 %x_dim, 0
    br i1 %74, label %.lr.ph17.preheader, label %.preheader
  
  .lr.ph17.preheader:                               ; preds = %.preheader1
    %75 = mul i32 %6, %x_dim
    %scevgep10 = getelementptr float, float* %result, i32 %75
    br label %.lr.ph17
  
  .preheader:                                       ; preds = %.lr.ph17, %.preheader1, %.loopexit
    %76 = icmp sgt i32 %8, 0
    br i1 %76, label %.lr.ph13.preheader, label %._crit_edge14.thread
  
  .lr.ph13.preheader:                               ; preds = %.preheader
    %77 = mul i32 %y_dim, %x_dim
    br label %.lr.ph13
  
  ._crit_edge14.thread:                             ; preds = %.preheader
    %78 = tail call double @sqrt(double 0.000000e+00) #5
    %79 = fcmp oeq double %78, %78
    br i1 %79, label %._crit_edge10.thread, label %call.sqrt
  
  call.sqrt:                                        ; preds = %._crit_edge14.thread
    %80 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge10.thread
  
  .lr.ph17:                                         ; preds = %.lr.ph17, %.lr.ph17.preheader
    %lsr.iv11 = phi float* [ %scevgep12, %.lr.ph17 ], [ %scevgep10, %.lr.ph17.preheader ]
    %x_filt.116 = phi i32 [ %85, %.lr.ph17 ], [ %7, %.lr.ph17.preheader ]
    %81 = load float, float* %lsr.iv11, align 4, !tbaa !6
    %82 = fpext float %81 to double
    %83 = fmul double %82, 0x3FF6A09E667F3BCD
    %84 = fptrunc double %83 to float
    store float %84, float* %lsr.iv11, align 4, !tbaa !6
    %85 = add nsw i32 %x_filt.116, 1
    %scevgep12 = getelementptr float, float* %lsr.iv11, i32 1
    %86 = icmp slt i32 %85, %73
    br i1 %86, label %.lr.ph17, label %.preheader
  
  .lr.ph13:                                         ; preds = %.lr.ph13, %.lr.ph13.preheader
    %lsr.iv8 = phi float* [ %scevgep9, %.lr.ph13 ], [ %result, %.lr.ph13.preheader ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next7, %.lr.ph13 ], [ %77, %.lr.ph13.preheader ]
    %norm.012 = phi double [ %90, %.lr.ph13 ], [ 0.000000e+00, %.lr.ph13.preheader ]
    %87 = load float, float* %lsr.iv8, align 4, !tbaa !6
    %88 = fmul float %87, %87
    %89 = fpext float %88 to double
    %90 = fadd double %norm.012, %89
    %lsr.iv.next7 = add i32 %lsr.iv6, -1
    %scevgep9 = getelementptr float, float* %lsr.iv8, i32 1
    %exitcond33 = icmp eq i32 %lsr.iv.next7, 0
    br i1 %exitcond33, label %._crit_edge14, label %.lr.ph13
  
  ._crit_edge14:                                    ; preds = %.lr.ph13
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %._crit_edge14.split, label %call.sqrt26
  
  call.sqrt26:                                      ; preds = %._crit_edge14
    %93 = tail call double @sqrt(double %90) #6
    br label %._crit_edge14.split
  
  ._crit_edge14.split:                              ; preds = %._crit_edge14, %call.sqrt26
    %94 = phi double [ %91, %._crit_edge14 ], [ %93, %call.sqrt26 ]
    %95 = icmp sgt i32 %8, 0
    br i1 %95, label %.lr.ph9.preheader, label %._crit_edge10.thread
  
  .lr.ph9.preheader:                                ; preds = %._crit_edge14.split
    %96 = mul i32 %y_dim, %x_dim
    br label %.lr.ph9
  
  .lr.ph9:                                          ; preds = %.lr.ph9, %.lr.ph9.preheader
    %lsr.iv4 = phi float* [ %scevgep5, %.lr.ph9 ], [ %filt, %.lr.ph9.preheader ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %.lr.ph9 ], [ %96, %.lr.ph9.preheader ]
    %onorm.07 = phi double [ %100, %.lr.ph9 ], [ 0.000000e+00, %.lr.ph9.preheader ]
    %97 = load float, float* %lsr.iv4, align 4, !tbaa !6
    %98 = fmul float %97, %97
    %99 = fpext float %98 to double
    %100 = fadd double %onorm.07, %99
    %lsr.iv.next3 = add i32 %lsr.iv2, -1
    %scevgep5 = getelementptr float, float* %lsr.iv4, i32 1
    %exitcond32 = icmp eq i32 %lsr.iv.next3, 0
    br i1 %exitcond32, label %._crit_edge10, label %.lr.ph9
  
  ._crit_edge10.thread:                             ; preds = %call.sqrt, %._crit_edge14.thread, %._crit_edge14.split
    %101 = tail call double @sqrt(double 0.000000e+00) #5
    %102 = fcmp oeq double %101, %101
    br i1 %102, label %._crit_edge, label %call.sqrt27
  
  call.sqrt27:                                      ; preds = %._crit_edge10.thread
    %103 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge
  
  ._crit_edge10:                                    ; preds = %.lr.ph9
    %104 = tail call double @sqrt(double %100) #5
    %105 = fcmp oeq double %104, %104
    br i1 %105, label %._crit_edge10.split, label %call.sqrt28
  
  call.sqrt28:                                      ; preds = %._crit_edge10
    %106 = tail call double @sqrt(double %100) #6
    br label %._crit_edge10.split
  
  ._crit_edge10.split:                              ; preds = %._crit_edge10, %call.sqrt28
    %107 = phi double [ %104, %._crit_edge10 ], [ %106, %call.sqrt28 ]
    %108 = icmp sgt i32 %8, 0
    %109 = fdiv double %94, %107
    br i1 %108, label %.lr.ph.preheader, label %._crit_edge
  
  .lr.ph.preheader:                                 ; preds = %._crit_edge10.split
    %110 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %110, %.lr.ph.preheader ]
    %111 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %112 = fpext float %111 to double
    %113 = fdiv double %112, %109
    %114 = fptrunc double %113 to float
    store float %114, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %call.sqrt27, %._crit_edge10.thread, %._crit_edge10.split
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  ; Function Attrs: norecurse nounwind
  define i32 @predict(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph12.preheader, label %._crit_edge
  
  .lr.ph12.preheader:                               ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep10 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph12
  
  .lr.ph12:                                         ; preds = %.loopexit2, %.lr.ph12.preheader
    %lsr.iv11 = phi float* [ %45, %.loopexit2 ], [ %scevgep10, %.lr.ph12.preheader ]
    %lsr.iv4 = phi float* [ %44, %.loopexit2 ], [ %filt, %.lr.ph12.preheader ]
    %y_filt.011 = phi i32 [ %27, %.loopexit2 ], [ 0, %.lr.ph12.preheader ]
    %y_res.010 = phi i32 [ %43, %.loopexit2 ], [ %22, %.lr.ph12.preheader ]
    %taps_used.09 = phi float [ %taps_used.3, %.loopexit2 ], [ 0.000000e+00, %.lr.ph12.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.011, %x_dim
    %notlhs = icmp slt i32 %y_res.010, 0
    %notrhs = icmp sge i32 %y_res.010, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit2, label %.lr.ph8
  
  .lr.ph8:                                          ; preds = %.lr.ph12, %38
    %lsr.iv14 = phi float* [ %scevgep15, %38 ], [ %lsr.iv11, %.lr.ph12 ]
    %lsr.iv7 = phi float* [ %scevgep8, %38 ], [ %lsr.iv4, %.lr.ph12 ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %38 ], [ 0, %.lr.ph12 ]
    %taps_used.15 = phi float [ %taps_used.2, %38 ], [ %taps_used.09, %.lr.ph12 ]
    %28 = add i32 %10, %lsr.iv2
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv2
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %38
  
  ; <label>:32                                      ; preds = %.lr.ph8
    %33 = bitcast float* %lsr.iv7 to i32*
    %34 = bitcast float* %lsr.iv14 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    %36 = load float, float* %lsr.iv7, align 4, !tbaa !6
    %37 = fadd float %taps_used.15, %36
    br label %38
  
  ; <label>:38                                      ; preds = %32, %.lr.ph8
    %taps_used.2 = phi float [ %37, %32 ], [ %taps_used.15, %.lr.ph8 ]
    %lsr.iv.next3 = add i32 %lsr.iv2, 1
    %39 = add i32 %y_filt.011, %lsr.iv.next3
    %scevgep8 = getelementptr float, float* %lsr.iv7, i32 1
    %scevgep15 = getelementptr float, float* %lsr.iv14, i32 1
    %40 = icmp slt i32 %39, %27
    br i1 %40, label %.lr.ph8, label %.loopexit2
  
  .loopexit2:                                       ; preds = %38, %.lr.ph12
    %taps_used.3 = phi float [ %taps_used.09, %.lr.ph12 ], [ %taps_used.2, %38 ]
    %41 = bitcast float* %lsr.iv4 to i1*
    %42 = bitcast float* %lsr.iv11 to i1*
    %43 = add nsw i32 %y_res.010, %x_dim
    %scevgep6 = getelementptr i1, i1* %41, i32 %24
    %44 = bitcast i1* %scevgep6 to float*
    %scevgep13 = getelementptr i1, i1* %42, i32 %24
    %45 = bitcast i1* %scevgep13 to float*
    %46 = icmp slt i32 %27, %1
    br i1 %46, label %.lr.ph12, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit2, %18
    %taps_used.0.lcssa = phi float [ 0.000000e+00, %18 ], [ %taps_used.3, %.loopexit2 ]
    %47 = icmp eq i32 %f_or_e, 0
    br i1 %47, label %48, label %.loopexit
  
  ; <label>:48                                      ; preds = %._crit_edge
    %49 = icmp sgt i32 %1, 0
    %50 = fdiv float 2.000000e+00, %taps_used.0.lcssa
    br i1 %49, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %48
    %51 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %51, %.lr.ph.preheader ]
    %52 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %53 = fmul float %50, %52
    store float %53, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %.lr.ph, %48, %._crit_edge
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare i32 @puts(i8* nocapture) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #4
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { nounwind "target-cpu"="mips32" }
  attributes #4 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #5 = { nounwind readnone }
  attributes #6 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"", !3, i64 0, !3, i64 4}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !7, i64 0}
  !7 = !{!"float", !4, i64 0}

...
---
name:            repeat
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: fgr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: fgr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: fgr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%22' }
  - { reg: '%a1', virtual-reg: '%23' }
  - { reg: '%a2', virtual-reg: '%24' }
  - { reg: '%a3', virtual-reg: '%25' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 24, size: 4, alignment: 8, isImmutable: true, isAliased: false }
  - { id: 1, offset: 20, size: 4, alignment: 4, isImmutable: true, isAliased: false }
  - { id: 2, offset: 16, size: 4, alignment: 8, isImmutable: true, isAliased: false }
body:             |
  bb.0 (%ir-block.0, freq 21):
    successors: %bb.1(62), %bb.2(37)
    liveins: %a0, %a1, %a2, %a3, %t9, %v0
  
    %32 = ADDu %v0, %t9
    %25 = COPY %a3
    %24 = COPY %a2
    %23 = COPY %a1
    %22 = COPY %a0
    %26 = LW %fixed-stack.2, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    BLEZ %25, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.3, freq 13):
    successors: %bb.3(100)
  
    %1 = ADDiu %25, -1
    B %bb.3, implicit-def dead %at
  
  bb.2 (%ir-block.5, freq 8):
    successors: %bb.3(100)
  
    %28 = ADDiu %25, 1
    %29 = SRA %25, 31
    %2 = AND killed %29, killed %28
  
  bb.3 (%ir-block.9, freq 21):
    successors: %bb.4(62), %bb.5(37)
  
    %3 = PHI %2, %bb.2, %1, %bb.1
    %0 = MUL %24, %23, implicit-def dead %hi0, implicit-def dead %lo0
    BLEZ %26, %bb.5, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.12, freq 13):
    successors: %bb.6(100)
  
    %4 = ADDiu %26, -1
    B %bb.6, implicit-def dead %at
  
  bb.5 (%ir-block.14, freq 8):
    successors: %bb.6(100)
  
    %30 = ADDiu %26, 1
    %31 = SRA %26, 31
    %5 = AND killed %31, killed %30
  
  bb.6 (%ir-block.18, freq 21):
    successors: %bb.7..preheader.lr.ph(62), %bb.12.._crit_edge6(37)
  
    %6 = PHI %5, %bb.5, %4, %bb.4
    BLEZ %0, %bb.12.._crit_edge6, implicit-def dead %at
    B %bb.7..preheader.lr.ph, implicit-def dead %at
  
  bb.7..preheader.lr.ph (freq 13):
    successors: %bb.8..preheader(100)
  
    %27 = LW %fixed-stack.1, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %34 = SLL %0, 2
    %35 = LW %32, target-flags(<unknown>) $memset, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry $memset)
    %33 = ADDiu %zero, 0
    %a0 = COPY %27
    %a1 = COPY %33
    %a2 = COPY %34
    %gp = COPY %32
    %t9 = COPY %35
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %7 = MUL %6, %23, implicit-def dead %hi0, implicit-def dead %lo0
    %8 = SUBu %0, %23
    %10 = SLL %23, 2
    %9 = ADDiu %23, -1
  
  bb.8..preheader (freq 426):
    successors: %bb.9..lr.ph(62), %bb.11.._crit_edge(37)
  
    %11 = PHI %22, %bb.7..preheader.lr.ph, %21, %bb.11.._crit_edge
    %12 = PHI %33, %bb.7..preheader.lr.ph, %14, %bb.11.._crit_edge
    %13 = PHI %7, %bb.7..preheader.lr.ph, %20, %bb.11.._crit_edge
    %14 = ADDu %12, %23
    BLEZ %23, %bb.11.._crit_edge, implicit-def dead %at
    B %bb.9..lr.ph, implicit-def dead %at
  
  bb.9..lr.ph (freq 266):
    successors: %bb.10(100)
  
    %37 = SLT %13, %0
    %38 = MOVN_I_I %13, killed %37, %8
    %39 = SLTi %13, 0
    %36 = ADDiu %zero, 0
    %15 = MOVN_I_I %zero, killed %39, %38
  
  bb.10 (%ir-block.31, freq 8533):
    successors: %bb.10(96), %bb.11.._crit_edge(3)
  
    %16 = PHI %11, %bb.9..lr.ph, %19, %bb.10
    %17 = PHI %36, %bb.9..lr.ph, %18, %bb.10
    %40 = ADDu %3, %17
    %41 = SLT %40, %23
    %42 = MOVN_I_I %40, killed %41, %9
    %43 = SLTi %40, 0
    %45 = MOVN_I_I killed %zero, killed %43, %42
    %46 = ADDu killed %45, %15
    %47 = SLL killed %46, 2
    %48 = LWXC1 %27, %47, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.41, !tbaa !6)
    %18 = ADDiu %17, 1
    %49 = ADDu %12, %18
    %19 = ADDiu %16, 4
    %50 = LWC1 %16, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv3, !tbaa !6)
    %51 = SLT killed %49, %14
    %52 = FADD_S killed %50, killed %48
    SWXC1 killed %52, %27, %47, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.41, !tbaa !6)
    BNE killed %51, %zero, %bb.10, implicit-def dead %at
    B %bb.11.._crit_edge, implicit-def dead %at
  
  bb.11.._crit_edge (freq 426):
    successors: %bb.8..preheader(96), %bb.12.._crit_edge6(3)
  
    %21 = ADDu %11, %10
    %20 = ADDu %13, %23
    %53 = SLT %14, %0
    BNE killed %53, %zero, %bb.8..preheader, implicit-def dead %at
    B %bb.12.._crit_edge6, implicit-def dead %at
  
  bb.12.._crit_edge6 (freq 21):
    liveouts: %v0
  
    %54 = IMPLICIT_DEF
    %v0 = COPY %54
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/epic/epic.edges.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.EDGE_HANDLER = type { i8*, i32 (...)* }
  
  @edge_foos = internal unnamed_addr constant [9 x %struct.EDGE_HANDLER] [%struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect2 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @repeat to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @zero to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @extend to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @nocompute to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @predict to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @ereflect to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }], align 4
  @.str.1 = private unnamed_addr constant [9 x i8] c"reflect1\00", align 1
  @.str.2 = private unnamed_addr constant [9 x i8] c"reflect2\00", align 1
  @.str.3 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
  @.str.4 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
  @.str.5 = private unnamed_addr constant [7 x i8] c"extend\00", align 1
  @.str.6 = private unnamed_addr constant [13 x i8] c"dont-compute\00", align 1
  @.str.7 = private unnamed_addr constant [8 x i8] c"predict\00", align 1
  @.str.8 = private unnamed_addr constant [9 x i8] c"ereflect\00", align 1
  @.str.9 = private unnamed_addr constant [9 x i8] c"treflect\00", align 1
  @str = private unnamed_addr constant [30 x i8] c"No such edge handler routine!\00"
  
  ; Function Attrs: nounwind
  define i32 (...)* @edge_function(i8* nocapture readonly %edges) #0 {
    %1 = tail call i32 @strcmp(i8* %edges, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0))
    %2 = icmp eq i32 %1, 0
    br i1 %2, label %3, label %6
  
  ; <label>:3                                       ; preds = %28, %25, %22, %19, %16, %13, %10, %6, %0
    %i.02.lcssa = phi i32 [ 0, %0 ], [ 1, %6 ], [ 2, %10 ], [ 3, %13 ], [ 4, %16 ], [ 5, %19 ], [ 6, %22 ], [ 7, %25 ], [ 8, %28 ]
    %4 = getelementptr inbounds [9 x %struct.EDGE_HANDLER], [9 x %struct.EDGE_HANDLER]* @edge_foos, i32 0, i32 %i.02.lcssa, i32 1
    %5 = load i32 (...)*, i32 (...)** %4, align 4, !tbaa !1
    br label %9
  
  ; <label>:6                                       ; preds = %0
    %7 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
    %8 = icmp eq i32 %7, 0
    br i1 %8, label %3, label %10
  
  ; <label>:9                                       ; preds = %31, %3
    %.0 = phi i32 (...)* [ %5, %3 ], [ null, %31 ]
    ret i32 (...)* %.0
  
  ; <label>:10                                      ; preds = %6
    %11 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0))
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %3, label %13
  
  ; <label>:13                                      ; preds = %10
    %14 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
    %15 = icmp eq i32 %14, 0
    br i1 %15, label %3, label %16
  
  ; <label>:16                                      ; preds = %13
    %17 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0))
    %18 = icmp eq i32 %17, 0
    br i1 %18, label %3, label %19
  
  ; <label>:19                                      ; preds = %16
    %20 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0))
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %3, label %22
  
  ; <label>:22                                      ; preds = %19
    %23 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0))
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %3, label %25
  
  ; <label>:25                                      ; preds = %22
    %26 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
    %27 = icmp eq i32 %26, 0
    br i1 %27, label %3, label %28
  
  ; <label>:28                                      ; preds = %25
    %29 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0))
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %3, label %31
  
  ; <label>:31                                      ; preds = %28
    %puts = tail call i32 @puts(i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @str, i32 0, i32 0))
    br label %9
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #1
  
  ; Function Attrs: norecurse nounwind
  define i32 @zero(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph7.preheader, label %._crit_edge
  
  .lr.ph7.preheader:                                ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep6 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph7
  
  .lr.ph7:                                          ; preds = %.loopexit, %.lr.ph7.preheader
    %lsr.iv7 = phi float* [ %43, %.loopexit ], [ %scevgep6, %.lr.ph7.preheader ]
    %lsr.iv1 = phi float* [ %42, %.loopexit ], [ %filt, %.lr.ph7.preheader ]
    %y_filt.06 = phi i32 [ %27, %.loopexit ], [ 0, %.lr.ph7.preheader ]
    %y_res.05 = phi i32 [ %41, %.loopexit ], [ %22, %.lr.ph7.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.06, %x_dim
    %notlhs = icmp slt i32 %y_res.05, 0
    %notrhs = icmp sge i32 %y_res.05, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph7, %36
    %lsr.iv10 = phi float* [ %scevgep11, %36 ], [ %lsr.iv7, %.lr.ph7 ]
    %lsr.iv3 = phi float* [ %scevgep4, %36 ], [ %lsr.iv1, %.lr.ph7 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %36 ], [ 0, %.lr.ph7 ]
    %28 = add i32 %10, %lsr.iv
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %36
  
  ; <label>:32                                      ; preds = %.lr.ph
    %33 = bitcast float* %lsr.iv3 to i32*
    %34 = bitcast float* %lsr.iv10 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    br label %36
  
  ; <label>:36                                      ; preds = %32, %.lr.ph
    %lsr.iv.next = add i32 %lsr.iv, 1
    %37 = add i32 %y_filt.06, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %scevgep11 = getelementptr float, float* %lsr.iv10, i32 1
    %38 = icmp slt i32 %37, %27
    br i1 %38, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %36, %.lr.ph7
    %39 = bitcast float* %lsr.iv1 to i1*
    %40 = bitcast float* %lsr.iv7 to i1*
    %41 = add nsw i32 %y_res.05, %x_dim
    %scevgep = getelementptr i1, i1* %39, i32 %24
    %42 = bitcast i1* %scevgep to float*
    %scevgep9 = getelementptr i1, i1* %40, i32 %24
    %43 = bitcast i1* %scevgep9 to float*
    %44 = icmp slt i32 %27, %1
    br i1 %44, label %.lr.ph7, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @repeat(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.preheader.lr.ph, label %._crit_edge6
  
  .preheader.lr.ph:                                 ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = sub nsw i32 %1, %x_dim
    %25 = add nsw i32 %x_dim, -1
    %26 = shl i32 %x_dim, 2
    br label %.preheader
  
  .preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
    %lsr.iv1 = phi float* [ %48, %._crit_edge ], [ %filt, %.preheader.lr.ph ]
    %y_filt.05 = phi i32 [ 0, %.preheader.lr.ph ], [ %28, %._crit_edge ]
    %y_res.04 = phi i32 [ %22, %.preheader.lr.ph ], [ %47, %._crit_edge ]
    %27 = icmp sgt i32 %x_dim, 0
    %28 = add nsw i32 %y_filt.05, %x_dim
    br i1 %27, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader
    %29 = icmp sgt i32 %y_res.04, -1
    %30 = icmp slt i32 %y_res.04, %1
    %y_res.0. = select i1 %30, i32 %y_res.04, i32 %24
    %y_res.0.. = select i1 %29, i32 %y_res.0., i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %31, %.lr.ph
    %lsr.iv3 = phi float* [ %scevgep4, %31 ], [ %lsr.iv1, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %31 ], [ 0, %.lr.ph ]
    %32 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %33 = add i32 %10, %lsr.iv
    %34 = icmp sgt i32 %33, -1
    %35 = add i32 %10, %lsr.iv
    %36 = icmp slt i32 %35, %x_dim
    %37 = add i32 %10, %lsr.iv
    %38 = select i1 %36, i32 %37, i32 %25
    %39 = select i1 %34, i32 %38, i32 0
    %40 = add nsw i32 %39, %y_res.0..
    %41 = getelementptr inbounds float, float* %result, i32 %40
    %42 = load float, float* %41, align 4, !tbaa !6
    %43 = fadd float %32, %42
    store float %43, float* %41, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, 1
    %44 = add i32 %y_filt.05, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %45 = icmp slt i32 %44, %28
    br i1 %45, label %31, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %31, %.preheader
    %46 = bitcast float* %lsr.iv1 to i1*
    %47 = add nsw i32 %y_res.04, %x_dim
    %scevgep = getelementptr i1, i1* %46, i32 %26
    %48 = bitcast i1* %scevgep to float*
    %49 = icmp slt i32 %28, %1
    br i1 %49, label %.preheader, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect2(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = mul nsw i32 %5, %x_dim
    %7 = select i1 %4, i32 %6, i32 0
    %8 = mul i32 %y_dim, %x_dim
    %9 = xor i32 %x_dim, -1
    %.v = select i1 %1, i32 %9, i32 1
    %10 = add i32 %.v, %x_pos
    %11 = icmp sgt i32 %8, 0
    br i1 %11, label %.lr.ph5.preheader, label %._crit_edge6
  
  .lr.ph5.preheader:                                ; preds = %0
    %12 = icmp sgt i32 %y_pos, 0
    %13 = xor i32 %y_dim, -1
    %.v10 = select i1 %12, i32 %13, i32 1
    %14 = add i32 %.v10, %y_pos
    %15 = mul nsw i32 %14, %x_dim
    %result11 = bitcast float* %result to i8*
    %16 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %result11, i8 0, i32 %16, i32 4, i1 false)
    %17 = shl i32 %x_dim, 2
    br label %.lr.ph5
  
  .lr.ph5:                                          ; preds = %._crit_edge, %.lr.ph5.preheader
    %lsr.iv = phi float* [ %51, %._crit_edge ], [ %filt, %.lr.ph5.preheader ]
    %y_filt.04 = phi i32 [ %21, %._crit_edge ], [ 0, %.lr.ph5.preheader ]
    %y_edge.03 = phi i32 [ %50, %._crit_edge ], [ %15, %.lr.ph5.preheader ]
    %18 = icmp sgt i32 %x_dim, 0
    %19 = icmp eq i32 %y_edge.03, 0
    %20 = select i1 %19, i32 %x_dim, i32 0
    %.y_edge.0 = add nsw i32 %20, %y_edge.03
    %21 = add nsw i32 %y_filt.04, %x_dim
    br i1 %18, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.lr.ph5
    %22 = icmp sgt i32 %.y_edge.0, -1
    %23 = sub nsw i32 0, %.y_edge.0
    %24 = select i1 %22, i32 %.y_edge.0, i32 %23
    %25 = sub nsw i32 %7, %24
    %26 = add nsw i32 %25, %x_dim
    %27 = icmp sgt i32 %26, -1
    %28 = sub nsw i32 0, %26
    %29 = select i1 %27, i32 %26, i32 %28
    br label %30
  
  ; <label>:30                                      ; preds = %30, %.lr.ph
    %lsr.iv2 = phi float* [ %scevgep3, %30 ], [ %lsr.iv, %.lr.ph ]
    %x_filt.02 = phi i32 [ %y_filt.04, %.lr.ph ], [ %46, %30 ]
    %x_edge.01 = phi i32 [ %10, %.lr.ph ], [ %47, %30 ]
    %31 = icmp eq i32 %x_edge.01, 0
    %32 = zext i1 %31 to i32
    %.x_edge.0 = add nsw i32 %32, %x_edge.01
    %33 = load float, float* %lsr.iv2, align 4, !tbaa !6
    %34 = icmp sgt i32 %.x_edge.0, -1
    %35 = sub nsw i32 0, %.x_edge.0
    %36 = select i1 %34, i32 %.x_edge.0, i32 %35
    %37 = sub nsw i32 %3, %36
    %38 = add nsw i32 %37, 1
    %39 = icmp sgt i32 %37, -2
    %40 = xor i32 %37, -1
    %41 = select i1 %39, i32 %38, i32 %40
    %42 = add nsw i32 %41, %29
    %43 = getelementptr inbounds float, float* %result, i32 %42
    %44 = load float, float* %43, align 4, !tbaa !6
    %45 = fadd float %33, %44
    store float %45, float* %43, align 4, !tbaa !6
    %46 = add nsw i32 %x_filt.02, 1
    %47 = add nsw i32 %.x_edge.0, 1
    %scevgep3 = getelementptr float, float* %lsr.iv2, i32 1
    %48 = icmp slt i32 %46, %21
    br i1 %48, label %30, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %30, %.lr.ph5
    %49 = bitcast float* %lsr.iv to i1*
    %50 = add nsw i32 %.y_edge.0, %x_dim
    %scevgep = getelementptr i1, i1* %49, i32 %17
    %51 = bitcast i1* %scevgep to float*
    %52 = icmp slt i32 %21, %8
    br i1 %52, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %0
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect1(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph22.preheader, label %._crit_edge23
  
  .lr.ph22.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %.lr.ph22.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge23
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.4 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.4, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.5 = select i1 %51, i32 0, i32 %26
    %.6 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge23
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge23 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge23 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge23 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge23 ], [ %.5, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge23 ], [ %.6, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge23 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph18.preheader, label %._crit_edge19
  
  .lr.ph18.preheader:                               ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep9 = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %.lr.ph18
  
  .lr.ph18:                                         ; preds = %._crit_edge, %.lr.ph18.preheader
    %lsr.iv10 = phi float* [ %85, %._crit_edge ], [ %scevgep9, %.lr.ph18.preheader ]
    %y_edge.016 = phi i32 [ %y_edge_dist.0, %.lr.ph18.preheader ], [ %84, %._crit_edge ]
    %y_filt.015 = phi i32 [ %y_start.0, %.lr.ph18.preheader ], [ %83, %._crit_edge ]
    %59 = add nsw i32 %y_filt.015, %x_start.1
    %60 = add nsw i32 %y_filt.015, %x_stop.1
    %61 = icmp slt i32 %59, %60
    br i1 %61, label %.lr.ph14, label %._crit_edge
  
  .lr.ph14:                                         ; preds = %.lr.ph18
    %62 = icmp sgt i32 %y_edge.016, -1
    %63 = sub nsw i32 0, %y_edge.016
    %64 = select i1 %62, i32 %y_edge.016, i32 %63
    %65 = sub nsw i32 %8, %64
    %66 = icmp sgt i32 %65, -1
    %67 = sub nsw i32 0, %65
    %68 = select i1 %66, i32 %65, i32 %67
    br label %69
  
  ; <label>:69                                      ; preds = %69, %.lr.ph14
    %lsr.iv13 = phi float* [ %scevgep14, %69 ], [ %lsr.iv10, %.lr.ph14 ]
    %lsr.iv7 = phi i32 [ %lsr.iv.next8, %69 ], [ %56, %.lr.ph14 ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next, %69 ], [ %55, %.lr.ph14 ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph14 ], [ %81, %69 ]
    %70 = load float, float* %lsr.iv13, align 4, !tbaa !6
    %71 = icmp sgt i32 %x_edge.013, -1
    %72 = select i1 %71, i32 %x_edge.013, i32 %lsr.iv6
    %73 = sub nsw i32 %4, %72
    %74 = icmp sgt i32 %73, -1
    %75 = sub nsw i32 0, %73
    %76 = select i1 %74, i32 %73, i32 %75
    %77 = add nsw i32 %76, %68
    %78 = getelementptr inbounds float, float* %result, i32 %77
    %79 = load float, float* %78, align 4, !tbaa !6
    %80 = fadd float %70, %79
    store float %80, float* %78, align 4, !tbaa !6
    %81 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv6, -1
    %lsr.iv.next8 = add i32 %lsr.iv7, -1
    %scevgep14 = getelementptr float, float* %lsr.iv13, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next8, 0
    br i1 %exitcond, label %._crit_edge, label %69
  
  ._crit_edge:                                      ; preds = %69, %.lr.ph18
    %82 = bitcast float* %lsr.iv10 to i1*
    %83 = add nsw i32 %y_filt.015, %x_dim
    %84 = add nsw i32 %y_edge.016, %x_dim
    %scevgep12 = getelementptr i1, i1* %82, i32 %58
    %85 = bitcast i1* %scevgep12 to float*
    %86 = icmp slt i32 %83, %y_stop.0
    br i1 %86, label %.lr.ph18, label %._crit_edge19
  
  ._crit_edge19:                                    ; preds = %._crit_edge, %53
    %87 = icmp eq i32 %f_or_e, 1
    br i1 %87, label %88, label %.loopexit
  
  ; <label>:88                                      ; preds = %._crit_edge19
    %89 = icmp sgt i32 %x_pos, -1
    %90 = sub nsw i32 0, %x_pos
    %91 = select i1 %89, i32 %x_pos, i32 %90
    %92 = icmp ne i32 %91, %28
    %93 = icmp ne i32 %x_pos, 0
    %or.cond = and i1 %93, %92
    %94 = icmp slt i32 %4, %1
    %or.cond24 = and i1 %or.cond, %94
    br i1 %or.cond24, label %.lr.ph11.preheader, label %.loopexit8
  
  .lr.ph11.preheader:                               ; preds = %88
    %scevgep2 = getelementptr float, float* %result, i32 %4
    %95 = shl i32 %x_dim, 2
    br label %.lr.ph11
  
  .lr.ph11:                                         ; preds = %.lr.ph11, %.lr.ph11.preheader
    %lsr.iv3 = phi float* [ %99, %.lr.ph11 ], [ %scevgep2, %.lr.ph11.preheader ]
    %y_filt.110 = phi i32 [ %98, %.lr.ph11 ], [ %4, %.lr.ph11.preheader ]
    %lsr.iv34 = bitcast float* %lsr.iv3 to i1*
    %96 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %97 = fadd float %96, %96
    store float %97, float* %lsr.iv3, align 4, !tbaa !6
    %98 = add nsw i32 %y_filt.110, %x_dim
    %scevgep5 = getelementptr i1, i1* %lsr.iv34, i32 %95
    %99 = bitcast i1* %scevgep5 to float*
    %100 = icmp slt i32 %98, %1
    br i1 %100, label %.lr.ph11, label %.loopexit8
  
  .loopexit8:                                       ; preds = %.lr.ph11, %88
    %101 = icmp sgt i32 %y_pos, -1
    %102 = sub nsw i32 0, %y_pos
    %103 = select i1 %101, i32 %y_pos, i32 %102
    %104 = icmp ne i32 %103, %30
    %105 = icmp ne i32 %y_pos, 0
    %or.cond3 = and i1 %105, %104
    br i1 %or.cond3, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %.loopexit8
    %106 = add nsw i32 %8, %x_dim
    %107 = icmp sgt i32 %x_dim, 0
    br i1 %107, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %scevgep = getelementptr float, float* %result, i32 %8
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv = phi float* [ %scevgep1, %.lr.ph ], [ %scevgep, %.lr.ph.preheader ]
    %x_filt.19 = phi i32 [ %110, %.lr.ph ], [ %8, %.lr.ph.preheader ]
    %108 = load float, float* %lsr.iv, align 4, !tbaa !6
    %109 = fadd float %108, %108
    store float %109, float* %lsr.iv, align 4, !tbaa !6
    %110 = add nsw i32 %x_filt.19, 1
    %scevgep1 = getelementptr float, float* %lsr.iv, i32 1
    %111 = icmp slt i32 %110, %106
    br i1 %111, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %.preheader, %.loopexit8, %._crit_edge19
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @extend(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph21.preheader, label %._crit_edge22
  
  .lr.ph21.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge22
  
  ._crit_edge22:                                    ; preds = %.lr.ph21.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge22
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.3 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.3, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.4 = select i1 %51, i32 0, i32 %26
    %.5 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge22
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge22 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge22 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge22 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge22 ], [ %.4, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge22 ], [ %.5, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge22 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph17, label %._crit_edge18
  
  .lr.ph17:                                         ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %59
  
  ; <label>:59                                      ; preds = %._crit_edge, %.lr.ph17
    %lsr.iv3 = phi float* [ %117, %._crit_edge ], [ %scevgep, %.lr.ph17 ]
    %y_edge.015 = phi i32 [ %y_edge_dist.0, %.lr.ph17 ], [ %116, %._crit_edge ]
    %y_filt.014 = phi i32 [ %y_start.0, %.lr.ph17 ], [ %115, %._crit_edge ]
    %60 = add nsw i32 %y_filt.014, %x_start.1
    %61 = add nsw i32 %y_filt.014, %x_stop.1
    %62 = icmp slt i32 %60, %61
    br i1 %62, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %59
    %63 = icmp ne i32 %8, 0
    %64 = icmp sgt i32 %y_edge.015, 0
    %65 = icmp slt i32 %y_edge.015, 0
    %not. = xor i1 %64, true
    %66 = and i1 %65, %not.
    %67 = select i1 %63, i1 %64, i1 %66
    %68 = icmp sgt i32 %y_edge.015, -1
    %69 = sub nsw i32 0, %y_edge.015
    %70 = select i1 %68, i32 %y_edge.015, i32 %69
    %71 = sub nsw i32 %8, %70
    %72 = icmp sgt i32 %71, -1
    %73 = sub nsw i32 0, %71
    %74 = select i1 %72, i32 %71, i32 %73
    %75 = add nsw i32 %y_edge.015, %8
    %76 = icmp slt i32 %75, 0
    %77 = icmp slt i32 %75, %y_dim
    %.10 = select i1 %77, i32 %75, i32 %6
    %78 = select i1 %76, i32 0, i32 %.10
    br label %79
  
  ; <label>:79                                      ; preds = %112, %.lr.ph
    %lsr.iv6 = phi float* [ %scevgep7, %112 ], [ %lsr.iv3, %.lr.ph ]
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %112 ], [ %56, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %112 ], [ %55, %.lr.ph ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph ], [ %113, %112 ]
    %80 = icmp ne i32 %4, 0
    %81 = icmp sgt i32 %x_edge.013, 0
    %82 = icmp slt i32 %x_edge.013, 0
    %not.11 = xor i1 %81, true
    %83 = and i1 %82, %not.11
    %84 = select i1 %80, i1 %81, i1 %83
    %85 = xor i1 %67, %84
    %86 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %87 = icmp sgt i32 %x_edge.013, -1
    %88 = select i1 %87, i32 %x_edge.013, i32 %lsr.iv
    %89 = sub nsw i32 %4, %88
    %90 = icmp sgt i32 %89, -1
    %91 = sub nsw i32 0, %89
    %92 = select i1 %90, i32 %89, i32 %91
    %93 = add nsw i32 %92, %74
    %94 = getelementptr inbounds float, float* %result, i32 %93
    %95 = load float, float* %94, align 4, !tbaa !6
    br i1 %85, label %96, label %110
  
  ; <label>:96                                      ; preds = %79
    %97 = fsub float %95, %86
    store float %97, float* %94, align 4, !tbaa !6
    %98 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %99 = fadd float %98, %98
    %100 = add i32 %4, %x_edge.013
    %101 = icmp slt i32 %100, 0
    %102 = add i32 %4, %x_edge.013
    %103 = icmp slt i32 %102, %x_dim
    %104 = add i32 %4, %x_edge.013
    %.9 = select i1 %103, i32 %104, i32 %3
    %105 = select i1 %101, i32 0, i32 %.9
    %106 = add nsw i32 %105, %78
    %107 = getelementptr inbounds float, float* %result, i32 %106
    %108 = load float, float* %107, align 4, !tbaa !6
    %109 = fadd float %108, %99
    store float %109, float* %107, align 4, !tbaa !6
    br label %112
  
  ; <label>:110                                     ; preds = %79
    %111 = fadd float %86, %95
    store float %111, float* %94, align 4, !tbaa !6
    br label %112
  
  ; <label>:112                                     ; preds = %110, %96
    %113 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv, -1
    %lsr.iv.next2 = add i32 %lsr.iv1, -1
    %scevgep7 = getelementptr float, float* %lsr.iv6, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next2, 0
    br i1 %exitcond, label %._crit_edge, label %79
  
  ._crit_edge:                                      ; preds = %112, %59
    %114 = bitcast float* %lsr.iv3 to i1*
    %115 = add nsw i32 %y_filt.014, %x_dim
    %116 = add nsw i32 %y_edge.015, %x_dim
    %scevgep5 = getelementptr i1, i1* %114, i32 %58
    %117 = bitcast i1* %scevgep5 to float*
    %118 = icmp slt i32 %115, %y_stop.0
    br i1 %118, label %59, label %._crit_edge18
  
  ._crit_edge18:                                    ; preds = %._crit_edge, %53
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @nocompute(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %x_pos.off = add i32 %x_pos, 1
    %2 = icmp ugt i32 %x_pos.off, 2
    %y_pos.off = add i32 %y_pos, 1
    %3 = icmp ugt i32 %y_pos.off, 2
    %4 = or i1 %2, %3
    br i1 %4, label %.preheader, label %.preheader6
  
  .preheader6:                                      ; preds = %0
    %5 = icmp sgt i32 %1, 0
    br i1 %5, label %.lr.ph10.preheader, label %.loopexit
  
  .lr.ph10.preheader:                               ; preds = %.preheader6
    %6 = mul i32 %y_dim, %x_dim
    br label %.lr.ph10
  
  .preheader:                                       ; preds = %0
    %7 = icmp sgt i32 %1, 0
    br i1 %7, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %8 = bitcast float* %result to i8*
    %9 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %8, i8 0, i32 %9, i32 4, i1 false)
    br label %.loopexit
  
  .lr.ph10:                                         ; preds = %.lr.ph10, %.lr.ph10.preheader
    %lsr.iv3 = phi float* [ %scevgep4, %.lr.ph10 ], [ %filt, %.lr.ph10.preheader ]
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph10 ], [ %result, %.lr.ph10.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph10 ], [ %6, %.lr.ph10.preheader ]
    %lsr.iv35 = bitcast float* %lsr.iv3 to i32*
    %lsr.iv12 = bitcast float* %lsr.iv1 to i32*
    %10 = load i32, i32* %lsr.iv35, align 4, !tbaa !6
    store i32 %10, i32* %lsr.iv12, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %exitcond12 = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond12, label %.loopexit, label %.lr.ph10
  
  .loopexit:                                        ; preds = %.lr.ph10, %.lr.ph.preheader, %.preheader, %.preheader6
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  define i32 @ereflect(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #0 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = select i1 %4, i32 %5, i32 0
    %7 = mul nsw i32 %6, %x_dim
    %8 = mul i32 %y_dim, %x_dim
    %9 = icmp sgt i32 %x_pos, 1
    br i1 %9, label %10, label %12
  
  ; <label>:10                                      ; preds = %0
    %11 = sub nsw i32 %x_pos, %x_dim
    br label %16
  
  ; <label>:12                                      ; preds = %0
    %13 = icmp slt i32 %x_pos, -1
    %14 = add nsw i32 %x_pos, 1
    %15 = select i1 %13, i32 %14, i32 0
    br label %16
  
  ; <label>:16                                      ; preds = %12, %10
    %17 = phi i32 [ %11, %10 ], [ %15, %12 ]
    %18 = icmp sgt i32 %y_pos, 1
    br i1 %18, label %19, label %21
  
  ; <label>:19                                      ; preds = %16
    %20 = sub nsw i32 %y_pos, %y_dim
    br label %25
  
  ; <label>:21                                      ; preds = %16
    %22 = icmp slt i32 %y_pos, -1
    %23 = add nsw i32 %y_pos, 1
    %24 = select i1 %22, i32 %23, i32 0
    br label %25
  
  ; <label>:25                                      ; preds = %21, %19
    %26 = phi i32 [ %20, %19 ], [ %24, %21 ]
    %27 = icmp sgt i32 %8, 0
    br i1 %27, label %.preheader3.preheader, label %._crit_edge27
  
  .preheader3.preheader:                            ; preds = %25
    %28 = bitcast float* %result to i8*
    %29 = mul nsw i32 %26, %x_dim
    %30 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %28, i8 0, i32 %30, i32 4, i1 false)
    %31 = shl i32 %x_dim, 2
    %32 = sub i32 0, %17
    br label %.preheader3
  
  .preheader3:                                      ; preds = %._crit_edge23, %.preheader3.preheader
    %lsr.iv19 = phi float* [ %60, %._crit_edge23 ], [ %filt, %.preheader3.preheader ]
    %y_filt.026 = phi i32 [ %34, %._crit_edge23 ], [ 0, %.preheader3.preheader ]
    %y_edge.025 = phi i32 [ %59, %._crit_edge23 ], [ %29, %.preheader3.preheader ]
    %33 = icmp sgt i32 %x_dim, 0
    %34 = add nsw i32 %y_filt.026, %x_dim
    br i1 %33, label %.lr.ph22, label %._crit_edge23
  
  .lr.ph22:                                         ; preds = %.preheader3
    %35 = icmp sgt i32 %y_edge.025, -1
    %36 = sub nsw i32 0, %y_edge.025
    %37 = select i1 %35, i32 %y_edge.025, i32 %36
    %38 = sub nsw i32 %7, %37
    %39 = icmp sgt i32 %38, -1
    %40 = sub nsw i32 0, %38
    %41 = select i1 %39, i32 %38, i32 %40
    br label %42
  
  ; <label>:42                                      ; preds = %42, %.lr.ph22
    %lsr.iv24 = phi i32 [ %lsr.iv.next25, %42 ], [ %32, %.lr.ph22 ]
    %lsr.iv22 = phi float* [ %scevgep23, %42 ], [ %lsr.iv19, %.lr.ph22 ]
    %lsr.iv17 = phi i32 [ %lsr.iv.next18, %42 ], [ 0, %.lr.ph22 ]
    %43 = load float, float* %lsr.iv22, align 4, !tbaa !6
    %44 = add i32 %17, %lsr.iv17
    %45 = icmp sgt i32 %44, -1
    %46 = add i32 %17, %lsr.iv17
    %47 = select i1 %45, i32 %46, i32 %lsr.iv24
    %48 = sub nsw i32 %3, %47
    %49 = icmp sgt i32 %48, -1
    %50 = sub nsw i32 0, %48
    %51 = select i1 %49, i32 %48, i32 %50
    %52 = add nsw i32 %51, %41
    %53 = getelementptr inbounds float, float* %result, i32 %52
    %54 = load float, float* %53, align 4, !tbaa !6
    %55 = fadd float %43, %54
    store float %55, float* %53, align 4, !tbaa !6
    %lsr.iv.next18 = add i32 %lsr.iv17, 1
    %56 = add i32 %y_filt.026, %lsr.iv.next18
    %scevgep23 = getelementptr float, float* %lsr.iv22, i32 1
    %lsr.iv.next25 = add i32 %lsr.iv24, -1
    %57 = icmp slt i32 %56, %34
    br i1 %57, label %42, label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %42, %.preheader3
    %58 = bitcast float* %lsr.iv19 to i1*
    %59 = add nsw i32 %y_edge.025, %x_dim
    %scevgep21 = getelementptr i1, i1* %58, i32 %31
    %60 = bitcast i1* %scevgep21 to float*
    %61 = icmp slt i32 %34, %8
    br i1 %61, label %.preheader3, label %._crit_edge27
  
  ._crit_edge27:                                    ; preds = %._crit_edge23, %25
    %62 = icmp ne i32 %x_pos, 0
    %63 = icmp slt i32 %3, %8
    %or.cond = and i1 %62, %63
    br i1 %or.cond, label %.lr.ph19.preheader, label %.loopexit
  
  .lr.ph19.preheader:                               ; preds = %._crit_edge27
    %scevgep13 = getelementptr float, float* %result, i32 %3
    %64 = shl i32 %x_dim, 2
    br label %.lr.ph19
  
  .lr.ph19:                                         ; preds = %.lr.ph19, %.lr.ph19.preheader
    %lsr.iv14 = phi float* [ %70, %.lr.ph19 ], [ %scevgep13, %.lr.ph19.preheader ]
    %y_filt.118 = phi i32 [ %69, %.lr.ph19 ], [ %3, %.lr.ph19.preheader ]
    %lsr.iv1415 = bitcast float* %lsr.iv14 to i1*
    %65 = load float, float* %lsr.iv14, align 4, !tbaa !6
    %66 = fpext float %65 to double
    %67 = fmul double %66, 0x3FF6A09E667F3BCD
    %68 = fptrunc double %67 to float
    store float %68, float* %lsr.iv14, align 4, !tbaa !6
    %69 = add nsw i32 %y_filt.118, %x_dim
    %scevgep16 = getelementptr i1, i1* %lsr.iv1415, i32 %64
    %70 = bitcast i1* %scevgep16 to float*
    %71 = icmp slt i32 %69, %8
    br i1 %71, label %.lr.ph19, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph19, %._crit_edge27
    %72 = icmp eq i32 %y_pos, 0
    br i1 %72, label %.preheader, label %.preheader1
  
  .preheader1:                                      ; preds = %.loopexit
    %73 = add nsw i32 %7, %x_dim
    %74 = icmp sgt i32 %x_dim, 0
    br i1 %74, label %.lr.ph17.preheader, label %.preheader
  
  .lr.ph17.preheader:                               ; preds = %.preheader1
    %75 = mul i32 %6, %x_dim
    %scevgep10 = getelementptr float, float* %result, i32 %75
    br label %.lr.ph17
  
  .preheader:                                       ; preds = %.lr.ph17, %.preheader1, %.loopexit
    %76 = icmp sgt i32 %8, 0
    br i1 %76, label %.lr.ph13.preheader, label %._crit_edge14.thread
  
  .lr.ph13.preheader:                               ; preds = %.preheader
    %77 = mul i32 %y_dim, %x_dim
    br label %.lr.ph13
  
  ._crit_edge14.thread:                             ; preds = %.preheader
    %78 = tail call double @sqrt(double 0.000000e+00) #5
    %79 = fcmp oeq double %78, %78
    br i1 %79, label %._crit_edge10.thread, label %call.sqrt
  
  call.sqrt:                                        ; preds = %._crit_edge14.thread
    %80 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge10.thread
  
  .lr.ph17:                                         ; preds = %.lr.ph17, %.lr.ph17.preheader
    %lsr.iv11 = phi float* [ %scevgep12, %.lr.ph17 ], [ %scevgep10, %.lr.ph17.preheader ]
    %x_filt.116 = phi i32 [ %85, %.lr.ph17 ], [ %7, %.lr.ph17.preheader ]
    %81 = load float, float* %lsr.iv11, align 4, !tbaa !6
    %82 = fpext float %81 to double
    %83 = fmul double %82, 0x3FF6A09E667F3BCD
    %84 = fptrunc double %83 to float
    store float %84, float* %lsr.iv11, align 4, !tbaa !6
    %85 = add nsw i32 %x_filt.116, 1
    %scevgep12 = getelementptr float, float* %lsr.iv11, i32 1
    %86 = icmp slt i32 %85, %73
    br i1 %86, label %.lr.ph17, label %.preheader
  
  .lr.ph13:                                         ; preds = %.lr.ph13, %.lr.ph13.preheader
    %lsr.iv8 = phi float* [ %scevgep9, %.lr.ph13 ], [ %result, %.lr.ph13.preheader ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next7, %.lr.ph13 ], [ %77, %.lr.ph13.preheader ]
    %norm.012 = phi double [ %90, %.lr.ph13 ], [ 0.000000e+00, %.lr.ph13.preheader ]
    %87 = load float, float* %lsr.iv8, align 4, !tbaa !6
    %88 = fmul float %87, %87
    %89 = fpext float %88 to double
    %90 = fadd double %norm.012, %89
    %lsr.iv.next7 = add i32 %lsr.iv6, -1
    %scevgep9 = getelementptr float, float* %lsr.iv8, i32 1
    %exitcond33 = icmp eq i32 %lsr.iv.next7, 0
    br i1 %exitcond33, label %._crit_edge14, label %.lr.ph13
  
  ._crit_edge14:                                    ; preds = %.lr.ph13
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %._crit_edge14.split, label %call.sqrt26
  
  call.sqrt26:                                      ; preds = %._crit_edge14
    %93 = tail call double @sqrt(double %90) #6
    br label %._crit_edge14.split
  
  ._crit_edge14.split:                              ; preds = %._crit_edge14, %call.sqrt26
    %94 = phi double [ %91, %._crit_edge14 ], [ %93, %call.sqrt26 ]
    %95 = icmp sgt i32 %8, 0
    br i1 %95, label %.lr.ph9.preheader, label %._crit_edge10.thread
  
  .lr.ph9.preheader:                                ; preds = %._crit_edge14.split
    %96 = mul i32 %y_dim, %x_dim
    br label %.lr.ph9
  
  .lr.ph9:                                          ; preds = %.lr.ph9, %.lr.ph9.preheader
    %lsr.iv4 = phi float* [ %scevgep5, %.lr.ph9 ], [ %filt, %.lr.ph9.preheader ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %.lr.ph9 ], [ %96, %.lr.ph9.preheader ]
    %onorm.07 = phi double [ %100, %.lr.ph9 ], [ 0.000000e+00, %.lr.ph9.preheader ]
    %97 = load float, float* %lsr.iv4, align 4, !tbaa !6
    %98 = fmul float %97, %97
    %99 = fpext float %98 to double
    %100 = fadd double %onorm.07, %99
    %lsr.iv.next3 = add i32 %lsr.iv2, -1
    %scevgep5 = getelementptr float, float* %lsr.iv4, i32 1
    %exitcond32 = icmp eq i32 %lsr.iv.next3, 0
    br i1 %exitcond32, label %._crit_edge10, label %.lr.ph9
  
  ._crit_edge10.thread:                             ; preds = %call.sqrt, %._crit_edge14.thread, %._crit_edge14.split
    %101 = tail call double @sqrt(double 0.000000e+00) #5
    %102 = fcmp oeq double %101, %101
    br i1 %102, label %._crit_edge, label %call.sqrt27
  
  call.sqrt27:                                      ; preds = %._crit_edge10.thread
    %103 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge
  
  ._crit_edge10:                                    ; preds = %.lr.ph9
    %104 = tail call double @sqrt(double %100) #5
    %105 = fcmp oeq double %104, %104
    br i1 %105, label %._crit_edge10.split, label %call.sqrt28
  
  call.sqrt28:                                      ; preds = %._crit_edge10
    %106 = tail call double @sqrt(double %100) #6
    br label %._crit_edge10.split
  
  ._crit_edge10.split:                              ; preds = %._crit_edge10, %call.sqrt28
    %107 = phi double [ %104, %._crit_edge10 ], [ %106, %call.sqrt28 ]
    %108 = icmp sgt i32 %8, 0
    %109 = fdiv double %94, %107
    br i1 %108, label %.lr.ph.preheader, label %._crit_edge
  
  .lr.ph.preheader:                                 ; preds = %._crit_edge10.split
    %110 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %110, %.lr.ph.preheader ]
    %111 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %112 = fpext float %111 to double
    %113 = fdiv double %112, %109
    %114 = fptrunc double %113 to float
    store float %114, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %call.sqrt27, %._crit_edge10.thread, %._crit_edge10.split
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  ; Function Attrs: norecurse nounwind
  define i32 @predict(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph12.preheader, label %._crit_edge
  
  .lr.ph12.preheader:                               ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep10 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph12
  
  .lr.ph12:                                         ; preds = %.loopexit2, %.lr.ph12.preheader
    %lsr.iv11 = phi float* [ %45, %.loopexit2 ], [ %scevgep10, %.lr.ph12.preheader ]
    %lsr.iv4 = phi float* [ %44, %.loopexit2 ], [ %filt, %.lr.ph12.preheader ]
    %y_filt.011 = phi i32 [ %27, %.loopexit2 ], [ 0, %.lr.ph12.preheader ]
    %y_res.010 = phi i32 [ %43, %.loopexit2 ], [ %22, %.lr.ph12.preheader ]
    %taps_used.09 = phi float [ %taps_used.3, %.loopexit2 ], [ 0.000000e+00, %.lr.ph12.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.011, %x_dim
    %notlhs = icmp slt i32 %y_res.010, 0
    %notrhs = icmp sge i32 %y_res.010, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit2, label %.lr.ph8
  
  .lr.ph8:                                          ; preds = %.lr.ph12, %38
    %lsr.iv14 = phi float* [ %scevgep15, %38 ], [ %lsr.iv11, %.lr.ph12 ]
    %lsr.iv7 = phi float* [ %scevgep8, %38 ], [ %lsr.iv4, %.lr.ph12 ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %38 ], [ 0, %.lr.ph12 ]
    %taps_used.15 = phi float [ %taps_used.2, %38 ], [ %taps_used.09, %.lr.ph12 ]
    %28 = add i32 %10, %lsr.iv2
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv2
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %38
  
  ; <label>:32                                      ; preds = %.lr.ph8
    %33 = bitcast float* %lsr.iv7 to i32*
    %34 = bitcast float* %lsr.iv14 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    %36 = load float, float* %lsr.iv7, align 4, !tbaa !6
    %37 = fadd float %taps_used.15, %36
    br label %38
  
  ; <label>:38                                      ; preds = %32, %.lr.ph8
    %taps_used.2 = phi float [ %37, %32 ], [ %taps_used.15, %.lr.ph8 ]
    %lsr.iv.next3 = add i32 %lsr.iv2, 1
    %39 = add i32 %y_filt.011, %lsr.iv.next3
    %scevgep8 = getelementptr float, float* %lsr.iv7, i32 1
    %scevgep15 = getelementptr float, float* %lsr.iv14, i32 1
    %40 = icmp slt i32 %39, %27
    br i1 %40, label %.lr.ph8, label %.loopexit2
  
  .loopexit2:                                       ; preds = %38, %.lr.ph12
    %taps_used.3 = phi float [ %taps_used.09, %.lr.ph12 ], [ %taps_used.2, %38 ]
    %41 = bitcast float* %lsr.iv4 to i1*
    %42 = bitcast float* %lsr.iv11 to i1*
    %43 = add nsw i32 %y_res.010, %x_dim
    %scevgep6 = getelementptr i1, i1* %41, i32 %24
    %44 = bitcast i1* %scevgep6 to float*
    %scevgep13 = getelementptr i1, i1* %42, i32 %24
    %45 = bitcast i1* %scevgep13 to float*
    %46 = icmp slt i32 %27, %1
    br i1 %46, label %.lr.ph12, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit2, %18
    %taps_used.0.lcssa = phi float [ 0.000000e+00, %18 ], [ %taps_used.3, %.loopexit2 ]
    %47 = icmp eq i32 %f_or_e, 0
    br i1 %47, label %48, label %.loopexit
  
  ; <label>:48                                      ; preds = %._crit_edge
    %49 = icmp sgt i32 %1, 0
    %50 = fdiv float 2.000000e+00, %taps_used.0.lcssa
    br i1 %49, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %48
    %51 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %51, %.lr.ph.preheader ]
    %52 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %53 = fmul float %50, %52
    store float %53, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %.lr.ph, %48, %._crit_edge
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare i32 @puts(i8* nocapture) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #4
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { nounwind "target-cpu"="mips32" }
  attributes #4 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #5 = { nounwind readnone }
  attributes #6 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"", !3, i64 0, !3, i64 4}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !7, i64 0}
  !7 = !{!"float", !4, i64 0}

...
---
name:            reflect2
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: fgr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: fgr32 }
  - { id: 68, class: fgr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%20' }
  - { reg: '%a1', virtual-reg: '%21' }
  - { reg: '%a2', virtual-reg: '%22' }
  - { reg: '%a3', virtual-reg: '%23' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 24, size: 4, alignment: 8, isImmutable: true, isAliased: false }
  - { id: 1, offset: 20, size: 4, alignment: 4, isImmutable: true, isAliased: false }
  - { id: 2, offset: 16, size: 4, alignment: 8, isImmutable: true, isAliased: false }
body:             |
  bb.0 (%ir-block.0, freq 12):
    successors: %bb.1..lr.ph5.preheader(62), %bb.6.._crit_edge6(37)
    liveins: %a0, %a1, %a2, %a3, %t9, %v0
  
    %35 = ADDu %v0, %t9
    %23 = COPY %a3
    %22 = COPY %a2
    %21 = COPY %a1
    %20 = COPY %a0
    %2 = MUL %22, %21, implicit-def dead %hi0, implicit-def dead %lo0
    BLEZ %2, %bb.6.._crit_edge6, implicit-def dead %at
    B %bb.1..lr.ph5.preheader, implicit-def dead %at
  
  bb.1..lr.ph5.preheader (freq 8):
    successors: %bb.2..lr.ph5(100)
  
    %26 = ADDiu %22, -1
    %27 = MUL %26, %21, implicit-def dead %hi0, implicit-def dead %lo0
    %28 = NOR %21, %zero
    %29 = ADDiu %21, -1
    %30 = SLTi %23, 1
    %31 = ADDiu %zero, 1
    %0 = MOVN_I_I %zero, %30, %29
    %33 = MOVZ_I_I %28, %30, %31
    %3 = ADDu %33, %23
    %24 = LW %fixed-stack.2, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    %34 = SLTi %24, 1
    %25 = LW %fixed-stack.1, 0, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from stack)
    %1 = MOVN_I_I %zero, %34, %27
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %37 = SLL %2, 2
    %38 = LW %35, target-flags(<unknown>) $memset, <0x43b88c0> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry $memset)
    %36 = ADDiu %zero, 0
    %a0 = COPY %25
    %a1 = COPY %36
    %a2 = COPY %37
    %gp = COPY %35
    %t9 = COPY %38
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %39 = NOR %22, %zero
    %42 = MOVZ_I_I killed %39, %34, %31
    %43 = ADDu killed %42, %24
    %4 = MUL killed %43, %21, implicit-def dead %hi0, implicit-def dead %lo0
    %5 = SLL %21, 2
  
  bb.2..lr.ph5 (freq 255):
    successors: %bb.3..lr.ph(62), %bb.5.._crit_edge(37)
  
    %6 = PHI %20, %bb.1..lr.ph5.preheader, %19, %bb.5.._crit_edge
    %7 = PHI %36, %bb.1..lr.ph5.preheader, %10, %bb.5.._crit_edge
    %8 = PHI %4, %bb.1..lr.ph5.preheader, %18, %bb.5.._crit_edge
    %45 = MOVN_I_I %zero, %8, %21
    %9 = ADDu killed %45, %8
    %10 = ADDu %7, %21
    BLEZ %21, %bb.5.._crit_edge, implicit-def dead %at
    B %bb.3..lr.ph, implicit-def dead %at
  
  bb.3..lr.ph (freq 159):
    successors: %bb.4(100)
  
    %46 = SRA %9, 31
    %47 = ADDu %9, %46
    %48 = XOR killed %47, %46
    %49 = SUBu %1, killed %48
    %50 = ADDu killed %49, %21
    %51 = SRA %50, 31
    %52 = ADDu %50, %51
    %11 = XOR killed %52, %51
  
  bb.4 (%ir-block.30, freq 5119):
    successors: %bb.4(96), %bb.5.._crit_edge(3)
  
    %12 = PHI %6, %bb.3..lr.ph, %17, %bb.4
    %13 = PHI %7, %bb.3..lr.ph, %15, %bb.4
    %14 = PHI %3, %bb.3..lr.ph, %16, %bb.4
    %53 = SLTiu %14, 1
    %54 = ADDu killed %53, %14
    %55 = SRA %54, 31
    %56 = ADDu %54, %55
    %57 = XOR killed %56, %55
    %58 = SUBu %0, killed %57
    %59 = NOR %58, %zero
    %60 = ADDiu %58, 1
    %61 = SLTi %58, -1
    %62 = MOVZ_I_I killed %60, killed %61, %59
    %17 = ADDiu %12, 4
    %63 = ADDu killed %62, %11
    %16 = ADDiu %54, 1
    %64 = LWC1 %12, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv2, !tbaa !6)
    %15 = ADDiu %13, 1
    %65 = SLT %15, %10
    %66 = SLL killed %63, 2
    %67 = LWXC1 %25, %66, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.43, !tbaa !6)
    %68 = FADD_S killed %64, killed %67
    SWXC1 killed %68, %25, %66, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.43, !tbaa !6)
    BNE killed %65, %zero, %bb.4, implicit-def dead %at
    B %bb.5.._crit_edge, implicit-def dead %at
  
  bb.5.._crit_edge (freq 255):
    successors: %bb.2..lr.ph5(96), %bb.6.._crit_edge6(3)
  
    %19 = ADDu %6, %5
    %18 = ADDu %9, %21
    %69 = SLT %10, %2
    BNE killed %69, %zero, %bb.2..lr.ph5, implicit-def dead %at
    B %bb.6.._crit_edge6, implicit-def dead %at
  
  bb.6.._crit_edge6 (freq 12):
    liveouts: %v0
  
    %70 = IMPLICIT_DEF
    %v0 = COPY %70
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/epic/epic.edges.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.EDGE_HANDLER = type { i8*, i32 (...)* }
  
  @edge_foos = internal unnamed_addr constant [9 x %struct.EDGE_HANDLER] [%struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect2 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @repeat to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @zero to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @extend to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @nocompute to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @predict to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @ereflect to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }], align 4
  @.str.1 = private unnamed_addr constant [9 x i8] c"reflect1\00", align 1
  @.str.2 = private unnamed_addr constant [9 x i8] c"reflect2\00", align 1
  @.str.3 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
  @.str.4 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
  @.str.5 = private unnamed_addr constant [7 x i8] c"extend\00", align 1
  @.str.6 = private unnamed_addr constant [13 x i8] c"dont-compute\00", align 1
  @.str.7 = private unnamed_addr constant [8 x i8] c"predict\00", align 1
  @.str.8 = private unnamed_addr constant [9 x i8] c"ereflect\00", align 1
  @.str.9 = private unnamed_addr constant [9 x i8] c"treflect\00", align 1
  @str = private unnamed_addr constant [30 x i8] c"No such edge handler routine!\00"
  
  ; Function Attrs: nounwind
  define i32 (...)* @edge_function(i8* nocapture readonly %edges) #0 {
    %1 = tail call i32 @strcmp(i8* %edges, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0))
    %2 = icmp eq i32 %1, 0
    br i1 %2, label %3, label %6
  
  ; <label>:3                                       ; preds = %28, %25, %22, %19, %16, %13, %10, %6, %0
    %i.02.lcssa = phi i32 [ 0, %0 ], [ 1, %6 ], [ 2, %10 ], [ 3, %13 ], [ 4, %16 ], [ 5, %19 ], [ 6, %22 ], [ 7, %25 ], [ 8, %28 ]
    %4 = getelementptr inbounds [9 x %struct.EDGE_HANDLER], [9 x %struct.EDGE_HANDLER]* @edge_foos, i32 0, i32 %i.02.lcssa, i32 1
    %5 = load i32 (...)*, i32 (...)** %4, align 4, !tbaa !1
    br label %9
  
  ; <label>:6                                       ; preds = %0
    %7 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
    %8 = icmp eq i32 %7, 0
    br i1 %8, label %3, label %10
  
  ; <label>:9                                       ; preds = %31, %3
    %.0 = phi i32 (...)* [ %5, %3 ], [ null, %31 ]
    ret i32 (...)* %.0
  
  ; <label>:10                                      ; preds = %6
    %11 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0))
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %3, label %13
  
  ; <label>:13                                      ; preds = %10
    %14 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
    %15 = icmp eq i32 %14, 0
    br i1 %15, label %3, label %16
  
  ; <label>:16                                      ; preds = %13
    %17 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0))
    %18 = icmp eq i32 %17, 0
    br i1 %18, label %3, label %19
  
  ; <label>:19                                      ; preds = %16
    %20 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0))
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %3, label %22
  
  ; <label>:22                                      ; preds = %19
    %23 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0))
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %3, label %25
  
  ; <label>:25                                      ; preds = %22
    %26 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
    %27 = icmp eq i32 %26, 0
    br i1 %27, label %3, label %28
  
  ; <label>:28                                      ; preds = %25
    %29 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0))
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %3, label %31
  
  ; <label>:31                                      ; preds = %28
    %puts = tail call i32 @puts(i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @str, i32 0, i32 0))
    br label %9
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #1
  
  ; Function Attrs: norecurse nounwind
  define i32 @zero(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph7.preheader, label %._crit_edge
  
  .lr.ph7.preheader:                                ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep6 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph7
  
  .lr.ph7:                                          ; preds = %.loopexit, %.lr.ph7.preheader
    %lsr.iv7 = phi float* [ %43, %.loopexit ], [ %scevgep6, %.lr.ph7.preheader ]
    %lsr.iv1 = phi float* [ %42, %.loopexit ], [ %filt, %.lr.ph7.preheader ]
    %y_filt.06 = phi i32 [ %27, %.loopexit ], [ 0, %.lr.ph7.preheader ]
    %y_res.05 = phi i32 [ %41, %.loopexit ], [ %22, %.lr.ph7.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.06, %x_dim
    %notlhs = icmp slt i32 %y_res.05, 0
    %notrhs = icmp sge i32 %y_res.05, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph7, %36
    %lsr.iv10 = phi float* [ %scevgep11, %36 ], [ %lsr.iv7, %.lr.ph7 ]
    %lsr.iv3 = phi float* [ %scevgep4, %36 ], [ %lsr.iv1, %.lr.ph7 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %36 ], [ 0, %.lr.ph7 ]
    %28 = add i32 %10, %lsr.iv
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %36
  
  ; <label>:32                                      ; preds = %.lr.ph
    %33 = bitcast float* %lsr.iv3 to i32*
    %34 = bitcast float* %lsr.iv10 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    br label %36
  
  ; <label>:36                                      ; preds = %32, %.lr.ph
    %lsr.iv.next = add i32 %lsr.iv, 1
    %37 = add i32 %y_filt.06, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %scevgep11 = getelementptr float, float* %lsr.iv10, i32 1
    %38 = icmp slt i32 %37, %27
    br i1 %38, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %36, %.lr.ph7
    %39 = bitcast float* %lsr.iv1 to i1*
    %40 = bitcast float* %lsr.iv7 to i1*
    %41 = add nsw i32 %y_res.05, %x_dim
    %scevgep = getelementptr i1, i1* %39, i32 %24
    %42 = bitcast i1* %scevgep to float*
    %scevgep9 = getelementptr i1, i1* %40, i32 %24
    %43 = bitcast i1* %scevgep9 to float*
    %44 = icmp slt i32 %27, %1
    br i1 %44, label %.lr.ph7, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @repeat(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.preheader.lr.ph, label %._crit_edge6
  
  .preheader.lr.ph:                                 ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = sub nsw i32 %1, %x_dim
    %25 = add nsw i32 %x_dim, -1
    %26 = shl i32 %x_dim, 2
    br label %.preheader
  
  .preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
    %lsr.iv1 = phi float* [ %48, %._crit_edge ], [ %filt, %.preheader.lr.ph ]
    %y_filt.05 = phi i32 [ 0, %.preheader.lr.ph ], [ %28, %._crit_edge ]
    %y_res.04 = phi i32 [ %22, %.preheader.lr.ph ], [ %47, %._crit_edge ]
    %27 = icmp sgt i32 %x_dim, 0
    %28 = add nsw i32 %y_filt.05, %x_dim
    br i1 %27, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader
    %29 = icmp sgt i32 %y_res.04, -1
    %30 = icmp slt i32 %y_res.04, %1
    %y_res.0. = select i1 %30, i32 %y_res.04, i32 %24
    %y_res.0.. = select i1 %29, i32 %y_res.0., i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %31, %.lr.ph
    %lsr.iv3 = phi float* [ %scevgep4, %31 ], [ %lsr.iv1, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %31 ], [ 0, %.lr.ph ]
    %32 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %33 = add i32 %10, %lsr.iv
    %34 = icmp sgt i32 %33, -1
    %35 = add i32 %10, %lsr.iv
    %36 = icmp slt i32 %35, %x_dim
    %37 = add i32 %10, %lsr.iv
    %38 = select i1 %36, i32 %37, i32 %25
    %39 = select i1 %34, i32 %38, i32 0
    %40 = add nsw i32 %39, %y_res.0..
    %41 = getelementptr inbounds float, float* %result, i32 %40
    %42 = load float, float* %41, align 4, !tbaa !6
    %43 = fadd float %32, %42
    store float %43, float* %41, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, 1
    %44 = add i32 %y_filt.05, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %45 = icmp slt i32 %44, %28
    br i1 %45, label %31, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %31, %.preheader
    %46 = bitcast float* %lsr.iv1 to i1*
    %47 = add nsw i32 %y_res.04, %x_dim
    %scevgep = getelementptr i1, i1* %46, i32 %26
    %48 = bitcast i1* %scevgep to float*
    %49 = icmp slt i32 %28, %1
    br i1 %49, label %.preheader, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect2(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = mul nsw i32 %5, %x_dim
    %7 = select i1 %4, i32 %6, i32 0
    %8 = mul i32 %y_dim, %x_dim
    %9 = xor i32 %x_dim, -1
    %.v = select i1 %1, i32 %9, i32 1
    %10 = add i32 %.v, %x_pos
    %11 = icmp sgt i32 %8, 0
    br i1 %11, label %.lr.ph5.preheader, label %._crit_edge6
  
  .lr.ph5.preheader:                                ; preds = %0
    %12 = icmp sgt i32 %y_pos, 0
    %13 = xor i32 %y_dim, -1
    %.v10 = select i1 %12, i32 %13, i32 1
    %14 = add i32 %.v10, %y_pos
    %15 = mul nsw i32 %14, %x_dim
    %result11 = bitcast float* %result to i8*
    %16 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %result11, i8 0, i32 %16, i32 4, i1 false)
    %17 = shl i32 %x_dim, 2
    br label %.lr.ph5
  
  .lr.ph5:                                          ; preds = %._crit_edge, %.lr.ph5.preheader
    %lsr.iv = phi float* [ %51, %._crit_edge ], [ %filt, %.lr.ph5.preheader ]
    %y_filt.04 = phi i32 [ %21, %._crit_edge ], [ 0, %.lr.ph5.preheader ]
    %y_edge.03 = phi i32 [ %50, %._crit_edge ], [ %15, %.lr.ph5.preheader ]
    %18 = icmp sgt i32 %x_dim, 0
    %19 = icmp eq i32 %y_edge.03, 0
    %20 = select i1 %19, i32 %x_dim, i32 0
    %.y_edge.0 = add nsw i32 %20, %y_edge.03
    %21 = add nsw i32 %y_filt.04, %x_dim
    br i1 %18, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.lr.ph5
    %22 = icmp sgt i32 %.y_edge.0, -1
    %23 = sub nsw i32 0, %.y_edge.0
    %24 = select i1 %22, i32 %.y_edge.0, i32 %23
    %25 = sub nsw i32 %7, %24
    %26 = add nsw i32 %25, %x_dim
    %27 = icmp sgt i32 %26, -1
    %28 = sub nsw i32 0, %26
    %29 = select i1 %27, i32 %26, i32 %28
    br label %30
  
  ; <label>:30                                      ; preds = %30, %.lr.ph
    %lsr.iv2 = phi float* [ %scevgep3, %30 ], [ %lsr.iv, %.lr.ph ]
    %x_filt.02 = phi i32 [ %y_filt.04, %.lr.ph ], [ %46, %30 ]
    %x_edge.01 = phi i32 [ %10, %.lr.ph ], [ %47, %30 ]
    %31 = icmp eq i32 %x_edge.01, 0
    %32 = zext i1 %31 to i32
    %.x_edge.0 = add nsw i32 %32, %x_edge.01
    %33 = load float, float* %lsr.iv2, align 4, !tbaa !6
    %34 = icmp sgt i32 %.x_edge.0, -1
    %35 = sub nsw i32 0, %.x_edge.0
    %36 = select i1 %34, i32 %.x_edge.0, i32 %35
    %37 = sub nsw i32 %3, %36
    %38 = add nsw i32 %37, 1
    %39 = icmp sgt i32 %37, -2
    %40 = xor i32 %37, -1
    %41 = select i1 %39, i32 %38, i32 %40
    %42 = add nsw i32 %41, %29
    %43 = getelementptr inbounds float, float* %result, i32 %42
    %44 = load float, float* %43, align 4, !tbaa !6
    %45 = fadd float %33, %44
    store float %45, float* %43, align 4, !tbaa !6
    %46 = add nsw i32 %x_filt.02, 1
    %47 = add nsw i32 %.x_edge.0, 1
    %scevgep3 = getelementptr float, float* %lsr.iv2, i32 1
    %48 = icmp slt i32 %46, %21
    br i1 %48, label %30, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %30, %.lr.ph5
    %49 = bitcast float* %lsr.iv to i1*
    %50 = add nsw i32 %.y_edge.0, %x_dim
    %scevgep = getelementptr i1, i1* %49, i32 %17
    %51 = bitcast i1* %scevgep to float*
    %52 = icmp slt i32 %21, %8
    br i1 %52, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %0
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect1(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph22.preheader, label %._crit_edge23
  
  .lr.ph22.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %.lr.ph22.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge23
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.4 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.4, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.5 = select i1 %51, i32 0, i32 %26
    %.6 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge23
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge23 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge23 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge23 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge23 ], [ %.5, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge23 ], [ %.6, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge23 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph18.preheader, label %._crit_edge19
  
  .lr.ph18.preheader:                               ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep9 = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %.lr.ph18
  
  .lr.ph18:                                         ; preds = %._crit_edge, %.lr.ph18.preheader
    %lsr.iv10 = phi float* [ %85, %._crit_edge ], [ %scevgep9, %.lr.ph18.preheader ]
    %y_edge.016 = phi i32 [ %y_edge_dist.0, %.lr.ph18.preheader ], [ %84, %._crit_edge ]
    %y_filt.015 = phi i32 [ %y_start.0, %.lr.ph18.preheader ], [ %83, %._crit_edge ]
    %59 = add nsw i32 %y_filt.015, %x_start.1
    %60 = add nsw i32 %y_filt.015, %x_stop.1
    %61 = icmp slt i32 %59, %60
    br i1 %61, label %.lr.ph14, label %._crit_edge
  
  .lr.ph14:                                         ; preds = %.lr.ph18
    %62 = icmp sgt i32 %y_edge.016, -1
    %63 = sub nsw i32 0, %y_edge.016
    %64 = select i1 %62, i32 %y_edge.016, i32 %63
    %65 = sub nsw i32 %8, %64
    %66 = icmp sgt i32 %65, -1
    %67 = sub nsw i32 0, %65
    %68 = select i1 %66, i32 %65, i32 %67
    br label %69
  
  ; <label>:69                                      ; preds = %69, %.lr.ph14
    %lsr.iv13 = phi float* [ %scevgep14, %69 ], [ %lsr.iv10, %.lr.ph14 ]
    %lsr.iv7 = phi i32 [ %lsr.iv.next8, %69 ], [ %56, %.lr.ph14 ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next, %69 ], [ %55, %.lr.ph14 ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph14 ], [ %81, %69 ]
    %70 = load float, float* %lsr.iv13, align 4, !tbaa !6
    %71 = icmp sgt i32 %x_edge.013, -1
    %72 = select i1 %71, i32 %x_edge.013, i32 %lsr.iv6
    %73 = sub nsw i32 %4, %72
    %74 = icmp sgt i32 %73, -1
    %75 = sub nsw i32 0, %73
    %76 = select i1 %74, i32 %73, i32 %75
    %77 = add nsw i32 %76, %68
    %78 = getelementptr inbounds float, float* %result, i32 %77
    %79 = load float, float* %78, align 4, !tbaa !6
    %80 = fadd float %70, %79
    store float %80, float* %78, align 4, !tbaa !6
    %81 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv6, -1
    %lsr.iv.next8 = add i32 %lsr.iv7, -1
    %scevgep14 = getelementptr float, float* %lsr.iv13, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next8, 0
    br i1 %exitcond, label %._crit_edge, label %69
  
  ._crit_edge:                                      ; preds = %69, %.lr.ph18
    %82 = bitcast float* %lsr.iv10 to i1*
    %83 = add nsw i32 %y_filt.015, %x_dim
    %84 = add nsw i32 %y_edge.016, %x_dim
    %scevgep12 = getelementptr i1, i1* %82, i32 %58
    %85 = bitcast i1* %scevgep12 to float*
    %86 = icmp slt i32 %83, %y_stop.0
    br i1 %86, label %.lr.ph18, label %._crit_edge19
  
  ._crit_edge19:                                    ; preds = %._crit_edge, %53
    %87 = icmp eq i32 %f_or_e, 1
    br i1 %87, label %88, label %.loopexit
  
  ; <label>:88                                      ; preds = %._crit_edge19
    %89 = icmp sgt i32 %x_pos, -1
    %90 = sub nsw i32 0, %x_pos
    %91 = select i1 %89, i32 %x_pos, i32 %90
    %92 = icmp ne i32 %91, %28
    %93 = icmp ne i32 %x_pos, 0
    %or.cond = and i1 %93, %92
    %94 = icmp slt i32 %4, %1
    %or.cond24 = and i1 %or.cond, %94
    br i1 %or.cond24, label %.lr.ph11.preheader, label %.loopexit8
  
  .lr.ph11.preheader:                               ; preds = %88
    %scevgep2 = getelementptr float, float* %result, i32 %4
    %95 = shl i32 %x_dim, 2
    br label %.lr.ph11
  
  .lr.ph11:                                         ; preds = %.lr.ph11, %.lr.ph11.preheader
    %lsr.iv3 = phi float* [ %99, %.lr.ph11 ], [ %scevgep2, %.lr.ph11.preheader ]
    %y_filt.110 = phi i32 [ %98, %.lr.ph11 ], [ %4, %.lr.ph11.preheader ]
    %lsr.iv34 = bitcast float* %lsr.iv3 to i1*
    %96 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %97 = fadd float %96, %96
    store float %97, float* %lsr.iv3, align 4, !tbaa !6
    %98 = add nsw i32 %y_filt.110, %x_dim
    %scevgep5 = getelementptr i1, i1* %lsr.iv34, i32 %95
    %99 = bitcast i1* %scevgep5 to float*
    %100 = icmp slt i32 %98, %1
    br i1 %100, label %.lr.ph11, label %.loopexit8
  
  .loopexit8:                                       ; preds = %.lr.ph11, %88
    %101 = icmp sgt i32 %y_pos, -1
    %102 = sub nsw i32 0, %y_pos
    %103 = select i1 %101, i32 %y_pos, i32 %102
    %104 = icmp ne i32 %103, %30
    %105 = icmp ne i32 %y_pos, 0
    %or.cond3 = and i1 %105, %104
    br i1 %or.cond3, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %.loopexit8
    %106 = add nsw i32 %8, %x_dim
    %107 = icmp sgt i32 %x_dim, 0
    br i1 %107, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %scevgep = getelementptr float, float* %result, i32 %8
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv = phi float* [ %scevgep1, %.lr.ph ], [ %scevgep, %.lr.ph.preheader ]
    %x_filt.19 = phi i32 [ %110, %.lr.ph ], [ %8, %.lr.ph.preheader ]
    %108 = load float, float* %lsr.iv, align 4, !tbaa !6
    %109 = fadd float %108, %108
    store float %109, float* %lsr.iv, align 4, !tbaa !6
    %110 = add nsw i32 %x_filt.19, 1
    %scevgep1 = getelementptr float, float* %lsr.iv, i32 1
    %111 = icmp slt i32 %110, %106
    br i1 %111, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %.preheader, %.loopexit8, %._crit_edge19
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @extend(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph21.preheader, label %._crit_edge22
  
  .lr.ph21.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge22
  
  ._crit_edge22:                                    ; preds = %.lr.ph21.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge22
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.3 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.3, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.4 = select i1 %51, i32 0, i32 %26
    %.5 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge22
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge22 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge22 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge22 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge22 ], [ %.4, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge22 ], [ %.5, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge22 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph17, label %._crit_edge18
  
  .lr.ph17:                                         ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %59
  
  ; <label>:59                                      ; preds = %._crit_edge, %.lr.ph17
    %lsr.iv3 = phi float* [ %117, %._crit_edge ], [ %scevgep, %.lr.ph17 ]
    %y_edge.015 = phi i32 [ %y_edge_dist.0, %.lr.ph17 ], [ %116, %._crit_edge ]
    %y_filt.014 = phi i32 [ %y_start.0, %.lr.ph17 ], [ %115, %._crit_edge ]
    %60 = add nsw i32 %y_filt.014, %x_start.1
    %61 = add nsw i32 %y_filt.014, %x_stop.1
    %62 = icmp slt i32 %60, %61
    br i1 %62, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %59
    %63 = icmp ne i32 %8, 0
    %64 = icmp sgt i32 %y_edge.015, 0
    %65 = icmp slt i32 %y_edge.015, 0
    %not. = xor i1 %64, true
    %66 = and i1 %65, %not.
    %67 = select i1 %63, i1 %64, i1 %66
    %68 = icmp sgt i32 %y_edge.015, -1
    %69 = sub nsw i32 0, %y_edge.015
    %70 = select i1 %68, i32 %y_edge.015, i32 %69
    %71 = sub nsw i32 %8, %70
    %72 = icmp sgt i32 %71, -1
    %73 = sub nsw i32 0, %71
    %74 = select i1 %72, i32 %71, i32 %73
    %75 = add nsw i32 %y_edge.015, %8
    %76 = icmp slt i32 %75, 0
    %77 = icmp slt i32 %75, %y_dim
    %.10 = select i1 %77, i32 %75, i32 %6
    %78 = select i1 %76, i32 0, i32 %.10
    br label %79
  
  ; <label>:79                                      ; preds = %112, %.lr.ph
    %lsr.iv6 = phi float* [ %scevgep7, %112 ], [ %lsr.iv3, %.lr.ph ]
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %112 ], [ %56, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %112 ], [ %55, %.lr.ph ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph ], [ %113, %112 ]
    %80 = icmp ne i32 %4, 0
    %81 = icmp sgt i32 %x_edge.013, 0
    %82 = icmp slt i32 %x_edge.013, 0
    %not.11 = xor i1 %81, true
    %83 = and i1 %82, %not.11
    %84 = select i1 %80, i1 %81, i1 %83
    %85 = xor i1 %67, %84
    %86 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %87 = icmp sgt i32 %x_edge.013, -1
    %88 = select i1 %87, i32 %x_edge.013, i32 %lsr.iv
    %89 = sub nsw i32 %4, %88
    %90 = icmp sgt i32 %89, -1
    %91 = sub nsw i32 0, %89
    %92 = select i1 %90, i32 %89, i32 %91
    %93 = add nsw i32 %92, %74
    %94 = getelementptr inbounds float, float* %result, i32 %93
    %95 = load float, float* %94, align 4, !tbaa !6
    br i1 %85, label %96, label %110
  
  ; <label>:96                                      ; preds = %79
    %97 = fsub float %95, %86
    store float %97, float* %94, align 4, !tbaa !6
    %98 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %99 = fadd float %98, %98
    %100 = add i32 %4, %x_edge.013
    %101 = icmp slt i32 %100, 0
    %102 = add i32 %4, %x_edge.013
    %103 = icmp slt i32 %102, %x_dim
    %104 = add i32 %4, %x_edge.013
    %.9 = select i1 %103, i32 %104, i32 %3
    %105 = select i1 %101, i32 0, i32 %.9
    %106 = add nsw i32 %105, %78
    %107 = getelementptr inbounds float, float* %result, i32 %106
    %108 = load float, float* %107, align 4, !tbaa !6
    %109 = fadd float %108, %99
    store float %109, float* %107, align 4, !tbaa !6
    br label %112
  
  ; <label>:110                                     ; preds = %79
    %111 = fadd float %86, %95
    store float %111, float* %94, align 4, !tbaa !6
    br label %112
  
  ; <label>:112                                     ; preds = %110, %96
    %113 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv, -1
    %lsr.iv.next2 = add i32 %lsr.iv1, -1
    %scevgep7 = getelementptr float, float* %lsr.iv6, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next2, 0
    br i1 %exitcond, label %._crit_edge, label %79
  
  ._crit_edge:                                      ; preds = %112, %59
    %114 = bitcast float* %lsr.iv3 to i1*
    %115 = add nsw i32 %y_filt.014, %x_dim
    %116 = add nsw i32 %y_edge.015, %x_dim
    %scevgep5 = getelementptr i1, i1* %114, i32 %58
    %117 = bitcast i1* %scevgep5 to float*
    %118 = icmp slt i32 %115, %y_stop.0
    br i1 %118, label %59, label %._crit_edge18
  
  ._crit_edge18:                                    ; preds = %._crit_edge, %53
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @nocompute(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %x_pos.off = add i32 %x_pos, 1
    %2 = icmp ugt i32 %x_pos.off, 2
    %y_pos.off = add i32 %y_pos, 1
    %3 = icmp ugt i32 %y_pos.off, 2
    %4 = or i1 %2, %3
    br i1 %4, label %.preheader, label %.preheader6
  
  .preheader6:                                      ; preds = %0
    %5 = icmp sgt i32 %1, 0
    br i1 %5, label %.lr.ph10.preheader, label %.loopexit
  
  .lr.ph10.preheader:                               ; preds = %.preheader6
    %6 = mul i32 %y_dim, %x_dim
    br label %.lr.ph10
  
  .preheader:                                       ; preds = %0
    %7 = icmp sgt i32 %1, 0
    br i1 %7, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %8 = bitcast float* %result to i8*
    %9 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %8, i8 0, i32 %9, i32 4, i1 false)
    br label %.loopexit
  
  .lr.ph10:                                         ; preds = %.lr.ph10, %.lr.ph10.preheader
    %lsr.iv3 = phi float* [ %scevgep4, %.lr.ph10 ], [ %filt, %.lr.ph10.preheader ]
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph10 ], [ %result, %.lr.ph10.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph10 ], [ %6, %.lr.ph10.preheader ]
    %lsr.iv35 = bitcast float* %lsr.iv3 to i32*
    %lsr.iv12 = bitcast float* %lsr.iv1 to i32*
    %10 = load i32, i32* %lsr.iv35, align 4, !tbaa !6
    store i32 %10, i32* %lsr.iv12, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %exitcond12 = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond12, label %.loopexit, label %.lr.ph10
  
  .loopexit:                                        ; preds = %.lr.ph10, %.lr.ph.preheader, %.preheader, %.preheader6
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  define i32 @ereflect(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #0 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = select i1 %4, i32 %5, i32 0
    %7 = mul nsw i32 %6, %x_dim
    %8 = mul i32 %y_dim, %x_dim
    %9 = icmp sgt i32 %x_pos, 1
    br i1 %9, label %10, label %12
  
  ; <label>:10                                      ; preds = %0
    %11 = sub nsw i32 %x_pos, %x_dim
    br label %16
  
  ; <label>:12                                      ; preds = %0
    %13 = icmp slt i32 %x_pos, -1
    %14 = add nsw i32 %x_pos, 1
    %15 = select i1 %13, i32 %14, i32 0
    br label %16
  
  ; <label>:16                                      ; preds = %12, %10
    %17 = phi i32 [ %11, %10 ], [ %15, %12 ]
    %18 = icmp sgt i32 %y_pos, 1
    br i1 %18, label %19, label %21
  
  ; <label>:19                                      ; preds = %16
    %20 = sub nsw i32 %y_pos, %y_dim
    br label %25
  
  ; <label>:21                                      ; preds = %16
    %22 = icmp slt i32 %y_pos, -1
    %23 = add nsw i32 %y_pos, 1
    %24 = select i1 %22, i32 %23, i32 0
    br label %25
  
  ; <label>:25                                      ; preds = %21, %19
    %26 = phi i32 [ %20, %19 ], [ %24, %21 ]
    %27 = icmp sgt i32 %8, 0
    br i1 %27, label %.preheader3.preheader, label %._crit_edge27
  
  .preheader3.preheader:                            ; preds = %25
    %28 = bitcast float* %result to i8*
    %29 = mul nsw i32 %26, %x_dim
    %30 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %28, i8 0, i32 %30, i32 4, i1 false)
    %31 = shl i32 %x_dim, 2
    %32 = sub i32 0, %17
    br label %.preheader3
  
  .preheader3:                                      ; preds = %._crit_edge23, %.preheader3.preheader
    %lsr.iv19 = phi float* [ %60, %._crit_edge23 ], [ %filt, %.preheader3.preheader ]
    %y_filt.026 = phi i32 [ %34, %._crit_edge23 ], [ 0, %.preheader3.preheader ]
    %y_edge.025 = phi i32 [ %59, %._crit_edge23 ], [ %29, %.preheader3.preheader ]
    %33 = icmp sgt i32 %x_dim, 0
    %34 = add nsw i32 %y_filt.026, %x_dim
    br i1 %33, label %.lr.ph22, label %._crit_edge23
  
  .lr.ph22:                                         ; preds = %.preheader3
    %35 = icmp sgt i32 %y_edge.025, -1
    %36 = sub nsw i32 0, %y_edge.025
    %37 = select i1 %35, i32 %y_edge.025, i32 %36
    %38 = sub nsw i32 %7, %37
    %39 = icmp sgt i32 %38, -1
    %40 = sub nsw i32 0, %38
    %41 = select i1 %39, i32 %38, i32 %40
    br label %42
  
  ; <label>:42                                      ; preds = %42, %.lr.ph22
    %lsr.iv24 = phi i32 [ %lsr.iv.next25, %42 ], [ %32, %.lr.ph22 ]
    %lsr.iv22 = phi float* [ %scevgep23, %42 ], [ %lsr.iv19, %.lr.ph22 ]
    %lsr.iv17 = phi i32 [ %lsr.iv.next18, %42 ], [ 0, %.lr.ph22 ]
    %43 = load float, float* %lsr.iv22, align 4, !tbaa !6
    %44 = add i32 %17, %lsr.iv17
    %45 = icmp sgt i32 %44, -1
    %46 = add i32 %17, %lsr.iv17
    %47 = select i1 %45, i32 %46, i32 %lsr.iv24
    %48 = sub nsw i32 %3, %47
    %49 = icmp sgt i32 %48, -1
    %50 = sub nsw i32 0, %48
    %51 = select i1 %49, i32 %48, i32 %50
    %52 = add nsw i32 %51, %41
    %53 = getelementptr inbounds float, float* %result, i32 %52
    %54 = load float, float* %53, align 4, !tbaa !6
    %55 = fadd float %43, %54
    store float %55, float* %53, align 4, !tbaa !6
    %lsr.iv.next18 = add i32 %lsr.iv17, 1
    %56 = add i32 %y_filt.026, %lsr.iv.next18
    %scevgep23 = getelementptr float, float* %lsr.iv22, i32 1
    %lsr.iv.next25 = add i32 %lsr.iv24, -1
    %57 = icmp slt i32 %56, %34
    br i1 %57, label %42, label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %42, %.preheader3
    %58 = bitcast float* %lsr.iv19 to i1*
    %59 = add nsw i32 %y_edge.025, %x_dim
    %scevgep21 = getelementptr i1, i1* %58, i32 %31
    %60 = bitcast i1* %scevgep21 to float*
    %61 = icmp slt i32 %34, %8
    br i1 %61, label %.preheader3, label %._crit_edge27
  
  ._crit_edge27:                                    ; preds = %._crit_edge23, %25
    %62 = icmp ne i32 %x_pos, 0
    %63 = icmp slt i32 %3, %8
    %or.cond = and i1 %62, %63
    br i1 %or.cond, label %.lr.ph19.preheader, label %.loopexit
  
  .lr.ph19.preheader:                               ; preds = %._crit_edge27
    %scevgep13 = getelementptr float, float* %result, i32 %3
    %64 = shl i32 %x_dim, 2
    br label %.lr.ph19
  
  .lr.ph19:                                         ; preds = %.lr.ph19, %.lr.ph19.preheader
    %lsr.iv14 = phi float* [ %70, %.lr.ph19 ], [ %scevgep13, %.lr.ph19.preheader ]
    %y_filt.118 = phi i32 [ %69, %.lr.ph19 ], [ %3, %.lr.ph19.preheader ]
    %lsr.iv1415 = bitcast float* %lsr.iv14 to i1*
    %65 = load float, float* %lsr.iv14, align 4, !tbaa !6
    %66 = fpext float %65 to double
    %67 = fmul double %66, 0x3FF6A09E667F3BCD
    %68 = fptrunc double %67 to float
    store float %68, float* %lsr.iv14, align 4, !tbaa !6
    %69 = add nsw i32 %y_filt.118, %x_dim
    %scevgep16 = getelementptr i1, i1* %lsr.iv1415, i32 %64
    %70 = bitcast i1* %scevgep16 to float*
    %71 = icmp slt i32 %69, %8
    br i1 %71, label %.lr.ph19, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph19, %._crit_edge27
    %72 = icmp eq i32 %y_pos, 0
    br i1 %72, label %.preheader, label %.preheader1
  
  .preheader1:                                      ; preds = %.loopexit
    %73 = add nsw i32 %7, %x_dim
    %74 = icmp sgt i32 %x_dim, 0
    br i1 %74, label %.lr.ph17.preheader, label %.preheader
  
  .lr.ph17.preheader:                               ; preds = %.preheader1
    %75 = mul i32 %6, %x_dim
    %scevgep10 = getelementptr float, float* %result, i32 %75
    br label %.lr.ph17
  
  .preheader:                                       ; preds = %.lr.ph17, %.preheader1, %.loopexit
    %76 = icmp sgt i32 %8, 0
    br i1 %76, label %.lr.ph13.preheader, label %._crit_edge14.thread
  
  .lr.ph13.preheader:                               ; preds = %.preheader
    %77 = mul i32 %y_dim, %x_dim
    br label %.lr.ph13
  
  ._crit_edge14.thread:                             ; preds = %.preheader
    %78 = tail call double @sqrt(double 0.000000e+00) #5
    %79 = fcmp oeq double %78, %78
    br i1 %79, label %._crit_edge10.thread, label %call.sqrt
  
  call.sqrt:                                        ; preds = %._crit_edge14.thread
    %80 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge10.thread
  
  .lr.ph17:                                         ; preds = %.lr.ph17, %.lr.ph17.preheader
    %lsr.iv11 = phi float* [ %scevgep12, %.lr.ph17 ], [ %scevgep10, %.lr.ph17.preheader ]
    %x_filt.116 = phi i32 [ %85, %.lr.ph17 ], [ %7, %.lr.ph17.preheader ]
    %81 = load float, float* %lsr.iv11, align 4, !tbaa !6
    %82 = fpext float %81 to double
    %83 = fmul double %82, 0x3FF6A09E667F3BCD
    %84 = fptrunc double %83 to float
    store float %84, float* %lsr.iv11, align 4, !tbaa !6
    %85 = add nsw i32 %x_filt.116, 1
    %scevgep12 = getelementptr float, float* %lsr.iv11, i32 1
    %86 = icmp slt i32 %85, %73
    br i1 %86, label %.lr.ph17, label %.preheader
  
  .lr.ph13:                                         ; preds = %.lr.ph13, %.lr.ph13.preheader
    %lsr.iv8 = phi float* [ %scevgep9, %.lr.ph13 ], [ %result, %.lr.ph13.preheader ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next7, %.lr.ph13 ], [ %77, %.lr.ph13.preheader ]
    %norm.012 = phi double [ %90, %.lr.ph13 ], [ 0.000000e+00, %.lr.ph13.preheader ]
    %87 = load float, float* %lsr.iv8, align 4, !tbaa !6
    %88 = fmul float %87, %87
    %89 = fpext float %88 to double
    %90 = fadd double %norm.012, %89
    %lsr.iv.next7 = add i32 %lsr.iv6, -1
    %scevgep9 = getelementptr float, float* %lsr.iv8, i32 1
    %exitcond33 = icmp eq i32 %lsr.iv.next7, 0
    br i1 %exitcond33, label %._crit_edge14, label %.lr.ph13
  
  ._crit_edge14:                                    ; preds = %.lr.ph13
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %._crit_edge14.split, label %call.sqrt26
  
  call.sqrt26:                                      ; preds = %._crit_edge14
    %93 = tail call double @sqrt(double %90) #6
    br label %._crit_edge14.split
  
  ._crit_edge14.split:                              ; preds = %._crit_edge14, %call.sqrt26
    %94 = phi double [ %91, %._crit_edge14 ], [ %93, %call.sqrt26 ]
    %95 = icmp sgt i32 %8, 0
    br i1 %95, label %.lr.ph9.preheader, label %._crit_edge10.thread
  
  .lr.ph9.preheader:                                ; preds = %._crit_edge14.split
    %96 = mul i32 %y_dim, %x_dim
    br label %.lr.ph9
  
  .lr.ph9:                                          ; preds = %.lr.ph9, %.lr.ph9.preheader
    %lsr.iv4 = phi float* [ %scevgep5, %.lr.ph9 ], [ %filt, %.lr.ph9.preheader ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %.lr.ph9 ], [ %96, %.lr.ph9.preheader ]
    %onorm.07 = phi double [ %100, %.lr.ph9 ], [ 0.000000e+00, %.lr.ph9.preheader ]
    %97 = load float, float* %lsr.iv4, align 4, !tbaa !6
    %98 = fmul float %97, %97
    %99 = fpext float %98 to double
    %100 = fadd double %onorm.07, %99
    %lsr.iv.next3 = add i32 %lsr.iv2, -1
    %scevgep5 = getelementptr float, float* %lsr.iv4, i32 1
    %exitcond32 = icmp eq i32 %lsr.iv.next3, 0
    br i1 %exitcond32, label %._crit_edge10, label %.lr.ph9
  
  ._crit_edge10.thread:                             ; preds = %call.sqrt, %._crit_edge14.thread, %._crit_edge14.split
    %101 = tail call double @sqrt(double 0.000000e+00) #5
    %102 = fcmp oeq double %101, %101
    br i1 %102, label %._crit_edge, label %call.sqrt27
  
  call.sqrt27:                                      ; preds = %._crit_edge10.thread
    %103 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge
  
  ._crit_edge10:                                    ; preds = %.lr.ph9
    %104 = tail call double @sqrt(double %100) #5
    %105 = fcmp oeq double %104, %104
    br i1 %105, label %._crit_edge10.split, label %call.sqrt28
  
  call.sqrt28:                                      ; preds = %._crit_edge10
    %106 = tail call double @sqrt(double %100) #6
    br label %._crit_edge10.split
  
  ._crit_edge10.split:                              ; preds = %._crit_edge10, %call.sqrt28
    %107 = phi double [ %104, %._crit_edge10 ], [ %106, %call.sqrt28 ]
    %108 = icmp sgt i32 %8, 0
    %109 = fdiv double %94, %107
    br i1 %108, label %.lr.ph.preheader, label %._crit_edge
  
  .lr.ph.preheader:                                 ; preds = %._crit_edge10.split
    %110 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %110, %.lr.ph.preheader ]
    %111 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %112 = fpext float %111 to double
    %113 = fdiv double %112, %109
    %114 = fptrunc double %113 to float
    store float %114, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %call.sqrt27, %._crit_edge10.thread, %._crit_edge10.split
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  ; Function Attrs: norecurse nounwind
  define i32 @predict(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph12.preheader, label %._crit_edge
  
  .lr.ph12.preheader:                               ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep10 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph12
  
  .lr.ph12:                                         ; preds = %.loopexit2, %.lr.ph12.preheader
    %lsr.iv11 = phi float* [ %45, %.loopexit2 ], [ %scevgep10, %.lr.ph12.preheader ]
    %lsr.iv4 = phi float* [ %44, %.loopexit2 ], [ %filt, %.lr.ph12.preheader ]
    %y_filt.011 = phi i32 [ %27, %.loopexit2 ], [ 0, %.lr.ph12.preheader ]
    %y_res.010 = phi i32 [ %43, %.loopexit2 ], [ %22, %.lr.ph12.preheader ]
    %taps_used.09 = phi float [ %taps_used.3, %.loopexit2 ], [ 0.000000e+00, %.lr.ph12.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.011, %x_dim
    %notlhs = icmp slt i32 %y_res.010, 0
    %notrhs = icmp sge i32 %y_res.010, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit2, label %.lr.ph8
  
  .lr.ph8:                                          ; preds = %.lr.ph12, %38
    %lsr.iv14 = phi float* [ %scevgep15, %38 ], [ %lsr.iv11, %.lr.ph12 ]
    %lsr.iv7 = phi float* [ %scevgep8, %38 ], [ %lsr.iv4, %.lr.ph12 ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %38 ], [ 0, %.lr.ph12 ]
    %taps_used.15 = phi float [ %taps_used.2, %38 ], [ %taps_used.09, %.lr.ph12 ]
    %28 = add i32 %10, %lsr.iv2
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv2
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %38
  
  ; <label>:32                                      ; preds = %.lr.ph8
    %33 = bitcast float* %lsr.iv7 to i32*
    %34 = bitcast float* %lsr.iv14 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    %36 = load float, float* %lsr.iv7, align 4, !tbaa !6
    %37 = fadd float %taps_used.15, %36
    br label %38
  
  ; <label>:38                                      ; preds = %32, %.lr.ph8
    %taps_used.2 = phi float [ %37, %32 ], [ %taps_used.15, %.lr.ph8 ]
    %lsr.iv.next3 = add i32 %lsr.iv2, 1
    %39 = add i32 %y_filt.011, %lsr.iv.next3
    %scevgep8 = getelementptr float, float* %lsr.iv7, i32 1
    %scevgep15 = getelementptr float, float* %lsr.iv14, i32 1
    %40 = icmp slt i32 %39, %27
    br i1 %40, label %.lr.ph8, label %.loopexit2
  
  .loopexit2:                                       ; preds = %38, %.lr.ph12
    %taps_used.3 = phi float [ %taps_used.09, %.lr.ph12 ], [ %taps_used.2, %38 ]
    %41 = bitcast float* %lsr.iv4 to i1*
    %42 = bitcast float* %lsr.iv11 to i1*
    %43 = add nsw i32 %y_res.010, %x_dim
    %scevgep6 = getelementptr i1, i1* %41, i32 %24
    %44 = bitcast i1* %scevgep6 to float*
    %scevgep13 = getelementptr i1, i1* %42, i32 %24
    %45 = bitcast i1* %scevgep13 to float*
    %46 = icmp slt i32 %27, %1
    br i1 %46, label %.lr.ph12, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit2, %18
    %taps_used.0.lcssa = phi float [ 0.000000e+00, %18 ], [ %taps_used.3, %.loopexit2 ]
    %47 = icmp eq i32 %f_or_e, 0
    br i1 %47, label %48, label %.loopexit
  
  ; <label>:48                                      ; preds = %._crit_edge
    %49 = icmp sgt i32 %1, 0
    %50 = fdiv float 2.000000e+00, %taps_used.0.lcssa
    br i1 %49, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %48
    %51 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %51, %.lr.ph.preheader ]
    %52 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %53 = fmul float %50, %52
    store float %53, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %.lr.ph, %48, %._crit_edge
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare i32 @puts(i8* nocapture) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #4
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { nounwind "target-cpu"="mips32" }
  attributes #4 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #5 = { nounwind readnone }
  attributes #6 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"", !3, i64 0, !3, i64 4}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !7, i64 0}
  !7 = !{!"float", !4, i64 0}

...
---
name:            reflect1
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: gpr32 }
  - { id: 75, class: gpr32 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: gpr32 }
  - { id: 78, class: gpr32 }
  - { id: 79, class: gpr32 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: gpr32 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: gpr32 }
  - { id: 84, class: gpr32 }
  - { id: 85, class: gpr32 }
  - { id: 86, class: gpr32 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: gpr32 }
  - { id: 89, class: gpr32 }
  - { id: 90, class: gpr32 }
  - { id: 91, class: gpr32 }
  - { id: 92, class: gpr32 }
  - { id: 93, class: gpr32 }
  - { id: 94, class: gpr32 }
  - { id: 95, class: gpr32 }
  - { id: 96, class: gpr32 }
  - { id: 97, class: gpr32 }
  - { id: 98, class: gpr32 }
  - { id: 99, class: gpr32 }
  - { id: 100, class: gpr32 }
  - { id: 101, class: gpr32 }
  - { id: 102, class: gpr32 }
  - { id: 103, class: gpr32 }
  - { id: 104, class: gpr32 }
  - { id: 105, class: gpr32 }
  - { id: 106, class: gpr32 }
  - { id: 107, class: gpr32 }
  - { id: 108, class: gpr32 }
  - { id: 109, class: gpr32 }
  - { id: 110, class: gpr32 }
  - { id: 111, class: gpr32 }
  - { id: 112, class: gpr32 }
  - { id: 113, class: gpr32 }
  - { id: 114, class: gpr32 }
  - { id: 115, class: gpr32 }
  - { id: 116, class: gpr32 }
  - { id: 117, class: gpr32 }
  - { id: 118, class: gpr32 }
  - { id: 119, class: gpr32 }
  - { id: 120, class: gpr32 }
  - { id: 121, class: gpr32 }
  - { id: 122, class: gpr32 }
  - { id: 123, class: gpr32 }
  - { id: 124, class: gpr32 }
  - { id: 125, class: gpr32 }
  - { id: 126, class: fgr32 }
  - { id: 127, class: fgr32 }
  - { id: 128, class: fgr32 }
  - { id: 129, class: gpr32 }
  - { id: 130, class: gpr32 }
  - { id: 131, class: gpr32 }
  - { id: 132, class: gpr32 }
  - { id: 133, class: gpr32 }
  - { id: 134, class: gpr32 }
  - { id: 135, class: gpr32 }
  - { id: 136, class: fgr32 }
  - { id: 137, class: fgr32 }
  - { id: 138, class: gpr32 }
  - { id: 139, class: gpr32 }
  - { id: 140, class: gpr32 }
  - { id: 141, class: gpr32 }
  - { id: 142, class: gpr32 }
  - { id: 143, class: fgr32 }
  - { id: 144, class: fgr32 }
  - { id: 145, class: gpr32 }
  - { id: 146, class: gpr32 }
  - { id: 147, class: gpr32 }
  - { id: 148, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%60' }
  - { reg: '%a1', virtual-reg: '%61' }
  - { reg: '%a2', virtual-reg: '%62' }
  - { reg: '%a3', virtual-reg: '%63' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 24, size: 4, alignment: 8, isImmutable: true, isAliased: false }
  - { id: 1, offset: 20, size: 4, alignment: 4, isImmutable: true, isAliased: false }
  - { id: 2, offset: 16, size: 4, alignment: 8, isImmutable: true, isAliased: false }
body:             |
  bb.0 (%ir-block.0, freq 51):
    successors: %bb.1(62), %bb.2(37)
    liveins: %a0, %a1, %a2, %a3, %t9, %v0
  
    %83 = ADDu %v0, %t9
    %63 = COPY %a3
    %62 = COPY %a2
    %61 = COPY %a1
    %60 = COPY %a0
    %64 = LW %fixed-stack.2, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    BLEZ %63, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.9, freq 32):
    successors: %bb.3(100)
  
    %3 = SUBu %63, %61
    B %bb.3, implicit-def dead %at
  
  bb.2 (%ir-block.11, freq 19):
    successors: %bb.3(100)
  
    %73 = ADDiu %63, 1
    %74 = SLTi %63, -1
    %4 = MOVZ_I_I %zero, killed %74, %73
  
  bb.3 (%ir-block.15, freq 51):
    successors: %bb.4(62), %bb.5(37)
  
    %5 = PHI %4, %bb.2, %3, %bb.1
    %0 = MUL %62, %61, implicit-def dead %hi0, implicit-def dead %lo0
    BLEZ %64, %bb.5, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.18, freq 32):
    successors: %bb.6(100)
  
    %6 = SUBu %64, %62
    B %bb.6, implicit-def dead %at
  
  bb.5 (%ir-block.20, freq 19):
    successors: %bb.6(100)
  
    %76 = ADDiu %64, 1
    %77 = SLTi %64, -1
    %7 = MOVZ_I_I %zero, killed %77, %76
  
  bb.6 (%ir-block.24, freq 51):
    successors: %bb.7..lr.ph22.preheader(62), %bb.8.._crit_edge23(37)
  
    %8 = PHI %7, %bb.5, %6, %bb.4
    %67 = ADDiu %62, -1
    %66 = LW %fixed-stack.0, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    %65 = LW %fixed-stack.1, 0, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from stack)
    %79 = SRL %62, 31
    %80 = ADDu %62, killed %79
    %12 = SRA killed %80, 1
    %81 = SRL %61, 31
    %82 = ADDu %61, killed %81
    %10 = SRA killed %82, 1
    BLEZ %0, %bb.8.._crit_edge23, implicit-def dead %at
    B %bb.7..lr.ph22.preheader, implicit-def dead %at
  
  bb.7..lr.ph22.preheader (freq 32):
    successors: %bb.8.._crit_edge23(100)
  
    %84 = SLL %0, 2
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %85 = LW %83, target-flags(<unknown>) $memset, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry $memset)
    %86 = ADDiu %zero, 0
    %a0 = COPY %65
    %a1 = COPY %86
    %a2 = COPY %84
    %gp = COPY %83
    %t9 = COPY %85
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.8.._crit_edge23 (freq 51):
    successors: %bb.9(50), %bb.15(50)
  
    %68 = MUL %67, %61, implicit-def dead %hi0, implicit-def dead %lo0
    %69 = ADDiu %61, -1
    %70 = SLTi %63, 1
    %72 = SLTi %64, 1
    %9 = MUL %8, %61, implicit-def dead %hi0, implicit-def dead %lo0
    %13 = ADDiu %12, 1
    %11 = ADDiu %10, 1
    %87 = ADDiu %zero, 0
    %88 = ADDiu %zero, 1
    BNE %66, killed %88, %bb.15, implicit-def dead %at
    B %bb.9, implicit-def dead %at
  
  bb.9 (%ir-block.35, freq 25):
    successors: %bb.10(50), %bb.11(50)
  
    BNE %11, %63, %bb.11, implicit-def dead %at
    B %bb.10, implicit-def dead %at
  
  bb.10 (%ir-block.37, freq 12):
    successors: %bb.12(100)
  
    %93 = ADDiu %61, 1
    %94 = SRL %93, 31
    %95 = ADDu %93, killed %94
    %14 = SRA killed %95, 1
    %92 = ADDiu %zero, 0
    B %bb.12, implicit-def dead %at
  
  bb.11 (%ir-block.40, freq 12):
    successors: %bb.12(100)
  
    %89 = NOR %10, %zero
    %90 = XOR %63, killed %89
    %16 = MOVN_I_I %zero, %90, %10
    %15 = MOVZ_I_I %zero, %90, %5
  
  bb.12 (%ir-block.43, freq 25):
    successors: %bb.13(50), %bb.14(50)
  
    %17 = PHI %61, %bb.11, %14, %bb.10
    %18 = PHI %15, %bb.11, %5, %bb.10
    %19 = PHI %16, %bb.11, %92, %bb.10
    BNE %13, %64, %bb.14, implicit-def dead %at
    B %bb.13, implicit-def dead %at
  
  bb.13 (%ir-block.45, freq 12):
    successors: %bb.15(100)
  
    %101 = ADDiu %62, 1
    %102 = SRL %101, 31
    %103 = ADDu %101, killed %102
    %104 = SRA killed %103, 1
    %20 = MUL killed %104, %61, implicit-def dead %hi0, implicit-def dead %lo0
    B %bb.15, implicit-def dead %at
  
  bb.14 (%ir-block.49, freq 12):
    successors: %bb.15(100)
  
    %96 = MUL %12, %61, implicit-def dead %hi0, implicit-def dead %lo0
    %97 = NOR %12, %zero
    %98 = XOR %64, killed %97
    %21 = MOVZ_I_I %zero, %98, %9
    %22 = MOVN_I_I %zero, %98, %96
  
  bb.15 (%ir-block.53, freq 51):
    successors: %bb.16..lr.ph18.preheader(50), %bb.21.._crit_edge19(50)
  
    %23 = PHI %0, %bb.8.._crit_edge23, %0, %bb.14, %20, %bb.13
    %24 = PHI %61, %bb.8.._crit_edge23, %17, %bb.14, %17, %bb.13
    %25 = PHI %5, %bb.8.._crit_edge23, %18, %bb.14, %18, %bb.13
    %26 = PHI %9, %bb.8.._crit_edge23, %21, %bb.14, %9, %bb.13
    %27 = PHI %87, %bb.8.._crit_edge23, %22, %bb.14, %87, %bb.13
    %28 = PHI %87, %bb.8.._crit_edge23, %19, %bb.14, %19, %bb.13
    %1 = MOVN_I_I %zero, %70, %69
    %2 = MOVN_I_I %zero, %72, %68
    %105 = SLT %27, %23
    BEQ killed %105, %zero, %bb.21.._crit_edge19, implicit-def dead %at
    B %bb.16..lr.ph18.preheader, implicit-def dead %at
  
  bb.16..lr.ph18.preheader (freq 25):
    successors: %bb.17..lr.ph18(100)
  
    %30 = SUBu %24, %28
    %106 = ADDu %27, %28
    %29 = SUBu %zero, %25
    %108 = SLL killed %106, 2
    %31 = ADDu %60, killed %108
    %32 = SLL %61, 2
  
  bb.17..lr.ph18 (freq 819):
    successors: %bb.18..lr.ph14(50), %bb.20.._crit_edge(50)
  
    %33 = PHI %31, %bb.16..lr.ph18.preheader, %47, %bb.20.._crit_edge
    %34 = PHI %26, %bb.16..lr.ph18.preheader, %46, %bb.20.._crit_edge
    %35 = PHI %27, %bb.16..lr.ph18.preheader, %45, %bb.20.._crit_edge
    %109 = ADDu %35, %24
    %110 = ADDu %35, %28
    %111 = SLT killed %110, killed %109
    BEQ killed %111, %zero, %bb.20.._crit_edge, implicit-def dead %at
    B %bb.18..lr.ph14, implicit-def dead %at
  
  bb.18..lr.ph14 (freq 409):
    successors: %bb.19(100)
  
    %112 = SRA %34, 31
    %113 = ADDu %34, %112
    %114 = XOR killed %113, %112
    %115 = SUBu %2, killed %114
    %116 = SRA %115, 31
    %117 = ADDu %115, %116
    %36 = XOR killed %117, %116
  
  bb.19 (%ir-block.69, freq 13107):
    successors: %bb.20.._crit_edge(3), %bb.19(96)
  
    %37 = PHI %33, %bb.18..lr.ph14, %44, %bb.19
    %38 = PHI %30, %bb.18..lr.ph14, %43, %bb.19
    %39 = PHI %29, %bb.18..lr.ph14, %42, %bb.19
    %40 = PHI %25, %bb.18..lr.ph14, %41, %bb.19
    %118 = SLTi %40, 0
    %119 = MOVZ_I_I %40, killed %118, %39
    %120 = SUBu %1, killed %119
    %121 = SRA %120, 31
    %122 = ADDu %120, %121
    %123 = XOR killed %122, %121
    %124 = ADDu killed %123, %36
    %125 = SLL killed %124, 2
    %44 = ADDiu %37, 4
    %43 = ADDiu %38, -1
    %42 = ADDiu %39, -1
    %41 = ADDiu %40, 1
    %126 = LWC1 %37, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv13, !tbaa !6)
    %127 = LWXC1 %65, %125, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.78, !tbaa !6)
    %128 = FADD_S killed %126, killed %127
    SWXC1 killed %128, %65, %125, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.78, !tbaa !6)
    BNE %43, %zero, %bb.19, implicit-def dead %at
    B %bb.20.._crit_edge, implicit-def dead %at
  
  bb.20.._crit_edge (freq 819):
    successors: %bb.17..lr.ph18(96), %bb.21.._crit_edge19(3)
  
    %47 = ADDu %33, %32
    %46 = ADDu %34, %61
    %45 = ADDu %35, %61
    %129 = SLT %45, %23
    BNE killed %129, %zero, %bb.17..lr.ph18, implicit-def dead %at
    B %bb.21.._crit_edge19, implicit-def dead %at
  
  bb.21.._crit_edge19 (freq 51):
    successors: %bb.22(50), %bb.29..loopexit(50)
  
    %130 = ADDiu %zero, 1
    BNE %66, killed %130, %bb.29..loopexit, implicit-def dead %at
    B %bb.22, implicit-def dead %at
  
  bb.22 (%ir-block.88, freq 25):
    successors: %bb.31(87), %bb.25..loopexit8(12)
  
    BEQ %63, %zero, %bb.25..loopexit8, implicit-def dead %at
    B %bb.31, implicit-def dead %at
  
  bb.31 (%ir-block.88, freq 22):
    successors: %bb.30(85), %bb.25..loopexit8(14)
  
    %132 = SRA %63, 31
    %133 = ADDu %63, %132
    %131 = XOR %133, %132
    BEQ %131, %11, %bb.25..loopexit8, implicit-def dead %at
    B %bb.30, implicit-def dead %at
  
  bb.30 (%ir-block.88, freq 19):
    successors: %bb.23..lr.ph11.preheader(66), %bb.25..loopexit8(33)
  
    %134 = SLT %1, %0
    BEQ killed %134, %zero, %bb.25..loopexit8, implicit-def dead %at
    B %bb.23..lr.ph11.preheader, implicit-def dead %at
  
  bb.23..lr.ph11.preheader (freq 12):
    successors: %bb.24..lr.ph11(100)
  
    %135 = SLL %1, 2
    %48 = ADDu %65, killed %135
    %49 = SLL %61, 2
  
  bb.24..lr.ph11 (freq 409):
    successors: %bb.24..lr.ph11(96), %bb.25..loopexit8(3)
  
    %50 = PHI %48, %bb.23..lr.ph11.preheader, %53, %bb.24..lr.ph11
    %51 = PHI %1, %bb.23..lr.ph11.preheader, %52, %bb.24..lr.ph11
    %136 = LWC1 %50, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv3, !tbaa !6)
    %53 = ADDu %50, %49
    %52 = ADDu %51, %61
    %137 = FADD_S %136, %136
    SWC1 killed %137, %50, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.lsr.iv3, !tbaa !6)
    %138 = SLT %52, %0
    BNE killed %138, %zero, %bb.24..lr.ph11, implicit-def dead %at
    B %bb.25..loopexit8, implicit-def dead %at
  
  bb.25..loopexit8 (freq 25):
    successors: %bb.32..loopexit8(75), %bb.29..loopexit(25)
  
    BEQ %64, %zero, %bb.29..loopexit, implicit-def dead %at
    B %bb.32..loopexit8, implicit-def dead %at
  
  bb.32..loopexit8 (freq 19):
    successors: %bb.26..preheader(66), %bb.29..loopexit(33)
  
    %140 = SRA %64, 31
    %141 = ADDu %64, %140
    %139 = XOR %141, %140
    BEQ %139, %13, %bb.29..loopexit, implicit-def dead %at
    B %bb.26..preheader, implicit-def dead %at
  
  bb.26..preheader (freq 12):
    successors: %bb.27..lr.ph.preheader(62), %bb.29..loopexit(37)
  
    BLEZ %61, %bb.29..loopexit, implicit-def dead %at
    B %bb.27..lr.ph.preheader, implicit-def dead %at
  
  bb.27..lr.ph.preheader (freq 7):
    successors: %bb.28..lr.ph(100)
  
    %54 = ADDu %2, %61
    %142 = SLL %2, 2
    %55 = ADDu %65, killed %142
  
  bb.28..lr.ph (freq 255):
    successors: %bb.28..lr.ph(96), %bb.29..loopexit(3)
  
    %56 = PHI %55, %bb.27..lr.ph.preheader, %59, %bb.28..lr.ph
    %57 = PHI %2, %bb.27..lr.ph.preheader, %58, %bb.28..lr.ph
    %143 = LWC1 %56, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv, !tbaa !6)
    %58 = ADDiu %57, 1
    %144 = FADD_S %143, %143
    SWC1 killed %144, %56, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.lsr.iv, !tbaa !6)
    %145 = SLT %58, %54
    %59 = ADDiu %56, 4
    BNE killed %145, %zero, %bb.28..lr.ph, implicit-def dead %at
    B %bb.29..loopexit, implicit-def dead %at
  
  bb.29..loopexit (freq 51):
    liveouts: %v0
  
    %146 = IMPLICIT_DEF
    %v0 = COPY %146
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/epic/epic.edges.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.EDGE_HANDLER = type { i8*, i32 (...)* }
  
  @edge_foos = internal unnamed_addr constant [9 x %struct.EDGE_HANDLER] [%struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect2 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @repeat to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @zero to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @extend to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @nocompute to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @predict to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @ereflect to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }], align 4
  @.str.1 = private unnamed_addr constant [9 x i8] c"reflect1\00", align 1
  @.str.2 = private unnamed_addr constant [9 x i8] c"reflect2\00", align 1
  @.str.3 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
  @.str.4 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
  @.str.5 = private unnamed_addr constant [7 x i8] c"extend\00", align 1
  @.str.6 = private unnamed_addr constant [13 x i8] c"dont-compute\00", align 1
  @.str.7 = private unnamed_addr constant [8 x i8] c"predict\00", align 1
  @.str.8 = private unnamed_addr constant [9 x i8] c"ereflect\00", align 1
  @.str.9 = private unnamed_addr constant [9 x i8] c"treflect\00", align 1
  @str = private unnamed_addr constant [30 x i8] c"No such edge handler routine!\00"
  
  ; Function Attrs: nounwind
  define i32 (...)* @edge_function(i8* nocapture readonly %edges) #0 {
    %1 = tail call i32 @strcmp(i8* %edges, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0))
    %2 = icmp eq i32 %1, 0
    br i1 %2, label %3, label %6
  
  ; <label>:3                                       ; preds = %28, %25, %22, %19, %16, %13, %10, %6, %0
    %i.02.lcssa = phi i32 [ 0, %0 ], [ 1, %6 ], [ 2, %10 ], [ 3, %13 ], [ 4, %16 ], [ 5, %19 ], [ 6, %22 ], [ 7, %25 ], [ 8, %28 ]
    %4 = getelementptr inbounds [9 x %struct.EDGE_HANDLER], [9 x %struct.EDGE_HANDLER]* @edge_foos, i32 0, i32 %i.02.lcssa, i32 1
    %5 = load i32 (...)*, i32 (...)** %4, align 4, !tbaa !1
    br label %9
  
  ; <label>:6                                       ; preds = %0
    %7 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
    %8 = icmp eq i32 %7, 0
    br i1 %8, label %3, label %10
  
  ; <label>:9                                       ; preds = %31, %3
    %.0 = phi i32 (...)* [ %5, %3 ], [ null, %31 ]
    ret i32 (...)* %.0
  
  ; <label>:10                                      ; preds = %6
    %11 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0))
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %3, label %13
  
  ; <label>:13                                      ; preds = %10
    %14 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
    %15 = icmp eq i32 %14, 0
    br i1 %15, label %3, label %16
  
  ; <label>:16                                      ; preds = %13
    %17 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0))
    %18 = icmp eq i32 %17, 0
    br i1 %18, label %3, label %19
  
  ; <label>:19                                      ; preds = %16
    %20 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0))
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %3, label %22
  
  ; <label>:22                                      ; preds = %19
    %23 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0))
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %3, label %25
  
  ; <label>:25                                      ; preds = %22
    %26 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
    %27 = icmp eq i32 %26, 0
    br i1 %27, label %3, label %28
  
  ; <label>:28                                      ; preds = %25
    %29 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0))
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %3, label %31
  
  ; <label>:31                                      ; preds = %28
    %puts = tail call i32 @puts(i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @str, i32 0, i32 0))
    br label %9
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #1
  
  ; Function Attrs: norecurse nounwind
  define i32 @zero(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph7.preheader, label %._crit_edge
  
  .lr.ph7.preheader:                                ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep6 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph7
  
  .lr.ph7:                                          ; preds = %.loopexit, %.lr.ph7.preheader
    %lsr.iv7 = phi float* [ %43, %.loopexit ], [ %scevgep6, %.lr.ph7.preheader ]
    %lsr.iv1 = phi float* [ %42, %.loopexit ], [ %filt, %.lr.ph7.preheader ]
    %y_filt.06 = phi i32 [ %27, %.loopexit ], [ 0, %.lr.ph7.preheader ]
    %y_res.05 = phi i32 [ %41, %.loopexit ], [ %22, %.lr.ph7.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.06, %x_dim
    %notlhs = icmp slt i32 %y_res.05, 0
    %notrhs = icmp sge i32 %y_res.05, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph7, %36
    %lsr.iv10 = phi float* [ %scevgep11, %36 ], [ %lsr.iv7, %.lr.ph7 ]
    %lsr.iv3 = phi float* [ %scevgep4, %36 ], [ %lsr.iv1, %.lr.ph7 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %36 ], [ 0, %.lr.ph7 ]
    %28 = add i32 %10, %lsr.iv
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %36
  
  ; <label>:32                                      ; preds = %.lr.ph
    %33 = bitcast float* %lsr.iv3 to i32*
    %34 = bitcast float* %lsr.iv10 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    br label %36
  
  ; <label>:36                                      ; preds = %32, %.lr.ph
    %lsr.iv.next = add i32 %lsr.iv, 1
    %37 = add i32 %y_filt.06, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %scevgep11 = getelementptr float, float* %lsr.iv10, i32 1
    %38 = icmp slt i32 %37, %27
    br i1 %38, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %36, %.lr.ph7
    %39 = bitcast float* %lsr.iv1 to i1*
    %40 = bitcast float* %lsr.iv7 to i1*
    %41 = add nsw i32 %y_res.05, %x_dim
    %scevgep = getelementptr i1, i1* %39, i32 %24
    %42 = bitcast i1* %scevgep to float*
    %scevgep9 = getelementptr i1, i1* %40, i32 %24
    %43 = bitcast i1* %scevgep9 to float*
    %44 = icmp slt i32 %27, %1
    br i1 %44, label %.lr.ph7, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @repeat(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.preheader.lr.ph, label %._crit_edge6
  
  .preheader.lr.ph:                                 ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = sub nsw i32 %1, %x_dim
    %25 = add nsw i32 %x_dim, -1
    %26 = shl i32 %x_dim, 2
    br label %.preheader
  
  .preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
    %lsr.iv1 = phi float* [ %48, %._crit_edge ], [ %filt, %.preheader.lr.ph ]
    %y_filt.05 = phi i32 [ 0, %.preheader.lr.ph ], [ %28, %._crit_edge ]
    %y_res.04 = phi i32 [ %22, %.preheader.lr.ph ], [ %47, %._crit_edge ]
    %27 = icmp sgt i32 %x_dim, 0
    %28 = add nsw i32 %y_filt.05, %x_dim
    br i1 %27, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader
    %29 = icmp sgt i32 %y_res.04, -1
    %30 = icmp slt i32 %y_res.04, %1
    %y_res.0. = select i1 %30, i32 %y_res.04, i32 %24
    %y_res.0.. = select i1 %29, i32 %y_res.0., i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %31, %.lr.ph
    %lsr.iv3 = phi float* [ %scevgep4, %31 ], [ %lsr.iv1, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %31 ], [ 0, %.lr.ph ]
    %32 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %33 = add i32 %10, %lsr.iv
    %34 = icmp sgt i32 %33, -1
    %35 = add i32 %10, %lsr.iv
    %36 = icmp slt i32 %35, %x_dim
    %37 = add i32 %10, %lsr.iv
    %38 = select i1 %36, i32 %37, i32 %25
    %39 = select i1 %34, i32 %38, i32 0
    %40 = add nsw i32 %39, %y_res.0..
    %41 = getelementptr inbounds float, float* %result, i32 %40
    %42 = load float, float* %41, align 4, !tbaa !6
    %43 = fadd float %32, %42
    store float %43, float* %41, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, 1
    %44 = add i32 %y_filt.05, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %45 = icmp slt i32 %44, %28
    br i1 %45, label %31, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %31, %.preheader
    %46 = bitcast float* %lsr.iv1 to i1*
    %47 = add nsw i32 %y_res.04, %x_dim
    %scevgep = getelementptr i1, i1* %46, i32 %26
    %48 = bitcast i1* %scevgep to float*
    %49 = icmp slt i32 %28, %1
    br i1 %49, label %.preheader, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect2(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = mul nsw i32 %5, %x_dim
    %7 = select i1 %4, i32 %6, i32 0
    %8 = mul i32 %y_dim, %x_dim
    %9 = xor i32 %x_dim, -1
    %.v = select i1 %1, i32 %9, i32 1
    %10 = add i32 %.v, %x_pos
    %11 = icmp sgt i32 %8, 0
    br i1 %11, label %.lr.ph5.preheader, label %._crit_edge6
  
  .lr.ph5.preheader:                                ; preds = %0
    %12 = icmp sgt i32 %y_pos, 0
    %13 = xor i32 %y_dim, -1
    %.v10 = select i1 %12, i32 %13, i32 1
    %14 = add i32 %.v10, %y_pos
    %15 = mul nsw i32 %14, %x_dim
    %result11 = bitcast float* %result to i8*
    %16 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %result11, i8 0, i32 %16, i32 4, i1 false)
    %17 = shl i32 %x_dim, 2
    br label %.lr.ph5
  
  .lr.ph5:                                          ; preds = %._crit_edge, %.lr.ph5.preheader
    %lsr.iv = phi float* [ %51, %._crit_edge ], [ %filt, %.lr.ph5.preheader ]
    %y_filt.04 = phi i32 [ %21, %._crit_edge ], [ 0, %.lr.ph5.preheader ]
    %y_edge.03 = phi i32 [ %50, %._crit_edge ], [ %15, %.lr.ph5.preheader ]
    %18 = icmp sgt i32 %x_dim, 0
    %19 = icmp eq i32 %y_edge.03, 0
    %20 = select i1 %19, i32 %x_dim, i32 0
    %.y_edge.0 = add nsw i32 %20, %y_edge.03
    %21 = add nsw i32 %y_filt.04, %x_dim
    br i1 %18, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.lr.ph5
    %22 = icmp sgt i32 %.y_edge.0, -1
    %23 = sub nsw i32 0, %.y_edge.0
    %24 = select i1 %22, i32 %.y_edge.0, i32 %23
    %25 = sub nsw i32 %7, %24
    %26 = add nsw i32 %25, %x_dim
    %27 = icmp sgt i32 %26, -1
    %28 = sub nsw i32 0, %26
    %29 = select i1 %27, i32 %26, i32 %28
    br label %30
  
  ; <label>:30                                      ; preds = %30, %.lr.ph
    %lsr.iv2 = phi float* [ %scevgep3, %30 ], [ %lsr.iv, %.lr.ph ]
    %x_filt.02 = phi i32 [ %y_filt.04, %.lr.ph ], [ %46, %30 ]
    %x_edge.01 = phi i32 [ %10, %.lr.ph ], [ %47, %30 ]
    %31 = icmp eq i32 %x_edge.01, 0
    %32 = zext i1 %31 to i32
    %.x_edge.0 = add nsw i32 %32, %x_edge.01
    %33 = load float, float* %lsr.iv2, align 4, !tbaa !6
    %34 = icmp sgt i32 %.x_edge.0, -1
    %35 = sub nsw i32 0, %.x_edge.0
    %36 = select i1 %34, i32 %.x_edge.0, i32 %35
    %37 = sub nsw i32 %3, %36
    %38 = add nsw i32 %37, 1
    %39 = icmp sgt i32 %37, -2
    %40 = xor i32 %37, -1
    %41 = select i1 %39, i32 %38, i32 %40
    %42 = add nsw i32 %41, %29
    %43 = getelementptr inbounds float, float* %result, i32 %42
    %44 = load float, float* %43, align 4, !tbaa !6
    %45 = fadd float %33, %44
    store float %45, float* %43, align 4, !tbaa !6
    %46 = add nsw i32 %x_filt.02, 1
    %47 = add nsw i32 %.x_edge.0, 1
    %scevgep3 = getelementptr float, float* %lsr.iv2, i32 1
    %48 = icmp slt i32 %46, %21
    br i1 %48, label %30, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %30, %.lr.ph5
    %49 = bitcast float* %lsr.iv to i1*
    %50 = add nsw i32 %.y_edge.0, %x_dim
    %scevgep = getelementptr i1, i1* %49, i32 %17
    %51 = bitcast i1* %scevgep to float*
    %52 = icmp slt i32 %21, %8
    br i1 %52, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %0
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect1(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph22.preheader, label %._crit_edge23
  
  .lr.ph22.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %.lr.ph22.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge23
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.4 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.4, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.5 = select i1 %51, i32 0, i32 %26
    %.6 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge23
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge23 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge23 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge23 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge23 ], [ %.5, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge23 ], [ %.6, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge23 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph18.preheader, label %._crit_edge19
  
  .lr.ph18.preheader:                               ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep9 = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %.lr.ph18
  
  .lr.ph18:                                         ; preds = %._crit_edge, %.lr.ph18.preheader
    %lsr.iv10 = phi float* [ %85, %._crit_edge ], [ %scevgep9, %.lr.ph18.preheader ]
    %y_edge.016 = phi i32 [ %y_edge_dist.0, %.lr.ph18.preheader ], [ %84, %._crit_edge ]
    %y_filt.015 = phi i32 [ %y_start.0, %.lr.ph18.preheader ], [ %83, %._crit_edge ]
    %59 = add nsw i32 %y_filt.015, %x_start.1
    %60 = add nsw i32 %y_filt.015, %x_stop.1
    %61 = icmp slt i32 %59, %60
    br i1 %61, label %.lr.ph14, label %._crit_edge
  
  .lr.ph14:                                         ; preds = %.lr.ph18
    %62 = icmp sgt i32 %y_edge.016, -1
    %63 = sub nsw i32 0, %y_edge.016
    %64 = select i1 %62, i32 %y_edge.016, i32 %63
    %65 = sub nsw i32 %8, %64
    %66 = icmp sgt i32 %65, -1
    %67 = sub nsw i32 0, %65
    %68 = select i1 %66, i32 %65, i32 %67
    br label %69
  
  ; <label>:69                                      ; preds = %69, %.lr.ph14
    %lsr.iv13 = phi float* [ %scevgep14, %69 ], [ %lsr.iv10, %.lr.ph14 ]
    %lsr.iv7 = phi i32 [ %lsr.iv.next8, %69 ], [ %56, %.lr.ph14 ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next, %69 ], [ %55, %.lr.ph14 ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph14 ], [ %81, %69 ]
    %70 = load float, float* %lsr.iv13, align 4, !tbaa !6
    %71 = icmp sgt i32 %x_edge.013, -1
    %72 = select i1 %71, i32 %x_edge.013, i32 %lsr.iv6
    %73 = sub nsw i32 %4, %72
    %74 = icmp sgt i32 %73, -1
    %75 = sub nsw i32 0, %73
    %76 = select i1 %74, i32 %73, i32 %75
    %77 = add nsw i32 %76, %68
    %78 = getelementptr inbounds float, float* %result, i32 %77
    %79 = load float, float* %78, align 4, !tbaa !6
    %80 = fadd float %70, %79
    store float %80, float* %78, align 4, !tbaa !6
    %81 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv6, -1
    %lsr.iv.next8 = add i32 %lsr.iv7, -1
    %scevgep14 = getelementptr float, float* %lsr.iv13, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next8, 0
    br i1 %exitcond, label %._crit_edge, label %69
  
  ._crit_edge:                                      ; preds = %69, %.lr.ph18
    %82 = bitcast float* %lsr.iv10 to i1*
    %83 = add nsw i32 %y_filt.015, %x_dim
    %84 = add nsw i32 %y_edge.016, %x_dim
    %scevgep12 = getelementptr i1, i1* %82, i32 %58
    %85 = bitcast i1* %scevgep12 to float*
    %86 = icmp slt i32 %83, %y_stop.0
    br i1 %86, label %.lr.ph18, label %._crit_edge19
  
  ._crit_edge19:                                    ; preds = %._crit_edge, %53
    %87 = icmp eq i32 %f_or_e, 1
    br i1 %87, label %88, label %.loopexit
  
  ; <label>:88                                      ; preds = %._crit_edge19
    %89 = icmp sgt i32 %x_pos, -1
    %90 = sub nsw i32 0, %x_pos
    %91 = select i1 %89, i32 %x_pos, i32 %90
    %92 = icmp ne i32 %91, %28
    %93 = icmp ne i32 %x_pos, 0
    %or.cond = and i1 %93, %92
    %94 = icmp slt i32 %4, %1
    %or.cond24 = and i1 %or.cond, %94
    br i1 %or.cond24, label %.lr.ph11.preheader, label %.loopexit8
  
  .lr.ph11.preheader:                               ; preds = %88
    %scevgep2 = getelementptr float, float* %result, i32 %4
    %95 = shl i32 %x_dim, 2
    br label %.lr.ph11
  
  .lr.ph11:                                         ; preds = %.lr.ph11, %.lr.ph11.preheader
    %lsr.iv3 = phi float* [ %99, %.lr.ph11 ], [ %scevgep2, %.lr.ph11.preheader ]
    %y_filt.110 = phi i32 [ %98, %.lr.ph11 ], [ %4, %.lr.ph11.preheader ]
    %lsr.iv34 = bitcast float* %lsr.iv3 to i1*
    %96 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %97 = fadd float %96, %96
    store float %97, float* %lsr.iv3, align 4, !tbaa !6
    %98 = add nsw i32 %y_filt.110, %x_dim
    %scevgep5 = getelementptr i1, i1* %lsr.iv34, i32 %95
    %99 = bitcast i1* %scevgep5 to float*
    %100 = icmp slt i32 %98, %1
    br i1 %100, label %.lr.ph11, label %.loopexit8
  
  .loopexit8:                                       ; preds = %.lr.ph11, %88
    %101 = icmp sgt i32 %y_pos, -1
    %102 = sub nsw i32 0, %y_pos
    %103 = select i1 %101, i32 %y_pos, i32 %102
    %104 = icmp ne i32 %103, %30
    %105 = icmp ne i32 %y_pos, 0
    %or.cond3 = and i1 %105, %104
    br i1 %or.cond3, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %.loopexit8
    %106 = add nsw i32 %8, %x_dim
    %107 = icmp sgt i32 %x_dim, 0
    br i1 %107, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %scevgep = getelementptr float, float* %result, i32 %8
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv = phi float* [ %scevgep1, %.lr.ph ], [ %scevgep, %.lr.ph.preheader ]
    %x_filt.19 = phi i32 [ %110, %.lr.ph ], [ %8, %.lr.ph.preheader ]
    %108 = load float, float* %lsr.iv, align 4, !tbaa !6
    %109 = fadd float %108, %108
    store float %109, float* %lsr.iv, align 4, !tbaa !6
    %110 = add nsw i32 %x_filt.19, 1
    %scevgep1 = getelementptr float, float* %lsr.iv, i32 1
    %111 = icmp slt i32 %110, %106
    br i1 %111, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %.preheader, %.loopexit8, %._crit_edge19
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @extend(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph21.preheader, label %._crit_edge22
  
  .lr.ph21.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge22
  
  ._crit_edge22:                                    ; preds = %.lr.ph21.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge22
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.3 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.3, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.4 = select i1 %51, i32 0, i32 %26
    %.5 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge22
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge22 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge22 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge22 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge22 ], [ %.4, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge22 ], [ %.5, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge22 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph17, label %._crit_edge18
  
  .lr.ph17:                                         ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %59
  
  ; <label>:59                                      ; preds = %._crit_edge, %.lr.ph17
    %lsr.iv3 = phi float* [ %117, %._crit_edge ], [ %scevgep, %.lr.ph17 ]
    %y_edge.015 = phi i32 [ %y_edge_dist.0, %.lr.ph17 ], [ %116, %._crit_edge ]
    %y_filt.014 = phi i32 [ %y_start.0, %.lr.ph17 ], [ %115, %._crit_edge ]
    %60 = add nsw i32 %y_filt.014, %x_start.1
    %61 = add nsw i32 %y_filt.014, %x_stop.1
    %62 = icmp slt i32 %60, %61
    br i1 %62, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %59
    %63 = icmp ne i32 %8, 0
    %64 = icmp sgt i32 %y_edge.015, 0
    %65 = icmp slt i32 %y_edge.015, 0
    %not. = xor i1 %64, true
    %66 = and i1 %65, %not.
    %67 = select i1 %63, i1 %64, i1 %66
    %68 = icmp sgt i32 %y_edge.015, -1
    %69 = sub nsw i32 0, %y_edge.015
    %70 = select i1 %68, i32 %y_edge.015, i32 %69
    %71 = sub nsw i32 %8, %70
    %72 = icmp sgt i32 %71, -1
    %73 = sub nsw i32 0, %71
    %74 = select i1 %72, i32 %71, i32 %73
    %75 = add nsw i32 %y_edge.015, %8
    %76 = icmp slt i32 %75, 0
    %77 = icmp slt i32 %75, %y_dim
    %.10 = select i1 %77, i32 %75, i32 %6
    %78 = select i1 %76, i32 0, i32 %.10
    br label %79
  
  ; <label>:79                                      ; preds = %112, %.lr.ph
    %lsr.iv6 = phi float* [ %scevgep7, %112 ], [ %lsr.iv3, %.lr.ph ]
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %112 ], [ %56, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %112 ], [ %55, %.lr.ph ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph ], [ %113, %112 ]
    %80 = icmp ne i32 %4, 0
    %81 = icmp sgt i32 %x_edge.013, 0
    %82 = icmp slt i32 %x_edge.013, 0
    %not.11 = xor i1 %81, true
    %83 = and i1 %82, %not.11
    %84 = select i1 %80, i1 %81, i1 %83
    %85 = xor i1 %67, %84
    %86 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %87 = icmp sgt i32 %x_edge.013, -1
    %88 = select i1 %87, i32 %x_edge.013, i32 %lsr.iv
    %89 = sub nsw i32 %4, %88
    %90 = icmp sgt i32 %89, -1
    %91 = sub nsw i32 0, %89
    %92 = select i1 %90, i32 %89, i32 %91
    %93 = add nsw i32 %92, %74
    %94 = getelementptr inbounds float, float* %result, i32 %93
    %95 = load float, float* %94, align 4, !tbaa !6
    br i1 %85, label %96, label %110
  
  ; <label>:96                                      ; preds = %79
    %97 = fsub float %95, %86
    store float %97, float* %94, align 4, !tbaa !6
    %98 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %99 = fadd float %98, %98
    %100 = add i32 %4, %x_edge.013
    %101 = icmp slt i32 %100, 0
    %102 = add i32 %4, %x_edge.013
    %103 = icmp slt i32 %102, %x_dim
    %104 = add i32 %4, %x_edge.013
    %.9 = select i1 %103, i32 %104, i32 %3
    %105 = select i1 %101, i32 0, i32 %.9
    %106 = add nsw i32 %105, %78
    %107 = getelementptr inbounds float, float* %result, i32 %106
    %108 = load float, float* %107, align 4, !tbaa !6
    %109 = fadd float %108, %99
    store float %109, float* %107, align 4, !tbaa !6
    br label %112
  
  ; <label>:110                                     ; preds = %79
    %111 = fadd float %86, %95
    store float %111, float* %94, align 4, !tbaa !6
    br label %112
  
  ; <label>:112                                     ; preds = %110, %96
    %113 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv, -1
    %lsr.iv.next2 = add i32 %lsr.iv1, -1
    %scevgep7 = getelementptr float, float* %lsr.iv6, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next2, 0
    br i1 %exitcond, label %._crit_edge, label %79
  
  ._crit_edge:                                      ; preds = %112, %59
    %114 = bitcast float* %lsr.iv3 to i1*
    %115 = add nsw i32 %y_filt.014, %x_dim
    %116 = add nsw i32 %y_edge.015, %x_dim
    %scevgep5 = getelementptr i1, i1* %114, i32 %58
    %117 = bitcast i1* %scevgep5 to float*
    %118 = icmp slt i32 %115, %y_stop.0
    br i1 %118, label %59, label %._crit_edge18
  
  ._crit_edge18:                                    ; preds = %._crit_edge, %53
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @nocompute(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %x_pos.off = add i32 %x_pos, 1
    %2 = icmp ugt i32 %x_pos.off, 2
    %y_pos.off = add i32 %y_pos, 1
    %3 = icmp ugt i32 %y_pos.off, 2
    %4 = or i1 %2, %3
    br i1 %4, label %.preheader, label %.preheader6
  
  .preheader6:                                      ; preds = %0
    %5 = icmp sgt i32 %1, 0
    br i1 %5, label %.lr.ph10.preheader, label %.loopexit
  
  .lr.ph10.preheader:                               ; preds = %.preheader6
    %6 = mul i32 %y_dim, %x_dim
    br label %.lr.ph10
  
  .preheader:                                       ; preds = %0
    %7 = icmp sgt i32 %1, 0
    br i1 %7, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %8 = bitcast float* %result to i8*
    %9 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %8, i8 0, i32 %9, i32 4, i1 false)
    br label %.loopexit
  
  .lr.ph10:                                         ; preds = %.lr.ph10, %.lr.ph10.preheader
    %lsr.iv3 = phi float* [ %scevgep4, %.lr.ph10 ], [ %filt, %.lr.ph10.preheader ]
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph10 ], [ %result, %.lr.ph10.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph10 ], [ %6, %.lr.ph10.preheader ]
    %lsr.iv35 = bitcast float* %lsr.iv3 to i32*
    %lsr.iv12 = bitcast float* %lsr.iv1 to i32*
    %10 = load i32, i32* %lsr.iv35, align 4, !tbaa !6
    store i32 %10, i32* %lsr.iv12, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %exitcond12 = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond12, label %.loopexit, label %.lr.ph10
  
  .loopexit:                                        ; preds = %.lr.ph10, %.lr.ph.preheader, %.preheader, %.preheader6
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  define i32 @ereflect(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #0 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = select i1 %4, i32 %5, i32 0
    %7 = mul nsw i32 %6, %x_dim
    %8 = mul i32 %y_dim, %x_dim
    %9 = icmp sgt i32 %x_pos, 1
    br i1 %9, label %10, label %12
  
  ; <label>:10                                      ; preds = %0
    %11 = sub nsw i32 %x_pos, %x_dim
    br label %16
  
  ; <label>:12                                      ; preds = %0
    %13 = icmp slt i32 %x_pos, -1
    %14 = add nsw i32 %x_pos, 1
    %15 = select i1 %13, i32 %14, i32 0
    br label %16
  
  ; <label>:16                                      ; preds = %12, %10
    %17 = phi i32 [ %11, %10 ], [ %15, %12 ]
    %18 = icmp sgt i32 %y_pos, 1
    br i1 %18, label %19, label %21
  
  ; <label>:19                                      ; preds = %16
    %20 = sub nsw i32 %y_pos, %y_dim
    br label %25
  
  ; <label>:21                                      ; preds = %16
    %22 = icmp slt i32 %y_pos, -1
    %23 = add nsw i32 %y_pos, 1
    %24 = select i1 %22, i32 %23, i32 0
    br label %25
  
  ; <label>:25                                      ; preds = %21, %19
    %26 = phi i32 [ %20, %19 ], [ %24, %21 ]
    %27 = icmp sgt i32 %8, 0
    br i1 %27, label %.preheader3.preheader, label %._crit_edge27
  
  .preheader3.preheader:                            ; preds = %25
    %28 = bitcast float* %result to i8*
    %29 = mul nsw i32 %26, %x_dim
    %30 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %28, i8 0, i32 %30, i32 4, i1 false)
    %31 = shl i32 %x_dim, 2
    %32 = sub i32 0, %17
    br label %.preheader3
  
  .preheader3:                                      ; preds = %._crit_edge23, %.preheader3.preheader
    %lsr.iv19 = phi float* [ %60, %._crit_edge23 ], [ %filt, %.preheader3.preheader ]
    %y_filt.026 = phi i32 [ %34, %._crit_edge23 ], [ 0, %.preheader3.preheader ]
    %y_edge.025 = phi i32 [ %59, %._crit_edge23 ], [ %29, %.preheader3.preheader ]
    %33 = icmp sgt i32 %x_dim, 0
    %34 = add nsw i32 %y_filt.026, %x_dim
    br i1 %33, label %.lr.ph22, label %._crit_edge23
  
  .lr.ph22:                                         ; preds = %.preheader3
    %35 = icmp sgt i32 %y_edge.025, -1
    %36 = sub nsw i32 0, %y_edge.025
    %37 = select i1 %35, i32 %y_edge.025, i32 %36
    %38 = sub nsw i32 %7, %37
    %39 = icmp sgt i32 %38, -1
    %40 = sub nsw i32 0, %38
    %41 = select i1 %39, i32 %38, i32 %40
    br label %42
  
  ; <label>:42                                      ; preds = %42, %.lr.ph22
    %lsr.iv24 = phi i32 [ %lsr.iv.next25, %42 ], [ %32, %.lr.ph22 ]
    %lsr.iv22 = phi float* [ %scevgep23, %42 ], [ %lsr.iv19, %.lr.ph22 ]
    %lsr.iv17 = phi i32 [ %lsr.iv.next18, %42 ], [ 0, %.lr.ph22 ]
    %43 = load float, float* %lsr.iv22, align 4, !tbaa !6
    %44 = add i32 %17, %lsr.iv17
    %45 = icmp sgt i32 %44, -1
    %46 = add i32 %17, %lsr.iv17
    %47 = select i1 %45, i32 %46, i32 %lsr.iv24
    %48 = sub nsw i32 %3, %47
    %49 = icmp sgt i32 %48, -1
    %50 = sub nsw i32 0, %48
    %51 = select i1 %49, i32 %48, i32 %50
    %52 = add nsw i32 %51, %41
    %53 = getelementptr inbounds float, float* %result, i32 %52
    %54 = load float, float* %53, align 4, !tbaa !6
    %55 = fadd float %43, %54
    store float %55, float* %53, align 4, !tbaa !6
    %lsr.iv.next18 = add i32 %lsr.iv17, 1
    %56 = add i32 %y_filt.026, %lsr.iv.next18
    %scevgep23 = getelementptr float, float* %lsr.iv22, i32 1
    %lsr.iv.next25 = add i32 %lsr.iv24, -1
    %57 = icmp slt i32 %56, %34
    br i1 %57, label %42, label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %42, %.preheader3
    %58 = bitcast float* %lsr.iv19 to i1*
    %59 = add nsw i32 %y_edge.025, %x_dim
    %scevgep21 = getelementptr i1, i1* %58, i32 %31
    %60 = bitcast i1* %scevgep21 to float*
    %61 = icmp slt i32 %34, %8
    br i1 %61, label %.preheader3, label %._crit_edge27
  
  ._crit_edge27:                                    ; preds = %._crit_edge23, %25
    %62 = icmp ne i32 %x_pos, 0
    %63 = icmp slt i32 %3, %8
    %or.cond = and i1 %62, %63
    br i1 %or.cond, label %.lr.ph19.preheader, label %.loopexit
  
  .lr.ph19.preheader:                               ; preds = %._crit_edge27
    %scevgep13 = getelementptr float, float* %result, i32 %3
    %64 = shl i32 %x_dim, 2
    br label %.lr.ph19
  
  .lr.ph19:                                         ; preds = %.lr.ph19, %.lr.ph19.preheader
    %lsr.iv14 = phi float* [ %70, %.lr.ph19 ], [ %scevgep13, %.lr.ph19.preheader ]
    %y_filt.118 = phi i32 [ %69, %.lr.ph19 ], [ %3, %.lr.ph19.preheader ]
    %lsr.iv1415 = bitcast float* %lsr.iv14 to i1*
    %65 = load float, float* %lsr.iv14, align 4, !tbaa !6
    %66 = fpext float %65 to double
    %67 = fmul double %66, 0x3FF6A09E667F3BCD
    %68 = fptrunc double %67 to float
    store float %68, float* %lsr.iv14, align 4, !tbaa !6
    %69 = add nsw i32 %y_filt.118, %x_dim
    %scevgep16 = getelementptr i1, i1* %lsr.iv1415, i32 %64
    %70 = bitcast i1* %scevgep16 to float*
    %71 = icmp slt i32 %69, %8
    br i1 %71, label %.lr.ph19, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph19, %._crit_edge27
    %72 = icmp eq i32 %y_pos, 0
    br i1 %72, label %.preheader, label %.preheader1
  
  .preheader1:                                      ; preds = %.loopexit
    %73 = add nsw i32 %7, %x_dim
    %74 = icmp sgt i32 %x_dim, 0
    br i1 %74, label %.lr.ph17.preheader, label %.preheader
  
  .lr.ph17.preheader:                               ; preds = %.preheader1
    %75 = mul i32 %6, %x_dim
    %scevgep10 = getelementptr float, float* %result, i32 %75
    br label %.lr.ph17
  
  .preheader:                                       ; preds = %.lr.ph17, %.preheader1, %.loopexit
    %76 = icmp sgt i32 %8, 0
    br i1 %76, label %.lr.ph13.preheader, label %._crit_edge14.thread
  
  .lr.ph13.preheader:                               ; preds = %.preheader
    %77 = mul i32 %y_dim, %x_dim
    br label %.lr.ph13
  
  ._crit_edge14.thread:                             ; preds = %.preheader
    %78 = tail call double @sqrt(double 0.000000e+00) #5
    %79 = fcmp oeq double %78, %78
    br i1 %79, label %._crit_edge10.thread, label %call.sqrt
  
  call.sqrt:                                        ; preds = %._crit_edge14.thread
    %80 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge10.thread
  
  .lr.ph17:                                         ; preds = %.lr.ph17, %.lr.ph17.preheader
    %lsr.iv11 = phi float* [ %scevgep12, %.lr.ph17 ], [ %scevgep10, %.lr.ph17.preheader ]
    %x_filt.116 = phi i32 [ %85, %.lr.ph17 ], [ %7, %.lr.ph17.preheader ]
    %81 = load float, float* %lsr.iv11, align 4, !tbaa !6
    %82 = fpext float %81 to double
    %83 = fmul double %82, 0x3FF6A09E667F3BCD
    %84 = fptrunc double %83 to float
    store float %84, float* %lsr.iv11, align 4, !tbaa !6
    %85 = add nsw i32 %x_filt.116, 1
    %scevgep12 = getelementptr float, float* %lsr.iv11, i32 1
    %86 = icmp slt i32 %85, %73
    br i1 %86, label %.lr.ph17, label %.preheader
  
  .lr.ph13:                                         ; preds = %.lr.ph13, %.lr.ph13.preheader
    %lsr.iv8 = phi float* [ %scevgep9, %.lr.ph13 ], [ %result, %.lr.ph13.preheader ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next7, %.lr.ph13 ], [ %77, %.lr.ph13.preheader ]
    %norm.012 = phi double [ %90, %.lr.ph13 ], [ 0.000000e+00, %.lr.ph13.preheader ]
    %87 = load float, float* %lsr.iv8, align 4, !tbaa !6
    %88 = fmul float %87, %87
    %89 = fpext float %88 to double
    %90 = fadd double %norm.012, %89
    %lsr.iv.next7 = add i32 %lsr.iv6, -1
    %scevgep9 = getelementptr float, float* %lsr.iv8, i32 1
    %exitcond33 = icmp eq i32 %lsr.iv.next7, 0
    br i1 %exitcond33, label %._crit_edge14, label %.lr.ph13
  
  ._crit_edge14:                                    ; preds = %.lr.ph13
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %._crit_edge14.split, label %call.sqrt26
  
  call.sqrt26:                                      ; preds = %._crit_edge14
    %93 = tail call double @sqrt(double %90) #6
    br label %._crit_edge14.split
  
  ._crit_edge14.split:                              ; preds = %._crit_edge14, %call.sqrt26
    %94 = phi double [ %91, %._crit_edge14 ], [ %93, %call.sqrt26 ]
    %95 = icmp sgt i32 %8, 0
    br i1 %95, label %.lr.ph9.preheader, label %._crit_edge10.thread
  
  .lr.ph9.preheader:                                ; preds = %._crit_edge14.split
    %96 = mul i32 %y_dim, %x_dim
    br label %.lr.ph9
  
  .lr.ph9:                                          ; preds = %.lr.ph9, %.lr.ph9.preheader
    %lsr.iv4 = phi float* [ %scevgep5, %.lr.ph9 ], [ %filt, %.lr.ph9.preheader ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %.lr.ph9 ], [ %96, %.lr.ph9.preheader ]
    %onorm.07 = phi double [ %100, %.lr.ph9 ], [ 0.000000e+00, %.lr.ph9.preheader ]
    %97 = load float, float* %lsr.iv4, align 4, !tbaa !6
    %98 = fmul float %97, %97
    %99 = fpext float %98 to double
    %100 = fadd double %onorm.07, %99
    %lsr.iv.next3 = add i32 %lsr.iv2, -1
    %scevgep5 = getelementptr float, float* %lsr.iv4, i32 1
    %exitcond32 = icmp eq i32 %lsr.iv.next3, 0
    br i1 %exitcond32, label %._crit_edge10, label %.lr.ph9
  
  ._crit_edge10.thread:                             ; preds = %call.sqrt, %._crit_edge14.thread, %._crit_edge14.split
    %101 = tail call double @sqrt(double 0.000000e+00) #5
    %102 = fcmp oeq double %101, %101
    br i1 %102, label %._crit_edge, label %call.sqrt27
  
  call.sqrt27:                                      ; preds = %._crit_edge10.thread
    %103 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge
  
  ._crit_edge10:                                    ; preds = %.lr.ph9
    %104 = tail call double @sqrt(double %100) #5
    %105 = fcmp oeq double %104, %104
    br i1 %105, label %._crit_edge10.split, label %call.sqrt28
  
  call.sqrt28:                                      ; preds = %._crit_edge10
    %106 = tail call double @sqrt(double %100) #6
    br label %._crit_edge10.split
  
  ._crit_edge10.split:                              ; preds = %._crit_edge10, %call.sqrt28
    %107 = phi double [ %104, %._crit_edge10 ], [ %106, %call.sqrt28 ]
    %108 = icmp sgt i32 %8, 0
    %109 = fdiv double %94, %107
    br i1 %108, label %.lr.ph.preheader, label %._crit_edge
  
  .lr.ph.preheader:                                 ; preds = %._crit_edge10.split
    %110 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %110, %.lr.ph.preheader ]
    %111 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %112 = fpext float %111 to double
    %113 = fdiv double %112, %109
    %114 = fptrunc double %113 to float
    store float %114, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %call.sqrt27, %._crit_edge10.thread, %._crit_edge10.split
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  ; Function Attrs: norecurse nounwind
  define i32 @predict(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph12.preheader, label %._crit_edge
  
  .lr.ph12.preheader:                               ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep10 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph12
  
  .lr.ph12:                                         ; preds = %.loopexit2, %.lr.ph12.preheader
    %lsr.iv11 = phi float* [ %45, %.loopexit2 ], [ %scevgep10, %.lr.ph12.preheader ]
    %lsr.iv4 = phi float* [ %44, %.loopexit2 ], [ %filt, %.lr.ph12.preheader ]
    %y_filt.011 = phi i32 [ %27, %.loopexit2 ], [ 0, %.lr.ph12.preheader ]
    %y_res.010 = phi i32 [ %43, %.loopexit2 ], [ %22, %.lr.ph12.preheader ]
    %taps_used.09 = phi float [ %taps_used.3, %.loopexit2 ], [ 0.000000e+00, %.lr.ph12.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.011, %x_dim
    %notlhs = icmp slt i32 %y_res.010, 0
    %notrhs = icmp sge i32 %y_res.010, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit2, label %.lr.ph8
  
  .lr.ph8:                                          ; preds = %.lr.ph12, %38
    %lsr.iv14 = phi float* [ %scevgep15, %38 ], [ %lsr.iv11, %.lr.ph12 ]
    %lsr.iv7 = phi float* [ %scevgep8, %38 ], [ %lsr.iv4, %.lr.ph12 ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %38 ], [ 0, %.lr.ph12 ]
    %taps_used.15 = phi float [ %taps_used.2, %38 ], [ %taps_used.09, %.lr.ph12 ]
    %28 = add i32 %10, %lsr.iv2
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv2
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %38
  
  ; <label>:32                                      ; preds = %.lr.ph8
    %33 = bitcast float* %lsr.iv7 to i32*
    %34 = bitcast float* %lsr.iv14 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    %36 = load float, float* %lsr.iv7, align 4, !tbaa !6
    %37 = fadd float %taps_used.15, %36
    br label %38
  
  ; <label>:38                                      ; preds = %32, %.lr.ph8
    %taps_used.2 = phi float [ %37, %32 ], [ %taps_used.15, %.lr.ph8 ]
    %lsr.iv.next3 = add i32 %lsr.iv2, 1
    %39 = add i32 %y_filt.011, %lsr.iv.next3
    %scevgep8 = getelementptr float, float* %lsr.iv7, i32 1
    %scevgep15 = getelementptr float, float* %lsr.iv14, i32 1
    %40 = icmp slt i32 %39, %27
    br i1 %40, label %.lr.ph8, label %.loopexit2
  
  .loopexit2:                                       ; preds = %38, %.lr.ph12
    %taps_used.3 = phi float [ %taps_used.09, %.lr.ph12 ], [ %taps_used.2, %38 ]
    %41 = bitcast float* %lsr.iv4 to i1*
    %42 = bitcast float* %lsr.iv11 to i1*
    %43 = add nsw i32 %y_res.010, %x_dim
    %scevgep6 = getelementptr i1, i1* %41, i32 %24
    %44 = bitcast i1* %scevgep6 to float*
    %scevgep13 = getelementptr i1, i1* %42, i32 %24
    %45 = bitcast i1* %scevgep13 to float*
    %46 = icmp slt i32 %27, %1
    br i1 %46, label %.lr.ph12, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit2, %18
    %taps_used.0.lcssa = phi float [ 0.000000e+00, %18 ], [ %taps_used.3, %.loopexit2 ]
    %47 = icmp eq i32 %f_or_e, 0
    br i1 %47, label %48, label %.loopexit
  
  ; <label>:48                                      ; preds = %._crit_edge
    %49 = icmp sgt i32 %1, 0
    %50 = fdiv float 2.000000e+00, %taps_used.0.lcssa
    br i1 %49, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %48
    %51 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %51, %.lr.ph.preheader ]
    %52 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %53 = fmul float %50, %52
    store float %53, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %.lr.ph, %48, %._crit_edge
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare i32 @puts(i8* nocapture) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #4
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { nounwind "target-cpu"="mips32" }
  attributes #4 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #5 = { nounwind readnone }
  attributes #6 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"", !3, i64 0, !3, i64 4}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !7, i64 0}
  !7 = !{!"float", !4, i64 0}

...
---
name:            extend
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: fgr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: fgr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: gpr32 }
  - { id: 75, class: gpr32 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: gpr32 }
  - { id: 78, class: gpr32 }
  - { id: 79, class: gpr32 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: gpr32 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: gpr32 }
  - { id: 84, class: gpr32 }
  - { id: 85, class: gpr32 }
  - { id: 86, class: gpr32 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: gpr32 }
  - { id: 89, class: gpr32 }
  - { id: 90, class: gpr32 }
  - { id: 91, class: gpr32 }
  - { id: 92, class: gpr32 }
  - { id: 93, class: gpr32 }
  - { id: 94, class: gpr32 }
  - { id: 95, class: gpr32 }
  - { id: 96, class: gpr32 }
  - { id: 97, class: gpr32 }
  - { id: 98, class: gpr32 }
  - { id: 99, class: gpr32 }
  - { id: 100, class: gpr32 }
  - { id: 101, class: gpr32 }
  - { id: 102, class: gpr32 }
  - { id: 103, class: gpr32 }
  - { id: 104, class: gpr32 }
  - { id: 105, class: gpr32 }
  - { id: 106, class: gpr32 }
  - { id: 107, class: gpr32 }
  - { id: 108, class: gpr32 }
  - { id: 109, class: gpr32 }
  - { id: 110, class: gpr32 }
  - { id: 111, class: gpr32 }
  - { id: 112, class: gpr32 }
  - { id: 113, class: gpr32 }
  - { id: 114, class: gpr32 }
  - { id: 115, class: gpr32 }
  - { id: 116, class: gpr32 }
  - { id: 117, class: gpr32 }
  - { id: 118, class: gpr32 }
  - { id: 119, class: gpr32 }
  - { id: 120, class: gpr32 }
  - { id: 121, class: gpr32 }
  - { id: 122, class: gpr32 }
  - { id: 123, class: gpr32 }
  - { id: 124, class: gpr32 }
  - { id: 125, class: gpr32 }
  - { id: 126, class: gpr32 }
  - { id: 127, class: gpr32 }
  - { id: 128, class: gpr32 }
  - { id: 129, class: gpr32 }
  - { id: 130, class: gpr32 }
  - { id: 131, class: fgr32 }
  - { id: 132, class: gpr32 }
  - { id: 133, class: gpr32 }
  - { id: 134, class: fgr32 }
  - { id: 135, class: gpr32 }
  - { id: 136, class: gpr32 }
  - { id: 137, class: gpr32 }
  - { id: 138, class: gpr32 }
  - { id: 139, class: gpr32 }
  - { id: 140, class: gpr32 }
  - { id: 141, class: fgr32 }
  - { id: 142, class: fgr32 }
  - { id: 143, class: fgr32 }
  - { id: 144, class: fgr32 }
  - { id: 145, class: gpr32 }
  - { id: 146, class: gpr32 }
  - { id: 147, class: gpr32 }
  - { id: 148, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%55' }
  - { reg: '%a1', virtual-reg: '%56' }
  - { reg: '%a2', virtual-reg: '%57' }
  - { reg: '%a3', virtual-reg: '%58' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 24, size: 4, alignment: 8, isImmutable: true, isAliased: false }
  - { id: 1, offset: 20, size: 4, alignment: 4, isImmutable: true, isAliased: false }
  - { id: 2, offset: 16, size: 4, alignment: 8, isImmutable: true, isAliased: false }
body:             |
  bb.0 (%ir-block.0, freq 32):
    successors: %bb.1(62), %bb.2(37)
    liveins: %a0, %a1, %a2, %a3, %t9, %v0
  
    %76 = ADDu %v0, %t9
    %58 = COPY %a3
    %57 = COPY %a2
    %56 = COPY %a1
    %55 = COPY %a0
    %59 = LW %fixed-stack.2, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    BLEZ %58, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.9, freq 20):
    successors: %bb.3(100)
  
    %5 = SUBu %58, %56
    B %bb.3, implicit-def dead %at
  
  bb.2 (%ir-block.11, freq 12):
    successors: %bb.3(100)
  
    %66 = ADDiu %58, 1
    %67 = SLTi %58, -1
    %6 = MOVZ_I_I %zero, killed %67, %66
  
  bb.3 (%ir-block.15, freq 32):
    successors: %bb.4(62), %bb.5(37)
  
    %7 = PHI %6, %bb.2, %5, %bb.1
    %0 = MUL %57, %56, implicit-def dead %hi0, implicit-def dead %lo0
    BLEZ %59, %bb.5, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.18, freq 20):
    successors: %bb.6(100)
  
    %8 = SUBu %59, %57
    B %bb.6, implicit-def dead %at
  
  bb.5 (%ir-block.20, freq 12):
    successors: %bb.6(100)
  
    %69 = ADDiu %59, 1
    %70 = SLTi %59, -1
    %9 = MOVZ_I_I %zero, killed %70, %69
  
  bb.6 (%ir-block.24, freq 32):
    successors: %bb.7..lr.ph21.preheader(62), %bb.8.._crit_edge22(37)
  
    %10 = PHI %9, %bb.5, %8, %bb.4
    %61 = LW %fixed-stack.0, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    %60 = LW %fixed-stack.1, 0, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from stack)
    BLEZ %0, %bb.8.._crit_edge22, implicit-def dead %at
    B %bb.7..lr.ph21.preheader, implicit-def dead %at
  
  bb.7..lr.ph21.preheader (freq 20):
    successors: %bb.8.._crit_edge22(100)
  
    %77 = SLL %0, 2
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %78 = LW %76, target-flags(<unknown>) $memset, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry $memset)
    %79 = ADDiu %zero, 0
    %a0 = COPY %60
    %a1 = COPY %79
    %a2 = COPY %77
    %gp = COPY %76
    %t9 = COPY %78
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.8.._crit_edge22 (freq 32):
    successors: %bb.9(50), %bb.15(50)
  
    %11 = MUL %10, %56, implicit-def dead %hi0, implicit-def dead %lo0
    %80 = ADDiu %zero, 0
    %81 = ADDiu %zero, 1
    BNE %61, killed %81, %bb.15, implicit-def dead %at
    B %bb.9, implicit-def dead %at
  
  bb.9 (%ir-block.35, freq 16):
    successors: %bb.10(50), %bb.11(50)
  
    %72 = SRL %57, 31
    %74 = SRL %56, 31
    %73 = ADDu %57, %72
    %75 = ADDu %56, %74
    %14 = SRA %73, 1
    %12 = SRA %75, 1
    %15 = ADDiu %14, 1
    %13 = ADDiu %12, 1
    BNE %13, %58, %bb.11, implicit-def dead %at
    B %bb.10, implicit-def dead %at
  
  bb.10 (%ir-block.37, freq 8):
    successors: %bb.12(100)
  
    %86 = ADDiu %56, 1
    %87 = SRL %86, 31
    %88 = ADDu %86, killed %87
    %16 = SRA killed %88, 1
    %85 = ADDiu %zero, 0
    B %bb.12, implicit-def dead %at
  
  bb.11 (%ir-block.40, freq 8):
    successors: %bb.12(100)
  
    %82 = NOR %12, %zero
    %83 = XOR %58, killed %82
    %18 = MOVN_I_I %zero, %83, %12
    %17 = MOVZ_I_I %zero, %83, %7
  
  bb.12 (%ir-block.43, freq 16):
    successors: %bb.13(50), %bb.14(50)
  
    %19 = PHI %56, %bb.11, %16, %bb.10
    %20 = PHI %17, %bb.11, %7, %bb.10
    %21 = PHI %18, %bb.11, %85, %bb.10
    BNE %15, %59, %bb.14, implicit-def dead %at
    B %bb.13, implicit-def dead %at
  
  bb.13 (%ir-block.45, freq 8):
    successors: %bb.15(100)
  
    %94 = ADDiu %57, 1
    %95 = SRL %94, 31
    %96 = ADDu %94, killed %95
    %97 = SRA killed %96, 1
    %22 = MUL killed %97, %56, implicit-def dead %hi0, implicit-def dead %lo0
    B %bb.15, implicit-def dead %at
  
  bb.14 (%ir-block.49, freq 8):
    successors: %bb.15(100)
  
    %89 = MUL %14, %56, implicit-def dead %hi0, implicit-def dead %lo0
    %90 = NOR %14, %zero
    %91 = XOR %59, killed %90
    %23 = MOVZ_I_I %zero, %91, %11
    %24 = MOVN_I_I %zero, %91, %89
  
  bb.15 (%ir-block.53, freq 32):
    successors: %bb.16..lr.ph17(50), %bb.24.._crit_edge18(50)
  
    %25 = PHI %0, %bb.8.._crit_edge22, %0, %bb.14, %22, %bb.13
    %26 = PHI %56, %bb.8.._crit_edge22, %19, %bb.14, %19, %bb.13
    %27 = PHI %7, %bb.8.._crit_edge22, %20, %bb.14, %20, %bb.13
    %28 = PHI %11, %bb.8.._crit_edge22, %23, %bb.14, %11, %bb.13
    %29 = PHI %80, %bb.8.._crit_edge22, %24, %bb.14, %80, %bb.13
    %30 = PHI %80, %bb.8.._crit_edge22, %21, %bb.14, %21, %bb.13
    %98 = SLT %29, %25
    BEQ killed %98, %zero, %bb.24.._crit_edge18, implicit-def dead %at
    B %bb.16..lr.ph17, implicit-def dead %at
  
  bb.16..lr.ph17 (freq 16):
    successors: %bb.17(100)
  
    %3 = ADDiu %57, -1
    %62 = MUL %3, %56, implicit-def dead %hi0, implicit-def dead %lo0
    %1 = ADDiu %56, -1
    %63 = SLTi %58, 1
    %65 = SLTi %59, 1
    %2 = MOVN_I_I %zero, %63, %1
    %4 = MOVN_I_I %zero, %65, %62
    %32 = SUBu %26, %30
    %99 = ADDu %29, %30
    %31 = SUBu %zero, %27
    %101 = SLL killed %99, 2
    %33 = ADDu %55, killed %101
    %34 = SLL %56, 2
    %130 = ADDiu %zero, 1
  
  bb.17 (%ir-block.59, freq 511):
    successors: %bb.18..lr.ph(50), %bb.23.._crit_edge(50)
  
    %35 = PHI %33, %bb.16..lr.ph17, %54, %bb.23.._crit_edge
    %36 = PHI %28, %bb.16..lr.ph17, %53, %bb.23.._crit_edge
    %37 = PHI %29, %bb.16..lr.ph17, %52, %bb.23.._crit_edge
    %102 = ADDu %37, %26
    %103 = ADDu %37, %30
    %104 = SLT killed %103, killed %102
    BEQ killed %104, %zero, %bb.23.._crit_edge, implicit-def dead %at
    B %bb.18..lr.ph, implicit-def dead %at
  
  bb.18..lr.ph (freq 255):
    successors: %bb.19(100)
  
    %105 = ADDu %36, %4
    %106 = SLT %105, %57
    %107 = MOVN_I_I %105, killed %106, %3
    %108 = SRA %36, 31
    %109 = ADDu %36, %108
    %110 = XOR killed %109, %108
    %111 = SUBu %4, killed %110
    %112 = SLTi %105, 0
    %40 = MOVN_I_I %zero, killed %112, %107
    %114 = SRA %111, 31
    %115 = ADDu %111, %114
    %39 = XOR killed %115, %114
    %116 = SLT %zero, %36
    %117 = SLTi %36, 0
    %38 = MOVN_I_I killed %116, %4, %117
  
  bb.19 (%ir-block.79, freq 8191):
    successors: %bb.20(50), %bb.21(50)
  
    %41 = PHI %35, %bb.18..lr.ph, %51, %bb.22
    %42 = PHI %32, %bb.18..lr.ph, %50, %bb.22
    %43 = PHI %31, %bb.18..lr.ph, %49, %bb.22
    %44 = PHI %27, %bb.18..lr.ph, %48, %bb.22
    %118 = SLTi %44, 0
    %119 = MOVZ_I_I %44, %118, %43
    %120 = SUBu %2, killed %119
    %121 = SRA %120, 31
    %122 = ADDu %120, %121
    %123 = XOR killed %122, %121
    %124 = ADDu killed %123, %39
    %126 = SLT %zero, %44
    %127 = SLL killed %124, 2
    %128 = MOVN_I_I killed %126, %2, %118
    %45 = LWC1 %41, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv6, !tbaa !6)
    %129 = XOR %38, killed %128
    %47 = LWXC1 %60, %127, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.94, !tbaa !6)
    %46 = ADDu %60, %127
    BNE killed %129, %130, %bb.21, implicit-def dead %at
    B %bb.20, implicit-def dead %at
  
  bb.20 (%ir-block.96, freq 4095):
    successors: %bb.22(100)
  
    %132 = ADDu %2, %44
    %133 = SLT %132, %56
    %134 = FSUB_S %47, %45
    SWC1 killed %134, %46, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.94, !tbaa !6)
    %135 = MOVN_I_I %132, killed %133, %1
    %136 = SLTi %132, 0
    %138 = MOVN_I_I %zero, killed %136, %135
    %139 = ADDu killed %138, %40
    %140 = SLL killed %139, 2
    %141 = LWXC1 %60, %140, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.107, !tbaa !6)
    %142 = LWC1 %41, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv6, !tbaa !6)
    %143 = FADD_S %142, %142
    %144 = FADD_S killed %141, killed %143
    SWXC1 killed %144, %60, %140, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.107, !tbaa !6)
    B %bb.22, implicit-def dead %at
  
  bb.21 (%ir-block.110, freq 4095):
    successors: %bb.22(100)
  
    %131 = FADD_S %45, %47
    SWC1 killed %131, %46, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.94, !tbaa !6)
  
  bb.22 (%ir-block.112, freq 8191):
    successors: %bb.23.._crit_edge(3), %bb.19(96)
  
    %51 = ADDiu %41, 4
    %50 = ADDiu %42, -1
    %49 = ADDiu %43, -1
    %48 = ADDiu %44, 1
    BNE %50, %zero, %bb.19, implicit-def dead %at
    B %bb.23.._crit_edge, implicit-def dead %at
  
  bb.23.._crit_edge (freq 511):
    successors: %bb.17(96), %bb.24.._crit_edge18(3)
  
    %54 = ADDu %35, %34
    %53 = ADDu %36, %56
    %52 = ADDu %37, %56
    %145 = SLT %52, %25
    BNE killed %145, %zero, %bb.17, implicit-def dead %at
    B %bb.24.._crit_edge18, implicit-def dead %at
  
  bb.24.._crit_edge18 (freq 32):
    liveouts: %v0
  
    %146 = IMPLICIT_DEF
    %v0 = COPY %146
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/epic/epic.edges.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.EDGE_HANDLER = type { i8*, i32 (...)* }
  
  @edge_foos = internal unnamed_addr constant [9 x %struct.EDGE_HANDLER] [%struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect2 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @repeat to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @zero to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @extend to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @nocompute to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @predict to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @ereflect to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }], align 4
  @.str.1 = private unnamed_addr constant [9 x i8] c"reflect1\00", align 1
  @.str.2 = private unnamed_addr constant [9 x i8] c"reflect2\00", align 1
  @.str.3 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
  @.str.4 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
  @.str.5 = private unnamed_addr constant [7 x i8] c"extend\00", align 1
  @.str.6 = private unnamed_addr constant [13 x i8] c"dont-compute\00", align 1
  @.str.7 = private unnamed_addr constant [8 x i8] c"predict\00", align 1
  @.str.8 = private unnamed_addr constant [9 x i8] c"ereflect\00", align 1
  @.str.9 = private unnamed_addr constant [9 x i8] c"treflect\00", align 1
  @str = private unnamed_addr constant [30 x i8] c"No such edge handler routine!\00"
  
  ; Function Attrs: nounwind
  define i32 (...)* @edge_function(i8* nocapture readonly %edges) #0 {
    %1 = tail call i32 @strcmp(i8* %edges, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0))
    %2 = icmp eq i32 %1, 0
    br i1 %2, label %3, label %6
  
  ; <label>:3                                       ; preds = %28, %25, %22, %19, %16, %13, %10, %6, %0
    %i.02.lcssa = phi i32 [ 0, %0 ], [ 1, %6 ], [ 2, %10 ], [ 3, %13 ], [ 4, %16 ], [ 5, %19 ], [ 6, %22 ], [ 7, %25 ], [ 8, %28 ]
    %4 = getelementptr inbounds [9 x %struct.EDGE_HANDLER], [9 x %struct.EDGE_HANDLER]* @edge_foos, i32 0, i32 %i.02.lcssa, i32 1
    %5 = load i32 (...)*, i32 (...)** %4, align 4, !tbaa !1
    br label %9
  
  ; <label>:6                                       ; preds = %0
    %7 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
    %8 = icmp eq i32 %7, 0
    br i1 %8, label %3, label %10
  
  ; <label>:9                                       ; preds = %31, %3
    %.0 = phi i32 (...)* [ %5, %3 ], [ null, %31 ]
    ret i32 (...)* %.0
  
  ; <label>:10                                      ; preds = %6
    %11 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0))
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %3, label %13
  
  ; <label>:13                                      ; preds = %10
    %14 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
    %15 = icmp eq i32 %14, 0
    br i1 %15, label %3, label %16
  
  ; <label>:16                                      ; preds = %13
    %17 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0))
    %18 = icmp eq i32 %17, 0
    br i1 %18, label %3, label %19
  
  ; <label>:19                                      ; preds = %16
    %20 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0))
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %3, label %22
  
  ; <label>:22                                      ; preds = %19
    %23 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0))
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %3, label %25
  
  ; <label>:25                                      ; preds = %22
    %26 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
    %27 = icmp eq i32 %26, 0
    br i1 %27, label %3, label %28
  
  ; <label>:28                                      ; preds = %25
    %29 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0))
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %3, label %31
  
  ; <label>:31                                      ; preds = %28
    %puts = tail call i32 @puts(i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @str, i32 0, i32 0))
    br label %9
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #1
  
  ; Function Attrs: norecurse nounwind
  define i32 @zero(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph7.preheader, label %._crit_edge
  
  .lr.ph7.preheader:                                ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep6 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph7
  
  .lr.ph7:                                          ; preds = %.loopexit, %.lr.ph7.preheader
    %lsr.iv7 = phi float* [ %43, %.loopexit ], [ %scevgep6, %.lr.ph7.preheader ]
    %lsr.iv1 = phi float* [ %42, %.loopexit ], [ %filt, %.lr.ph7.preheader ]
    %y_filt.06 = phi i32 [ %27, %.loopexit ], [ 0, %.lr.ph7.preheader ]
    %y_res.05 = phi i32 [ %41, %.loopexit ], [ %22, %.lr.ph7.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.06, %x_dim
    %notlhs = icmp slt i32 %y_res.05, 0
    %notrhs = icmp sge i32 %y_res.05, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph7, %36
    %lsr.iv10 = phi float* [ %scevgep11, %36 ], [ %lsr.iv7, %.lr.ph7 ]
    %lsr.iv3 = phi float* [ %scevgep4, %36 ], [ %lsr.iv1, %.lr.ph7 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %36 ], [ 0, %.lr.ph7 ]
    %28 = add i32 %10, %lsr.iv
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %36
  
  ; <label>:32                                      ; preds = %.lr.ph
    %33 = bitcast float* %lsr.iv3 to i32*
    %34 = bitcast float* %lsr.iv10 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    br label %36
  
  ; <label>:36                                      ; preds = %32, %.lr.ph
    %lsr.iv.next = add i32 %lsr.iv, 1
    %37 = add i32 %y_filt.06, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %scevgep11 = getelementptr float, float* %lsr.iv10, i32 1
    %38 = icmp slt i32 %37, %27
    br i1 %38, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %36, %.lr.ph7
    %39 = bitcast float* %lsr.iv1 to i1*
    %40 = bitcast float* %lsr.iv7 to i1*
    %41 = add nsw i32 %y_res.05, %x_dim
    %scevgep = getelementptr i1, i1* %39, i32 %24
    %42 = bitcast i1* %scevgep to float*
    %scevgep9 = getelementptr i1, i1* %40, i32 %24
    %43 = bitcast i1* %scevgep9 to float*
    %44 = icmp slt i32 %27, %1
    br i1 %44, label %.lr.ph7, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @repeat(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.preheader.lr.ph, label %._crit_edge6
  
  .preheader.lr.ph:                                 ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = sub nsw i32 %1, %x_dim
    %25 = add nsw i32 %x_dim, -1
    %26 = shl i32 %x_dim, 2
    br label %.preheader
  
  .preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
    %lsr.iv1 = phi float* [ %48, %._crit_edge ], [ %filt, %.preheader.lr.ph ]
    %y_filt.05 = phi i32 [ 0, %.preheader.lr.ph ], [ %28, %._crit_edge ]
    %y_res.04 = phi i32 [ %22, %.preheader.lr.ph ], [ %47, %._crit_edge ]
    %27 = icmp sgt i32 %x_dim, 0
    %28 = add nsw i32 %y_filt.05, %x_dim
    br i1 %27, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader
    %29 = icmp sgt i32 %y_res.04, -1
    %30 = icmp slt i32 %y_res.04, %1
    %y_res.0. = select i1 %30, i32 %y_res.04, i32 %24
    %y_res.0.. = select i1 %29, i32 %y_res.0., i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %31, %.lr.ph
    %lsr.iv3 = phi float* [ %scevgep4, %31 ], [ %lsr.iv1, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %31 ], [ 0, %.lr.ph ]
    %32 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %33 = add i32 %10, %lsr.iv
    %34 = icmp sgt i32 %33, -1
    %35 = add i32 %10, %lsr.iv
    %36 = icmp slt i32 %35, %x_dim
    %37 = add i32 %10, %lsr.iv
    %38 = select i1 %36, i32 %37, i32 %25
    %39 = select i1 %34, i32 %38, i32 0
    %40 = add nsw i32 %39, %y_res.0..
    %41 = getelementptr inbounds float, float* %result, i32 %40
    %42 = load float, float* %41, align 4, !tbaa !6
    %43 = fadd float %32, %42
    store float %43, float* %41, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, 1
    %44 = add i32 %y_filt.05, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %45 = icmp slt i32 %44, %28
    br i1 %45, label %31, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %31, %.preheader
    %46 = bitcast float* %lsr.iv1 to i1*
    %47 = add nsw i32 %y_res.04, %x_dim
    %scevgep = getelementptr i1, i1* %46, i32 %26
    %48 = bitcast i1* %scevgep to float*
    %49 = icmp slt i32 %28, %1
    br i1 %49, label %.preheader, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect2(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = mul nsw i32 %5, %x_dim
    %7 = select i1 %4, i32 %6, i32 0
    %8 = mul i32 %y_dim, %x_dim
    %9 = xor i32 %x_dim, -1
    %.v = select i1 %1, i32 %9, i32 1
    %10 = add i32 %.v, %x_pos
    %11 = icmp sgt i32 %8, 0
    br i1 %11, label %.lr.ph5.preheader, label %._crit_edge6
  
  .lr.ph5.preheader:                                ; preds = %0
    %12 = icmp sgt i32 %y_pos, 0
    %13 = xor i32 %y_dim, -1
    %.v10 = select i1 %12, i32 %13, i32 1
    %14 = add i32 %.v10, %y_pos
    %15 = mul nsw i32 %14, %x_dim
    %result11 = bitcast float* %result to i8*
    %16 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %result11, i8 0, i32 %16, i32 4, i1 false)
    %17 = shl i32 %x_dim, 2
    br label %.lr.ph5
  
  .lr.ph5:                                          ; preds = %._crit_edge, %.lr.ph5.preheader
    %lsr.iv = phi float* [ %51, %._crit_edge ], [ %filt, %.lr.ph5.preheader ]
    %y_filt.04 = phi i32 [ %21, %._crit_edge ], [ 0, %.lr.ph5.preheader ]
    %y_edge.03 = phi i32 [ %50, %._crit_edge ], [ %15, %.lr.ph5.preheader ]
    %18 = icmp sgt i32 %x_dim, 0
    %19 = icmp eq i32 %y_edge.03, 0
    %20 = select i1 %19, i32 %x_dim, i32 0
    %.y_edge.0 = add nsw i32 %20, %y_edge.03
    %21 = add nsw i32 %y_filt.04, %x_dim
    br i1 %18, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.lr.ph5
    %22 = icmp sgt i32 %.y_edge.0, -1
    %23 = sub nsw i32 0, %.y_edge.0
    %24 = select i1 %22, i32 %.y_edge.0, i32 %23
    %25 = sub nsw i32 %7, %24
    %26 = add nsw i32 %25, %x_dim
    %27 = icmp sgt i32 %26, -1
    %28 = sub nsw i32 0, %26
    %29 = select i1 %27, i32 %26, i32 %28
    br label %30
  
  ; <label>:30                                      ; preds = %30, %.lr.ph
    %lsr.iv2 = phi float* [ %scevgep3, %30 ], [ %lsr.iv, %.lr.ph ]
    %x_filt.02 = phi i32 [ %y_filt.04, %.lr.ph ], [ %46, %30 ]
    %x_edge.01 = phi i32 [ %10, %.lr.ph ], [ %47, %30 ]
    %31 = icmp eq i32 %x_edge.01, 0
    %32 = zext i1 %31 to i32
    %.x_edge.0 = add nsw i32 %32, %x_edge.01
    %33 = load float, float* %lsr.iv2, align 4, !tbaa !6
    %34 = icmp sgt i32 %.x_edge.0, -1
    %35 = sub nsw i32 0, %.x_edge.0
    %36 = select i1 %34, i32 %.x_edge.0, i32 %35
    %37 = sub nsw i32 %3, %36
    %38 = add nsw i32 %37, 1
    %39 = icmp sgt i32 %37, -2
    %40 = xor i32 %37, -1
    %41 = select i1 %39, i32 %38, i32 %40
    %42 = add nsw i32 %41, %29
    %43 = getelementptr inbounds float, float* %result, i32 %42
    %44 = load float, float* %43, align 4, !tbaa !6
    %45 = fadd float %33, %44
    store float %45, float* %43, align 4, !tbaa !6
    %46 = add nsw i32 %x_filt.02, 1
    %47 = add nsw i32 %.x_edge.0, 1
    %scevgep3 = getelementptr float, float* %lsr.iv2, i32 1
    %48 = icmp slt i32 %46, %21
    br i1 %48, label %30, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %30, %.lr.ph5
    %49 = bitcast float* %lsr.iv to i1*
    %50 = add nsw i32 %.y_edge.0, %x_dim
    %scevgep = getelementptr i1, i1* %49, i32 %17
    %51 = bitcast i1* %scevgep to float*
    %52 = icmp slt i32 %21, %8
    br i1 %52, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %0
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect1(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph22.preheader, label %._crit_edge23
  
  .lr.ph22.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %.lr.ph22.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge23
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.4 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.4, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.5 = select i1 %51, i32 0, i32 %26
    %.6 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge23
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge23 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge23 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge23 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge23 ], [ %.5, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge23 ], [ %.6, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge23 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph18.preheader, label %._crit_edge19
  
  .lr.ph18.preheader:                               ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep9 = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %.lr.ph18
  
  .lr.ph18:                                         ; preds = %._crit_edge, %.lr.ph18.preheader
    %lsr.iv10 = phi float* [ %85, %._crit_edge ], [ %scevgep9, %.lr.ph18.preheader ]
    %y_edge.016 = phi i32 [ %y_edge_dist.0, %.lr.ph18.preheader ], [ %84, %._crit_edge ]
    %y_filt.015 = phi i32 [ %y_start.0, %.lr.ph18.preheader ], [ %83, %._crit_edge ]
    %59 = add nsw i32 %y_filt.015, %x_start.1
    %60 = add nsw i32 %y_filt.015, %x_stop.1
    %61 = icmp slt i32 %59, %60
    br i1 %61, label %.lr.ph14, label %._crit_edge
  
  .lr.ph14:                                         ; preds = %.lr.ph18
    %62 = icmp sgt i32 %y_edge.016, -1
    %63 = sub nsw i32 0, %y_edge.016
    %64 = select i1 %62, i32 %y_edge.016, i32 %63
    %65 = sub nsw i32 %8, %64
    %66 = icmp sgt i32 %65, -1
    %67 = sub nsw i32 0, %65
    %68 = select i1 %66, i32 %65, i32 %67
    br label %69
  
  ; <label>:69                                      ; preds = %69, %.lr.ph14
    %lsr.iv13 = phi float* [ %scevgep14, %69 ], [ %lsr.iv10, %.lr.ph14 ]
    %lsr.iv7 = phi i32 [ %lsr.iv.next8, %69 ], [ %56, %.lr.ph14 ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next, %69 ], [ %55, %.lr.ph14 ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph14 ], [ %81, %69 ]
    %70 = load float, float* %lsr.iv13, align 4, !tbaa !6
    %71 = icmp sgt i32 %x_edge.013, -1
    %72 = select i1 %71, i32 %x_edge.013, i32 %lsr.iv6
    %73 = sub nsw i32 %4, %72
    %74 = icmp sgt i32 %73, -1
    %75 = sub nsw i32 0, %73
    %76 = select i1 %74, i32 %73, i32 %75
    %77 = add nsw i32 %76, %68
    %78 = getelementptr inbounds float, float* %result, i32 %77
    %79 = load float, float* %78, align 4, !tbaa !6
    %80 = fadd float %70, %79
    store float %80, float* %78, align 4, !tbaa !6
    %81 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv6, -1
    %lsr.iv.next8 = add i32 %lsr.iv7, -1
    %scevgep14 = getelementptr float, float* %lsr.iv13, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next8, 0
    br i1 %exitcond, label %._crit_edge, label %69
  
  ._crit_edge:                                      ; preds = %69, %.lr.ph18
    %82 = bitcast float* %lsr.iv10 to i1*
    %83 = add nsw i32 %y_filt.015, %x_dim
    %84 = add nsw i32 %y_edge.016, %x_dim
    %scevgep12 = getelementptr i1, i1* %82, i32 %58
    %85 = bitcast i1* %scevgep12 to float*
    %86 = icmp slt i32 %83, %y_stop.0
    br i1 %86, label %.lr.ph18, label %._crit_edge19
  
  ._crit_edge19:                                    ; preds = %._crit_edge, %53
    %87 = icmp eq i32 %f_or_e, 1
    br i1 %87, label %88, label %.loopexit
  
  ; <label>:88                                      ; preds = %._crit_edge19
    %89 = icmp sgt i32 %x_pos, -1
    %90 = sub nsw i32 0, %x_pos
    %91 = select i1 %89, i32 %x_pos, i32 %90
    %92 = icmp ne i32 %91, %28
    %93 = icmp ne i32 %x_pos, 0
    %or.cond = and i1 %93, %92
    %94 = icmp slt i32 %4, %1
    %or.cond24 = and i1 %or.cond, %94
    br i1 %or.cond24, label %.lr.ph11.preheader, label %.loopexit8
  
  .lr.ph11.preheader:                               ; preds = %88
    %scevgep2 = getelementptr float, float* %result, i32 %4
    %95 = shl i32 %x_dim, 2
    br label %.lr.ph11
  
  .lr.ph11:                                         ; preds = %.lr.ph11, %.lr.ph11.preheader
    %lsr.iv3 = phi float* [ %99, %.lr.ph11 ], [ %scevgep2, %.lr.ph11.preheader ]
    %y_filt.110 = phi i32 [ %98, %.lr.ph11 ], [ %4, %.lr.ph11.preheader ]
    %lsr.iv34 = bitcast float* %lsr.iv3 to i1*
    %96 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %97 = fadd float %96, %96
    store float %97, float* %lsr.iv3, align 4, !tbaa !6
    %98 = add nsw i32 %y_filt.110, %x_dim
    %scevgep5 = getelementptr i1, i1* %lsr.iv34, i32 %95
    %99 = bitcast i1* %scevgep5 to float*
    %100 = icmp slt i32 %98, %1
    br i1 %100, label %.lr.ph11, label %.loopexit8
  
  .loopexit8:                                       ; preds = %.lr.ph11, %88
    %101 = icmp sgt i32 %y_pos, -1
    %102 = sub nsw i32 0, %y_pos
    %103 = select i1 %101, i32 %y_pos, i32 %102
    %104 = icmp ne i32 %103, %30
    %105 = icmp ne i32 %y_pos, 0
    %or.cond3 = and i1 %105, %104
    br i1 %or.cond3, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %.loopexit8
    %106 = add nsw i32 %8, %x_dim
    %107 = icmp sgt i32 %x_dim, 0
    br i1 %107, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %scevgep = getelementptr float, float* %result, i32 %8
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv = phi float* [ %scevgep1, %.lr.ph ], [ %scevgep, %.lr.ph.preheader ]
    %x_filt.19 = phi i32 [ %110, %.lr.ph ], [ %8, %.lr.ph.preheader ]
    %108 = load float, float* %lsr.iv, align 4, !tbaa !6
    %109 = fadd float %108, %108
    store float %109, float* %lsr.iv, align 4, !tbaa !6
    %110 = add nsw i32 %x_filt.19, 1
    %scevgep1 = getelementptr float, float* %lsr.iv, i32 1
    %111 = icmp slt i32 %110, %106
    br i1 %111, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %.preheader, %.loopexit8, %._crit_edge19
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @extend(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph21.preheader, label %._crit_edge22
  
  .lr.ph21.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge22
  
  ._crit_edge22:                                    ; preds = %.lr.ph21.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge22
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.3 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.3, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.4 = select i1 %51, i32 0, i32 %26
    %.5 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge22
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge22 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge22 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge22 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge22 ], [ %.4, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge22 ], [ %.5, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge22 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph17, label %._crit_edge18
  
  .lr.ph17:                                         ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %59
  
  ; <label>:59                                      ; preds = %._crit_edge, %.lr.ph17
    %lsr.iv3 = phi float* [ %117, %._crit_edge ], [ %scevgep, %.lr.ph17 ]
    %y_edge.015 = phi i32 [ %y_edge_dist.0, %.lr.ph17 ], [ %116, %._crit_edge ]
    %y_filt.014 = phi i32 [ %y_start.0, %.lr.ph17 ], [ %115, %._crit_edge ]
    %60 = add nsw i32 %y_filt.014, %x_start.1
    %61 = add nsw i32 %y_filt.014, %x_stop.1
    %62 = icmp slt i32 %60, %61
    br i1 %62, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %59
    %63 = icmp ne i32 %8, 0
    %64 = icmp sgt i32 %y_edge.015, 0
    %65 = icmp slt i32 %y_edge.015, 0
    %not. = xor i1 %64, true
    %66 = and i1 %65, %not.
    %67 = select i1 %63, i1 %64, i1 %66
    %68 = icmp sgt i32 %y_edge.015, -1
    %69 = sub nsw i32 0, %y_edge.015
    %70 = select i1 %68, i32 %y_edge.015, i32 %69
    %71 = sub nsw i32 %8, %70
    %72 = icmp sgt i32 %71, -1
    %73 = sub nsw i32 0, %71
    %74 = select i1 %72, i32 %71, i32 %73
    %75 = add nsw i32 %y_edge.015, %8
    %76 = icmp slt i32 %75, 0
    %77 = icmp slt i32 %75, %y_dim
    %.10 = select i1 %77, i32 %75, i32 %6
    %78 = select i1 %76, i32 0, i32 %.10
    br label %79
  
  ; <label>:79                                      ; preds = %112, %.lr.ph
    %lsr.iv6 = phi float* [ %scevgep7, %112 ], [ %lsr.iv3, %.lr.ph ]
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %112 ], [ %56, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %112 ], [ %55, %.lr.ph ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph ], [ %113, %112 ]
    %80 = icmp ne i32 %4, 0
    %81 = icmp sgt i32 %x_edge.013, 0
    %82 = icmp slt i32 %x_edge.013, 0
    %not.11 = xor i1 %81, true
    %83 = and i1 %82, %not.11
    %84 = select i1 %80, i1 %81, i1 %83
    %85 = xor i1 %67, %84
    %86 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %87 = icmp sgt i32 %x_edge.013, -1
    %88 = select i1 %87, i32 %x_edge.013, i32 %lsr.iv
    %89 = sub nsw i32 %4, %88
    %90 = icmp sgt i32 %89, -1
    %91 = sub nsw i32 0, %89
    %92 = select i1 %90, i32 %89, i32 %91
    %93 = add nsw i32 %92, %74
    %94 = getelementptr inbounds float, float* %result, i32 %93
    %95 = load float, float* %94, align 4, !tbaa !6
    br i1 %85, label %96, label %110
  
  ; <label>:96                                      ; preds = %79
    %97 = fsub float %95, %86
    store float %97, float* %94, align 4, !tbaa !6
    %98 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %99 = fadd float %98, %98
    %100 = add i32 %4, %x_edge.013
    %101 = icmp slt i32 %100, 0
    %102 = add i32 %4, %x_edge.013
    %103 = icmp slt i32 %102, %x_dim
    %104 = add i32 %4, %x_edge.013
    %.9 = select i1 %103, i32 %104, i32 %3
    %105 = select i1 %101, i32 0, i32 %.9
    %106 = add nsw i32 %105, %78
    %107 = getelementptr inbounds float, float* %result, i32 %106
    %108 = load float, float* %107, align 4, !tbaa !6
    %109 = fadd float %108, %99
    store float %109, float* %107, align 4, !tbaa !6
    br label %112
  
  ; <label>:110                                     ; preds = %79
    %111 = fadd float %86, %95
    store float %111, float* %94, align 4, !tbaa !6
    br label %112
  
  ; <label>:112                                     ; preds = %110, %96
    %113 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv, -1
    %lsr.iv.next2 = add i32 %lsr.iv1, -1
    %scevgep7 = getelementptr float, float* %lsr.iv6, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next2, 0
    br i1 %exitcond, label %._crit_edge, label %79
  
  ._crit_edge:                                      ; preds = %112, %59
    %114 = bitcast float* %lsr.iv3 to i1*
    %115 = add nsw i32 %y_filt.014, %x_dim
    %116 = add nsw i32 %y_edge.015, %x_dim
    %scevgep5 = getelementptr i1, i1* %114, i32 %58
    %117 = bitcast i1* %scevgep5 to float*
    %118 = icmp slt i32 %115, %y_stop.0
    br i1 %118, label %59, label %._crit_edge18
  
  ._crit_edge18:                                    ; preds = %._crit_edge, %53
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @nocompute(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %x_pos.off = add i32 %x_pos, 1
    %2 = icmp ugt i32 %x_pos.off, 2
    %y_pos.off = add i32 %y_pos, 1
    %3 = icmp ugt i32 %y_pos.off, 2
    %4 = or i1 %2, %3
    br i1 %4, label %.preheader, label %.preheader6
  
  .preheader6:                                      ; preds = %0
    %5 = icmp sgt i32 %1, 0
    br i1 %5, label %.lr.ph10.preheader, label %.loopexit
  
  .lr.ph10.preheader:                               ; preds = %.preheader6
    %6 = mul i32 %y_dim, %x_dim
    br label %.lr.ph10
  
  .preheader:                                       ; preds = %0
    %7 = icmp sgt i32 %1, 0
    br i1 %7, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %8 = bitcast float* %result to i8*
    %9 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %8, i8 0, i32 %9, i32 4, i1 false)
    br label %.loopexit
  
  .lr.ph10:                                         ; preds = %.lr.ph10, %.lr.ph10.preheader
    %lsr.iv3 = phi float* [ %scevgep4, %.lr.ph10 ], [ %filt, %.lr.ph10.preheader ]
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph10 ], [ %result, %.lr.ph10.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph10 ], [ %6, %.lr.ph10.preheader ]
    %lsr.iv35 = bitcast float* %lsr.iv3 to i32*
    %lsr.iv12 = bitcast float* %lsr.iv1 to i32*
    %10 = load i32, i32* %lsr.iv35, align 4, !tbaa !6
    store i32 %10, i32* %lsr.iv12, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %exitcond12 = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond12, label %.loopexit, label %.lr.ph10
  
  .loopexit:                                        ; preds = %.lr.ph10, %.lr.ph.preheader, %.preheader, %.preheader6
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  define i32 @ereflect(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #0 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = select i1 %4, i32 %5, i32 0
    %7 = mul nsw i32 %6, %x_dim
    %8 = mul i32 %y_dim, %x_dim
    %9 = icmp sgt i32 %x_pos, 1
    br i1 %9, label %10, label %12
  
  ; <label>:10                                      ; preds = %0
    %11 = sub nsw i32 %x_pos, %x_dim
    br label %16
  
  ; <label>:12                                      ; preds = %0
    %13 = icmp slt i32 %x_pos, -1
    %14 = add nsw i32 %x_pos, 1
    %15 = select i1 %13, i32 %14, i32 0
    br label %16
  
  ; <label>:16                                      ; preds = %12, %10
    %17 = phi i32 [ %11, %10 ], [ %15, %12 ]
    %18 = icmp sgt i32 %y_pos, 1
    br i1 %18, label %19, label %21
  
  ; <label>:19                                      ; preds = %16
    %20 = sub nsw i32 %y_pos, %y_dim
    br label %25
  
  ; <label>:21                                      ; preds = %16
    %22 = icmp slt i32 %y_pos, -1
    %23 = add nsw i32 %y_pos, 1
    %24 = select i1 %22, i32 %23, i32 0
    br label %25
  
  ; <label>:25                                      ; preds = %21, %19
    %26 = phi i32 [ %20, %19 ], [ %24, %21 ]
    %27 = icmp sgt i32 %8, 0
    br i1 %27, label %.preheader3.preheader, label %._crit_edge27
  
  .preheader3.preheader:                            ; preds = %25
    %28 = bitcast float* %result to i8*
    %29 = mul nsw i32 %26, %x_dim
    %30 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %28, i8 0, i32 %30, i32 4, i1 false)
    %31 = shl i32 %x_dim, 2
    %32 = sub i32 0, %17
    br label %.preheader3
  
  .preheader3:                                      ; preds = %._crit_edge23, %.preheader3.preheader
    %lsr.iv19 = phi float* [ %60, %._crit_edge23 ], [ %filt, %.preheader3.preheader ]
    %y_filt.026 = phi i32 [ %34, %._crit_edge23 ], [ 0, %.preheader3.preheader ]
    %y_edge.025 = phi i32 [ %59, %._crit_edge23 ], [ %29, %.preheader3.preheader ]
    %33 = icmp sgt i32 %x_dim, 0
    %34 = add nsw i32 %y_filt.026, %x_dim
    br i1 %33, label %.lr.ph22, label %._crit_edge23
  
  .lr.ph22:                                         ; preds = %.preheader3
    %35 = icmp sgt i32 %y_edge.025, -1
    %36 = sub nsw i32 0, %y_edge.025
    %37 = select i1 %35, i32 %y_edge.025, i32 %36
    %38 = sub nsw i32 %7, %37
    %39 = icmp sgt i32 %38, -1
    %40 = sub nsw i32 0, %38
    %41 = select i1 %39, i32 %38, i32 %40
    br label %42
  
  ; <label>:42                                      ; preds = %42, %.lr.ph22
    %lsr.iv24 = phi i32 [ %lsr.iv.next25, %42 ], [ %32, %.lr.ph22 ]
    %lsr.iv22 = phi float* [ %scevgep23, %42 ], [ %lsr.iv19, %.lr.ph22 ]
    %lsr.iv17 = phi i32 [ %lsr.iv.next18, %42 ], [ 0, %.lr.ph22 ]
    %43 = load float, float* %lsr.iv22, align 4, !tbaa !6
    %44 = add i32 %17, %lsr.iv17
    %45 = icmp sgt i32 %44, -1
    %46 = add i32 %17, %lsr.iv17
    %47 = select i1 %45, i32 %46, i32 %lsr.iv24
    %48 = sub nsw i32 %3, %47
    %49 = icmp sgt i32 %48, -1
    %50 = sub nsw i32 0, %48
    %51 = select i1 %49, i32 %48, i32 %50
    %52 = add nsw i32 %51, %41
    %53 = getelementptr inbounds float, float* %result, i32 %52
    %54 = load float, float* %53, align 4, !tbaa !6
    %55 = fadd float %43, %54
    store float %55, float* %53, align 4, !tbaa !6
    %lsr.iv.next18 = add i32 %lsr.iv17, 1
    %56 = add i32 %y_filt.026, %lsr.iv.next18
    %scevgep23 = getelementptr float, float* %lsr.iv22, i32 1
    %lsr.iv.next25 = add i32 %lsr.iv24, -1
    %57 = icmp slt i32 %56, %34
    br i1 %57, label %42, label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %42, %.preheader3
    %58 = bitcast float* %lsr.iv19 to i1*
    %59 = add nsw i32 %y_edge.025, %x_dim
    %scevgep21 = getelementptr i1, i1* %58, i32 %31
    %60 = bitcast i1* %scevgep21 to float*
    %61 = icmp slt i32 %34, %8
    br i1 %61, label %.preheader3, label %._crit_edge27
  
  ._crit_edge27:                                    ; preds = %._crit_edge23, %25
    %62 = icmp ne i32 %x_pos, 0
    %63 = icmp slt i32 %3, %8
    %or.cond = and i1 %62, %63
    br i1 %or.cond, label %.lr.ph19.preheader, label %.loopexit
  
  .lr.ph19.preheader:                               ; preds = %._crit_edge27
    %scevgep13 = getelementptr float, float* %result, i32 %3
    %64 = shl i32 %x_dim, 2
    br label %.lr.ph19
  
  .lr.ph19:                                         ; preds = %.lr.ph19, %.lr.ph19.preheader
    %lsr.iv14 = phi float* [ %70, %.lr.ph19 ], [ %scevgep13, %.lr.ph19.preheader ]
    %y_filt.118 = phi i32 [ %69, %.lr.ph19 ], [ %3, %.lr.ph19.preheader ]
    %lsr.iv1415 = bitcast float* %lsr.iv14 to i1*
    %65 = load float, float* %lsr.iv14, align 4, !tbaa !6
    %66 = fpext float %65 to double
    %67 = fmul double %66, 0x3FF6A09E667F3BCD
    %68 = fptrunc double %67 to float
    store float %68, float* %lsr.iv14, align 4, !tbaa !6
    %69 = add nsw i32 %y_filt.118, %x_dim
    %scevgep16 = getelementptr i1, i1* %lsr.iv1415, i32 %64
    %70 = bitcast i1* %scevgep16 to float*
    %71 = icmp slt i32 %69, %8
    br i1 %71, label %.lr.ph19, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph19, %._crit_edge27
    %72 = icmp eq i32 %y_pos, 0
    br i1 %72, label %.preheader, label %.preheader1
  
  .preheader1:                                      ; preds = %.loopexit
    %73 = add nsw i32 %7, %x_dim
    %74 = icmp sgt i32 %x_dim, 0
    br i1 %74, label %.lr.ph17.preheader, label %.preheader
  
  .lr.ph17.preheader:                               ; preds = %.preheader1
    %75 = mul i32 %6, %x_dim
    %scevgep10 = getelementptr float, float* %result, i32 %75
    br label %.lr.ph17
  
  .preheader:                                       ; preds = %.lr.ph17, %.preheader1, %.loopexit
    %76 = icmp sgt i32 %8, 0
    br i1 %76, label %.lr.ph13.preheader, label %._crit_edge14.thread
  
  .lr.ph13.preheader:                               ; preds = %.preheader
    %77 = mul i32 %y_dim, %x_dim
    br label %.lr.ph13
  
  ._crit_edge14.thread:                             ; preds = %.preheader
    %78 = tail call double @sqrt(double 0.000000e+00) #5
    %79 = fcmp oeq double %78, %78
    br i1 %79, label %._crit_edge10.thread, label %call.sqrt
  
  call.sqrt:                                        ; preds = %._crit_edge14.thread
    %80 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge10.thread
  
  .lr.ph17:                                         ; preds = %.lr.ph17, %.lr.ph17.preheader
    %lsr.iv11 = phi float* [ %scevgep12, %.lr.ph17 ], [ %scevgep10, %.lr.ph17.preheader ]
    %x_filt.116 = phi i32 [ %85, %.lr.ph17 ], [ %7, %.lr.ph17.preheader ]
    %81 = load float, float* %lsr.iv11, align 4, !tbaa !6
    %82 = fpext float %81 to double
    %83 = fmul double %82, 0x3FF6A09E667F3BCD
    %84 = fptrunc double %83 to float
    store float %84, float* %lsr.iv11, align 4, !tbaa !6
    %85 = add nsw i32 %x_filt.116, 1
    %scevgep12 = getelementptr float, float* %lsr.iv11, i32 1
    %86 = icmp slt i32 %85, %73
    br i1 %86, label %.lr.ph17, label %.preheader
  
  .lr.ph13:                                         ; preds = %.lr.ph13, %.lr.ph13.preheader
    %lsr.iv8 = phi float* [ %scevgep9, %.lr.ph13 ], [ %result, %.lr.ph13.preheader ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next7, %.lr.ph13 ], [ %77, %.lr.ph13.preheader ]
    %norm.012 = phi double [ %90, %.lr.ph13 ], [ 0.000000e+00, %.lr.ph13.preheader ]
    %87 = load float, float* %lsr.iv8, align 4, !tbaa !6
    %88 = fmul float %87, %87
    %89 = fpext float %88 to double
    %90 = fadd double %norm.012, %89
    %lsr.iv.next7 = add i32 %lsr.iv6, -1
    %scevgep9 = getelementptr float, float* %lsr.iv8, i32 1
    %exitcond33 = icmp eq i32 %lsr.iv.next7, 0
    br i1 %exitcond33, label %._crit_edge14, label %.lr.ph13
  
  ._crit_edge14:                                    ; preds = %.lr.ph13
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %._crit_edge14.split, label %call.sqrt26
  
  call.sqrt26:                                      ; preds = %._crit_edge14
    %93 = tail call double @sqrt(double %90) #6
    br label %._crit_edge14.split
  
  ._crit_edge14.split:                              ; preds = %._crit_edge14, %call.sqrt26
    %94 = phi double [ %91, %._crit_edge14 ], [ %93, %call.sqrt26 ]
    %95 = icmp sgt i32 %8, 0
    br i1 %95, label %.lr.ph9.preheader, label %._crit_edge10.thread
  
  .lr.ph9.preheader:                                ; preds = %._crit_edge14.split
    %96 = mul i32 %y_dim, %x_dim
    br label %.lr.ph9
  
  .lr.ph9:                                          ; preds = %.lr.ph9, %.lr.ph9.preheader
    %lsr.iv4 = phi float* [ %scevgep5, %.lr.ph9 ], [ %filt, %.lr.ph9.preheader ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %.lr.ph9 ], [ %96, %.lr.ph9.preheader ]
    %onorm.07 = phi double [ %100, %.lr.ph9 ], [ 0.000000e+00, %.lr.ph9.preheader ]
    %97 = load float, float* %lsr.iv4, align 4, !tbaa !6
    %98 = fmul float %97, %97
    %99 = fpext float %98 to double
    %100 = fadd double %onorm.07, %99
    %lsr.iv.next3 = add i32 %lsr.iv2, -1
    %scevgep5 = getelementptr float, float* %lsr.iv4, i32 1
    %exitcond32 = icmp eq i32 %lsr.iv.next3, 0
    br i1 %exitcond32, label %._crit_edge10, label %.lr.ph9
  
  ._crit_edge10.thread:                             ; preds = %call.sqrt, %._crit_edge14.thread, %._crit_edge14.split
    %101 = tail call double @sqrt(double 0.000000e+00) #5
    %102 = fcmp oeq double %101, %101
    br i1 %102, label %._crit_edge, label %call.sqrt27
  
  call.sqrt27:                                      ; preds = %._crit_edge10.thread
    %103 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge
  
  ._crit_edge10:                                    ; preds = %.lr.ph9
    %104 = tail call double @sqrt(double %100) #5
    %105 = fcmp oeq double %104, %104
    br i1 %105, label %._crit_edge10.split, label %call.sqrt28
  
  call.sqrt28:                                      ; preds = %._crit_edge10
    %106 = tail call double @sqrt(double %100) #6
    br label %._crit_edge10.split
  
  ._crit_edge10.split:                              ; preds = %._crit_edge10, %call.sqrt28
    %107 = phi double [ %104, %._crit_edge10 ], [ %106, %call.sqrt28 ]
    %108 = icmp sgt i32 %8, 0
    %109 = fdiv double %94, %107
    br i1 %108, label %.lr.ph.preheader, label %._crit_edge
  
  .lr.ph.preheader:                                 ; preds = %._crit_edge10.split
    %110 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %110, %.lr.ph.preheader ]
    %111 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %112 = fpext float %111 to double
    %113 = fdiv double %112, %109
    %114 = fptrunc double %113 to float
    store float %114, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %call.sqrt27, %._crit_edge10.thread, %._crit_edge10.split
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  ; Function Attrs: norecurse nounwind
  define i32 @predict(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph12.preheader, label %._crit_edge
  
  .lr.ph12.preheader:                               ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep10 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph12
  
  .lr.ph12:                                         ; preds = %.loopexit2, %.lr.ph12.preheader
    %lsr.iv11 = phi float* [ %45, %.loopexit2 ], [ %scevgep10, %.lr.ph12.preheader ]
    %lsr.iv4 = phi float* [ %44, %.loopexit2 ], [ %filt, %.lr.ph12.preheader ]
    %y_filt.011 = phi i32 [ %27, %.loopexit2 ], [ 0, %.lr.ph12.preheader ]
    %y_res.010 = phi i32 [ %43, %.loopexit2 ], [ %22, %.lr.ph12.preheader ]
    %taps_used.09 = phi float [ %taps_used.3, %.loopexit2 ], [ 0.000000e+00, %.lr.ph12.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.011, %x_dim
    %notlhs = icmp slt i32 %y_res.010, 0
    %notrhs = icmp sge i32 %y_res.010, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit2, label %.lr.ph8
  
  .lr.ph8:                                          ; preds = %.lr.ph12, %38
    %lsr.iv14 = phi float* [ %scevgep15, %38 ], [ %lsr.iv11, %.lr.ph12 ]
    %lsr.iv7 = phi float* [ %scevgep8, %38 ], [ %lsr.iv4, %.lr.ph12 ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %38 ], [ 0, %.lr.ph12 ]
    %taps_used.15 = phi float [ %taps_used.2, %38 ], [ %taps_used.09, %.lr.ph12 ]
    %28 = add i32 %10, %lsr.iv2
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv2
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %38
  
  ; <label>:32                                      ; preds = %.lr.ph8
    %33 = bitcast float* %lsr.iv7 to i32*
    %34 = bitcast float* %lsr.iv14 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    %36 = load float, float* %lsr.iv7, align 4, !tbaa !6
    %37 = fadd float %taps_used.15, %36
    br label %38
  
  ; <label>:38                                      ; preds = %32, %.lr.ph8
    %taps_used.2 = phi float [ %37, %32 ], [ %taps_used.15, %.lr.ph8 ]
    %lsr.iv.next3 = add i32 %lsr.iv2, 1
    %39 = add i32 %y_filt.011, %lsr.iv.next3
    %scevgep8 = getelementptr float, float* %lsr.iv7, i32 1
    %scevgep15 = getelementptr float, float* %lsr.iv14, i32 1
    %40 = icmp slt i32 %39, %27
    br i1 %40, label %.lr.ph8, label %.loopexit2
  
  .loopexit2:                                       ; preds = %38, %.lr.ph12
    %taps_used.3 = phi float [ %taps_used.09, %.lr.ph12 ], [ %taps_used.2, %38 ]
    %41 = bitcast float* %lsr.iv4 to i1*
    %42 = bitcast float* %lsr.iv11 to i1*
    %43 = add nsw i32 %y_res.010, %x_dim
    %scevgep6 = getelementptr i1, i1* %41, i32 %24
    %44 = bitcast i1* %scevgep6 to float*
    %scevgep13 = getelementptr i1, i1* %42, i32 %24
    %45 = bitcast i1* %scevgep13 to float*
    %46 = icmp slt i32 %27, %1
    br i1 %46, label %.lr.ph12, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit2, %18
    %taps_used.0.lcssa = phi float [ 0.000000e+00, %18 ], [ %taps_used.3, %.loopexit2 ]
    %47 = icmp eq i32 %f_or_e, 0
    br i1 %47, label %48, label %.loopexit
  
  ; <label>:48                                      ; preds = %._crit_edge
    %49 = icmp sgt i32 %1, 0
    %50 = fdiv float 2.000000e+00, %taps_used.0.lcssa
    br i1 %49, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %48
    %51 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %51, %.lr.ph.preheader ]
    %52 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %53 = fmul float %50, %52
    store float %53, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %.lr.ph, %48, %._crit_edge
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare i32 @puts(i8* nocapture) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #4
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { nounwind "target-cpu"="mips32" }
  attributes #4 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #5 = { nounwind readnone }
  attributes #6 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"", !3, i64 0, !3, i64 4}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !7, i64 0}
  !7 = !{!"float", !4, i64 0}

...
---
name:            nocompute
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%8' }
  - { reg: '%a1', virtual-reg: '%9' }
  - { reg: '%a2', virtual-reg: '%10' }
  - { reg: '%a3', virtual-reg: '%11' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 24, size: 4, alignment: 8, isImmutable: true, isAliased: false }
  - { id: 1, offset: 20, size: 4, alignment: 4, isImmutable: true, isAliased: false }
  - { id: 2, offset: 16, size: 4, alignment: 8, isImmutable: true, isAliased: false }
body:             |
  bb.0 (%ir-block.0, freq 25):
    successors: %bb.3..preheader(25), %bb.7(75)
    liveins: %a0, %a1, %a2, %a3, %t9, %v0
  
    %19 = ADDu %v0, %t9
    %11 = COPY %a3
    %10 = COPY %a2
    %9 = COPY %a1
    %8 = COPY %a0
    %0 = MUL %10, %9, implicit-def dead %hi0, implicit-def dead %lo0
    %15 = ADDiu %11, 1
    %12 = LW %fixed-stack.1, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack)
    %16 = SLTiu killed %15, 3
    BEQ killed %16, %zero, %bb.3..preheader, implicit-def dead %at
    B %bb.7, implicit-def dead %at
  
  bb.7 (%ir-block.0, freq 19):
    successors: %bb.3..preheader(33), %bb.1..preheader6(66)
  
    %14 = LW %fixed-stack.2, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    %13 = ADDiu %14, 1
    %17 = SLTiu %13, 3
    BEQ killed %17, %zero, %bb.3..preheader, implicit-def dead %at
    B %bb.1..preheader6, implicit-def dead %at
  
  bb.1..preheader6 (freq 12):
    successors: %bb.2..lr.ph10.preheader(62), %bb.6..loopexit(37)
  
    BLEZ %0, %bb.6..loopexit, implicit-def dead %at
    B %bb.2..lr.ph10.preheader, implicit-def dead %at
  
  bb.2..lr.ph10.preheader (freq 7):
    successors: %bb.5..lr.ph10(100)
  
    B %bb.5..lr.ph10, implicit-def dead %at
  
  bb.3..preheader (freq 12):
    successors: %bb.4..lr.ph.preheader(62), %bb.6..loopexit(37)
  
    BLEZ %0, %bb.6..loopexit, implicit-def dead %at
    B %bb.4..lr.ph.preheader, implicit-def dead %at
  
  bb.4..lr.ph.preheader (freq 8):
    successors: %bb.6..loopexit(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %20 = SLL %0, 2
    %21 = LW %19, target-flags(<unknown>) $memset, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry $memset)
    %22 = ADDiu %zero, 0
    %a0 = COPY %12
    %a1 = COPY %22
    %a2 = COPY %20
    %gp = COPY %19
    %t9 = COPY %21
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.6..loopexit, implicit-def dead %at
  
  bb.5..lr.ph10 (freq 255):
    successors: %bb.6..loopexit(3), %bb.5..lr.ph10(96)
  
    %2 = PHI %8, %bb.2..lr.ph10.preheader, %7, %bb.5..lr.ph10
    %3 = PHI %12, %bb.2..lr.ph10.preheader, %6, %bb.5..lr.ph10
    %4 = PHI %0, %bb.2..lr.ph10.preheader, %5, %bb.5..lr.ph10
    %18 = LW %2, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv35, !tbaa !6)
    SW killed %18, %3, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.lsr.iv12, !tbaa !6)
    %7 = ADDiu %2, 4
    %6 = ADDiu %3, 4
    %5 = ADDiu %4, -1
    BNE %5, %zero, %bb.5..lr.ph10, implicit-def dead %at
    B %bb.6..loopexit, implicit-def dead %at
  
  bb.6..loopexit (freq 25):
    liveouts: %v0
  
    %23 = IMPLICIT_DEF
    %v0 = COPY %23
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/epic/epic.edges.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.EDGE_HANDLER = type { i8*, i32 (...)* }
  
  @edge_foos = internal unnamed_addr constant [9 x %struct.EDGE_HANDLER] [%struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect2 to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @repeat to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @zero to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @extend to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @nocompute to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @predict to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @ereflect to i32 (...)*) }, %struct.EDGE_HANDLER { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0), i32 (...)* bitcast (i32 (float*, i32, i32, i32, i32, float*, i32)* @reflect1 to i32 (...)*) }], align 4
  @.str.1 = private unnamed_addr constant [9 x i8] c"reflect1\00", align 1
  @.str.2 = private unnamed_addr constant [9 x i8] c"reflect2\00", align 1
  @.str.3 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
  @.str.4 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
  @.str.5 = private unnamed_addr constant [7 x i8] c"extend\00", align 1
  @.str.6 = private unnamed_addr constant [13 x i8] c"dont-compute\00", align 1
  @.str.7 = private unnamed_addr constant [8 x i8] c"predict\00", align 1
  @.str.8 = private unnamed_addr constant [9 x i8] c"ereflect\00", align 1
  @.str.9 = private unnamed_addr constant [9 x i8] c"treflect\00", align 1
  @str = private unnamed_addr constant [30 x i8] c"No such edge handler routine!\00"
  
  ; Function Attrs: nounwind
  define i32 (...)* @edge_function(i8* nocapture readonly %edges) #0 {
    %1 = tail call i32 @strcmp(i8* %edges, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i32 0, i32 0))
    %2 = icmp eq i32 %1, 0
    br i1 %2, label %3, label %6
  
  ; <label>:3                                       ; preds = %28, %25, %22, %19, %16, %13, %10, %6, %0
    %i.02.lcssa = phi i32 [ 0, %0 ], [ 1, %6 ], [ 2, %10 ], [ 3, %13 ], [ 4, %16 ], [ 5, %19 ], [ 6, %22 ], [ 7, %25 ], [ 8, %28 ]
    %4 = getelementptr inbounds [9 x %struct.EDGE_HANDLER], [9 x %struct.EDGE_HANDLER]* @edge_foos, i32 0, i32 %i.02.lcssa, i32 1
    %5 = load i32 (...)*, i32 (...)** %4, align 4, !tbaa !1
    br label %9
  
  ; <label>:6                                       ; preds = %0
    %7 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2, i32 0, i32 0))
    %8 = icmp eq i32 %7, 0
    br i1 %8, label %3, label %10
  
  ; <label>:9                                       ; preds = %31, %3
    %.0 = phi i32 (...)* [ %5, %3 ], [ null, %31 ]
    ret i32 (...)* %.0
  
  ; <label>:10                                      ; preds = %6
    %11 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0))
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %3, label %13
  
  ; <label>:13                                      ; preds = %10
    %14 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
    %15 = icmp eq i32 %14, 0
    br i1 %15, label %3, label %16
  
  ; <label>:16                                      ; preds = %13
    %17 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5, i32 0, i32 0))
    %18 = icmp eq i32 %17, 0
    br i1 %18, label %3, label %19
  
  ; <label>:19                                      ; preds = %16
    %20 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0))
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %3, label %22
  
  ; <label>:22                                      ; preds = %19
    %23 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0))
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %3, label %25
  
  ; <label>:25                                      ; preds = %22
    %26 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
    %27 = icmp eq i32 %26, 0
    br i1 %27, label %3, label %28
  
  ; <label>:28                                      ; preds = %25
    %29 = tail call i32 @strcmp(i8* %edges, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0))
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %3, label %31
  
  ; <label>:31                                      ; preds = %28
    %puts = tail call i32 @puts(i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @str, i32 0, i32 0))
    br label %9
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #1
  
  ; Function Attrs: norecurse nounwind
  define i32 @zero(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph7.preheader, label %._crit_edge
  
  .lr.ph7.preheader:                                ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep6 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph7
  
  .lr.ph7:                                          ; preds = %.loopexit, %.lr.ph7.preheader
    %lsr.iv7 = phi float* [ %43, %.loopexit ], [ %scevgep6, %.lr.ph7.preheader ]
    %lsr.iv1 = phi float* [ %42, %.loopexit ], [ %filt, %.lr.ph7.preheader ]
    %y_filt.06 = phi i32 [ %27, %.loopexit ], [ 0, %.lr.ph7.preheader ]
    %y_res.05 = phi i32 [ %41, %.loopexit ], [ %22, %.lr.ph7.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.06, %x_dim
    %notlhs = icmp slt i32 %y_res.05, 0
    %notrhs = icmp sge i32 %y_res.05, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph7, %36
    %lsr.iv10 = phi float* [ %scevgep11, %36 ], [ %lsr.iv7, %.lr.ph7 ]
    %lsr.iv3 = phi float* [ %scevgep4, %36 ], [ %lsr.iv1, %.lr.ph7 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %36 ], [ 0, %.lr.ph7 ]
    %28 = add i32 %10, %lsr.iv
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %36
  
  ; <label>:32                                      ; preds = %.lr.ph
    %33 = bitcast float* %lsr.iv3 to i32*
    %34 = bitcast float* %lsr.iv10 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    br label %36
  
  ; <label>:36                                      ; preds = %32, %.lr.ph
    %lsr.iv.next = add i32 %lsr.iv, 1
    %37 = add i32 %y_filt.06, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %scevgep11 = getelementptr float, float* %lsr.iv10, i32 1
    %38 = icmp slt i32 %37, %27
    br i1 %38, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %36, %.lr.ph7
    %39 = bitcast float* %lsr.iv1 to i1*
    %40 = bitcast float* %lsr.iv7 to i1*
    %41 = add nsw i32 %y_res.05, %x_dim
    %scevgep = getelementptr i1, i1* %39, i32 %24
    %42 = bitcast i1* %scevgep to float*
    %scevgep9 = getelementptr i1, i1* %40, i32 %24
    %43 = bitcast i1* %scevgep9 to float*
    %44 = icmp slt i32 %27, %1
    br i1 %44, label %.lr.ph7, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @repeat(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.preheader.lr.ph, label %._crit_edge6
  
  .preheader.lr.ph:                                 ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = sub nsw i32 %1, %x_dim
    %25 = add nsw i32 %x_dim, -1
    %26 = shl i32 %x_dim, 2
    br label %.preheader
  
  .preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
    %lsr.iv1 = phi float* [ %48, %._crit_edge ], [ %filt, %.preheader.lr.ph ]
    %y_filt.05 = phi i32 [ 0, %.preheader.lr.ph ], [ %28, %._crit_edge ]
    %y_res.04 = phi i32 [ %22, %.preheader.lr.ph ], [ %47, %._crit_edge ]
    %27 = icmp sgt i32 %x_dim, 0
    %28 = add nsw i32 %y_filt.05, %x_dim
    br i1 %27, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader
    %29 = icmp sgt i32 %y_res.04, -1
    %30 = icmp slt i32 %y_res.04, %1
    %y_res.0. = select i1 %30, i32 %y_res.04, i32 %24
    %y_res.0.. = select i1 %29, i32 %y_res.0., i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %31, %.lr.ph
    %lsr.iv3 = phi float* [ %scevgep4, %31 ], [ %lsr.iv1, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %31 ], [ 0, %.lr.ph ]
    %32 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %33 = add i32 %10, %lsr.iv
    %34 = icmp sgt i32 %33, -1
    %35 = add i32 %10, %lsr.iv
    %36 = icmp slt i32 %35, %x_dim
    %37 = add i32 %10, %lsr.iv
    %38 = select i1 %36, i32 %37, i32 %25
    %39 = select i1 %34, i32 %38, i32 0
    %40 = add nsw i32 %39, %y_res.0..
    %41 = getelementptr inbounds float, float* %result, i32 %40
    %42 = load float, float* %41, align 4, !tbaa !6
    %43 = fadd float %32, %42
    store float %43, float* %41, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, 1
    %44 = add i32 %y_filt.05, %lsr.iv.next
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %45 = icmp slt i32 %44, %28
    br i1 %45, label %31, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %31, %.preheader
    %46 = bitcast float* %lsr.iv1 to i1*
    %47 = add nsw i32 %y_res.04, %x_dim
    %scevgep = getelementptr i1, i1* %46, i32 %26
    %48 = bitcast i1* %scevgep to float*
    %49 = icmp slt i32 %28, %1
    br i1 %49, label %.preheader, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %18
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect2(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = mul nsw i32 %5, %x_dim
    %7 = select i1 %4, i32 %6, i32 0
    %8 = mul i32 %y_dim, %x_dim
    %9 = xor i32 %x_dim, -1
    %.v = select i1 %1, i32 %9, i32 1
    %10 = add i32 %.v, %x_pos
    %11 = icmp sgt i32 %8, 0
    br i1 %11, label %.lr.ph5.preheader, label %._crit_edge6
  
  .lr.ph5.preheader:                                ; preds = %0
    %12 = icmp sgt i32 %y_pos, 0
    %13 = xor i32 %y_dim, -1
    %.v10 = select i1 %12, i32 %13, i32 1
    %14 = add i32 %.v10, %y_pos
    %15 = mul nsw i32 %14, %x_dim
    %result11 = bitcast float* %result to i8*
    %16 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %result11, i8 0, i32 %16, i32 4, i1 false)
    %17 = shl i32 %x_dim, 2
    br label %.lr.ph5
  
  .lr.ph5:                                          ; preds = %._crit_edge, %.lr.ph5.preheader
    %lsr.iv = phi float* [ %51, %._crit_edge ], [ %filt, %.lr.ph5.preheader ]
    %y_filt.04 = phi i32 [ %21, %._crit_edge ], [ 0, %.lr.ph5.preheader ]
    %y_edge.03 = phi i32 [ %50, %._crit_edge ], [ %15, %.lr.ph5.preheader ]
    %18 = icmp sgt i32 %x_dim, 0
    %19 = icmp eq i32 %y_edge.03, 0
    %20 = select i1 %19, i32 %x_dim, i32 0
    %.y_edge.0 = add nsw i32 %20, %y_edge.03
    %21 = add nsw i32 %y_filt.04, %x_dim
    br i1 %18, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.lr.ph5
    %22 = icmp sgt i32 %.y_edge.0, -1
    %23 = sub nsw i32 0, %.y_edge.0
    %24 = select i1 %22, i32 %.y_edge.0, i32 %23
    %25 = sub nsw i32 %7, %24
    %26 = add nsw i32 %25, %x_dim
    %27 = icmp sgt i32 %26, -1
    %28 = sub nsw i32 0, %26
    %29 = select i1 %27, i32 %26, i32 %28
    br label %30
  
  ; <label>:30                                      ; preds = %30, %.lr.ph
    %lsr.iv2 = phi float* [ %scevgep3, %30 ], [ %lsr.iv, %.lr.ph ]
    %x_filt.02 = phi i32 [ %y_filt.04, %.lr.ph ], [ %46, %30 ]
    %x_edge.01 = phi i32 [ %10, %.lr.ph ], [ %47, %30 ]
    %31 = icmp eq i32 %x_edge.01, 0
    %32 = zext i1 %31 to i32
    %.x_edge.0 = add nsw i32 %32, %x_edge.01
    %33 = load float, float* %lsr.iv2, align 4, !tbaa !6
    %34 = icmp sgt i32 %.x_edge.0, -1
    %35 = sub nsw i32 0, %.x_edge.0
    %36 = select i1 %34, i32 %.x_edge.0, i32 %35
    %37 = sub nsw i32 %3, %36
    %38 = add nsw i32 %37, 1
    %39 = icmp sgt i32 %37, -2
    %40 = xor i32 %37, -1
    %41 = select i1 %39, i32 %38, i32 %40
    %42 = add nsw i32 %41, %29
    %43 = getelementptr inbounds float, float* %result, i32 %42
    %44 = load float, float* %43, align 4, !tbaa !6
    %45 = fadd float %33, %44
    store float %45, float* %43, align 4, !tbaa !6
    %46 = add nsw i32 %x_filt.02, 1
    %47 = add nsw i32 %.x_edge.0, 1
    %scevgep3 = getelementptr float, float* %lsr.iv2, i32 1
    %48 = icmp slt i32 %46, %21
    br i1 %48, label %30, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %30, %.lr.ph5
    %49 = bitcast float* %lsr.iv to i1*
    %50 = add nsw i32 %.y_edge.0, %x_dim
    %scevgep = getelementptr i1, i1* %49, i32 %17
    %51 = bitcast i1* %scevgep to float*
    %52 = icmp slt i32 %21, %8
    br i1 %52, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %._crit_edge, %0
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @reflect1(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph22.preheader, label %._crit_edge23
  
  .lr.ph22.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %.lr.ph22.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge23
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.4 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.4, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.5 = select i1 %51, i32 0, i32 %26
    %.6 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge23
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge23 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge23 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge23 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge23 ], [ %.5, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge23 ], [ %.6, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge23 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph18.preheader, label %._crit_edge19
  
  .lr.ph18.preheader:                               ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep9 = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %.lr.ph18
  
  .lr.ph18:                                         ; preds = %._crit_edge, %.lr.ph18.preheader
    %lsr.iv10 = phi float* [ %85, %._crit_edge ], [ %scevgep9, %.lr.ph18.preheader ]
    %y_edge.016 = phi i32 [ %y_edge_dist.0, %.lr.ph18.preheader ], [ %84, %._crit_edge ]
    %y_filt.015 = phi i32 [ %y_start.0, %.lr.ph18.preheader ], [ %83, %._crit_edge ]
    %59 = add nsw i32 %y_filt.015, %x_start.1
    %60 = add nsw i32 %y_filt.015, %x_stop.1
    %61 = icmp slt i32 %59, %60
    br i1 %61, label %.lr.ph14, label %._crit_edge
  
  .lr.ph14:                                         ; preds = %.lr.ph18
    %62 = icmp sgt i32 %y_edge.016, -1
    %63 = sub nsw i32 0, %y_edge.016
    %64 = select i1 %62, i32 %y_edge.016, i32 %63
    %65 = sub nsw i32 %8, %64
    %66 = icmp sgt i32 %65, -1
    %67 = sub nsw i32 0, %65
    %68 = select i1 %66, i32 %65, i32 %67
    br label %69
  
  ; <label>:69                                      ; preds = %69, %.lr.ph14
    %lsr.iv13 = phi float* [ %scevgep14, %69 ], [ %lsr.iv10, %.lr.ph14 ]
    %lsr.iv7 = phi i32 [ %lsr.iv.next8, %69 ], [ %56, %.lr.ph14 ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next, %69 ], [ %55, %.lr.ph14 ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph14 ], [ %81, %69 ]
    %70 = load float, float* %lsr.iv13, align 4, !tbaa !6
    %71 = icmp sgt i32 %x_edge.013, -1
    %72 = select i1 %71, i32 %x_edge.013, i32 %lsr.iv6
    %73 = sub nsw i32 %4, %72
    %74 = icmp sgt i32 %73, -1
    %75 = sub nsw i32 0, %73
    %76 = select i1 %74, i32 %73, i32 %75
    %77 = add nsw i32 %76, %68
    %78 = getelementptr inbounds float, float* %result, i32 %77
    %79 = load float, float* %78, align 4, !tbaa !6
    %80 = fadd float %70, %79
    store float %80, float* %78, align 4, !tbaa !6
    %81 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv6, -1
    %lsr.iv.next8 = add i32 %lsr.iv7, -1
    %scevgep14 = getelementptr float, float* %lsr.iv13, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next8, 0
    br i1 %exitcond, label %._crit_edge, label %69
  
  ._crit_edge:                                      ; preds = %69, %.lr.ph18
    %82 = bitcast float* %lsr.iv10 to i1*
    %83 = add nsw i32 %y_filt.015, %x_dim
    %84 = add nsw i32 %y_edge.016, %x_dim
    %scevgep12 = getelementptr i1, i1* %82, i32 %58
    %85 = bitcast i1* %scevgep12 to float*
    %86 = icmp slt i32 %83, %y_stop.0
    br i1 %86, label %.lr.ph18, label %._crit_edge19
  
  ._crit_edge19:                                    ; preds = %._crit_edge, %53
    %87 = icmp eq i32 %f_or_e, 1
    br i1 %87, label %88, label %.loopexit
  
  ; <label>:88                                      ; preds = %._crit_edge19
    %89 = icmp sgt i32 %x_pos, -1
    %90 = sub nsw i32 0, %x_pos
    %91 = select i1 %89, i32 %x_pos, i32 %90
    %92 = icmp ne i32 %91, %28
    %93 = icmp ne i32 %x_pos, 0
    %or.cond = and i1 %93, %92
    %94 = icmp slt i32 %4, %1
    %or.cond24 = and i1 %or.cond, %94
    br i1 %or.cond24, label %.lr.ph11.preheader, label %.loopexit8
  
  .lr.ph11.preheader:                               ; preds = %88
    %scevgep2 = getelementptr float, float* %result, i32 %4
    %95 = shl i32 %x_dim, 2
    br label %.lr.ph11
  
  .lr.ph11:                                         ; preds = %.lr.ph11, %.lr.ph11.preheader
    %lsr.iv3 = phi float* [ %99, %.lr.ph11 ], [ %scevgep2, %.lr.ph11.preheader ]
    %y_filt.110 = phi i32 [ %98, %.lr.ph11 ], [ %4, %.lr.ph11.preheader ]
    %lsr.iv34 = bitcast float* %lsr.iv3 to i1*
    %96 = load float, float* %lsr.iv3, align 4, !tbaa !6
    %97 = fadd float %96, %96
    store float %97, float* %lsr.iv3, align 4, !tbaa !6
    %98 = add nsw i32 %y_filt.110, %x_dim
    %scevgep5 = getelementptr i1, i1* %lsr.iv34, i32 %95
    %99 = bitcast i1* %scevgep5 to float*
    %100 = icmp slt i32 %98, %1
    br i1 %100, label %.lr.ph11, label %.loopexit8
  
  .loopexit8:                                       ; preds = %.lr.ph11, %88
    %101 = icmp sgt i32 %y_pos, -1
    %102 = sub nsw i32 0, %y_pos
    %103 = select i1 %101, i32 %y_pos, i32 %102
    %104 = icmp ne i32 %103, %30
    %105 = icmp ne i32 %y_pos, 0
    %or.cond3 = and i1 %105, %104
    br i1 %or.cond3, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %.loopexit8
    %106 = add nsw i32 %8, %x_dim
    %107 = icmp sgt i32 %x_dim, 0
    br i1 %107, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %scevgep = getelementptr float, float* %result, i32 %8
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv = phi float* [ %scevgep1, %.lr.ph ], [ %scevgep, %.lr.ph.preheader ]
    %x_filt.19 = phi i32 [ %110, %.lr.ph ], [ %8, %.lr.ph.preheader ]
    %108 = load float, float* %lsr.iv, align 4, !tbaa !6
    %109 = fadd float %108, %108
    store float %109, float* %lsr.iv, align 4, !tbaa !6
    %110 = add nsw i32 %x_filt.19, 1
    %scevgep1 = getelementptr float, float* %lsr.iv, i32 1
    %111 = icmp slt i32 %110, %106
    br i1 %111, label %.lr.ph, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %.preheader, %.loopexit8, %._crit_edge19
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @extend(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    %3 = add nsw i32 %x_dim, -1
    %4 = select i1 %2, i32 %3, i32 0
    %5 = icmp sgt i32 %y_pos, 0
    %6 = add nsw i32 %y_dim, -1
    %7 = mul nsw i32 %6, %x_dim
    %8 = select i1 %5, i32 %7, i32 0
    br i1 %2, label %9, label %11
  
  ; <label>:9                                       ; preds = %0
    %10 = sub nsw i32 %x_pos, %x_dim
    br label %15
  
  ; <label>:11                                      ; preds = %0
    %12 = icmp slt i32 %x_pos, -1
    %13 = add nsw i32 %x_pos, 1
    %14 = select i1 %12, i32 %13, i32 0
    br label %15
  
  ; <label>:15                                      ; preds = %11, %9
    %16 = phi i32 [ %10, %9 ], [ %14, %11 ]
    %17 = icmp sgt i32 %y_pos, 0
    br i1 %17, label %18, label %20
  
  ; <label>:18                                      ; preds = %15
    %19 = sub nsw i32 %y_pos, %y_dim
    br label %24
  
  ; <label>:20                                      ; preds = %15
    %21 = icmp slt i32 %y_pos, -1
    %22 = add nsw i32 %y_pos, 1
    %23 = select i1 %21, i32 %22, i32 0
    br label %24
  
  ; <label>:24                                      ; preds = %20, %18
    %25 = phi i32 [ %19, %18 ], [ %23, %20 ]
    %26 = mul nsw i32 %25, %x_dim
    %27 = sdiv i32 %x_dim, 2
    %28 = add nsw i32 %27, 1
    %29 = sdiv i32 %y_dim, 2
    %30 = add nsw i32 %29, 1
    %31 = icmp sgt i32 %1, 0
    br i1 %31, label %.lr.ph21.preheader, label %._crit_edge22
  
  .lr.ph21.preheader:                               ; preds = %24
    %32 = bitcast float* %result to i8*
    %33 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 %33, i32 4, i1 false)
    br label %._crit_edge22
  
  ._crit_edge22:                                    ; preds = %.lr.ph21.preheader, %24
    %34 = icmp eq i32 %f_or_e, 1
    br i1 %34, label %35, label %53
  
  ; <label>:35                                      ; preds = %._crit_edge22
    %36 = icmp eq i32 %28, %x_pos
    br i1 %36, label %37, label %40
  
  ; <label>:37                                      ; preds = %35
    %38 = add nsw i32 %x_dim, 1
    %39 = sdiv i32 %38, 2
    br label %43
  
  ; <label>:40                                      ; preds = %35
    %41 = xor i32 %27, -1
    %42 = icmp eq i32 %x_pos, %41
    %. = select i1 %42, i32 0, i32 %16
    %.3 = select i1 %42, i32 %27, i32 0
    br label %43
  
  ; <label>:43                                      ; preds = %40, %37
    %x_stop.0 = phi i32 [ %39, %37 ], [ %x_dim, %40 ]
    %x_edge_dist.0 = phi i32 [ %16, %37 ], [ %., %40 ]
    %x_start.0 = phi i32 [ 0, %37 ], [ %.3, %40 ]
    %44 = icmp eq i32 %30, %y_pos
    br i1 %44, label %45, label %49
  
  ; <label>:45                                      ; preds = %43
    %46 = add nsw i32 %y_dim, 1
    %47 = sdiv i32 %46, 2
    %48 = mul nsw i32 %47, %x_dim
    br label %53
  
  ; <label>:49                                      ; preds = %43
    %50 = xor i32 %29, -1
    %51 = icmp eq i32 %y_pos, %50
    %52 = mul nsw i32 %29, %x_dim
    %.4 = select i1 %51, i32 0, i32 %26
    %.5 = select i1 %51, i32 %52, i32 0
    br label %53
  
  ; <label>:53                                      ; preds = %49, %45, %._crit_edge22
    %y_stop.0 = phi i32 [ %48, %45 ], [ %1, %._crit_edge22 ], [ %1, %49 ]
    %x_stop.1 = phi i32 [ %x_stop.0, %45 ], [ %x_dim, %._crit_edge22 ], [ %x_stop.0, %49 ]
    %x_edge_dist.1 = phi i32 [ %x_edge_dist.0, %45 ], [ %16, %._crit_edge22 ], [ %x_edge_dist.0, %49 ]
    %y_edge_dist.0 = phi i32 [ %26, %45 ], [ %26, %._crit_edge22 ], [ %.4, %49 ]
    %y_start.0 = phi i32 [ 0, %45 ], [ 0, %._crit_edge22 ], [ %.5, %49 ]
    %x_start.1 = phi i32 [ %x_start.0, %45 ], [ 0, %._crit_edge22 ], [ %x_start.0, %49 ]
    %54 = icmp slt i32 %y_start.0, %y_stop.0
    br i1 %54, label %.lr.ph17, label %._crit_edge18
  
  .lr.ph17:                                         ; preds = %53
    %55 = sub i32 0, %x_edge_dist.1
    %56 = sub i32 %x_stop.1, %x_start.1
    %57 = add i32 %y_start.0, %x_start.1
    %scevgep = getelementptr float, float* %filt, i32 %57
    %58 = shl i32 %x_dim, 2
    br label %59
  
  ; <label>:59                                      ; preds = %._crit_edge, %.lr.ph17
    %lsr.iv3 = phi float* [ %117, %._crit_edge ], [ %scevgep, %.lr.ph17 ]
    %y_edge.015 = phi i32 [ %y_edge_dist.0, %.lr.ph17 ], [ %116, %._crit_edge ]
    %y_filt.014 = phi i32 [ %y_start.0, %.lr.ph17 ], [ %115, %._crit_edge ]
    %60 = add nsw i32 %y_filt.014, %x_start.1
    %61 = add nsw i32 %y_filt.014, %x_stop.1
    %62 = icmp slt i32 %60, %61
    br i1 %62, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %59
    %63 = icmp ne i32 %8, 0
    %64 = icmp sgt i32 %y_edge.015, 0
    %65 = icmp slt i32 %y_edge.015, 0
    %not. = xor i1 %64, true
    %66 = and i1 %65, %not.
    %67 = select i1 %63, i1 %64, i1 %66
    %68 = icmp sgt i32 %y_edge.015, -1
    %69 = sub nsw i32 0, %y_edge.015
    %70 = select i1 %68, i32 %y_edge.015, i32 %69
    %71 = sub nsw i32 %8, %70
    %72 = icmp sgt i32 %71, -1
    %73 = sub nsw i32 0, %71
    %74 = select i1 %72, i32 %71, i32 %73
    %75 = add nsw i32 %y_edge.015, %8
    %76 = icmp slt i32 %75, 0
    %77 = icmp slt i32 %75, %y_dim
    %.10 = select i1 %77, i32 %75, i32 %6
    %78 = select i1 %76, i32 0, i32 %.10
    br label %79
  
  ; <label>:79                                      ; preds = %112, %.lr.ph
    %lsr.iv6 = phi float* [ %scevgep7, %112 ], [ %lsr.iv3, %.lr.ph ]
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %112 ], [ %56, %.lr.ph ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %112 ], [ %55, %.lr.ph ]
    %x_edge.013 = phi i32 [ %x_edge_dist.1, %.lr.ph ], [ %113, %112 ]
    %80 = icmp ne i32 %4, 0
    %81 = icmp sgt i32 %x_edge.013, 0
    %82 = icmp slt i32 %x_edge.013, 0
    %not.11 = xor i1 %81, true
    %83 = and i1 %82, %not.11
    %84 = select i1 %80, i1 %81, i1 %83
    %85 = xor i1 %67, %84
    %86 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %87 = icmp sgt i32 %x_edge.013, -1
    %88 = select i1 %87, i32 %x_edge.013, i32 %lsr.iv
    %89 = sub nsw i32 %4, %88
    %90 = icmp sgt i32 %89, -1
    %91 = sub nsw i32 0, %89
    %92 = select i1 %90, i32 %89, i32 %91
    %93 = add nsw i32 %92, %74
    %94 = getelementptr inbounds float, float* %result, i32 %93
    %95 = load float, float* %94, align 4, !tbaa !6
    br i1 %85, label %96, label %110
  
  ; <label>:96                                      ; preds = %79
    %97 = fsub float %95, %86
    store float %97, float* %94, align 4, !tbaa !6
    %98 = load float, float* %lsr.iv6, align 4, !tbaa !6
    %99 = fadd float %98, %98
    %100 = add i32 %4, %x_edge.013
    %101 = icmp slt i32 %100, 0
    %102 = add i32 %4, %x_edge.013
    %103 = icmp slt i32 %102, %x_dim
    %104 = add i32 %4, %x_edge.013
    %.9 = select i1 %103, i32 %104, i32 %3
    %105 = select i1 %101, i32 0, i32 %.9
    %106 = add nsw i32 %105, %78
    %107 = getelementptr inbounds float, float* %result, i32 %106
    %108 = load float, float* %107, align 4, !tbaa !6
    %109 = fadd float %108, %99
    store float %109, float* %107, align 4, !tbaa !6
    br label %112
  
  ; <label>:110                                     ; preds = %79
    %111 = fadd float %86, %95
    store float %111, float* %94, align 4, !tbaa !6
    br label %112
  
  ; <label>:112                                     ; preds = %110, %96
    %113 = add nsw i32 %x_edge.013, 1
    %lsr.iv.next = add i32 %lsr.iv, -1
    %lsr.iv.next2 = add i32 %lsr.iv1, -1
    %scevgep7 = getelementptr float, float* %lsr.iv6, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next2, 0
    br i1 %exitcond, label %._crit_edge, label %79
  
  ._crit_edge:                                      ; preds = %112, %59
    %114 = bitcast float* %lsr.iv3 to i1*
    %115 = add nsw i32 %y_filt.014, %x_dim
    %116 = add nsw i32 %y_edge.015, %x_dim
    %scevgep5 = getelementptr i1, i1* %114, i32 %58
    %117 = bitcast i1* %scevgep5 to float*
    %118 = icmp slt i32 %115, %y_stop.0
    br i1 %118, label %59, label %._crit_edge18
  
  ._crit_edge18:                                    ; preds = %._crit_edge, %53
    ret i32 undef
  }
  
  ; Function Attrs: norecurse nounwind
  define i32 @nocompute(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %x_pos.off = add i32 %x_pos, 1
    %2 = icmp ugt i32 %x_pos.off, 2
    %y_pos.off = add i32 %y_pos, 1
    %3 = icmp ugt i32 %y_pos.off, 2
    %4 = or i1 %2, %3
    br i1 %4, label %.preheader, label %.preheader6
  
  .preheader6:                                      ; preds = %0
    %5 = icmp sgt i32 %1, 0
    br i1 %5, label %.lr.ph10.preheader, label %.loopexit
  
  .lr.ph10.preheader:                               ; preds = %.preheader6
    %6 = mul i32 %y_dim, %x_dim
    br label %.lr.ph10
  
  .preheader:                                       ; preds = %0
    %7 = icmp sgt i32 %1, 0
    br i1 %7, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %.preheader
    %8 = bitcast float* %result to i8*
    %9 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %8, i8 0, i32 %9, i32 4, i1 false)
    br label %.loopexit
  
  .lr.ph10:                                         ; preds = %.lr.ph10, %.lr.ph10.preheader
    %lsr.iv3 = phi float* [ %scevgep4, %.lr.ph10 ], [ %filt, %.lr.ph10.preheader ]
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph10 ], [ %result, %.lr.ph10.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph10 ], [ %6, %.lr.ph10.preheader ]
    %lsr.iv35 = bitcast float* %lsr.iv3 to i32*
    %lsr.iv12 = bitcast float* %lsr.iv1 to i32*
    %10 = load i32, i32* %lsr.iv35, align 4, !tbaa !6
    store i32 %10, i32* %lsr.iv12, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %scevgep4 = getelementptr float, float* %lsr.iv3, i32 1
    %exitcond12 = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond12, label %.loopexit, label %.lr.ph10
  
  .loopexit:                                        ; preds = %.lr.ph10, %.lr.ph.preheader, %.preheader, %.preheader6
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  define i32 @ereflect(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #0 {
    %1 = icmp sgt i32 %x_pos, 0
    %2 = add nsw i32 %x_dim, -1
    %3 = select i1 %1, i32 %2, i32 0
    %4 = icmp sgt i32 %y_pos, 0
    %5 = add nsw i32 %y_dim, -1
    %6 = select i1 %4, i32 %5, i32 0
    %7 = mul nsw i32 %6, %x_dim
    %8 = mul i32 %y_dim, %x_dim
    %9 = icmp sgt i32 %x_pos, 1
    br i1 %9, label %10, label %12
  
  ; <label>:10                                      ; preds = %0
    %11 = sub nsw i32 %x_pos, %x_dim
    br label %16
  
  ; <label>:12                                      ; preds = %0
    %13 = icmp slt i32 %x_pos, -1
    %14 = add nsw i32 %x_pos, 1
    %15 = select i1 %13, i32 %14, i32 0
    br label %16
  
  ; <label>:16                                      ; preds = %12, %10
    %17 = phi i32 [ %11, %10 ], [ %15, %12 ]
    %18 = icmp sgt i32 %y_pos, 1
    br i1 %18, label %19, label %21
  
  ; <label>:19                                      ; preds = %16
    %20 = sub nsw i32 %y_pos, %y_dim
    br label %25
  
  ; <label>:21                                      ; preds = %16
    %22 = icmp slt i32 %y_pos, -1
    %23 = add nsw i32 %y_pos, 1
    %24 = select i1 %22, i32 %23, i32 0
    br label %25
  
  ; <label>:25                                      ; preds = %21, %19
    %26 = phi i32 [ %20, %19 ], [ %24, %21 ]
    %27 = icmp sgt i32 %8, 0
    br i1 %27, label %.preheader3.preheader, label %._crit_edge27
  
  .preheader3.preheader:                            ; preds = %25
    %28 = bitcast float* %result to i8*
    %29 = mul nsw i32 %26, %x_dim
    %30 = shl i32 %8, 2
    call void @llvm.memset.p0i8.i32(i8* %28, i8 0, i32 %30, i32 4, i1 false)
    %31 = shl i32 %x_dim, 2
    %32 = sub i32 0, %17
    br label %.preheader3
  
  .preheader3:                                      ; preds = %._crit_edge23, %.preheader3.preheader
    %lsr.iv19 = phi float* [ %60, %._crit_edge23 ], [ %filt, %.preheader3.preheader ]
    %y_filt.026 = phi i32 [ %34, %._crit_edge23 ], [ 0, %.preheader3.preheader ]
    %y_edge.025 = phi i32 [ %59, %._crit_edge23 ], [ %29, %.preheader3.preheader ]
    %33 = icmp sgt i32 %x_dim, 0
    %34 = add nsw i32 %y_filt.026, %x_dim
    br i1 %33, label %.lr.ph22, label %._crit_edge23
  
  .lr.ph22:                                         ; preds = %.preheader3
    %35 = icmp sgt i32 %y_edge.025, -1
    %36 = sub nsw i32 0, %y_edge.025
    %37 = select i1 %35, i32 %y_edge.025, i32 %36
    %38 = sub nsw i32 %7, %37
    %39 = icmp sgt i32 %38, -1
    %40 = sub nsw i32 0, %38
    %41 = select i1 %39, i32 %38, i32 %40
    br label %42
  
  ; <label>:42                                      ; preds = %42, %.lr.ph22
    %lsr.iv24 = phi i32 [ %lsr.iv.next25, %42 ], [ %32, %.lr.ph22 ]
    %lsr.iv22 = phi float* [ %scevgep23, %42 ], [ %lsr.iv19, %.lr.ph22 ]
    %lsr.iv17 = phi i32 [ %lsr.iv.next18, %42 ], [ 0, %.lr.ph22 ]
    %43 = load float, float* %lsr.iv22, align 4, !tbaa !6
    %44 = add i32 %17, %lsr.iv17
    %45 = icmp sgt i32 %44, -1
    %46 = add i32 %17, %lsr.iv17
    %47 = select i1 %45, i32 %46, i32 %lsr.iv24
    %48 = sub nsw i32 %3, %47
    %49 = icmp sgt i32 %48, -1
    %50 = sub nsw i32 0, %48
    %51 = select i1 %49, i32 %48, i32 %50
    %52 = add nsw i32 %51, %41
    %53 = getelementptr inbounds float, float* %result, i32 %52
    %54 = load float, float* %53, align 4, !tbaa !6
    %55 = fadd float %43, %54
    store float %55, float* %53, align 4, !tbaa !6
    %lsr.iv.next18 = add i32 %lsr.iv17, 1
    %56 = add i32 %y_filt.026, %lsr.iv.next18
    %scevgep23 = getelementptr float, float* %lsr.iv22, i32 1
    %lsr.iv.next25 = add i32 %lsr.iv24, -1
    %57 = icmp slt i32 %56, %34
    br i1 %57, label %42, label %._crit_edge23
  
  ._crit_edge23:                                    ; preds = %42, %.preheader3
    %58 = bitcast float* %lsr.iv19 to i1*
    %59 = add nsw i32 %y_edge.025, %x_dim
    %scevgep21 = getelementptr i1, i1* %58, i32 %31
    %60 = bitcast i1* %scevgep21 to float*
    %61 = icmp slt i32 %34, %8
    br i1 %61, label %.preheader3, label %._crit_edge27
  
  ._crit_edge27:                                    ; preds = %._crit_edge23, %25
    %62 = icmp ne i32 %x_pos, 0
    %63 = icmp slt i32 %3, %8
    %or.cond = and i1 %62, %63
    br i1 %or.cond, label %.lr.ph19.preheader, label %.loopexit
  
  .lr.ph19.preheader:                               ; preds = %._crit_edge27
    %scevgep13 = getelementptr float, float* %result, i32 %3
    %64 = shl i32 %x_dim, 2
    br label %.lr.ph19
  
  .lr.ph19:                                         ; preds = %.lr.ph19, %.lr.ph19.preheader
    %lsr.iv14 = phi float* [ %70, %.lr.ph19 ], [ %scevgep13, %.lr.ph19.preheader ]
    %y_filt.118 = phi i32 [ %69, %.lr.ph19 ], [ %3, %.lr.ph19.preheader ]
    %lsr.iv1415 = bitcast float* %lsr.iv14 to i1*
    %65 = load float, float* %lsr.iv14, align 4, !tbaa !6
    %66 = fpext float %65 to double
    %67 = fmul double %66, 0x3FF6A09E667F3BCD
    %68 = fptrunc double %67 to float
    store float %68, float* %lsr.iv14, align 4, !tbaa !6
    %69 = add nsw i32 %y_filt.118, %x_dim
    %scevgep16 = getelementptr i1, i1* %lsr.iv1415, i32 %64
    %70 = bitcast i1* %scevgep16 to float*
    %71 = icmp slt i32 %69, %8
    br i1 %71, label %.lr.ph19, label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph19, %._crit_edge27
    %72 = icmp eq i32 %y_pos, 0
    br i1 %72, label %.preheader, label %.preheader1
  
  .preheader1:                                      ; preds = %.loopexit
    %73 = add nsw i32 %7, %x_dim
    %74 = icmp sgt i32 %x_dim, 0
    br i1 %74, label %.lr.ph17.preheader, label %.preheader
  
  .lr.ph17.preheader:                               ; preds = %.preheader1
    %75 = mul i32 %6, %x_dim
    %scevgep10 = getelementptr float, float* %result, i32 %75
    br label %.lr.ph17
  
  .preheader:                                       ; preds = %.lr.ph17, %.preheader1, %.loopexit
    %76 = icmp sgt i32 %8, 0
    br i1 %76, label %.lr.ph13.preheader, label %._crit_edge14.thread
  
  .lr.ph13.preheader:                               ; preds = %.preheader
    %77 = mul i32 %y_dim, %x_dim
    br label %.lr.ph13
  
  ._crit_edge14.thread:                             ; preds = %.preheader
    %78 = tail call double @sqrt(double 0.000000e+00) #5
    %79 = fcmp oeq double %78, %78
    br i1 %79, label %._crit_edge10.thread, label %call.sqrt
  
  call.sqrt:                                        ; preds = %._crit_edge14.thread
    %80 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge10.thread
  
  .lr.ph17:                                         ; preds = %.lr.ph17, %.lr.ph17.preheader
    %lsr.iv11 = phi float* [ %scevgep12, %.lr.ph17 ], [ %scevgep10, %.lr.ph17.preheader ]
    %x_filt.116 = phi i32 [ %85, %.lr.ph17 ], [ %7, %.lr.ph17.preheader ]
    %81 = load float, float* %lsr.iv11, align 4, !tbaa !6
    %82 = fpext float %81 to double
    %83 = fmul double %82, 0x3FF6A09E667F3BCD
    %84 = fptrunc double %83 to float
    store float %84, float* %lsr.iv11, align 4, !tbaa !6
    %85 = add nsw i32 %x_filt.116, 1
    %scevgep12 = getelementptr float, float* %lsr.iv11, i32 1
    %86 = icmp slt i32 %85, %73
    br i1 %86, label %.lr.ph17, label %.preheader
  
  .lr.ph13:                                         ; preds = %.lr.ph13, %.lr.ph13.preheader
    %lsr.iv8 = phi float* [ %scevgep9, %.lr.ph13 ], [ %result, %.lr.ph13.preheader ]
    %lsr.iv6 = phi i32 [ %lsr.iv.next7, %.lr.ph13 ], [ %77, %.lr.ph13.preheader ]
    %norm.012 = phi double [ %90, %.lr.ph13 ], [ 0.000000e+00, %.lr.ph13.preheader ]
    %87 = load float, float* %lsr.iv8, align 4, !tbaa !6
    %88 = fmul float %87, %87
    %89 = fpext float %88 to double
    %90 = fadd double %norm.012, %89
    %lsr.iv.next7 = add i32 %lsr.iv6, -1
    %scevgep9 = getelementptr float, float* %lsr.iv8, i32 1
    %exitcond33 = icmp eq i32 %lsr.iv.next7, 0
    br i1 %exitcond33, label %._crit_edge14, label %.lr.ph13
  
  ._crit_edge14:                                    ; preds = %.lr.ph13
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %._crit_edge14.split, label %call.sqrt26
  
  call.sqrt26:                                      ; preds = %._crit_edge14
    %93 = tail call double @sqrt(double %90) #6
    br label %._crit_edge14.split
  
  ._crit_edge14.split:                              ; preds = %._crit_edge14, %call.sqrt26
    %94 = phi double [ %91, %._crit_edge14 ], [ %93, %call.sqrt26 ]
    %95 = icmp sgt i32 %8, 0
    br i1 %95, label %.lr.ph9.preheader, label %._crit_edge10.thread
  
  .lr.ph9.preheader:                                ; preds = %._crit_edge14.split
    %96 = mul i32 %y_dim, %x_dim
    br label %.lr.ph9
  
  .lr.ph9:                                          ; preds = %.lr.ph9, %.lr.ph9.preheader
    %lsr.iv4 = phi float* [ %scevgep5, %.lr.ph9 ], [ %filt, %.lr.ph9.preheader ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %.lr.ph9 ], [ %96, %.lr.ph9.preheader ]
    %onorm.07 = phi double [ %100, %.lr.ph9 ], [ 0.000000e+00, %.lr.ph9.preheader ]
    %97 = load float, float* %lsr.iv4, align 4, !tbaa !6
    %98 = fmul float %97, %97
    %99 = fpext float %98 to double
    %100 = fadd double %onorm.07, %99
    %lsr.iv.next3 = add i32 %lsr.iv2, -1
    %scevgep5 = getelementptr float, float* %lsr.iv4, i32 1
    %exitcond32 = icmp eq i32 %lsr.iv.next3, 0
    br i1 %exitcond32, label %._crit_edge10, label %.lr.ph9
  
  ._crit_edge10.thread:                             ; preds = %call.sqrt, %._crit_edge14.thread, %._crit_edge14.split
    %101 = tail call double @sqrt(double 0.000000e+00) #5
    %102 = fcmp oeq double %101, %101
    br i1 %102, label %._crit_edge, label %call.sqrt27
  
  call.sqrt27:                                      ; preds = %._crit_edge10.thread
    %103 = tail call double @sqrt(double 0.000000e+00) #6
    br label %._crit_edge
  
  ._crit_edge10:                                    ; preds = %.lr.ph9
    %104 = tail call double @sqrt(double %100) #5
    %105 = fcmp oeq double %104, %104
    br i1 %105, label %._crit_edge10.split, label %call.sqrt28
  
  call.sqrt28:                                      ; preds = %._crit_edge10
    %106 = tail call double @sqrt(double %100) #6
    br label %._crit_edge10.split
  
  ._crit_edge10.split:                              ; preds = %._crit_edge10, %call.sqrt28
    %107 = phi double [ %104, %._crit_edge10 ], [ %106, %call.sqrt28 ]
    %108 = icmp sgt i32 %8, 0
    %109 = fdiv double %94, %107
    br i1 %108, label %.lr.ph.preheader, label %._crit_edge
  
  .lr.ph.preheader:                                 ; preds = %._crit_edge10.split
    %110 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %110, %.lr.ph.preheader ]
    %111 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %112 = fpext float %111 to double
    %113 = fdiv double %112, %109
    %114 = fptrunc double %113 to float
    store float %114, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %call.sqrt27, %._crit_edge10.thread, %._crit_edge10.split
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  ; Function Attrs: norecurse nounwind
  define i32 @predict(float* nocapture readonly %filt, i32 signext %x_dim, i32 signext %y_dim, i32 signext %x_pos, i32 signext %y_pos, float* nocapture %result, i32 signext %f_or_e) #2 {
    %1 = mul i32 %y_dim, %x_dim
    %2 = icmp sgt i32 %x_pos, 0
    br i1 %2, label %3, label %5
  
  ; <label>:3                                       ; preds = %0
    %4 = add nsw i32 %x_pos, -1
    br label %9
  
  ; <label>:5                                       ; preds = %0
    %6 = icmp slt i32 %x_pos, 0
    %7 = add nsw i32 %x_pos, 1
    %8 = select i1 %6, i32 %7, i32 0
    br label %9
  
  ; <label>:9                                       ; preds = %5, %3
    %10 = phi i32 [ %4, %3 ], [ %8, %5 ]
    %11 = icmp sgt i32 %y_pos, 0
    br i1 %11, label %12, label %14
  
  ; <label>:12                                      ; preds = %9
    %13 = add nsw i32 %y_pos, -1
    br label %18
  
  ; <label>:14                                      ; preds = %9
    %15 = icmp slt i32 %y_pos, 0
    %16 = add nsw i32 %y_pos, 1
    %17 = select i1 %15, i32 %16, i32 0
    br label %18
  
  ; <label>:18                                      ; preds = %14, %12
    %19 = phi i32 [ %13, %12 ], [ %17, %14 ]
    %20 = icmp sgt i32 %1, 0
    br i1 %20, label %.lr.ph12.preheader, label %._crit_edge
  
  .lr.ph12.preheader:                               ; preds = %18
    %21 = bitcast float* %result to i8*
    %22 = mul nsw i32 %19, %x_dim
    %23 = shl i32 %1, 2
    call void @llvm.memset.p0i8.i32(i8* %21, i8 0, i32 %23, i32 4, i1 false)
    %24 = shl i32 %x_dim, 2
    %25 = add i32 %10, %22
    %scevgep10 = getelementptr float, float* %result, i32 %25
    br label %.lr.ph12
  
  .lr.ph12:                                         ; preds = %.loopexit2, %.lr.ph12.preheader
    %lsr.iv11 = phi float* [ %45, %.loopexit2 ], [ %scevgep10, %.lr.ph12.preheader ]
    %lsr.iv4 = phi float* [ %44, %.loopexit2 ], [ %filt, %.lr.ph12.preheader ]
    %y_filt.011 = phi i32 [ %27, %.loopexit2 ], [ 0, %.lr.ph12.preheader ]
    %y_res.010 = phi i32 [ %43, %.loopexit2 ], [ %22, %.lr.ph12.preheader ]
    %taps_used.09 = phi float [ %taps_used.3, %.loopexit2 ], [ 0.000000e+00, %.lr.ph12.preheader ]
    %26 = icmp slt i32 %x_dim, 1
    %27 = add nsw i32 %y_filt.011, %x_dim
    %notlhs = icmp slt i32 %y_res.010, 0
    %notrhs = icmp sge i32 %y_res.010, %1
    %or.cond.not = or i1 %notrhs, %notlhs
    %brmerge = or i1 %or.cond.not, %26
    br i1 %brmerge, label %.loopexit2, label %.lr.ph8
  
  .lr.ph8:                                          ; preds = %.lr.ph12, %38
    %lsr.iv14 = phi float* [ %scevgep15, %38 ], [ %lsr.iv11, %.lr.ph12 ]
    %lsr.iv7 = phi float* [ %scevgep8, %38 ], [ %lsr.iv4, %.lr.ph12 ]
    %lsr.iv2 = phi i32 [ %lsr.iv.next3, %38 ], [ 0, %.lr.ph12 ]
    %taps_used.15 = phi float [ %taps_used.2, %38 ], [ %taps_used.09, %.lr.ph12 ]
    %28 = add i32 %10, %lsr.iv2
    %29 = icmp sgt i32 %28, -1
    %30 = add i32 %10, %lsr.iv2
    %31 = icmp slt i32 %30, %x_dim
    %or.cond1 = and i1 %29, %31
    br i1 %or.cond1, label %32, label %38
  
  ; <label>:32                                      ; preds = %.lr.ph8
    %33 = bitcast float* %lsr.iv7 to i32*
    %34 = bitcast float* %lsr.iv14 to i32*
    %35 = load i32, i32* %33, align 4, !tbaa !6
    store i32 %35, i32* %34, align 4, !tbaa !6
    %36 = load float, float* %lsr.iv7, align 4, !tbaa !6
    %37 = fadd float %taps_used.15, %36
    br label %38
  
  ; <label>:38                                      ; preds = %32, %.lr.ph8
    %taps_used.2 = phi float [ %37, %32 ], [ %taps_used.15, %.lr.ph8 ]
    %lsr.iv.next3 = add i32 %lsr.iv2, 1
    %39 = add i32 %y_filt.011, %lsr.iv.next3
    %scevgep8 = getelementptr float, float* %lsr.iv7, i32 1
    %scevgep15 = getelementptr float, float* %lsr.iv14, i32 1
    %40 = icmp slt i32 %39, %27
    br i1 %40, label %.lr.ph8, label %.loopexit2
  
  .loopexit2:                                       ; preds = %38, %.lr.ph12
    %taps_used.3 = phi float [ %taps_used.09, %.lr.ph12 ], [ %taps_used.2, %38 ]
    %41 = bitcast float* %lsr.iv4 to i1*
    %42 = bitcast float* %lsr.iv11 to i1*
    %43 = add nsw i32 %y_res.010, %x_dim
    %scevgep6 = getelementptr i1, i1* %41, i32 %24
    %44 = bitcast i1* %scevgep6 to float*
    %scevgep13 = getelementptr i1, i1* %42, i32 %24
    %45 = bitcast i1* %scevgep13 to float*
    %46 = icmp slt i32 %27, %1
    br i1 %46, label %.lr.ph12, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.loopexit2, %18
    %taps_used.0.lcssa = phi float [ 0.000000e+00, %18 ], [ %taps_used.3, %.loopexit2 ]
    %47 = icmp eq i32 %f_or_e, 0
    br i1 %47, label %48, label %.loopexit
  
  ; <label>:48                                      ; preds = %._crit_edge
    %49 = icmp sgt i32 %1, 0
    %50 = fdiv float 2.000000e+00, %taps_used.0.lcssa
    br i1 %49, label %.lr.ph.preheader, label %.loopexit
  
  .lr.ph.preheader:                                 ; preds = %48
    %51 = mul i32 %y_dim, %x_dim
    br label %.lr.ph
  
  .lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader
    %lsr.iv1 = phi float* [ %scevgep, %.lr.ph ], [ %result, %.lr.ph.preheader ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ %51, %.lr.ph.preheader ]
    %52 = load float, float* %lsr.iv1, align 4, !tbaa !6
    %53 = fmul float %50, %52
    store float %53, float* %lsr.iv1, align 4, !tbaa !6
    %lsr.iv.next = add i32 %lsr.iv, -1
    %scevgep = getelementptr float, float* %lsr.iv1, i32 1
    %exitcond = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %.lr.ph, %48, %._crit_edge
    ret i32 undef
  }
  
  ; Function Attrs: nounwind
  declare i32 @puts(i8* nocapture) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #4
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { nounwind "target-cpu"="mips32" }
  attributes #4 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #5 = { nounwind readnone }
  attributes #6 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"", !3, i64 0, !3, i64 4}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !7, i64 0}
  !7 = !{!"float", !4, i64 0}

...
---
name:            ereflect
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: afgr64 }
  - { id: 42, class: afgr64 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: afgr64 }
  - { id: 46, class: afgr64 }
  - { id: 47, class: afgr64 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: afgr64 }
  - { id: 52, class: afgr64 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: afgr64 }
  - { id: 56, class: afgr64 }
  - { id: 57, class: afgr64 }
  - { id: 58, class: afgr64 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: gpr32 }
  - { id: 75, class: gpr32 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: gpr32 }
  - { id: 78, class: gpr32 }
  - { id: 79, class: gpr32 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: gpr32 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: gpr32 }
  - { id: 84, class: gpr32 }
  - { id: 85, class: gpr32 }
  - { id: 86, class: gpr32 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: gpr32 }
  - { id: 89, class: gpr32 }
  - { id: 90, class: gpr32 }
  - { id: 91, class: gpr32 }
  - { id: 92, class: gpr32 }
  - { id: 93, class: gpr32 }
  - { id: 94, class: gpr32 }
  - { id: 95, class: gpr32 }
  - { id: 96, class: gpr32 }
  - { id: 97, class: gpr32 }
  - { id: 98, class: gpr32 }
  - { id: 99, class: gpr32 }
  - { id: 100, class: gpr32 }
  - { id: 101, class: gpr32 }
  - { id: 102, class: fgr32 }
  - { id: 103, class: gpr32 }
  - { id: 104, class: gpr32 }
  - { id: 105, class: gpr32 }
  - { id: 106, class: fgr32 }
  - { id: 107, class: fgr32 }
  - { id: 108, class: gpr32 }
  - { id: 109, class: gpr32 }
  - { id: 110, class: gpr32 }
  - { id: 111, class: gpr32 }
  - { id: 112, class: afgr64 }
  - { id: 113, class: fgr32 }
  - { id: 114, class: afgr64 }
  - { id: 115, class: afgr64 }
  - { id: 116, class: gpr32 }
  - { id: 117, class: fgr32 }
  - { id: 118, class: gpr32 }
  - { id: 119, class: gpr32 }
  - { id: 120, class: gpr32 }
  - { id: 121, class: afgr64 }
  - { id: 122, class: fgr32 }
  - { id: 123, class: afgr64 }
  - { id: 124, class: afgr64 }
  - { id: 125, class: gpr32 }
  - { id: 126, class: fgr32 }
  - { id: 127, class: gpr32 }
  - { id: 128, class: afgr64 }
  - { id: 129, class: afgr64 }
  - { id: 130, class: gpr32 }
  - { id: 131, class: afgr64 }
  - { id: 132, class: gpr32 }
  - { id: 133, class: afgr64 }
  - { id: 134, class: afgr64 }
  - { id: 135, class: gpr32 }
  - { id: 136, class: fgr32 }
  - { id: 137, class: fgr32 }
  - { id: 138, class: afgr64 }
  - { id: 139, class: gpr32 }
  - { id: 140, class: afgr64 }
  - { id: 141, class: gpr32 }
  - { id: 142, class: afgr64 }
  - { id: 143, class: afgr64 }
  - { id: 144, class: gpr32 }
  - { id: 145, class: afgr64 }
  - { id: 146, class: gpr32 }
  - { id: 147, class: afgr64 }
  - { id: 148, class: afgr64 }
  - { id: 149, class: gpr32 }
  - { id: 150, class: fgr32 }
  - { id: 151, class: fgr32 }
  - { id: 152, class: afgr64 }
  - { id: 153, class: gpr32 }
  - { id: 154, class: afgr64 }
  - { id: 155, class: fgr32 }
  - { id: 156, class: afgr64 }
  - { id: 157, class: afgr64 }
  - { id: 158, class: fgr32 }
  - { id: 159, class: gpr32 }
  - { id: 160, class: gpr32 }
  - { id: 161, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%64' }
  - { reg: '%a1', virtual-reg: '%65' }
  - { reg: '%a2', virtual-reg: '%66' }
  - { reg: '%a3', virtual-reg: '%67' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 24, size: 4, alignment: 8, isImmutable: true, isAliased: false }
  - { id: 1, offset: 20, size: 4, alignment: 4, isImmutable: true, isAliased: false }
  - { id: 2, offset: 16, size: 4, alignment: 8, isImmutable: true, isAliased: false }
constants:       
  - id:              0
    value:           double 0x3FF6A09E667F3BCD
    alignment:       8
body:             |
  bb.0 (%ir-block.0, freq 56):
    successors: %bb.1(50), %bb.2(50)
    liveins: %a0, %a1, %a2, %a3, %t9, %v0
  
    %83 = ADDu %v0, %t9
    %67 = COPY %a3
    %66 = COPY %a2
    %65 = COPY %a1
    %64 = COPY %a0
    %70 = ADDiu %66, -1
    %68 = LW %fixed-stack.2, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    %71 = SLTi %68, 1
    %75 = SLTi %67, 2
    BNE killed %75, %zero, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.10, freq 28):
    successors: %bb.3(100)
  
    %4 = SUBu %67, %65
    B %bb.3, implicit-def dead %at
  
  bb.2 (%ir-block.12, freq 28):
    successors: %bb.3(100)
  
    %76 = ADDiu %67, 1
    %77 = SLTi %67, -1
    %5 = MOVZ_I_I %zero, killed %77, %76
  
  bb.3 (%ir-block.16, freq 56):
    successors: %bb.4(50), %bb.5(50)
  
    %6 = PHI %5, %bb.2, %4, %bb.1
    %1 = MOVN_I_I %zero, %71, %70
    %73 = ADDiu %65, -1
    %74 = SLTi %67, 1
    %3 = MUL %66, %65, implicit-def dead %hi0, implicit-def dead %lo0
    %79 = SLTi %68, 2
    BNE killed %79, %zero, %bb.5, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.19, freq 28):
    successors: %bb.6(100)
  
    %7 = SUBu %68, %66
    B %bb.6, implicit-def dead %at
  
  bb.5 (%ir-block.21, freq 28):
    successors: %bb.6(100)
  
    %80 = ADDiu %68, 1
    %81 = SLTi %68, -1
    %8 = MOVZ_I_I %zero, killed %81, %80
  
  bb.6 (%ir-block.25, freq 56):
    successors: %bb.7..preheader3.preheader(62), %bb.12.._crit_edge27(37)
  
    %9 = PHI %8, %bb.5, %7, %bb.4
    %2 = MUL %1, %65, implicit-def dead %hi0, implicit-def dead %lo0
    %0 = MOVN_I_I %zero, %74, %73
    %69 = LW %fixed-stack.1, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack)
    BLEZ %3, %bb.12.._crit_edge27, implicit-def dead %at
    B %bb.7..preheader3.preheader, implicit-def dead %at
  
  bb.7..preheader3.preheader (freq 35):
    successors: %bb.8..preheader3(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %85 = SLL %3, 2
    %86 = LW %83, target-flags(<unknown>) $memset, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry $memset)
    %84 = ADDiu %zero, 0
    %a0 = COPY %69
    %a1 = COPY %84
    %a2 = COPY %85
    %gp = COPY %83
    %t9 = COPY %86
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %10 = MUL %9, %65, implicit-def dead %hi0, implicit-def dead %lo0
    %12 = SUBu %zero, %6
    %11 = SLL %65, 2
  
  bb.8..preheader3 (freq 1137):
    successors: %bb.9..lr.ph22(62), %bb.11.._crit_edge23(37)
  
    %13 = PHI %64, %bb.7..preheader3.preheader, %25, %bb.11.._crit_edge23
    %14 = PHI %84, %bb.7..preheader3.preheader, %16, %bb.11.._crit_edge23
    %15 = PHI %10, %bb.7..preheader3.preheader, %24, %bb.11.._crit_edge23
    %16 = ADDu %14, %65
    BLEZ %65, %bb.11.._crit_edge23, implicit-def dead %at
    B %bb.9..lr.ph22, implicit-def dead %at
  
  bb.9..lr.ph22 (freq 711):
    successors: %bb.10(100)
  
    %88 = SRA %15, 31
    %89 = ADDu %15, %88
    %90 = XOR killed %89, %88
    %91 = SUBu %2, killed %90
    %92 = SRA %91, 31
    %93 = ADDu %91, %92
    %17 = XOR killed %93, %92
    %87 = ADDiu %zero, 0
  
  bb.10 (%ir-block.42, freq 22755):
    successors: %bb.10(96), %bb.11.._crit_edge23(3)
  
    %18 = PHI %12, %bb.9..lr.ph22, %23, %bb.10
    %19 = PHI %13, %bb.9..lr.ph22, %22, %bb.10
    %20 = PHI %87, %bb.9..lr.ph22, %21, %bb.10
    %94 = ADDu %6, %20
    %95 = SLTi %94, 0
    %96 = MOVZ_I_I %94, killed %95, %18
    %97 = SUBu %0, killed %96
    %98 = SRA %97, 31
    %99 = ADDu %97, %98
    %100 = XOR killed %99, %98
    %101 = ADDu killed %100, %17
    %23 = ADDiu %18, -1
    %22 = ADDiu %19, 4
    %21 = ADDiu %20, 1
    %102 = LWC1 %19, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv22, !tbaa !6)
    %103 = SLL killed %101, 2
    %104 = ADDu %14, %21
    %105 = SLT killed %104, %16
    %106 = LWXC1 %69, %103, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.53, !tbaa !6)
    %107 = FADD_S killed %102, killed %106
    SWXC1 killed %107, %69, %103, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.53, !tbaa !6)
    BNE killed %105, %zero, %bb.10, implicit-def dead %at
    B %bb.11.._crit_edge23, implicit-def dead %at
  
  bb.11.._crit_edge23 (freq 1137):
    successors: %bb.8..preheader3(96), %bb.12.._crit_edge27(3)
  
    %25 = ADDu %13, %11
    %24 = ADDu %15, %65
    %108 = SLT %16, %3
    BNE killed %108, %zero, %bb.8..preheader3, implicit-def dead %at
    B %bb.12.._crit_edge27, implicit-def dead %at
  
  bb.12.._crit_edge27 (freq 56):
    successors: %bb.37.._crit_edge27(75), %bb.15..loopexit(25)
  
    BEQ %67, %zero, %bb.15..loopexit, implicit-def dead %at
    B %bb.37.._crit_edge27, implicit-def dead %at
  
  bb.37.._crit_edge27 (freq 42):
    successors: %bb.13..lr.ph19.preheader(66), %bb.15..loopexit(33)
  
    %109 = SLT %0, %3
    BEQ killed %109, %zero, %bb.15..loopexit, implicit-def dead %at
    B %bb.13..lr.ph19.preheader, implicit-def dead %at
  
  bb.13..lr.ph19.preheader (freq 28):
    successors: %bb.14..lr.ph19(100)
  
    %110 = SLL %0, 2
    %26 = ADDu %69, killed %110
    %27 = SLL %65, 2
    %111 = LW %83, target-flags(<unknown>) %const.0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %112 = LDC1 %111, target-flags(<unknown>) %const.0, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 8 from constant-pool)
  
  bb.14..lr.ph19 (freq 910):
    successors: %bb.14..lr.ph19(96), %bb.15..loopexit(3)
  
    %28 = PHI %26, %bb.13..lr.ph19.preheader, %31, %bb.14..lr.ph19
    %29 = PHI %0, %bb.13..lr.ph19.preheader, %30, %bb.14..lr.ph19
    %113 = LWC1 %28, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv14, !tbaa !6)
    %31 = ADDu %28, %27
    %114 = CVT_D32_S killed %113
    %115 = FMUL_D32 killed %114, %112
    %30 = ADDu %29, %65
    %116 = SLT %30, %3
    %117 = CVT_S_D32 killed %115
    SWC1 killed %117, %28, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.lsr.iv14, !tbaa !6)
    BNE killed %116, %zero, %bb.14..lr.ph19, implicit-def dead %at
    B %bb.15..loopexit, implicit-def dead %at
  
  bb.15..loopexit (freq 56):
    successors: %bb.18..preheader(37), %bb.16..preheader1(62)
  
    BEQ %68, %zero, %bb.18..preheader, implicit-def dead %at
    B %bb.16..preheader1, implicit-def dead %at
  
  bb.16..preheader1 (freq 35):
    successors: %bb.17..lr.ph17.preheader(62), %bb.18..preheader(37)
  
    BLEZ %65, %bb.18..preheader, implicit-def dead %at
    B %bb.17..lr.ph17.preheader, implicit-def dead %at
  
  bb.17..lr.ph17.preheader (freq 22):
    successors: %bb.22..lr.ph17(100)
  
    %32 = ADDu %2, %65
    %118 = MUL %1, %65, implicit-def dead %hi0, implicit-def dead %lo0
    %119 = SLL killed %118, 2
    %33 = ADDu %69, killed %119
    %120 = LW %83, target-flags(<unknown>) %const.0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %121 = LDC1 %120, target-flags(<unknown>) %const.0, <0x43d2800> = !{!"unison-memory-partition", i32 1} :: (load 8 from constant-pool)
    B %bb.22..lr.ph17, implicit-def dead %at
  
  bb.18..preheader (freq 56):
    successors: %bb.19..lr.ph13.preheader(62), %bb.20.._crit_edge14.thread(37)
  
    BLEZ %3, %bb.20.._crit_edge14.thread, implicit-def dead %at
    B %bb.19..lr.ph13.preheader, implicit-def dead %at
  
  bb.19..lr.ph13.preheader (freq 35):
    successors: %bb.23..lr.ph13(100)
  
    %135 = COPY %zero
    %134 = BuildPairF64 %135, %135
    B %bb.23..lr.ph13, implicit-def dead %at
  
  bb.20.._crit_edge14.thread (freq 21):
    successors: %bb.29.._crit_edge10.thread(62), %bb.21.call.sqrt(37)
  
    %127 = COPY %zero
    %128 = BuildPairF64 %127, %127
    %129 = FSQRT_D32 killed %128
    FCMP_D32 %129, %129, 17, implicit-def %fcc0
    BC1F %fcc0, %bb.29.._crit_edge10.thread, implicit-def dead %at
    B %bb.21.call.sqrt, implicit-def dead %at
  
  bb.21.call.sqrt (freq 8):
    successors: %bb.29.._crit_edge10.thread(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %130 = COPY %zero
    %131 = BuildPairF64 %130, %130
    %132 = LW %83, target-flags(<unknown>) @sqrt, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sqrt)
    %d6 = COPY %131
    %gp = COPY %83
    %t9 = COPY %132
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit %gp, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.29.._crit_edge10.thread, implicit-def dead %at
  
  bb.22..lr.ph17 (freq 711):
    successors: %bb.22..lr.ph17(96), %bb.18..preheader(3)
  
    %35 = PHI %33, %bb.17..lr.ph17.preheader, %38, %bb.22..lr.ph17
    %36 = PHI %2, %bb.17..lr.ph17.preheader, %37, %bb.22..lr.ph17
    %122 = LWC1 %35, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv11, !tbaa !6)
    %123 = CVT_D32_S killed %122
    %124 = FMUL_D32 killed %123, %121
    %37 = ADDiu %36, 1
    %125 = SLT %37, %32
    %38 = ADDiu %35, 4
    %126 = CVT_S_D32 killed %124
    SWC1 killed %126, %35, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.lsr.iv11, !tbaa !6)
    BNE killed %125, %zero, %bb.22..lr.ph17, implicit-def dead %at
    B %bb.18..preheader, implicit-def dead %at
  
  bb.23..lr.ph13 (freq 1137):
    successors: %bb.24.._crit_edge14(3), %bb.23..lr.ph13(96)
  
    %39 = PHI %69, %bb.19..lr.ph13.preheader, %44, %bb.23..lr.ph13
    %40 = PHI %3, %bb.19..lr.ph13.preheader, %43, %bb.23..lr.ph13
    %41 = PHI %134, %bb.19..lr.ph13.preheader, %42, %bb.23..lr.ph13
    %44 = ADDiu %39, 4
    %136 = LWC1 %39, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv8, !tbaa !6)
    %43 = ADDiu %40, -1
    %137 = FMUL_S %136, %136
    %138 = CVT_D32_S killed %137
    %42 = FADD_D32 %41, killed %138
    BNE %43, %zero, %bb.23..lr.ph13, implicit-def dead %at
    B %bb.24.._crit_edge14, implicit-def dead %at
  
  bb.24.._crit_edge14 (freq 35):
    successors: %bb.26.._crit_edge14.split(62), %bb.25.call.sqrt26(37)
  
    %45 = FSQRT_D32 %42
    FCMP_D32 %45, %45, 17, implicit-def %fcc0
    BC1F %fcc0, %bb.26.._crit_edge14.split, implicit-def dead %at
    B %bb.25.call.sqrt26, implicit-def dead %at
  
  bb.25.call.sqrt26 (freq 13):
    successors: %bb.26.._crit_edge14.split(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %139 = LW %83, target-flags(<unknown>) @sqrt, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sqrt)
    %d6 = COPY %42
    %gp = COPY %83
    %t9 = COPY %139
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit %gp, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %140 = COPY %d0
    %46 = COPY %140
  
  bb.26.._crit_edge14.split (freq 35):
    successors: %bb.27..lr.ph9.preheader(62), %bb.29.._crit_edge10.thread(37)
  
    %47 = PHI %45, %bb.24.._crit_edge14, %46, %bb.25.call.sqrt26
    BLEZ %3, %bb.29.._crit_edge10.thread, implicit-def dead %at
    B %bb.27..lr.ph9.preheader, implicit-def dead %at
  
  bb.27..lr.ph9.preheader (freq 22):
    successors: %bb.28..lr.ph9(100)
  
    %48 = MUL %66, %65, implicit-def dead %hi0, implicit-def dead %lo0
    %149 = COPY %zero
    %148 = BuildPairF64 %149, %149
  
  bb.28..lr.ph9 (freq 711):
    successors: %bb.31.._crit_edge10(3), %bb.28..lr.ph9(96)
  
    %49 = PHI %64, %bb.27..lr.ph9.preheader, %54, %bb.28..lr.ph9
    %50 = PHI %48, %bb.27..lr.ph9.preheader, %53, %bb.28..lr.ph9
    %51 = PHI %148, %bb.27..lr.ph9.preheader, %52, %bb.28..lr.ph9
    %54 = ADDiu %49, 4
    %150 = LWC1 %49, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv4, !tbaa !6)
    %53 = ADDiu %50, -1
    %151 = FMUL_S %150, %150
    %152 = CVT_D32_S killed %151
    %52 = FADD_D32 %51, killed %152
    BEQ %53, %zero, %bb.31.._crit_edge10, implicit-def dead %at
    B %bb.28..lr.ph9, implicit-def dead %at
  
  bb.29.._crit_edge10.thread (freq 34):
    successors: %bb.36.._crit_edge(62), %bb.30.call.sqrt27(37)
  
    %141 = COPY %zero
    %142 = BuildPairF64 %141, %141
    %143 = FSQRT_D32 killed %142
    FCMP_D32 %143, %143, 17, implicit-def %fcc0
    BC1F %fcc0, %bb.36.._crit_edge, implicit-def dead %at
    B %bb.30.call.sqrt27, implicit-def dead %at
  
  bb.30.call.sqrt27 (freq 13):
    successors: %bb.36.._crit_edge(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %144 = COPY %zero
    %145 = BuildPairF64 %144, %144
    %146 = LW %83, target-flags(<unknown>) @sqrt, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sqrt)
    %d6 = COPY %145
    %gp = COPY %83
    %t9 = COPY %146
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit %gp, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.36.._crit_edge, implicit-def dead %at
  
  bb.31.._crit_edge10 (freq 22):
    successors: %bb.33.._crit_edge10.split(62), %bb.32.call.sqrt28(37)
  
    %55 = FSQRT_D32 %52
    FCMP_D32 %55, %55, 17, implicit-def %fcc0
    BC1F %fcc0, %bb.33.._crit_edge10.split, implicit-def dead %at
    B %bb.32.call.sqrt28, implicit-def dead %at
  
  bb.32.call.sqrt28 (freq 8):
    successors: %bb.33.._crit_edge10.split(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %153 = LW %83, target-flags(<unknown>) @sqrt, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sqrt)
    %d6 = COPY %52
    %gp = COPY %83
    %t9 = COPY %153
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit %gp, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %154 = COPY %d0
    %56 = COPY %154
  
  bb.33.._crit_edge10.split (freq 22):
    successors: %bb.34..lr.ph.preheader(62), %bb.36.._crit_edge(37)
  
    %57 = PHI %55, %bb.31.._crit_edge10, %56, %bb.32.call.sqrt28
    BLEZ %3, %bb.36.._crit_edge, implicit-def dead %at
    B %bb.34..lr.ph.preheader, implicit-def dead %at
  
  bb.34..lr.ph.preheader (freq 13):
    successors: %bb.35..lr.ph(100)
  
    %58 = FDIV_D32 %47, %57
    %59 = MUL %66, %65, implicit-def dead %hi0, implicit-def dead %lo0
  
  bb.35..lr.ph (freq 444):
    successors: %bb.36.._crit_edge(3), %bb.35..lr.ph(96)
  
    %60 = PHI %69, %bb.34..lr.ph.preheader, %63, %bb.35..lr.ph
    %61 = PHI %59, %bb.34..lr.ph.preheader, %62, %bb.35..lr.ph
    %155 = LWC1 %60, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv1, !tbaa !6)
    %156 = CVT_D32_S killed %155
    %157 = FDIV_D32 killed %156, %58
    %63 = ADDiu %60, 4
    %62 = ADDiu %61, -1
    %158 = CVT_S_D32 killed %157
    SWC1 killed %158, %60, 0, <0x43cd9b0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.lsr.iv1, !tbaa !6)
    BNE %62, %zero, %bb.35..lr.ph, implicit-def dead %at
    B %bb.36.._crit_edge, implicit-def dead %at
  
  bb.36.._crit_edge (freq 56):
    liveouts: %v0
  
    %159 = IMPLICIT_DEF
    %v0 = COPY %159
    RetRA implicit %v0

...
