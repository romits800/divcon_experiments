--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/ghostscript/ghostscript.gximage1.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.gx_image_strategies_s = type { i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)* }
  %struct.gx_device_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s }
  %struct.gs_memory_s = type { %struct.gs_memory_procs_s }
  %struct.gs_memory_procs_s = type { i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i32, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i32, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i8*, i32, i8*)*, i32 (%struct.gs_memory_s*, i8*)*, %struct.gs_memory_struct_type_s* (%struct.gs_memory_s*, i8*)*, void (%struct.gs_memory_s*, i8*, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i8*, i32, i32, i8*)*, void (%struct.gs_memory_s*, i8*, i32, i8*)*, void (%struct.gs_memory_s*, %struct.gs_gc_root_s*, %struct.gs_ptr_procs_s*, i8**, i8*)*, void (%struct.gs_memory_s*, %struct.gs_gc_root_s*, i8*)*, void (%struct.gs_memory_s*, %struct.gs_memory_status_s*)*, void (%struct.gs_memory_s*, i32)* }
  %struct.gs_gc_root_s = type { %struct.gs_gc_root_s*, %struct.gs_ptr_procs_s*, i8** }
  %struct.gs_ptr_procs_s = type { void (i8*, %struct.gc_state_s*)*, i32 (i8*, %struct.gc_state_s*)*, i8* (i8*, %struct.gc_state_s*)* }
  %struct.gc_state_s = type opaque
  %struct.gs_memory_status_s = type { i32, i32 }
  %struct.gs_memory_struct_type_s = type { i32, i8*, %struct.struct_shared_procs_s*, void (i8*, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)*, void (i8*)* }
  %struct.struct_shared_procs_s = type opaque
  %struct.gx_device_color_info_s = type { i32, i32, i16, i16, i16, i16 }
  %struct.gx_page_device_procs_s = type { i32 (%struct.gx_device_s*, %struct.gs_state_s*)*, i32 (%struct.gx_device_s*, %struct.gs_state_s*)*, i32 (%struct.gx_device_s*, i32, %struct.gs_state_s*)* }
  %struct.gs_state_s = type opaque
  %struct.gx_device_procs_s = type { i32 (%struct.gx_device_s*)*, void (%struct.gx_device_s*, %struct.gs_matrix_s*)*, i32 (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i32, i32)*, i32 (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16)*, i32 (%struct.gx_device_s*, i32, i16*)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, %struct.gx_tile_bitmap_s*, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i8*, i8**)*, i32 (%struct.gx_device_s*, %struct.gs_param_list_s*)*, i32 (%struct.gx_device_s*, %struct.gs_param_list_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16, i16)*, %struct.gx_xfont_procs_s* (%struct.gx_device_s*)*, %struct.gx_device_s* (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16, i16)*, %struct.gx_device_s* (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i32*)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32*, %struct.gx_tile_bitmap_s*, i32*, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gx_path_s*, %struct.gx_fill_params_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gx_path_s*, %struct.gx_stroke_params_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32, i32, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, %struct.gs_fixed_edge_s*, %struct.gs_fixed_edge_s*, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gs_image_s*, i32, %struct.gs_int_rect_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*, %struct.gs_memory_s*, i8**)*, i32 (%struct.gx_device_s*, i8*, i8**, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32)*, i32 (%struct.gx_device_s*, %struct.gx_strip_bitmap_s*, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32*, %struct.gx_strip_bitmap_s*, i32*, i32, i32, i32, i32, i32, i32, i32)*, void (%struct.gx_device_s*, %struct.gs_fixed_rect_s*)* }
  %struct.gs_matrix_s = type { float, float, float, float, float, float }
  %struct.gx_tile_bitmap_s = type { i8*, i32, %struct.gs_int_point_s, i32, i16, i16 }
  %struct.gs_int_point_s = type { i32, i32 }
  %struct.gs_param_list_s = type opaque
  %struct.gx_xfont_procs_s = type opaque
  %struct.gs_imager_state_s = type { %struct.gs_memory_s*, %struct.gx_line_params_s, %struct.gs_matrix_fixed_s, i32, i16, i32, float, %struct.gs_fixed_point_s, i32, i32, %struct.gs_halftone_s*, [2 x %struct.gs_int_point_s], %struct.gx_device_halftone_s*, %struct.gx_ht_cache_s*, %struct.gs_cie_render_s*, %struct.gx_transfer_map_s*, %struct.gx_transfer_map_s*, %union.gx_transfer_s, %union.gx_transfer_s, %struct.gx_cie_joint_caches_s*, %struct.gx_color_map_procs_s*, %struct.gx_pattern_cache_s* }
  %struct.gx_line_params_s = type { float, i32, i32, float, float, float, float, %struct.gx_dash_params_s }
  %struct.gx_dash_params_s = type { float*, i32, float, i32, float, i32, i32, float }
  %struct.gs_matrix_fixed_s = type { float, float, float, float, float, float, i32, i32, i32 }
  %struct.gs_fixed_point_s = type { i32, i32 }
  %struct.gs_halftone_s = type { i32, %struct.rc_header_s, %union.anon }
  %struct.rc_header_s = type { i32, %struct.gs_memory_s*, void (%struct.gs_memory_s*, i8*, i8*)* }
  %union.anon = type { %struct.gs_colorscreen_halftone_s }
  %struct.gs_colorscreen_halftone_s = type { %union._css }
  %union._css = type { [4 x %struct.gs_screen_halftone_s] }
  %struct.gs_screen_halftone_s = type { float, float, float (double, double)*, float, float }
  %struct.gx_device_halftone_s = type { %struct.gx_ht_order_s, %struct.rc_header_s, i32, %struct.gx_ht_order_component_s*, i32, [4 x i32], i32, i32 }
  %struct.gx_ht_order_s = type { %struct.gx_ht_cell_params_s, i16, i16, i16, i16, i16, i16, i32, i32, i32, i32*, %struct.gx_ht_bit_s*, %struct.gx_ht_cache_s*, %struct.gx_transfer_map_s* }
  %struct.gx_ht_cell_params_s = type { i16, i16, i16, i16, i16, i16, i32, i16, i16, i32, i32, i32 }
  %struct.gx_ht_bit_s = type { i32, i32 }
  %struct.gx_ht_order_component_s = type { %struct.gx_ht_order_s, i32 }
  %struct.gx_ht_cache_s = type { i8*, i32, %struct.gx_ht_tile_s*, i32, %struct.gx_ht_order_s, i32, i32, i32 }
  %struct.gx_ht_tile_s = type { %struct.gx_strip_bitmap_s, i32, i32 }
  %struct.gx_strip_bitmap_s = type { i8*, i32, %struct.gs_int_point_s, i32, i16, i16, i16, i16 }
  %struct.gs_cie_render_s = type opaque
  %struct.gx_transfer_map_s = type { %struct.rc_header_s, {}*, i32, [256 x i16] }
  %union.gx_transfer_s = type { [4 x %struct.gx_transfer_map_s*] }
  %struct.gx_cie_joint_caches_s = type opaque
  %struct.gx_color_map_procs_s = type { void (i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, void (i16, i16, i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, void (i16, i16, i16, i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)* }
  %struct.gx_pattern_cache_s = type opaque
  %struct.gx_path_s = type { %struct.gs_memory_s*, %struct.gs_fixed_rect_s, %struct.segment_s*, %struct.subpath_s*, %struct.subpath_s*, i32, i32, %struct.gs_fixed_point_s, %struct.gs_point_s, %struct.gs_point_s, i8, i8, i8, i8 }
  %struct.gs_fixed_rect_s = type { %struct.gs_fixed_point_s, %struct.gs_fixed_point_s }
  %struct.segment_s = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s }
  %struct.subpath_s = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s, %struct.segment_s*, i32, %struct.line_close_segment, i8 }
  %struct.line_close_segment = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s, %struct.subpath_s* }
  %struct.gs_point_s = type { double, double }
  %struct.gx_fill_params_s = type opaque
  %struct.gx_device_color_s = type { %struct.gx_device_color_procs_s*, %union._c, %struct.gs_int_point_s, %struct._mask }
  %struct.gx_device_color_procs_s = type { i32 (%struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)*, i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)* }
  %struct.gx_rop_source_s = type { i8*, i32, i32, i32, [2 x i32], i32 }
  %union._c = type { %struct._col }
  %struct._col = type { %struct.gx_device_halftone_s*, [4 x i8], [4 x i32], i16 }
  %struct._mask = type { %struct.gs_client_color_s, i32, %struct.gx_color_tile_s* }
  %struct.gs_client_color_s = type { %struct.gs_paint_color_s, %struct.gs_pattern_instance_s* }
  %struct.gs_paint_color_s = type { [4 x float] }
  %struct.gs_pattern_instance_s = type opaque
  %struct.gx_color_tile_s = type opaque
  %struct.gx_clip_path_s = type opaque
  %struct.gx_stroke_params_s = type opaque
  %struct.gs_fixed_edge_s = type { %struct.gs_fixed_point_s, %struct.gs_fixed_point_s }
  %struct.gs_image_s = type { i32, i32, %struct.gs_matrix_s, i32, %struct.gs_color_space_s*, [8 x float], i32, i32, i32, i32 }
  %struct.gs_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.1 }
  %struct.gs_color_space_type_s = type { i32, i32, i32, void (%struct.gs_client_color_s*, %struct.gs_color_space_s*)*, %struct.gs_color_space_s* (%struct.gs_color_space_s*, %struct.gs_imager_state_s*)*, i32 (%struct.gs_client_color_s*, %struct.gs_color_space_s*, i16*, %struct.gs_imager_state_s*)*, i32 (i16*, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gs_client_color_s*, %struct.gs_color_space_s*, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gs_color_space_s*, %struct.gs_state_s*)*, void (%struct.gs_color_space_s*, %struct.gs_memory_s*, i32)*, void (%struct.gs_client_color_s*, %struct.gs_color_space_s*, %struct.gs_memory_s*, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)* }
  %union.anon.1 = type { %struct.gs_pattern_params_s }
  %struct.gs_pattern_params_s = type { i32, %struct.gs_paint_color_space_s }
  %struct.gs_paint_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.4 }
  %union.anon.4 = type { %struct.gs_indexed_params_s }
  %struct.gs_indexed_params_s = type { %struct.gs_base_color_space_s, i32, %union.anon.3, i32 }
  %struct.gs_base_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.2 }
  %union.anon.2 = type { %struct.gs_cie_defg_s* }
  %struct.gs_cie_defg_s = type opaque
  %union.anon.3 = type { %struct.gs_const_string_s }
  %struct.gs_const_string_s = type { i8*, i32 }
  %struct.gs_int_rect_s = type { %struct.gs_int_point_s, %struct.gs_int_point_s }
  %struct.gx_image_enum_s = type { i8, i8, i8, i8, i8, i8, i8, i8, %struct.gs_matrix_s, %struct.r_, %struct.gs_fixed_point_s, %struct.gs_fixed_point_s, i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)*, {}*, %struct.gs_imager_state_s*, %struct.gs_color_space_s*, %struct.gs_memory_s*, %struct.gx_device_s*, i8*, i32, i8*, i32, i32, i32, i8, i8, i8, i8, %struct.gs_fixed_rect_s, %struct.gs_fixed_rect_s, i32, i32, i32, i32, %struct.gx_device_clip_s*, %struct.gx_device_rop_texture_s*, %struct.stream_IScale_state_s*, i32, %struct.gs_fixed_point_s, %struct.gs_fixed_point_s, %struct.dd_, i32, i32, %struct.gs_int_point_s, i32, i32, i32, i32, [4 x %struct.sample_map_s], [256 x %struct.gx_image_clue_s] }
  %struct.r_ = type { i32, i32, i32, i32 }
  %union.sample_lookup_s = type { [16 x i32], [192 x i8] }
  %struct.gx_device_clip_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s, %struct.gx_device_s*, %struct.gx_clip_list_s, %struct.gx_clip_rect_s*, %struct.gs_int_point_s }
  %struct.gx_clip_list_s = type { %struct.gx_clip_rect_s, %struct.gx_clip_rect_s*, %struct.gx_clip_rect_s*, i32, i32 }
  %struct.gx_clip_rect_s = type { %struct.gx_clip_rect_s*, %struct.gx_clip_rect_s*, i32, i32, i32, i32, i8 }
  %struct.gx_device_rop_texture_s = type opaque
  %struct.stream_IScale_state_s = type { %struct.stream_template_s*, %struct.gs_memory_s*, i32 (%struct.stream_state_s*, i8*)*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, double, double, i8*, i8*, i8*, %struct.CLIST*, %struct.CONTRIB*, i32, i32, i32, i32, i32, i32, %struct.CLIST, i32, [8 x %struct.CONTRIB] }
  %struct.stream_template_s = type { %struct.gs_memory_struct_type_s*, i32 (%struct.stream_state_s*)*, i32 (%struct.stream_state_s*, %struct.stream_cursor_read_s*, %struct.stream_cursor_write_s*, i32)*, i32, i32, void (%struct.stream_state_s*)*, void (%struct.stream_state_s*)*, i32 (%struct.stream_state_s*)* }
  %struct.stream_state_s = type { %struct.stream_template_s*, %struct.gs_memory_s*, i32 (%struct.stream_state_s*, i8*)* }
  %struct.stream_cursor_read_s = type { i8*, i8*, i8* }
  %struct.stream_cursor_write_s = type { i8*, i8*, i8* }
  %struct.CONTRIB = type { float }
  %struct.CLIST = type { i32, i32, i32 }
  %struct.dd_ = type { %struct.gx_dda_fixed_point_s, %struct.gx_dda_fixed_point_s }
  %struct.gx_dda_fixed_point_s = type { %struct.gx_dda_fixed_s, %struct.gx_dda_fixed_s }
  %struct.gx_dda_fixed_s = type { %struct._a, %struct._e }
  %struct._a = type { i32, i32 }
  %struct._e = type { i32, i32, i32 }
  %struct.sample_map_s = type { %union.sample_lookup_s, [16 x float], double, i32 }
  %struct.gx_image_clue_s = type { %struct.gx_device_color_s, i32 }
  %struct.gx_device_memory_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s, %struct.gx_device_s*, %struct.gs_matrix_s, i32, i32, i8*, i8**, %struct.gs_memory_s*, %struct.gs_const_string_s, %struct._c24, %struct.gs_log2_scale_point_s, i32, i32, i32, i32, i32, i32 }
  %struct._c24 = type { i32, i32, i32, i32 }
  %struct.gs_log2_scale_point_s = type { i32, i32 }
  
  @image_strategies = external global %struct.gx_image_strategies_s, align 4
  @.str = private unnamed_addr constant [11 x i8] c"image line\00", align 1
  @mem_mono_device = external global %struct.gx_device_memory_s, align 4
  @gx_dc_procs_pure = external global %struct.gx_device_color_procs_s, align 4
  @byte_reverse_bits = external global [256 x i8], align 1
  @byte_bit_run_length_0 = external global [256 x i8], align 1
  @image_simple_expand.lmasks = internal unnamed_addr constant [9 x i8] c"\FF\7F?\1F\0F\07\03\01\00", align 1
  @image_simple_expand.rmasks = internal unnamed_addr constant [9 x i8] c"\00\80\C0\E0\F0\F8\FC\FE\FF", align 1
  
  ; Function Attrs: norecurse nounwind
  define void @gs_gximage1_init(%struct.gs_memory_s* nocapture readnone %mem) #0 {
    store i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)* @image_strategy_simple, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)** getelementptr inbounds (%struct.gx_image_strategies_s, %struct.gx_image_strategies_s* @image_strategies, i32 0, i32 1), align 4, !tbaa !1
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* @image_strategy_simple(%struct.gx_image_enum_s* %penum) #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 0, i32 0, i32 0
    %2 = load i32, i32* %1, align 4, !tbaa !6
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 1, i32 0, i32 0
    %4 = load i32, i32* %3, align 4, !tbaa !21
    %5 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 24
    %6 = load i8, i8* %5, align 8, !tbaa !22
    %7 = icmp eq i8 %6, 0
    br i1 %7, label %8, label %114
  
  ; <label>:8                                       ; preds = %0
    %9 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 3
    %10 = load i8, i8* %9, align 1, !tbaa !23
    %11 = icmp eq i8 %10, 1
    br i1 %11, label %12, label %114
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %14 = load i8, i8* %13, align 8, !tbaa !24
    %15 = icmp eq i8 %14, 1
    br i1 %15, label %16, label %114
  
  ; <label>:16                                      ; preds = %12
    %17 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 23
    %18 = load i32, i32* %17, align 4, !tbaa !25
    switch i32 %18, label %114 [
      i32 0, label %19
      i32 1, label %56
    ]
  
  ; <label>:19                                      ; preds = %16
    %20 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %21 = load i32, i32* %20, align 8, !tbaa !26
    %22 = add i32 %2, 2047
    %23 = add i32 %22, %21
    %24 = ashr i32 %23, 12
    %25 = ashr i32 %22, 12
    %26 = sub nsw i32 %24, %25
    %27 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 9, i32 2
    %28 = load i32, i32* %27, align 8, !tbaa !27
    %29 = icmp eq i32 %26, %28
    br i1 %29, label %.thread16, label %30
  
  ; <label>:30                                      ; preds = %19
    %31 = icmp slt i32 %26, 0
    %32 = sub nsw i32 0, %26
    %33 = select i1 %31, i32 %32, i32 %26
    %34 = add nsw i32 %33, 31
    %35 = ashr i32 %34, 5
    %36 = shl nsw i32 %35, 2
    %37 = add nsw i32 %36, 4
    %38 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 31
    %39 = load i32, i32* %38, align 8, !tbaa !28
    %40 = icmp eq i32 %39, 0
    br i1 %40, label %41, label %114
  
  ; <label>:41                                      ; preds = %30
    %42 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    store i32 %33, i32* %42, align 8, !tbaa !29
    %43 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    store i32 %37, i32* %43, align 4, !tbaa !30
    %44 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 16
    %45 = load %struct.gs_memory_s*, %struct.gs_memory_s** %44, align 8, !tbaa !31
    %46 = bitcast %struct.gs_memory_s* %45 to i8* (%struct.gs_memory_s*, i32, i8*)**
    %47 = load i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)** %46, align 4, !tbaa !32
    %48 = tail call i8* %47(%struct.gs_memory_s* %45, i32 signext %37, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i32 0, i32 0)) #4
    %49 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    store i8* %48, i8** %49, align 8, !tbaa !35
    %50 = icmp eq i8* %48, null
    br i1 %50, label %51, label %.thread16
  
  ; <label>:51                                      ; preds = %41
    %52 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %53 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 17
    %54 = load %struct.gx_device_s*, %struct.gx_device_s** %53, align 4, !tbaa !36
    %55 = tail call i32 @gx_default_end_image(%struct.gx_device_s* %54, i8* nonnull %52, i32 signext 0) #4
    br label %114
  
  ; <label>:56                                      ; preds = %16
    %57 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 1
    %58 = load i32, i32* %57, align 4, !tbaa !37
    %59 = add i32 %4, 2048
    %60 = add i32 %59, %58
    %61 = ashr i32 %60, 12
    %62 = ashr i32 %59, 12
    %63 = sub nsw i32 %61, %62
    %64 = icmp slt i32 %63, 0
    %65 = sub nsw i32 0, %63
    %66 = select i1 %64, i32 %65, i32 %63
    %67 = add nsw i32 %66, 31
    %68 = and i32 %67, -32
    %69 = shl nsw i32 %66, 2
    %70 = add nsw i32 %69, 28
    %71 = and i32 %70, -32
    %72 = add i32 %71, %68
    %73 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 9, i32 2
    %74 = load i32, i32* %73, align 8, !tbaa !27
    %75 = icmp eq i32 %66, %74
    br i1 %75, label %80, label %76
  
  ; <label>:76                                      ; preds = %56
    %77 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 31
    %78 = load i32, i32* %77, align 8, !tbaa !28
    %79 = icmp eq i32 %78, 0
    br i1 %79, label %80, label %114
  
  ; <label>:80                                      ; preds = %76, %56
    %81 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    store i32 %66, i32* %81, align 8, !tbaa !29
    %82 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    store i32 %72, i32* %82, align 4, !tbaa !30
    %83 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 16
    %84 = load %struct.gs_memory_s*, %struct.gs_memory_s** %83, align 8, !tbaa !31
    %85 = bitcast %struct.gs_memory_s* %84 to i8* (%struct.gs_memory_s*, i32, i8*)**
    %86 = load i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)** %85, align 4, !tbaa !32
    %87 = tail call i8* %86(%struct.gs_memory_s* %84, i32 signext %72, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i32 0, i32 0)) #4
    %88 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    store i8* %87, i8** %88, align 8, !tbaa !35
    %89 = icmp eq i8* %87, null
    br i1 %89, label %.critedge, label %.critedge13
  
  .critedge:                                        ; preds = %80
    %90 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %91 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 17
    %92 = load %struct.gx_device_s*, %struct.gx_device_s** %91, align 4, !tbaa !36
    %93 = tail call i32 @gx_default_end_image(%struct.gx_device_s* %92, i8* nonnull %90, i32 signext 0) #4
    br label %114
  
  .critedge13:                                      ; preds = %80
    %94 = add nsw i32 %2, 2048
    %95 = ashr i32 %94, 12
    %96 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    store i32 %95, i32* %96, align 4, !tbaa !38
    %97 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 42
    store i32 %95, i32* %97, align 8, !tbaa !39
    %98 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 1
    %99 = load float, float* %98, align 4, !tbaa !40
    %100 = fpext float %99 to double
    %101 = fadd double %100, 0x3F20000000000000
    %102 = fmul double %101, 4.096000e+03
    %103 = fptosi double %102 to i32
    %104 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 33
    store i32 %103, i32* %104, align 8, !tbaa !41
    br label %.thread16
  
  .thread16:                                        ; preds = %.critedge13, %41, %19
    %rproc.2 = phi i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* [ @image_render_landscape, %.critedge13 ], [ @image_render_simple, %41 ], [ @image_render_simple, %19 ]
    %105 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 0
    %106 = load float, float* %105, align 8, !tbaa !42
    %107 = fpext float %106 to double
    %108 = fadd double %107, 0x3F20000000000000
    %109 = fmul double %108, 4.096000e+03
    %110 = fptosi double %109 to i32
    %111 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 32
    store i32 %110, i32* %111, align 4, !tbaa !43
    %112 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 12
    store i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)* @sample_unpack_copy, i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)** %112, align 8, !tbaa !44
    %113 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 1
    store i8 8, i8* %113, align 1, !tbaa !45
    br label %114
  
  ; <label>:114                                     ; preds = %.thread16, %.critedge, %76, %51, %30, %16, %12, %8, %0
    %.4 = phi i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* [ %rproc.2, %.thread16 ], [ null, %12 ], [ null, %8 ], [ null, %0 ], [ null, %.critedge ], [ null, %76 ], [ null, %16 ], [ null, %51 ], [ null, %30 ]
    ret i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* %.4
  }
  
  declare i32 @gx_default_end_image(%struct.gx_device_s*, i8*, i32 signext) #2
  
  ; Function Attrs: nounwind
  define internal i32 @image_render_simple(%struct.gx_image_enum_s* %penum, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) #1 {
    %1 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 0, i32 21, i32 9
    %2 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** %1, align 4, !tbaa !46
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 32
    %4 = load i32, i32* %3, align 4, !tbaa !43
    %5 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 0, i32 0, i32 0
    %6 = load i32, i32* %5, align 4, !tbaa !6
    %7 = add nsw i32 %6, 2047
    %8 = ashr i32 %7, 12
    %9 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 44
    %10 = load i32, i32* %9, align 4, !tbaa !52
    %11 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 45
    %12 = load i32, i32* %11, align 8, !tbaa !53
    %13 = icmp eq i32 %h, 0
    br i1 %13, label %.loopexit, label %14
  
  ; <label>:14                                      ; preds = %0
    %15 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %16 = load i8*, i8** %15, align 8, !tbaa !35
    %17 = icmp eq i8* %16, null
    br i1 %17, label %18, label %21
  
  ; <label>:18                                      ; preds = %14
    %19 = add i32 %w, 7
    %20 = lshr i32 %19, 3
    br label %121
  
  ; <label>:21                                      ; preds = %14
    %22 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** getelementptr inbounds (%struct.gx_device_memory_s, %struct.gx_device_memory_s* @mem_mono_device, i32 0, i32 21, i32 9), align 4, !tbaa !54
    %23 = icmp eq i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)* %2, %22
    %24 = icmp sgt i32 %4, 0
    %or.cond = and i1 %24, %23
    br i1 %or.cond, label %25, label %113
  
  ; <label>:25                                      ; preds = %21
    %26 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0, i32 0
    %27 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %26, align 8, !tbaa !59
    %28 = icmp eq %struct.gx_device_color_procs_s* %27, @gx_dc_procs_pure
    br i1 %28, label %29, label %113
  
  ; <label>:29                                      ; preds = %25
    %30 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0, i32 0
    %31 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %30, align 8, !tbaa !59
    %32 = icmp eq %struct.gx_device_color_procs_s* %31, @gx_dc_procs_pure
    br i1 %32, label %33, label %113
  
  ; <label>:33                                      ; preds = %29
    %34 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0, i32 1
    %35 = bitcast %union._c* %34 to i32*
    %36 = load i32, i32* %35, align 4, !tbaa !64
    %37 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0, i32 1
    %38 = bitcast %union._c* %37 to i32*
    %39 = load i32, i32* %38, align 4, !tbaa !64
    %40 = xor i32 %39, %36
    %41 = icmp eq i32 %40, 1
    br i1 %41, label %42, label %113
  
  ; <label>:42                                      ; preds = %33
    %43 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 25
    %44 = load i8, i8* %43, align 1, !tbaa !65
    %45 = icmp eq i8 %44, 0
    br i1 %45, label %46, label %113
  
  ; <label>:46                                      ; preds = %42
    %47 = mul i32 %4, %w
    %48 = add i32 %47, 2047
    %49 = add i32 %48, %6
    %50 = lshr i32 %49, 12
    %51 = add nsw i32 %50, -1
    %52 = ashr i32 %7, 15
    %53 = ashr i32 %51, 3
    %54 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 1, i32 7, i32 4
    %55 = bitcast i16* %54 to i8***
    %56 = load i8**, i8*** %55, align 4, !tbaa !66
    %57 = getelementptr inbounds i8*, i8** %56, i32 %10
    %58 = load i8*, i8** %57, align 4, !tbaa !67
    %59 = and i32 %8, 31
    %60 = sub nsw i32 %8, %59
    %61 = add nsw i32 %53, 1
    %62 = ashr i32 %60, 3
    %63 = sub nsw i32 %61, %62
    %64 = sub nsw i32 %50, %8
    %65 = getelementptr inbounds i8, i8* %58, i32 %52
    %66 = load i8, i8* %65, align 1, !tbaa !68
    %67 = zext i8 %66 to i32
    %68 = getelementptr inbounds i8, i8* %58, i32 %53
    %69 = load i8, i8* %68, align 1, !tbaa !68
    %70 = zext i8 %69 to i32
    %71 = getelementptr inbounds i8, i8* %58, i32 %62
    %72 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %73 = load i32, i32* %72, align 8, !tbaa !26
    %74 = icmp eq i32 %36, 0
    %75 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 48, i32 0, i32 0, i32 0, i32 0
    %76 = load i32, i32* %75, align 8, !tbaa !69
    %77 = icmp eq i32 %76, 0
    %78 = xor i1 %74, %77
    %79 = sext i1 %78 to i8
    tail call fastcc void @image_simple_expand(i8* %71, i32 signext %59, i32 signext %63, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %6, i32 signext %73, i8 zeroext %79)
    %80 = and i32 %8, 7
    %81 = icmp eq i32 %80, 0
    br i1 %81, label %91, label %82
  
  ; <label>:82                                      ; preds = %46
    %83 = lshr i32 65280, %80
    %84 = and i32 %67, %83
    %85 = load i8, i8* %65, align 1, !tbaa !68
    %86 = zext i8 %85 to i32
    %87 = xor i32 %83, 255
    %88 = and i32 %86, %87
    %89 = add nuw nsw i32 %88, %84
    %90 = trunc i32 %89 to i8
    store i8 %90, i8* %65, align 1, !tbaa !68
    br label %91
  
  ; <label>:91                                      ; preds = %82, %46
    %92 = and i32 %50, 7
    %93 = icmp eq i32 %92, 0
    br i1 %93, label %103, label %94
  
  ; <label>:94                                      ; preds = %91
    %95 = lshr i32 65280, %92
    %96 = load i8, i8* %68, align 1, !tbaa !68
    %97 = zext i8 %96 to i32
    %98 = and i32 %97, %95
    %99 = xor i32 %95, 255
    %100 = and i32 %70, %99
    %101 = add nuw nsw i32 %98, %100
    %102 = trunc i32 %101 to i8
    store i8 %102, i8* %68, align 1, !tbaa !68
    br label %103
  
  ; <label>:103                                     ; preds = %94, %91
    %104 = icmp slt i32 %12, 2
    br i1 %104, label %.loopexit, label %.lr.ph20.preheader
  
  .lr.ph20.preheader:                               ; preds = %103
    %105 = icmp slt i32 %4, 0
    %106 = select i1 %105, i32 %64, i32 0
    %. = sub nsw i32 %8, %106
    br label %.lr.ph20
  
  ; <label>:107                                     ; preds = %.lr.ph20
    %108 = icmp slt i32 %112, %12
    br i1 %108, label %.lr.ph20, label %.loopexit
  
  .lr.ph20:                                         ; preds = %107, %.lr.ph20.preheader
    %dy.018 = phi i32 [ %112, %107 ], [ 1, %.lr.ph20.preheader ]
    %109 = add i32 %10, %dy.018
    %110 = tail call i32 %2(%struct.gx_device_s* %dev, i8* %71, i32 signext %59, i32 signext %63, i32 signext 0, i32 signext %., i32 signext %109, i32 signext %64, i32 signext 1, i32 signext 0, i32 signext 1) #4
    %111 = icmp slt i32 %110, 0
    %112 = add nuw nsw i32 %dy.018, 1
    br i1 %111, label %.loopexit, label %107
  
  ; <label>:113                                     ; preds = %42, %33, %29, %25, %21
    %114 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    %115 = load i32, i32* %114, align 4, !tbaa !30
    %116 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %117 = load i32, i32* %116, align 8, !tbaa !29
    %118 = and i32 %8, 31
    %119 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %120 = load i32, i32* %119, align 8, !tbaa !26
    tail call fastcc void @image_simple_expand(i8* nonnull %16, i32 signext %118, i32 signext %115, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %6, i32 signext %120, i8 zeroext 0)
    br label %121
  
  ; <label>:121                                     ; preds = %113, %18
    %line_x.0 = phi i32 [ 0, %18 ], [ %118, %113 ]
    %line_size.0 = phi i32 [ %20, %18 ], [ %115, %113 ]
    %line_width.0 = phi i32 [ %w, %18 ], [ %117, %113 ]
    %line.0 = phi i8* [ %buffer, %18 ], [ %16, %113 ]
    %122 = icmp slt i32 %4, 0
    %123 = select i1 %122, i32 %line_width.0, i32 0
    %.9 = sub i32 %8, %123
    %124 = icmp sgt i32 %12, 0
    br i1 %124, label %.lr.ph, label %.loopexit
  
  ; <label>:125                                     ; preds = %.lr.ph
    %126 = icmp slt i32 %130, %12
    br i1 %126, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %121, %125
    %dy.114 = phi i32 [ %130, %125 ], [ 0, %121 ]
    %127 = add i32 %10, %dy.114
    %128 = tail call fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %line.0, i32 signext %line_x.0, i32 signext %line_size.0, i32 signext %.9, i32 signext %127, i32 signext %line_width.0, i32 signext 1, %struct.gx_device_s* %dev)
    %129 = icmp slt i32 %128, 0
    %130 = add nuw nsw i32 %dy.114, 1
    br i1 %129, label %.loopexit, label %125
  
  .loopexit:                                        ; preds = %107, %.lr.ph20, %125, %.lr.ph, %121, %103, %0
    %.5 = phi i32 [ 0, %0 ], [ 1, %103 ], [ 1, %121 ], [ 1, %125 ], [ %128, %.lr.ph ], [ 0, %107 ], [ %110, %.lr.ph20 ]
    ret i32 %.5
  }
  
  ; Function Attrs: nounwind
  define internal i32 @image_render_landscape(%struct.gx_image_enum_s* %penum, i8* readonly %buffer, i32 signext %data_x, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %2 = load i8*, i8** %1, align 8, !tbaa !35
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %4 = load i32, i32* %3, align 8, !tbaa !29
    %5 = add i32 %4, 31
    %6 = lshr i32 %5, 5
    %7 = shl nuw nsw i32 %6, 2
    %8 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 46
    %9 = load i32, i32* %8, align 4, !tbaa !70
    %10 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 47
    %11 = load i32, i32* %10, align 8, !tbaa !71
    %12 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 33
    %13 = load i32, i32* %12, align 8, !tbaa !41
    %.lobit = lshr i32 %13, 31
    %14 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 2
    %15 = load float, float* %14, align 8, !tbaa !72
    %16 = fcmp olt float %15, 0.000000e+00
    %17 = sub nsw i32 0, %11
    %xinc.0 = select i1 %16, i32 -1, i32 1
    %iw.0 = select i1 %16, i32 %17, i32 %11
    %18 = select i1 %16, i32 %11, i32 0
    %ix.0 = add nsw i32 %18, %9
    %19 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 42
    %20 = load i32, i32* %19, align 8, !tbaa !39
    %21 = icmp eq i32 %ix.0, %20
    br i1 %21, label %33, label %22
  
  ; <label>:22                                      ; preds = %0
    %23 = fcmp olt float %15, 0.000000e+00
    %24 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    %25 = load i32, i32* %24, align 4, !tbaa !38
    br i1 %23, label %28, label %26
  
  ; <label>:26                                      ; preds = %22
    %27 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %25, i32 signext %20, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %30
  
  ; <label>:28                                      ; preds = %22
    %29 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %20, i32 signext %25, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %30
  
  ; <label>:30                                      ; preds = %28, %26
    %31 = phi i32 [ %27, %26 ], [ %29, %28 ]
    %32 = icmp slt i32 %31, 0
    br i1 %32, label %.loopexit, label %.critedge
  
  .critedge:                                        ; preds = %30
    %sunkaddr = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr1 = add i32 %sunkaddr, 276
    %sunkaddr2 = inttoptr i32 %sunkaddr1 to i32*
    store i32 %ix.0, i32* %sunkaddr2, align 4, !tbaa !38
    br label %33
  
  ; <label>:33                                      ; preds = %.critedge, %0
    %34 = icmp eq i32 %h, 0
    br i1 %34, label %65, label %.preheader
  
  .preheader:                                       ; preds = %33
    %35 = icmp eq i32 %iw.0, 0
    br i1 %35, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader
    %36 = fcmp olt float %15, 0.000000e+00
    %37 = sext i1 %36 to i32
    %38 = sub i32 0, %iw.0
    br label %39
  
  ; <label>:39                                      ; preds = %63, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %63 ], [ %38, %.lr.ph ]
    %ix.116 = phi i32 [ %ix.0, %.lr.ph ], [ %ix.3, %63 ]
    %orig_row.014 = phi i8* [ null, %.lr.ph ], [ %orig_row.4, %63 ]
    %.ix.1 = add nsw i32 %ix.116, %37
    %40 = and i32 %.ix.1, 7
    %41 = mul nuw i32 %40, %7
    %42 = getelementptr inbounds i8, i8* %2, i32 %41
    %43 = icmp eq i8* %orig_row.014, null
    br i1 %43, label %44, label %47
  
  ; <label>:44                                      ; preds = %39
    %sunkaddr3 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr4 = add i32 %sunkaddr3, 256
    %sunkaddr5 = inttoptr i32 %sunkaddr4 to i32*
    %45 = load i32, i32* %sunkaddr5, align 4, !tbaa !21
    %sunkaddr6 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr7 = add i32 %sunkaddr6, 52
    %sunkaddr8 = inttoptr i32 %sunkaddr7 to i32*
    %46 = load i32, i32* %sunkaddr8, align 4, !tbaa !37
    tail call fastcc void @image_simple_expand(i8* %42, i32 signext 0, i32 signext %7, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %45, i32 signext %46, i8 zeroext 0)
    br label %48
  
  ; <label>:47                                      ; preds = %39
    tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %42, i8* nonnull %orig_row.014, i32 %7, i32 1, i1 false)
    br label %48
  
  ; <label>:48                                      ; preds = %47, %44
    %orig_row.1 = phi i8* [ %42, %44 ], [ %orig_row.014, %47 ]
    %49 = fcmp olt float %15, 0.000000e+00
    br i1 %49, label %57, label %50
  
  ; <label>:50                                      ; preds = %48
    %51 = add nsw i32 %.ix.1, 1
    %52 = icmp eq i32 %40, 7
    br i1 %52, label %53, label %63
  
  ; <label>:53                                      ; preds = %50
    %sunkaddr9 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr10 = add i32 %sunkaddr9, 276
    %sunkaddr11 = inttoptr i32 %sunkaddr10 to i32*
    %54 = load i32, i32* %sunkaddr11, align 4, !tbaa !38
    %55 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %54, i32 signext %51, i32 signext %.lobit, %struct.gx_device_s* %dev)
    %56 = icmp slt i32 %55, 0
    br i1 %56, label %.loopexit, label %.thread
  
  .thread:                                          ; preds = %53
    %sunkaddr12 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr13 = add i32 %sunkaddr12, 276
    %sunkaddr14 = inttoptr i32 %sunkaddr13 to i32*
    store i32 %51, i32* %sunkaddr14, align 4, !tbaa !38
    br label %63
  
  ; <label>:57                                      ; preds = %48
    %58 = icmp eq i32 %40, 0
    br i1 %58, label %59, label %63
  
  ; <label>:59                                      ; preds = %57
    %sunkaddr15 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr16 = add i32 %sunkaddr15, 276
    %sunkaddr17 = inttoptr i32 %sunkaddr16 to i32*
    %60 = load i32, i32* %sunkaddr17, align 4, !tbaa !38
    %61 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %.ix.1, i32 signext %60, i32 signext %.lobit, %struct.gx_device_s* %dev)
    %62 = icmp slt i32 %61, 0
    br i1 %62, label %.loopexit, label %.thread10
  
  .thread10:                                        ; preds = %59
    %sunkaddr18 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr19 = add i32 %sunkaddr18, 276
    %sunkaddr20 = inttoptr i32 %sunkaddr19 to i32*
    store i32 %.ix.1, i32* %sunkaddr20, align 4, !tbaa !38
    br label %63
  
  ; <label>:63                                      ; preds = %.thread10, %57, %.thread, %50
    %orig_row.4 = phi i8* [ %orig_row.1, %50 ], [ %orig_row.1, %57 ], [ null, %.thread ], [ null, %.thread10 ]
    %ix.3 = phi i32 [ %51, %50 ], [ %.ix.1, %57 ], [ %51, %.thread ], [ %.ix.1, %.thread10 ]
    %lsr.iv.next = add i32 %lsr.iv, %xinc.0
    %64 = icmp eq i32 %lsr.iv.next, 0
    br i1 %64, label %._crit_edge, label %39
  
  ._crit_edge:                                      ; preds = %63, %.preheader
    %ix.1.lcssa = phi i32 [ %ix.0, %.preheader ], [ %ix.3, %63 ]
    %sunkaddr21 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr22 = add i32 %sunkaddr21, 280
    %sunkaddr23 = inttoptr i32 %sunkaddr22 to i32*
    store i32 %ix.1.lcssa, i32* %sunkaddr23, align 8, !tbaa !39
    br label %.loopexit
  
  ; <label>:65                                      ; preds = %33
    %66 = fcmp olt float %15, 0.000000e+00
    %67 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    %68 = load i32, i32* %67, align 4, !tbaa !38
    br i1 %66, label %71, label %69
  
  ; <label>:69                                      ; preds = %65
    %70 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %68, i32 signext %ix.0, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %.loopexit
  
  ; <label>:71                                      ; preds = %65
    %72 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %ix.0, i32 signext %68, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %53, %59, %71, %69, %._crit_edge, %30
    %.6 = phi i32 [ 0, %._crit_edge ], [ %31, %30 ], [ %70, %69 ], [ %72, %71 ], [ %61, %59 ], [ %55, %53 ]
    ret i32 %.6
  }
  
  declare i8* @sample_unpack_copy(i8*, i32*, i8*, i32 signext, i32 signext, %union.sample_lookup_s*, i32 signext) #2
  
  ; Function Attrs: norecurse nounwind
  define internal fastcc void @image_simple_expand(i8* nocapture %line, i32 signext %line_x, i32 signext %raster, i8* readonly %buffer, i32 signext %data_x, i32 signext %w, i32 signext %xcur, i32 signext %x_extent, i8 zeroext %zero) unnamed_addr #0 {
    %1 = and i32 %data_x, 7
    %2 = lshr i32 128, %1
    %3 = lshr i32 255, %1
    %4 = add i32 %1, %w
    %5 = ashr i32 %data_x, 3
    %6 = getelementptr inbounds i8, i8* %buffer, i32 %5
    %7 = lshr i32 %4, 3
    %8 = getelementptr inbounds i8, i8* %6, i32 %7
    %9 = zext i8 %zero to i32
    %10 = xor i32 %9, 255
    %11 = icmp eq i32 %w, 0
    br i1 %11, label %.thread, label %12
  
  ; <label>:12                                      ; preds = %0
    %fold = add i32 %w, %data_x
    %13 = and i32 %fold, 7
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %15, label %17
  
  ; <label>:15                                      ; preds = %12
    %16 = getelementptr inbounds i8, i8* %8, i32 -1
    br label %21
  
  ; <label>:17                                      ; preds = %12
    %18 = xor i32 %13, 7
    %19 = shl i32 2, %18
    %20 = trunc i32 %19 to i8
    br label %21
  
  ; <label>:21                                      ; preds = %17, %15
    %stop.0 = phi i8* [ %16, %15 ], [ %8, %17 ]
    %stopbit.0 = phi i8 [ 1, %15 ], [ %20, %17 ]
    %22 = zext i8 %stopbit.0 to i32
    %23 = sub nsw i32 0, %22
    %24 = shl nsw i32 %23, 1
    %25 = load i8, i8* %stop.0, align 1, !tbaa !68
    %26 = icmp eq i8* %stop.0, %6
    %27 = select i1 %26, i32 %3, i32 -1
    %. = and i32 %24, %27
    %28 = zext i8 %25 to i32
    %29 = and i8 %25, %stopbit.0
    %30 = icmp eq i8 %29, 0
    br i1 %30, label %64, label %31
  
  ; <label>:31                                      ; preds = %21
    %32 = xor i32 %28, 254
    %33 = and i32 %32, %.
    %34 = icmp eq i32 %33, 0
    br i1 %34, label %.preheader16, label %35
  
  ; <label>:35                                      ; preds = %31
    %36 = add nuw nsw i32 %22, 255
    %37 = or i32 %28, %36
    %38 = trunc i32 %37 to i8
    br label %62
  
  .preheader16:                                     ; preds = %31, %40
    %stop.1 = phi i8* [ %41, %40 ], [ %stop.0, %31 ]
    %39 = icmp ugt i8* %stop.1, %6
    br i1 %39, label %40, label %.critedge
  
  ; <label>:40                                      ; preds = %.preheader16
    %41 = getelementptr inbounds i8, i8* %stop.1, i32 -1
    %scevgep11 = getelementptr i8, i8* %stop.1, i32 -1
    %42 = load i8, i8* %scevgep11, align 1, !tbaa !68
    %43 = icmp eq i8 %42, -1
    br i1 %43, label %.preheader16, label %.critedge
  
  .critedge:                                        ; preds = %.preheader16, %40
    %44 = icmp eq i8* %stop.1, %6
    br i1 %44, label %54, label %45
  
  ; <label>:45                                      ; preds = %.critedge
    %46 = getelementptr inbounds i8, i8* %6, i32 1
    %47 = icmp eq i8* %stop.1, %46
    br i1 %47, label %48, label %59
  
  ; <label>:48                                      ; preds = %45
    %49 = load i8, i8* %6, align 1, !tbaa !68
    %50 = zext i8 %49 to i32
    %51 = xor i32 %50, -1
    %52 = and i32 %3, %51
    %53 = icmp eq i32 %52, 0
    br i1 %53, label %54, label %59
  
  ; <label>:54                                      ; preds = %48, %.critedge
    %55 = trunc i32 %10 to i8
    %56 = ashr i32 %line_x, 3
    %57 = getelementptr inbounds i8, i8* %line, i32 %56
    %58 = sub i32 %raster, %56
    tail call void @llvm.memset.p0i8.i32(i8* %57, i8 %55, i32 %58, i32 1, i1 false)
    br label %.thread
  
  ; <label>:59                                      ; preds = %48, %45
    %60 = getelementptr inbounds i8, i8* %stop.1, i32 -1
    %61 = load i8, i8* %60, align 1, !tbaa !68
    br label %62
  
  ; <label>:62                                      ; preds = %59, %35
    %stop.2 = phi i8* [ %stop.0, %35 ], [ %60, %59 ]
    %last.0 = phi i8 [ %38, %35 ], [ %61, %59 ]
    %63 = zext i8 %last.0 to i32
    br label %94
  
  ; <label>:64                                      ; preds = %21
    %stopmask.0 = trunc i32 %. to i8
    %65 = and i8 %stopmask.0, %25
    %66 = icmp eq i8 %65, 0
    br i1 %66, label %.preheader15, label %67
  
  ; <label>:67                                      ; preds = %64
    %68 = and i32 %28, %23
    %69 = trunc i32 %68 to i8
    br label %91
  
  .preheader15:                                     ; preds = %64, %71
    %stop.3 = phi i8* [ %72, %71 ], [ %stop.0, %64 ]
    %70 = icmp ugt i8* %stop.3, %6
    br i1 %70, label %71, label %.critedge3
  
  ; <label>:71                                      ; preds = %.preheader15
    %72 = getelementptr inbounds i8, i8* %stop.3, i32 -1
    %scevgep10 = getelementptr i8, i8* %stop.3, i32 -1
    %73 = load i8, i8* %scevgep10, align 1, !tbaa !68
    %74 = icmp eq i8 %73, 0
    br i1 %74, label %.preheader15, label %.critedge3
  
  .critedge3:                                       ; preds = %.preheader15, %71
    %75 = icmp eq i8* %stop.3, %6
    br i1 %75, label %84, label %76
  
  ; <label>:76                                      ; preds = %.critedge3
    %77 = getelementptr inbounds i8, i8* %6, i32 1
    %78 = icmp eq i8* %stop.3, %77
    br i1 %78, label %79, label %88
  
  ; <label>:79                                      ; preds = %76
    %80 = load i8, i8* %6, align 1, !tbaa !68
    %81 = zext i8 %80 to i32
    %82 = and i32 %81, %3
    %83 = icmp eq i32 %82, 0
    br i1 %83, label %84, label %88
  
  ; <label>:84                                      ; preds = %79, %.critedge3
    %85 = ashr i32 %line_x, 3
    %86 = getelementptr inbounds i8, i8* %line, i32 %85
    %87 = sub i32 %raster, %85
    tail call void @llvm.memset.p0i8.i32(i8* %86, i8 %zero, i32 %87, i32 1, i1 false)
    br label %.thread
  
  ; <label>:88                                      ; preds = %79, %76
    %89 = getelementptr inbounds i8, i8* %stop.3, i32 -1
    %90 = load i8, i8* %89, align 1, !tbaa !68
    br label %91
  
  ; <label>:91                                      ; preds = %88, %67
    %stop.4 = phi i8* [ %stop.0, %67 ], [ %89, %88 ]
    %last.1 = phi i8 [ %69, %67 ], [ %90, %88 ]
    %92 = zext i8 %last.1 to i32
    %93 = xor i32 %92, 255
    br label %94
  
  ; <label>:94                                      ; preds = %91, %62
    %.pn87 = phi i32 [ %63, %62 ], [ %93, %91 ]
    %stop.5 = phi i8* [ %stop.2, %62 ], [ %stop.4, %91 ]
    %.sink8.in = getelementptr inbounds [256 x i8], [256 x i8]* @byte_reverse_bits, i32 0, i32 %.pn87
    %.sink8 = load i8, i8* %.sink8.in, align 1, !tbaa !68
    %95 = zext i8 %.sink8 to i32
    %.sink.in = getelementptr inbounds [256 x i8], [256 x i8]* @byte_bit_run_length_0, i32 0, i32 %95
    %.sink = load i8, i8* %.sink.in, align 1, !tbaa !68
    %96 = zext i8 %.sink to i32
    %stopx.0 = add nsw i32 %96, -1
    %97 = icmp eq i8 %.sink, 0
    %98 = getelementptr inbounds i8, i8* %stop.5, i32 1
    %.stop.5 = select i1 %97, i8* %98, i8* %stop.5
    %stopx.0.op = shl i32 1, %stopx.0
    %99 = trunc i32 %stopx.0.op to i8
    %100 = select i1 %97, i8 -128, i8 %99
    %101 = ashr i32 %line_x, 3
    %102 = getelementptr inbounds i8, i8* %line, i32 %101
    %103 = sub i32 %raster, %101
    tail call void @llvm.memset.p0i8.i32(i8* %102, i8 %zero, i32 %103, i32 1, i1 false)
    %104 = icmp sgt i32 %x_extent, -1
    %105 = add i32 %xcur, 2047
    br i1 %104, label %120, label %106
  
  ; <label>:106                                     ; preds = %94
    %107 = add i32 %105, %x_extent
    %108 = and i32 %107, 4095
    %109 = sub nsw i32 %108, %x_extent
    %110 = shl i32 %line_x, 12
    %111 = add nsw i32 %109, %110
    %112 = sub nsw i32 0, %x_extent
    %113 = udiv i32 %112, %w
    %114 = sub i32 0, %113
    %115 = urem i32 %112, %w
    %116 = icmp eq i32 %115, 0
    br i1 %116, label %126, label %117
  
  ; <label>:117                                     ; preds = %106
    %118 = xor i32 %113, -1
    %119 = sub i32 %w, %115
    br label %126
  
  ; <label>:120                                     ; preds = %94
    %121 = and i32 %105, 4095
    %122 = shl i32 %line_x, 12
    %123 = or i32 %121, %122
    %124 = udiv i32 %x_extent, %w
    %125 = urem i32 %x_extent, %w
    br label %126
  
  ; <label>:126                                     ; preds = %120, %117, %106
    %127 = phi i32 [ %111, %117 ], [ %111, %106 ], [ %123, %120 ]
    %xl.sroa.82.0 = phi i32 [ %118, %117 ], [ %114, %106 ], [ %124, %120 ]
    %xl.sroa.98.0 = phi i32 [ %119, %117 ], [ 0, %106 ], [ %125, %120 ]
    %128 = trunc i32 %2 to i8
    %129 = sub i32 %w, %xl.sroa.98.0
    %130 = icmp ult i32 %xl.sroa.98.0, %129
    %131 = shl i32 %xl.sroa.98.0, 1
    %132 = sub i32 %xl.sroa.98.0, %129
    %133 = add nsw i32 %xl.sroa.82.0, 1
    %dxx4.sroa.16.0 = select i1 %130, i32 %131, i32 %132
    %134 = select i1 %130, i32 %xl.sroa.82.0, i32 %133
    %135 = add nsw i32 %134, %xl.sroa.82.0
    %136 = icmp ult i32 %dxx4.sroa.16.0, %129
    %137 = shl i32 %dxx4.sroa.16.0, 1
    %138 = sub i32 %dxx4.sroa.16.0, %129
    %dxx4.sroa.16.1 = select i1 %136, i32 %137, i32 %138
    %139 = zext i1 %136 to i32
    %factor = shl i32 %135, 1
    %140 = or i32 %139, %factor
    %141 = xor i32 %140, 1
    %142 = icmp ult i32 %dxx4.sroa.16.1, %129
    %143 = shl i32 %dxx4.sroa.16.1, 1
    %144 = sub i32 %dxx4.sroa.16.1, %129
    %145 = add nsw i32 %141, 1
    %dxx8.sroa.16.0 = select i1 %142, i32 %143, i32 %144
    %146 = select i1 %142, i32 %141, i32 %145
    %147 = add nsw i32 %146, %141
    %148 = icmp ult i32 %dxx8.sroa.16.0, %129
    %149 = shl i32 %dxx8.sroa.16.0, 1
    %150 = sub i32 %dxx8.sroa.16.0, %129
    %151 = add nsw i32 %147, 1
    %dxx16.sroa.8.0 = select i1 %148, i32 %149, i32 %150
    %152 = select i1 %148, i32 %147, i32 %151
    %153 = add nsw i32 %152, %147
    %154 = icmp ult i32 %dxx16.sroa.8.0, %129
    %155 = sub i32 0, %129
    %dxx24.sroa.8.0.p = select i1 %154, i32 %dxx8.sroa.16.0, i32 %155
    %dxx24.sroa.8.0 = add i32 %dxx24.sroa.8.0.p, %dxx16.sroa.8.0
    %156 = select i1 %154, i32 %147, i32 %151
    %157 = add nsw i32 %153, %156
    %158 = icmp ult i32 %dxx24.sroa.8.0, %129
    %dxx32.sroa.7.0.p = select i1 %158, i32 %dxx8.sroa.16.0, i32 %155
    %dxx32.sroa.7.0 = add i32 %dxx32.sroa.7.0.p, %dxx24.sroa.8.0
    %159 = select i1 %158, i32 %147, i32 %151
    %160 = add nsw i32 %157, %159
    %161 = load i8, i8* %6, align 1, !tbaa !68
    %162 = add nsw i32 %127, %x_extent
    %163 = sub i32 0, %xl.sroa.98.0
    %164 = sub i32 0, %dxx4.sroa.16.1
    %165 = sub i32 0, %dxx8.sroa.16.0
    %166 = sub i32 0, %dxx32.sroa.7.0
    %167 = sub i32 0, %dxx24.sroa.8.0
    %168 = sub i32 0, %dxx16.sroa.8.0
    %scevgep = getelementptr i8, i8* %line, i32 2
    %scevgep128 = getelementptr i8, i8* %line, i32 1
    br label %.critedge5
  
  .critedge5:                                       ; preds = %334, %126
    %psrc.0 = phi i8* [ %6, %126 ], [ %psrc.6, %334 ]
    %xl.sroa.0.0 = phi i32 [ %127, %126 ], [ %xl.sroa.0.11, %334 ]
    %xl.sroa.27.0 = phi i32 [ %w, %126 ], [ %xl.sroa.27.22, %334 ]
    %data.0 = phi i8 [ %161, %126 ], [ %data.4, %334 ]
    %sbit.0 = phi i8 [ %128, %126 ], [ %sbit.8, %334 ]
    %169 = zext i8 %data.0 to i32
    %170 = xor i32 %169, 255
    %171 = zext i8 %sbit.0 to i32
    %172 = and i32 %171, %170
    %173 = icmp eq i32 %172, 0
    br i1 %173, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.critedge5, %.lr.ph
    %sbit.149 = phi i8 [ %177, %.lr.ph ], [ %sbit.0, %.critedge5 ]
    %xl.sroa.27.148 = phi i32 [ %xl.sroa.27.2, %.lr.ph ], [ %xl.sroa.27.0, %.critedge5 ]
    %xl.sroa.0.147 = phi i32 [ %176, %.lr.ph ], [ %xl.sroa.0.0, %.critedge5 ]
    %174 = icmp ult i32 %xl.sroa.27.148, %xl.sroa.98.0
    %xl.sroa.27.2.p = select i1 %174, i32 %129, i32 %163
    %xl.sroa.27.2 = add i32 %xl.sroa.27.2.p, %xl.sroa.27.148
    %175 = select i1 %174, i32 %133, i32 %xl.sroa.82.0
    %176 = add nsw i32 %175, %xl.sroa.0.147
    %177 = lshr i8 %sbit.149, 1
    %178 = zext i8 %177 to i32
    %179 = and i32 %178, %170
    %180 = icmp eq i32 %179, 0
    br i1 %180, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.critedge5
    %sbit.1.lcssa = phi i8 [ %sbit.0, %.critedge5 ], [ %177, %.lr.ph ]
    %xl.sroa.27.1.lcssa = phi i32 [ %xl.sroa.27.0, %.critedge5 ], [ %xl.sroa.27.2, %.lr.ph ]
    %xl.sroa.0.1.lcssa = phi i32 [ %xl.sroa.0.0, %.critedge5 ], [ %176, %.lr.ph ]
    %181 = icmp eq i8 %sbit.1.lcssa, 0
    br i1 %181, label %.preheader13, label %.loopexit12
  
  .preheader13:                                     ; preds = %._crit_edge
    %182 = getelementptr inbounds i8, i8* %psrc.0, i32 1
    %183 = load i8, i8* %182, align 1, !tbaa !68
    %184 = icmp eq i8 %183, 0
    br i1 %184, label %.lr.ph55.preheader, label %.loopexit14
  
  .lr.ph55.preheader:                               ; preds = %.preheader13
    %scevgep1 = getelementptr i8, i8* %psrc.0, i32 2
    br label %.lr.ph55
  
  .lr.ph55:                                         ; preds = %207, %.lr.ph55.preheader
    %lsr.iv = phi i8* [ %scevgep2, %207 ], [ %scevgep1, %.lr.ph55.preheader ]
    %xl.sroa.27.354 = phi i32 [ %xl.sroa.27.7, %207 ], [ %xl.sroa.27.1.lcssa, %.lr.ph55.preheader ]
    %xl.sroa.0.253 = phi i32 [ %211, %207 ], [ %xl.sroa.0.1.lcssa, %.lr.ph55.preheader ]
    %185 = load i8, i8* %lsr.iv, align 1, !tbaa !68
    %186 = icmp eq i8 %185, 0
    br i1 %186, label %191, label %187
  
  ; <label>:187                                     ; preds = %.lr.ph55
    %188 = icmp ult i32 %xl.sroa.27.354, %dxx8.sroa.16.0
    %xl.sroa.27.4.p = select i1 %188, i32 %129, i32 %165
    %xl.sroa.27.4 = add i32 %xl.sroa.27.4.p, %xl.sroa.27.354
    %189 = select i1 %188, i32 %151, i32 %147
    %190 = add nsw i32 %189, %xl.sroa.0.253
    br label %.loopexit14
  
  ; <label>:191                                     ; preds = %.lr.ph55
    %scevgep8 = getelementptr i8, i8* %lsr.iv, i32 1
    %192 = load i8, i8* %scevgep8, align 1, !tbaa !68
    %193 = icmp eq i8 %192, 0
    %scevgep7 = getelementptr i8, i8* %lsr.iv, i32 1
    br i1 %193, label %199, label %194
  
  ; <label>:194                                     ; preds = %191
    %195 = icmp ult i32 %xl.sroa.27.354, %dxx16.sroa.8.0
    %xl.sroa.27.5.p = select i1 %195, i32 %129, i32 %168
    %xl.sroa.27.5 = add i32 %xl.sroa.27.5.p, %xl.sroa.27.354
    %196 = zext i1 %195 to i32
    %197 = add i32 %xl.sroa.0.253, %153
    %198 = add i32 %197, %196
    br label %.loopexit14
  
  ; <label>:199                                     ; preds = %191
    %scevgep6 = getelementptr i8, i8* %lsr.iv, i32 2
    %200 = load i8, i8* %scevgep6, align 1, !tbaa !68
    %201 = icmp eq i8 %200, 0
    %scevgep5 = getelementptr i8, i8* %lsr.iv, i32 2
    br i1 %201, label %207, label %202
  
  ; <label>:202                                     ; preds = %199
    %203 = icmp ult i32 %xl.sroa.27.354, %dxx24.sroa.8.0
    %xl.sroa.27.6.p = select i1 %203, i32 %129, i32 %167
    %xl.sroa.27.6 = add i32 %xl.sroa.27.6.p, %xl.sroa.27.354
    %204 = zext i1 %203 to i32
    %205 = add i32 %xl.sroa.0.253, %157
    %206 = add i32 %205, %204
    br label %.loopexit14
  
  ; <label>:207                                     ; preds = %199
    %208 = icmp ult i32 %xl.sroa.27.354, %dxx32.sroa.7.0
    %xl.sroa.27.7.p = select i1 %208, i32 %129, i32 %166
    %xl.sroa.27.7 = add i32 %xl.sroa.27.7.p, %xl.sroa.27.354
    %209 = zext i1 %208 to i32
    %210 = add i32 %160, %xl.sroa.0.253
    %211 = add i32 %210, %209
    %scevgep4 = getelementptr i8, i8* %lsr.iv, i32 3
    %212 = load i8, i8* %scevgep4, align 1, !tbaa !68
    %213 = icmp eq i8 %212, 0
    %scevgep2 = getelementptr i8, i8* %lsr.iv, i32 4
    %scevgep3 = getelementptr i8, i8* %scevgep2, i32 -1
    br i1 %213, label %.lr.ph55, label %.loopexit14
  
  .loopexit14:                                      ; preds = %207, %202, %194, %187, %.preheader13
    %psrc.2 = phi i8* [ %lsr.iv, %187 ], [ %scevgep7, %194 ], [ %scevgep5, %202 ], [ %182, %.preheader13 ], [ %scevgep3, %207 ]
    %xl.sroa.0.3 = phi i32 [ %190, %187 ], [ %198, %194 ], [ %206, %202 ], [ %xl.sroa.0.1.lcssa, %.preheader13 ], [ %211, %207 ]
    %xl.sroa.27.8 = phi i32 [ %xl.sroa.27.4, %187 ], [ %xl.sroa.27.5, %194 ], [ %xl.sroa.27.6, %202 ], [ %xl.sroa.27.1.lcssa, %.preheader13 ], [ %xl.sroa.27.7, %207 ]
    %data.1 = phi i8 [ %185, %187 ], [ %192, %194 ], [ %200, %202 ], [ %183, %.preheader13 ], [ %212, %207 ]
    %214 = zext i8 %data.1 to i32
    %215 = icmp ugt i8 %data.1, 15
    br i1 %215, label %220, label %216
  
  ; <label>:216                                     ; preds = %.loopexit14
    %217 = icmp ult i32 %xl.sroa.27.8, %dxx4.sroa.16.1
    %xl.sroa.27.9.p = select i1 %217, i32 %129, i32 %164
    %xl.sroa.27.9 = add i32 %xl.sroa.27.9.p, %xl.sroa.27.8
    %218 = select i1 %217, i32 %145, i32 %141
    %219 = add nsw i32 %218, %xl.sroa.0.3
    br label %220
  
  ; <label>:220                                     ; preds = %216, %.loopexit14
    %xl.sroa.0.4 = phi i32 [ %219, %216 ], [ %xl.sroa.0.3, %.loopexit14 ]
    %xl.sroa.27.10 = phi i32 [ %xl.sroa.27.9, %216 ], [ %xl.sroa.27.8, %.loopexit14 ]
    %sbit.2 = phi i8 [ 8, %216 ], [ -128, %.loopexit14 ]
    %221 = xor i32 %214, 255
    %222 = zext i8 %sbit.2 to i32
    %223 = and i32 %222, %221
    %224 = icmp eq i32 %223, 0
    br i1 %224, label %.loopexit12, label %.lr.ph64
  
  .lr.ph64:                                         ; preds = %220, %.lr.ph64
    %sbit.362 = phi i8 [ %228, %.lr.ph64 ], [ %sbit.2, %220 ]
    %xl.sroa.27.1161 = phi i32 [ %xl.sroa.27.12, %.lr.ph64 ], [ %xl.sroa.27.10, %220 ]
    %xl.sroa.0.560 = phi i32 [ %227, %.lr.ph64 ], [ %xl.sroa.0.4, %220 ]
    %225 = icmp ult i32 %xl.sroa.27.1161, %xl.sroa.98.0
    %xl.sroa.27.12.p = select i1 %225, i32 %129, i32 %163
    %xl.sroa.27.12 = add i32 %xl.sroa.27.12.p, %xl.sroa.27.1161
    %226 = select i1 %225, i32 %133, i32 %xl.sroa.82.0
    %227 = add nsw i32 %226, %xl.sroa.0.560
    %228 = lshr i8 %sbit.362, 1
    %229 = zext i8 %228 to i32
    %230 = and i32 %229, %221
    %231 = icmp eq i32 %230, 0
    br i1 %231, label %.loopexit12, label %.lr.ph64
  
  .loopexit12:                                      ; preds = %.lr.ph64, %220, %._crit_edge
    %psrc.3 = phi i8* [ %psrc.0, %._crit_edge ], [ %psrc.2, %220 ], [ %psrc.2, %.lr.ph64 ]
    %xl.sroa.0.6 = phi i32 [ %xl.sroa.0.1.lcssa, %._crit_edge ], [ %xl.sroa.0.4, %220 ], [ %227, %.lr.ph64 ]
    %xl.sroa.27.13 = phi i32 [ %xl.sroa.27.1.lcssa, %._crit_edge ], [ %xl.sroa.27.10, %220 ], [ %xl.sroa.27.12, %.lr.ph64 ]
    %data.2.in = phi i32 [ %170, %._crit_edge ], [ %221, %220 ], [ %221, %.lr.ph64 ]
    %sbit.4 = phi i8 [ %sbit.1.lcssa, %._crit_edge ], [ %sbit.2, %220 ], [ %228, %.lr.ph64 ]
    %232 = ashr i32 %xl.sroa.0.6, 12
    %233 = icmp uge i8* %psrc.3, %.stop.5
    %234 = icmp eq i8 %sbit.4, %100
    %or.cond = and i1 %233, %234
    br i1 %or.cond, label %235, label %236
  
  ; <label>:235                                     ; preds = %.loopexit12
    %data.2 = trunc i32 %data.2.in to i8
    br label %.loopexit10
  
  ; <label>:236                                     ; preds = %.loopexit12
    %237 = xor i32 %data.2.in, 255
    br label %238
  
  ; <label>:238                                     ; preds = %238, %236
    %xl.sroa.0.7 = phi i32 [ %xl.sroa.0.6, %236 ], [ %241, %238 ]
    %xl.sroa.27.14 = phi i32 [ %xl.sroa.27.13, %236 ], [ %xl.sroa.27.15, %238 ]
    %sbit.5 = phi i8 [ %sbit.4, %236 ], [ %242, %238 ]
    %239 = icmp ult i32 %xl.sroa.27.14, %xl.sroa.98.0
    %xl.sroa.27.15.p = select i1 %239, i32 %129, i32 %163
    %xl.sroa.27.15 = add i32 %xl.sroa.27.15.p, %xl.sroa.27.14
    %240 = select i1 %239, i32 %133, i32 %xl.sroa.82.0
    %241 = add nsw i32 %240, %xl.sroa.0.7
    %242 = lshr i8 %sbit.5, 1
    %243 = zext i8 %242 to i32
    %244 = and i32 %243, %237
    %245 = icmp eq i32 %244, 0
    br i1 %245, label %246, label %238
  
  ; <label>:246                                     ; preds = %238
    %247 = trunc i32 %237 to i8
    %248 = icmp eq i8 %242, 0
    br i1 %248, label %.preheader11, label %.loopexit10
  
  .preheader11:                                     ; preds = %246
    %249 = getelementptr inbounds i8, i8* %psrc.3, i32 1
    %250 = load i8, i8* %249, align 1, !tbaa !68
    %251 = icmp eq i8 %250, -1
    br i1 %251, label %.lr.ph70, label %._crit_edge71
  
  .lr.ph70:                                         ; preds = %.preheader11, %.lr.ph70
    %252 = phi i8* [ %256, %.lr.ph70 ], [ %249, %.preheader11 ]
    %xl.sroa.27.1669 = phi i32 [ %xl.sroa.27.17, %.lr.ph70 ], [ %xl.sroa.27.15, %.preheader11 ]
    %xl.sroa.0.868 = phi i32 [ %255, %.lr.ph70 ], [ %241, %.preheader11 ]
    %253 = icmp ult i32 %xl.sroa.27.1669, %dxx8.sroa.16.0
    %xl.sroa.27.17.p = select i1 %253, i32 %129, i32 %165
    %xl.sroa.27.17 = add i32 %xl.sroa.27.17.p, %xl.sroa.27.1669
    %254 = select i1 %253, i32 %151, i32 %147
    %255 = add nsw i32 %254, %xl.sroa.0.868
    %256 = getelementptr inbounds i8, i8* %252, i32 1
    %scevgep9 = getelementptr i8, i8* %252, i32 1
    %257 = load i8, i8* %scevgep9, align 1, !tbaa !68
    %258 = icmp eq i8 %257, -1
    br i1 %258, label %.lr.ph70, label %._crit_edge71
  
  ._crit_edge71:                                    ; preds = %.lr.ph70, %.preheader11
    %.lcssa45 = phi i8 [ %250, %.preheader11 ], [ %257, %.lr.ph70 ]
    %.lcssa44 = phi i8* [ %249, %.preheader11 ], [ %256, %.lr.ph70 ]
    %xl.sroa.27.16.lcssa = phi i32 [ %xl.sroa.27.15, %.preheader11 ], [ %xl.sroa.27.17, %.lr.ph70 ]
    %xl.sroa.0.8.lcssa = phi i32 [ %241, %.preheader11 ], [ %255, %.lr.ph70 ]
    %259 = icmp ult i8 %.lcssa45, -16
    br i1 %259, label %.preheader9, label %260
  
  ; <label>:260                                     ; preds = %._crit_edge71
    %261 = icmp ult i32 %xl.sroa.27.16.lcssa, %dxx4.sroa.16.1
    %xl.sroa.27.18.p = select i1 %261, i32 %129, i32 %164
    %xl.sroa.27.18 = add i32 %xl.sroa.27.18.p, %xl.sroa.27.16.lcssa
    %262 = select i1 %261, i32 %145, i32 %141
    %263 = add nsw i32 %262, %xl.sroa.0.8.lcssa
    br label %.preheader9
  
  .preheader9:                                      ; preds = %260, %._crit_edge71
    %xl.sroa.0.9.ph = phi i32 [ %xl.sroa.0.8.lcssa, %._crit_edge71 ], [ %263, %260 ]
    %xl.sroa.27.19.ph = phi i32 [ %xl.sroa.27.16.lcssa, %._crit_edge71 ], [ %xl.sroa.27.18, %260 ]
    %sbit.6.ph = phi i8 [ -128, %._crit_edge71 ], [ 8, %260 ]
    %264 = and i8 %sbit.6.ph, %.lcssa45
    %265 = icmp eq i8 %264, 0
    br i1 %265, label %.loopexit10, label %.lr.ph79
  
  .lr.ph79:                                         ; preds = %.preheader9, %.lr.ph79
    %sbit.678 = phi i8 [ %269, %.lr.ph79 ], [ %sbit.6.ph, %.preheader9 ]
    %xl.sroa.27.1977 = phi i32 [ %xl.sroa.27.20, %.lr.ph79 ], [ %xl.sroa.27.19.ph, %.preheader9 ]
    %xl.sroa.0.976 = phi i32 [ %268, %.lr.ph79 ], [ %xl.sroa.0.9.ph, %.preheader9 ]
    %266 = icmp ult i32 %xl.sroa.27.1977, %xl.sroa.98.0
    %xl.sroa.27.20.p = select i1 %266, i32 %129, i32 %163
    %xl.sroa.27.20 = add i32 %xl.sroa.27.20.p, %xl.sroa.27.1977
    %267 = select i1 %266, i32 %133, i32 %xl.sroa.82.0
    %268 = add nsw i32 %267, %xl.sroa.0.976
    %269 = lshr i8 %sbit.678, 1
    %270 = and i8 %269, %.lcssa45
    %271 = icmp eq i8 %270, 0
    br i1 %271, label %.loopexit10, label %.lr.ph79
  
  .loopexit10:                                      ; preds = %.lr.ph79, %.preheader9, %246, %235
    %psrc.6 = phi i8* [ %psrc.3, %235 ], [ %psrc.3, %246 ], [ %.lcssa44, %.preheader9 ], [ %.lcssa44, %.lr.ph79 ]
    %xl.sroa.0.11 = phi i32 [ %xl.sroa.0.6, %235 ], [ %241, %246 ], [ %xl.sroa.0.9.ph, %.preheader9 ], [ %268, %.lr.ph79 ]
    %xl.sroa.27.22 = phi i32 [ %xl.sroa.27.13, %235 ], [ %xl.sroa.27.15, %246 ], [ %xl.sroa.27.19.ph, %.preheader9 ], [ %xl.sroa.27.20, %.lr.ph79 ]
    %data.4 = phi i8 [ %data.2, %235 ], [ %247, %246 ], [ %.lcssa45, %.preheader9 ], [ %.lcssa45, %.lr.ph79 ]
    %.pn.in = phi i32 [ %162, %235 ], [ %241, %246 ], [ %xl.sroa.0.9.ph, %.preheader9 ], [ %268, %.lr.ph79 ]
    %sbit.8 = phi i8 [ %100, %235 ], [ %242, %246 ], [ %sbit.6.ph, %.preheader9 ], [ %269, %.lr.ph79 ]
    %.pn = ashr i32 %.pn.in, 12
    %n.0 = sub nsw i32 %.pn, %232
    %272 = icmp slt i32 %n.0, 0
    %273 = sub nsw i32 0, %n.0
    %.pn. = select i1 %272, i32 %.pn, i32 %232
    %.n.0 = select i1 %272, i32 %273, i32 %n.0
    %274 = ashr i32 %.pn., 3
    %275 = getelementptr inbounds i8, i8* %line, i32 %274
    %276 = and i32 %.pn., 7
    %277 = add nsw i32 %276, %.n.0
    %278 = icmp slt i32 %277, 9
    br i1 %278, label %279, label %291
  
  ; <label>:279                                     ; preds = %.loopexit10
    %280 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %276
    %281 = load i8, i8* %280, align 1, !tbaa !68
    %282 = zext i8 %281 to i32
    %283 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %277
    %284 = load i8, i8* %283, align 1, !tbaa !68
    %285 = zext i8 %284 to i32
    %286 = sub nsw i32 %282, %285
    %287 = load i8, i8* %275, align 1, !tbaa !68
    %288 = zext i8 %287 to i32
    %289 = xor i32 %288, %286
    %290 = trunc i32 %289 to i8
    store i8 %290, i8* %275, align 1, !tbaa !68
    br label %334
  
  ; <label>:291                                     ; preds = %.loopexit10
    %292 = add nsw i32 %277, -8
    %293 = icmp slt i32 %292, 9
    %294 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %276
    %295 = load i8, i8* %294, align 1, !tbaa !68
    br i1 %293, label %296, label %304
  
  ; <label>:296                                     ; preds = %291
    %297 = load i8, i8* %275, align 1, !tbaa !68
    %298 = xor i8 %297, %295
    store i8 %298, i8* %275, align 1, !tbaa !68
    %299 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.rmasks, i32 0, i32 %292
    %300 = load i8, i8* %299, align 1, !tbaa !68
    %301 = getelementptr inbounds i8, i8* %275, i32 1
    %302 = load i8, i8* %301, align 1, !tbaa !68
    %303 = xor i8 %302, %300
    store i8 %303, i8* %301, align 1, !tbaa !68
    br label %334
  
  ; <label>:304                                     ; preds = %291
    %305 = getelementptr inbounds i8, i8* %275, i32 1
    %306 = load i8, i8* %275, align 1, !tbaa !68
    %307 = xor i8 %306, %295
    store i8 %307, i8* %275, align 1, !tbaa !68
    %308 = icmp sgt i32 %292, 55
    br i1 %308, label %322, label %.preheader
  
  .preheader:                                       ; preds = %304
    %309 = add nsw i32 %277, -16
    %310 = icmp sgt i32 %309, -1
    br i1 %310, label %.lr.ph84.preheader, label %.loopexit
  
  .lr.ph84.preheader:                               ; preds = %.preheader
    %311 = trunc i32 %10 to i8
    %312 = add nsw i32 %232, -1
    %313 = sub nsw i32 %312, %.pn
    %314 = icmp sgt i32 %313, -1
    %smax = select i1 %314, i32 %313, i32 -1
    %315 = sub nsw i32 %312, %smax
    %316 = and i32 %315, 7
    %317 = add nsw i32 %.n.0, -16
    %318 = add nsw i32 %317, %316
    %319 = lshr i32 %318, 3
    %320 = add nsw i32 %274, %319
    %scevgep129 = getelementptr i8, i8* %scevgep128, i32 %274
    %321 = add nuw nsw i32 %319, 1
    call void @llvm.memset.p0i8.i32(i8* %scevgep129, i8 %311, i32 %321, i32 1, i1 false)
    br label %.lr.ph84
  
  ; <label>:322                                     ; preds = %304
    %323 = trunc i32 %10 to i8
    %324 = ashr i32 %292, 3
    tail call void @llvm.memset.p0i8.i32(i8* %305, i8 %323, i32 %324, i32 1, i1 false)
    %325 = getelementptr inbounds i8, i8* %305, i32 %324
    br label %.loopexit
  
  .lr.ph84:                                         ; preds = %.lr.ph84, %.lr.ph84.preheader
    %326 = phi i32 [ %327, %.lr.ph84 ], [ %309, %.lr.ph84.preheader ]
    %327 = add nsw i32 %326, -8
    %328 = icmp sgt i32 %327, -1
    br i1 %328, label %.lr.ph84, label %.loopexit.loopexit
  
  .loopexit.loopexit:                               ; preds = %.lr.ph84
    %scevgep127 = getelementptr i8, i8* %scevgep, i32 %320
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.loopexit.loopexit, %322, %.preheader
    %n.3 = phi i32 [ %292, %322 ], [ %309, %.preheader ], [ %327, %.loopexit.loopexit ]
    %bp.1 = phi i8* [ %325, %322 ], [ %305, %.preheader ], [ %scevgep127, %.loopexit.loopexit ]
    %329 = and i32 %n.3, 7
    %330 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.rmasks, i32 0, i32 %329
    %331 = load i8, i8* %330, align 1, !tbaa !68
    %332 = load i8, i8* %bp.1, align 1, !tbaa !68
    %333 = xor i8 %332, %331
    store i8 %333, i8* %bp.1, align 1, !tbaa !68
    br label %334
  
  ; <label>:334                                     ; preds = %.loopexit, %296, %279
    %335 = icmp uge i8* %psrc.6, %.stop.5
    %336 = icmp eq i8 %sbit.8, %100
    %or.cond4 = and i1 %335, %336
    br i1 %or.cond4, label %.thread, label %.critedge5
  
  .thread:                                          ; preds = %334, %84, %54, %0
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %data, i32 signext %dx, i32 signext %raster, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) unnamed_addr #1 {
    %1 = ptrtoint i8* %data to i32
    %2 = and i32 %1, 3
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 48, i32 0, i32 0, i32 0, i32 0
    %4 = load i32, i32* %3, align 8, !tbaa !69
    %5 = icmp eq i32 %4, 0
    %6 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0
    %7 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0
    %pdc0.0 = select i1 %5, %struct.gx_device_color_s* %7, %struct.gx_device_color_s* %6
    %pdc1.0 = select i1 %5, %struct.gx_device_color_s* %6, %struct.gx_device_color_s* %7
    %8 = sub nsw i32 0, %2
    %9 = getelementptr inbounds i8, i8* %data, i32 %8
    %10 = shl nuw nsw i32 %2, 3
    %11 = add i32 %10, %dx
    %12 = bitcast %struct.gx_device_color_s* %pdc0.0 to %struct.gx_device_color_procs_s**
    %13 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %12, align 4, !tbaa !59
    %14 = icmp eq %struct.gx_device_color_procs_s* %13, @gx_dc_procs_pure
    %15 = bitcast %struct.gx_device_color_s* %pdc1.0 to %struct.gx_device_color_procs_s**
    %16 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %15, align 4, !tbaa !59
    br i1 %14, label %17, label %35
  
  ; <label>:17                                      ; preds = %0
    %18 = icmp eq %struct.gx_device_color_procs_s* %16, @gx_dc_procs_pure
    br i1 %18, label %19, label %42
  
  ; <label>:19                                      ; preds = %17
    %20 = icmp eq i32 %h, 1
    %21 = and i32 %raster, 3
    %22 = icmp eq i32 %21, 0
    %or.cond = or i1 %22, %20
    br i1 %or.cond, label %23, label %26
  
  ; <label>:23                                      ; preds = %19
    %24 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 0, i32 21, i32 9
    %25 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** %24, align 4, !tbaa !46
    br label %26
  
  ; <label>:26                                      ; preds = %23, %19
    %27 = phi i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)* [ %25, %23 ], [ @gx_copy_mono_unaligned, %19 ]
    %28 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc0.0, i32 0, i32 1
    %29 = bitcast %union._c* %28 to i32*
    %30 = load i32, i32* %29, align 4, !tbaa !64
    %31 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc1.0, i32 0, i32 1
    %32 = bitcast %union._c* %31 to i32*
    %33 = load i32, i32* %32, align 4, !tbaa !64
    %34 = tail call i32 %27(%struct.gx_device_s* %dev, i8* %9, i32 signext %11, i32 signext %raster, i32 signext 0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, i32 signext %30, i32 signext %33) #4
    br label %56
  
  ; <label>:35                                      ; preds = %0
    %36 = icmp eq %struct.gx_device_color_procs_s* %16, @gx_dc_procs_pure
    br i1 %36, label %37, label %.thread3
  
  ; <label>:37                                      ; preds = %35
    %38 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc1.0, i32 0, i32 1
    %39 = bitcast %union._c* %38 to i32*
    %40 = load i32, i32* %39, align 4, !tbaa !64
    %41 = icmp eq i32 %40, -1
    br i1 %41, label %50, label %.thread3
  
  ; <label>:42                                      ; preds = %17
    %43 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc0.0, i32 0, i32 1
    %44 = bitcast %union._c* %43 to i32*
    %45 = load i32, i32* %44, align 4, !tbaa !64
    %46 = icmp eq i32 %45, -1
    br i1 %46, label %50, label %.thread3
  
  .thread3:                                         ; preds = %42, %37, %35
    %47 = getelementptr inbounds %struct.gx_device_color_procs_s, %struct.gx_device_color_procs_s* %13, i32 0, i32 1
    %48 = load i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)*, i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)** %47, align 4, !tbaa !73
    %49 = tail call i32 %48(%struct.gx_device_color_s* nonnull %pdc0.0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev, i32 signext 252, %struct.gx_rop_source_s* null) #4
    %not. = icmp sgt i32 %49, -1
    br i1 %not., label %50, label %56
  
  ; <label>:50                                      ; preds = %.thread3, %42, %37
    %pdc.0 = phi %struct.gx_device_color_s* [ %pdc0.0, %37 ], [ %pdc1.0, %.thread3 ], [ %pdc1.0, %42 ]
    %invert.0 = phi i32 [ 1, %37 ], [ 0, %.thread3 ], [ 0, %42 ]
    %51 = bitcast %struct.gx_device_color_s* %pdc.0 to %struct.gx_device_color_procs_s**
    %52 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %51, align 4, !tbaa !59
    %53 = getelementptr inbounds %struct.gx_device_color_procs_s, %struct.gx_device_color_procs_s* %52, i32 0, i32 2
    %54 = load i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)*, i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)** %53, align 4, !tbaa !75
    %55 = tail call i32 %54(%struct.gx_device_color_s* %pdc.0, i8* %9, i32 signext %11, i32 signext %raster, i32 signext 0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev, i32 signext 252, i32 signext %invert.0) #4
    br label %56
  
  ; <label>:56                                      ; preds = %50, %.thread3, %26
    %.2 = phi i32 [ %34, %26 ], [ %55, %50 ], [ %49, %.thread3 ]
    ret i32 %.2
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture readonly, i32, i32, i1) #3
  
  declare i32 @gx_copy_mono_unaligned(%struct.gx_device_s*, i8*, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %x0, i32 signext %x1, i32 signext %y_neg, %struct.gx_device_s* %dev) unnamed_addr #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %2 = load i8*, i8** %1, align 8, !tbaa !35
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %4 = load i32, i32* %3, align 8, !tbaa !29
    %5 = add i32 %4, 31
    %6 = lshr i32 %5, 5
    %7 = shl nuw nsw i32 %6, 2
    %8 = shl nuw i32 %6, 5
    %9 = getelementptr inbounds i8, i8* %2, i32 %8
    %10 = sub nsw i32 %x1, %x0
    %11 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 1, i32 0, i32 0
    %12 = load i32, i32* %11, align 4, !tbaa !21
    %13 = add nsw i32 %12, 2047
    %14 = ashr i32 %13, 12
    %15 = icmp eq i32 %x1, %x0
    %16 = icmp eq i32 %4, 0
    %or.cond = or i1 %15, %16
    br i1 %or.cond, label %34, label %17
  
  ; <label>:17                                      ; preds = %0
    %18 = add i32 %4, -1
    %19 = lshr i32 %18, 3
    %20 = add i32 %19, 1
    %21 = shl i32 %19, 5
    %22 = add i32 %4, 31
    %23 = lshr i32 %22, 5
    %24 = shl i32 %23, 5
    %25 = add i32 %21, %24
    %scevgep = getelementptr i8, i8* %2, i32 %25
    br label %26
  
  ; <label>:26                                      ; preds = %26, %17
    %lsr.iv1 = phi i8* [ %scevgep2, %26 ], [ %scevgep, %17 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %26 ], [ %20, %17 ]
    %scevgep3 = getelementptr i8, i8* %2, i32 %lsr.iv
    %scevgep4 = getelementptr i8, i8* %scevgep3, i32 -1
    tail call void @memflip8x8(i8* %scevgep4, i32 signext %7, i8* %lsr.iv1, i32 signext 4) #4
    %lsr.iv.next = add nsw i32 %lsr.iv, -1
    %scevgep2 = getelementptr i8, i8* %lsr.iv1, i32 -32
    %27 = icmp sgt i32 %lsr.iv.next, 0
    br i1 %27, label %26, label %.loopexit
  
  .loopexit:                                        ; preds = %26
    %28 = icmp slt i32 %10, 0
    %29 = sub nsw i32 0, %10
    %x1.x0 = select i1 %28, i32 %x1, i32 %x0
    %. = select i1 %28, i32 %29, i32 %10
    %30 = icmp eq i32 %y_neg, 0
    %31 = select i1 %30, i32 0, i32 %4
    %y.0 = sub i32 %14, %31
    %32 = and i32 %x1.x0, 7
    %33 = tail call fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %9, i32 signext %32, i32 signext 4, i32 signext %x1.x0, i32 signext %y.0, i32 signext %., i32 signext %4, %struct.gx_device_s* %dev)
    br label %34
  
  ; <label>:34                                      ; preds = %.loopexit, %0
    %.0 = phi i32 [ %33, %.loopexit ], [ 0, %0 ]
    ret i32 %.0
  }
  
  declare void @memflip8x8(i8*, i32 signext, i8*, i32 signext) #2
  
  attributes #0 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #4 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"gx_image_strategies_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !13, i64 236}
  !7 = !{!"gx_image_enum_s", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3, !4, i64 4, !4, i64 5, !4, i64 6, !4, i64 7, !8, i64 8, !10, i64 32, !12, i64 48, !12, i64 56, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76, !3, i64 80, !3, i64 84, !3, i64 88, !11, i64 92, !3, i64 96, !11, i64 100, !11, i64 104, !4, i64 108, !4, i64 112, !4, i64 113, !4, i64 114, !4, i64 115, !14, i64 116, !14, i64 132, !11, i64 148, !13, i64 152, !13, i64 156, !13, i64 160, !3, i64 164, !3, i64 168, !3, i64 172, !11, i64 176, !12, i64 180, !12, i64 188, !15, i64 196, !11, i64 276, !11, i64 280, !20, i64 284, !11, i64 292, !11, i64 296, !11, i64 300, !11, i64 304, !4, i64 312, !4, i64 1656}
  !8 = !{!"gs_matrix_s", !9, i64 0, !9, i64 4, !9, i64 8, !9, i64 12, !9, i64 16, !9, i64 20}
  !9 = !{!"float", !4, i64 0}
  !10 = !{!"r_", !11, i64 0, !11, i64 4, !11, i64 8, !11, i64 12}
  !11 = !{!"int", !4, i64 0}
  !12 = !{!"gs_fixed_point_s", !13, i64 0, !13, i64 4}
  !13 = !{!"long", !4, i64 0}
  !14 = !{!"gs_fixed_rect_s", !12, i64 0, !12, i64 8}
  !15 = !{!"dd_", !16, i64 0, !16, i64 40}
  !16 = !{!"gx_dda_fixed_point_s", !17, i64 0, !17, i64 20}
  !17 = !{!"gx_dda_fixed_s", !18, i64 0, !19, i64 8}
  !18 = !{!"_a", !13, i64 0, !11, i64 4}
  !19 = !{!"_e", !13, i64 0, !11, i64 4, !11, i64 8}
  !20 = !{!"gs_int_point_s", !11, i64 0, !11, i64 4}
  !21 = !{!7, !13, i64 256}
  !22 = !{!7, !4, i64 112}
  !23 = !{!7, !4, i64 3}
  !24 = !{!7, !4, i64 0}
  !25 = !{!7, !4, i64 108}
  !26 = !{!7, !13, i64 48}
  !27 = !{!7, !11, i64 40}
  !28 = !{!7, !13, i64 152}
  !29 = !{!7, !11, i64 104}
  !30 = !{!7, !11, i64 100}
  !31 = !{!7, !3, i64 80}
  !32 = !{!33, !3, i64 0}
  !33 = !{!"gs_memory_s", !34, i64 0}
  !34 = !{!"gs_memory_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !3, i64 24, !3, i64 28, !3, i64 32, !3, i64 36, !3, i64 40, !3, i64 44, !3, i64 48, !3, i64 52, !3, i64 56, !3, i64 60, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76}
  !35 = !{!7, !3, i64 96}
  !36 = !{!7, !3, i64 84}
  !37 = !{!7, !13, i64 52}
  !38 = !{!7, !11, i64 276}
  !39 = !{!7, !11, i64 280}
  !40 = !{!7, !9, i64 12}
  !41 = !{!7, !13, i64 160}
  !42 = !{!7, !9, i64 8}
  !43 = !{!7, !13, i64 156}
  !44 = !{!7, !3, i64 64}
  !45 = !{!7, !4, i64 1}
  !46 = !{!47, !3, i64 180}
  !47 = !{!"gx_device_s", !11, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !11, i64 20, !11, i64 24, !48, i64 28, !11, i64 44, !11, i64 48, !4, i64 52, !4, i64 60, !11, i64 76, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !13, i64 120, !13, i64 124, !11, i64 128, !50, i64 132, !51, i64 144}
  !48 = !{!"gx_device_color_info_s", !11, i64 0, !11, i64 4, !49, i64 8, !49, i64 10, !49, i64 12, !49, i64 14}
  !49 = !{!"short", !4, i64 0}
  !50 = !{!"gx_page_device_procs_s", !3, i64 0, !3, i64 4, !3, i64 8}
  !51 = !{!"gx_device_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !3, i64 24, !3, i64 28, !3, i64 32, !3, i64 36, !3, i64 40, !3, i64 44, !3, i64 48, !3, i64 52, !3, i64 56, !3, i64 60, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76, !3, i64 80, !3, i64 84, !3, i64 88, !3, i64 92, !3, i64 96, !3, i64 100, !3, i64 104, !3, i64 108, !3, i64 112, !3, i64 116, !3, i64 120, !3, i64 124, !3, i64 128, !3, i64 132, !3, i64 136, !3, i64 140, !3, i64 144}
  !52 = !{!7, !11, i64 292}
  !53 = !{!7, !11, i64 296}
  !54 = !{!55, !3, i64 180}
  !55 = !{!"gx_device_memory_s", !11, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !11, i64 20, !11, i64 24, !48, i64 28, !11, i64 44, !11, i64 48, !4, i64 52, !4, i64 60, !11, i64 76, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !13, i64 120, !13, i64 124, !11, i64 128, !50, i64 132, !51, i64 144, !3, i64 292, !8, i64 296, !11, i64 320, !11, i64 324, !3, i64 328, !3, i64 332, !3, i64 336, !56, i64 340, !57, i64 348, !58, i64 364, !11, i64 372, !11, i64 376, !11, i64 380, !11, i64 384, !11, i64 388, !13, i64 392}
  !56 = !{!"gs_const_string_s", !3, i64 0, !11, i64 4}
  !57 = !{!"_c24", !13, i64 0, !11, i64 4, !11, i64 8, !11, i64 12}
  !58 = !{!"gs_log2_scale_point_s", !11, i64 0, !11, i64 4}
  !59 = !{!60, !3, i64 0}
  !60 = !{!"gx_device_color_s", !3, i64 0, !4, i64 4, !20, i64 32, !61, i64 40}
  !61 = !{!"_mask", !62, i64 0, !13, i64 20, !3, i64 24}
  !62 = !{!"gs_client_color_s", !63, i64 0, !3, i64 16}
  !63 = !{!"gs_paint_color_s", !4, i64 0}
  !64 = !{!13, !13, i64 0}
  !65 = !{!7, !4, i64 113}
  !66 = !{!55, !3, i64 332}
  !67 = !{!3, !3, i64 0}
  !68 = !{!4, !4, i64 0}
  !69 = !{!11, !11, i64 0}
  !70 = !{!7, !11, i64 300}
  !71 = !{!7, !11, i64 304}
  !72 = !{!7, !9, i64 16}
  !73 = !{!74, !3, i64 4}
  !74 = !{!"gx_device_color_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16}
  !75 = !{!74, !3, i64 8}

...
---
name:            gs_gximage1_init
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
liveins:         
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 8):
    liveins: %t9, %v0
    liveouts:
  
    %1 = ADDu %v0, %t9
    %2 = LW %1, target-flags(<unknown>) @image_strategy_simple, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %3 = ADDiu killed %2, target-flags(<unknown>) @image_strategy_simple
    %4 = LW %1, target-flags(<unknown>) @image_strategies, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW killed %3, killed %4, 4, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)** getelementptr inbounds (%struct.gx_image_strategies_s, %struct.gx_image_strategies_s* @image_strategies, i32 0, i32 1)`, !tbaa !1)
    RetRA

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/ghostscript/ghostscript.gximage1.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.gx_image_strategies_s = type { i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)* }
  %struct.gx_device_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s }
  %struct.gs_memory_s = type { %struct.gs_memory_procs_s }
  %struct.gs_memory_procs_s = type { i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i32, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i32, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i8*, i32, i8*)*, i32 (%struct.gs_memory_s*, i8*)*, %struct.gs_memory_struct_type_s* (%struct.gs_memory_s*, i8*)*, void (%struct.gs_memory_s*, i8*, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i8*, i32, i32, i8*)*, void (%struct.gs_memory_s*, i8*, i32, i8*)*, void (%struct.gs_memory_s*, %struct.gs_gc_root_s*, %struct.gs_ptr_procs_s*, i8**, i8*)*, void (%struct.gs_memory_s*, %struct.gs_gc_root_s*, i8*)*, void (%struct.gs_memory_s*, %struct.gs_memory_status_s*)*, void (%struct.gs_memory_s*, i32)* }
  %struct.gs_gc_root_s = type { %struct.gs_gc_root_s*, %struct.gs_ptr_procs_s*, i8** }
  %struct.gs_ptr_procs_s = type { void (i8*, %struct.gc_state_s*)*, i32 (i8*, %struct.gc_state_s*)*, i8* (i8*, %struct.gc_state_s*)* }
  %struct.gc_state_s = type opaque
  %struct.gs_memory_status_s = type { i32, i32 }
  %struct.gs_memory_struct_type_s = type { i32, i8*, %struct.struct_shared_procs_s*, void (i8*, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)*, void (i8*)* }
  %struct.struct_shared_procs_s = type opaque
  %struct.gx_device_color_info_s = type { i32, i32, i16, i16, i16, i16 }
  %struct.gx_page_device_procs_s = type { i32 (%struct.gx_device_s*, %struct.gs_state_s*)*, i32 (%struct.gx_device_s*, %struct.gs_state_s*)*, i32 (%struct.gx_device_s*, i32, %struct.gs_state_s*)* }
  %struct.gs_state_s = type opaque
  %struct.gx_device_procs_s = type { i32 (%struct.gx_device_s*)*, void (%struct.gx_device_s*, %struct.gs_matrix_s*)*, i32 (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i32, i32)*, i32 (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16)*, i32 (%struct.gx_device_s*, i32, i16*)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, %struct.gx_tile_bitmap_s*, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i8*, i8**)*, i32 (%struct.gx_device_s*, %struct.gs_param_list_s*)*, i32 (%struct.gx_device_s*, %struct.gs_param_list_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16, i16)*, %struct.gx_xfont_procs_s* (%struct.gx_device_s*)*, %struct.gx_device_s* (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16, i16)*, %struct.gx_device_s* (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i32*)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32*, %struct.gx_tile_bitmap_s*, i32*, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gx_path_s*, %struct.gx_fill_params_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gx_path_s*, %struct.gx_stroke_params_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32, i32, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, %struct.gs_fixed_edge_s*, %struct.gs_fixed_edge_s*, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gs_image_s*, i32, %struct.gs_int_rect_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*, %struct.gs_memory_s*, i8**)*, i32 (%struct.gx_device_s*, i8*, i8**, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32)*, i32 (%struct.gx_device_s*, %struct.gx_strip_bitmap_s*, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32*, %struct.gx_strip_bitmap_s*, i32*, i32, i32, i32, i32, i32, i32, i32)*, void (%struct.gx_device_s*, %struct.gs_fixed_rect_s*)* }
  %struct.gs_matrix_s = type { float, float, float, float, float, float }
  %struct.gx_tile_bitmap_s = type { i8*, i32, %struct.gs_int_point_s, i32, i16, i16 }
  %struct.gs_int_point_s = type { i32, i32 }
  %struct.gs_param_list_s = type opaque
  %struct.gx_xfont_procs_s = type opaque
  %struct.gs_imager_state_s = type { %struct.gs_memory_s*, %struct.gx_line_params_s, %struct.gs_matrix_fixed_s, i32, i16, i32, float, %struct.gs_fixed_point_s, i32, i32, %struct.gs_halftone_s*, [2 x %struct.gs_int_point_s], %struct.gx_device_halftone_s*, %struct.gx_ht_cache_s*, %struct.gs_cie_render_s*, %struct.gx_transfer_map_s*, %struct.gx_transfer_map_s*, %union.gx_transfer_s, %union.gx_transfer_s, %struct.gx_cie_joint_caches_s*, %struct.gx_color_map_procs_s*, %struct.gx_pattern_cache_s* }
  %struct.gx_line_params_s = type { float, i32, i32, float, float, float, float, %struct.gx_dash_params_s }
  %struct.gx_dash_params_s = type { float*, i32, float, i32, float, i32, i32, float }
  %struct.gs_matrix_fixed_s = type { float, float, float, float, float, float, i32, i32, i32 }
  %struct.gs_fixed_point_s = type { i32, i32 }
  %struct.gs_halftone_s = type { i32, %struct.rc_header_s, %union.anon }
  %struct.rc_header_s = type { i32, %struct.gs_memory_s*, void (%struct.gs_memory_s*, i8*, i8*)* }
  %union.anon = type { %struct.gs_colorscreen_halftone_s }
  %struct.gs_colorscreen_halftone_s = type { %union._css }
  %union._css = type { [4 x %struct.gs_screen_halftone_s] }
  %struct.gs_screen_halftone_s = type { float, float, float (double, double)*, float, float }
  %struct.gx_device_halftone_s = type { %struct.gx_ht_order_s, %struct.rc_header_s, i32, %struct.gx_ht_order_component_s*, i32, [4 x i32], i32, i32 }
  %struct.gx_ht_order_s = type { %struct.gx_ht_cell_params_s, i16, i16, i16, i16, i16, i16, i32, i32, i32, i32*, %struct.gx_ht_bit_s*, %struct.gx_ht_cache_s*, %struct.gx_transfer_map_s* }
  %struct.gx_ht_cell_params_s = type { i16, i16, i16, i16, i16, i16, i32, i16, i16, i32, i32, i32 }
  %struct.gx_ht_bit_s = type { i32, i32 }
  %struct.gx_ht_order_component_s = type { %struct.gx_ht_order_s, i32 }
  %struct.gx_ht_cache_s = type { i8*, i32, %struct.gx_ht_tile_s*, i32, %struct.gx_ht_order_s, i32, i32, i32 }
  %struct.gx_ht_tile_s = type { %struct.gx_strip_bitmap_s, i32, i32 }
  %struct.gx_strip_bitmap_s = type { i8*, i32, %struct.gs_int_point_s, i32, i16, i16, i16, i16 }
  %struct.gs_cie_render_s = type opaque
  %struct.gx_transfer_map_s = type { %struct.rc_header_s, {}*, i32, [256 x i16] }
  %union.gx_transfer_s = type { [4 x %struct.gx_transfer_map_s*] }
  %struct.gx_cie_joint_caches_s = type opaque
  %struct.gx_color_map_procs_s = type { void (i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, void (i16, i16, i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, void (i16, i16, i16, i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)* }
  %struct.gx_pattern_cache_s = type opaque
  %struct.gx_path_s = type { %struct.gs_memory_s*, %struct.gs_fixed_rect_s, %struct.segment_s*, %struct.subpath_s*, %struct.subpath_s*, i32, i32, %struct.gs_fixed_point_s, %struct.gs_point_s, %struct.gs_point_s, i8, i8, i8, i8 }
  %struct.gs_fixed_rect_s = type { %struct.gs_fixed_point_s, %struct.gs_fixed_point_s }
  %struct.segment_s = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s }
  %struct.subpath_s = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s, %struct.segment_s*, i32, %struct.line_close_segment, i8 }
  %struct.line_close_segment = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s, %struct.subpath_s* }
  %struct.gs_point_s = type { double, double }
  %struct.gx_fill_params_s = type opaque
  %struct.gx_device_color_s = type { %struct.gx_device_color_procs_s*, %union._c, %struct.gs_int_point_s, %struct._mask }
  %struct.gx_device_color_procs_s = type { i32 (%struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)*, i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)* }
  %struct.gx_rop_source_s = type { i8*, i32, i32, i32, [2 x i32], i32 }
  %union._c = type { %struct._col }
  %struct._col = type { %struct.gx_device_halftone_s*, [4 x i8], [4 x i32], i16 }
  %struct._mask = type { %struct.gs_client_color_s, i32, %struct.gx_color_tile_s* }
  %struct.gs_client_color_s = type { %struct.gs_paint_color_s, %struct.gs_pattern_instance_s* }
  %struct.gs_paint_color_s = type { [4 x float] }
  %struct.gs_pattern_instance_s = type opaque
  %struct.gx_color_tile_s = type opaque
  %struct.gx_clip_path_s = type opaque
  %struct.gx_stroke_params_s = type opaque
  %struct.gs_fixed_edge_s = type { %struct.gs_fixed_point_s, %struct.gs_fixed_point_s }
  %struct.gs_image_s = type { i32, i32, %struct.gs_matrix_s, i32, %struct.gs_color_space_s*, [8 x float], i32, i32, i32, i32 }
  %struct.gs_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.1 }
  %struct.gs_color_space_type_s = type { i32, i32, i32, void (%struct.gs_client_color_s*, %struct.gs_color_space_s*)*, %struct.gs_color_space_s* (%struct.gs_color_space_s*, %struct.gs_imager_state_s*)*, i32 (%struct.gs_client_color_s*, %struct.gs_color_space_s*, i16*, %struct.gs_imager_state_s*)*, i32 (i16*, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gs_client_color_s*, %struct.gs_color_space_s*, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gs_color_space_s*, %struct.gs_state_s*)*, void (%struct.gs_color_space_s*, %struct.gs_memory_s*, i32)*, void (%struct.gs_client_color_s*, %struct.gs_color_space_s*, %struct.gs_memory_s*, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)* }
  %union.anon.1 = type { %struct.gs_pattern_params_s }
  %struct.gs_pattern_params_s = type { i32, %struct.gs_paint_color_space_s }
  %struct.gs_paint_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.4 }
  %union.anon.4 = type { %struct.gs_indexed_params_s }
  %struct.gs_indexed_params_s = type { %struct.gs_base_color_space_s, i32, %union.anon.3, i32 }
  %struct.gs_base_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.2 }
  %union.anon.2 = type { %struct.gs_cie_defg_s* }
  %struct.gs_cie_defg_s = type opaque
  %union.anon.3 = type { %struct.gs_const_string_s }
  %struct.gs_const_string_s = type { i8*, i32 }
  %struct.gs_int_rect_s = type { %struct.gs_int_point_s, %struct.gs_int_point_s }
  %struct.gx_image_enum_s = type { i8, i8, i8, i8, i8, i8, i8, i8, %struct.gs_matrix_s, %struct.r_, %struct.gs_fixed_point_s, %struct.gs_fixed_point_s, i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)*, {}*, %struct.gs_imager_state_s*, %struct.gs_color_space_s*, %struct.gs_memory_s*, %struct.gx_device_s*, i8*, i32, i8*, i32, i32, i32, i8, i8, i8, i8, %struct.gs_fixed_rect_s, %struct.gs_fixed_rect_s, i32, i32, i32, i32, %struct.gx_device_clip_s*, %struct.gx_device_rop_texture_s*, %struct.stream_IScale_state_s*, i32, %struct.gs_fixed_point_s, %struct.gs_fixed_point_s, %struct.dd_, i32, i32, %struct.gs_int_point_s, i32, i32, i32, i32, [4 x %struct.sample_map_s], [256 x %struct.gx_image_clue_s] }
  %struct.r_ = type { i32, i32, i32, i32 }
  %union.sample_lookup_s = type { [16 x i32], [192 x i8] }
  %struct.gx_device_clip_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s, %struct.gx_device_s*, %struct.gx_clip_list_s, %struct.gx_clip_rect_s*, %struct.gs_int_point_s }
  %struct.gx_clip_list_s = type { %struct.gx_clip_rect_s, %struct.gx_clip_rect_s*, %struct.gx_clip_rect_s*, i32, i32 }
  %struct.gx_clip_rect_s = type { %struct.gx_clip_rect_s*, %struct.gx_clip_rect_s*, i32, i32, i32, i32, i8 }
  %struct.gx_device_rop_texture_s = type opaque
  %struct.stream_IScale_state_s = type { %struct.stream_template_s*, %struct.gs_memory_s*, i32 (%struct.stream_state_s*, i8*)*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, double, double, i8*, i8*, i8*, %struct.CLIST*, %struct.CONTRIB*, i32, i32, i32, i32, i32, i32, %struct.CLIST, i32, [8 x %struct.CONTRIB] }
  %struct.stream_template_s = type { %struct.gs_memory_struct_type_s*, i32 (%struct.stream_state_s*)*, i32 (%struct.stream_state_s*, %struct.stream_cursor_read_s*, %struct.stream_cursor_write_s*, i32)*, i32, i32, void (%struct.stream_state_s*)*, void (%struct.stream_state_s*)*, i32 (%struct.stream_state_s*)* }
  %struct.stream_state_s = type { %struct.stream_template_s*, %struct.gs_memory_s*, i32 (%struct.stream_state_s*, i8*)* }
  %struct.stream_cursor_read_s = type { i8*, i8*, i8* }
  %struct.stream_cursor_write_s = type { i8*, i8*, i8* }
  %struct.CONTRIB = type { float }
  %struct.CLIST = type { i32, i32, i32 }
  %struct.dd_ = type { %struct.gx_dda_fixed_point_s, %struct.gx_dda_fixed_point_s }
  %struct.gx_dda_fixed_point_s = type { %struct.gx_dda_fixed_s, %struct.gx_dda_fixed_s }
  %struct.gx_dda_fixed_s = type { %struct._a, %struct._e }
  %struct._a = type { i32, i32 }
  %struct._e = type { i32, i32, i32 }
  %struct.sample_map_s = type { %union.sample_lookup_s, [16 x float], double, i32 }
  %struct.gx_image_clue_s = type { %struct.gx_device_color_s, i32 }
  %struct.gx_device_memory_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s, %struct.gx_device_s*, %struct.gs_matrix_s, i32, i32, i8*, i8**, %struct.gs_memory_s*, %struct.gs_const_string_s, %struct._c24, %struct.gs_log2_scale_point_s, i32, i32, i32, i32, i32, i32 }
  %struct._c24 = type { i32, i32, i32, i32 }
  %struct.gs_log2_scale_point_s = type { i32, i32 }
  
  @image_strategies = external global %struct.gx_image_strategies_s, align 4
  @.str = private unnamed_addr constant [11 x i8] c"image line\00", align 1
  @mem_mono_device = external global %struct.gx_device_memory_s, align 4
  @gx_dc_procs_pure = external global %struct.gx_device_color_procs_s, align 4
  @byte_reverse_bits = external global [256 x i8], align 1
  @byte_bit_run_length_0 = external global [256 x i8], align 1
  @image_simple_expand.lmasks = internal unnamed_addr constant [9 x i8] c"\FF\7F?\1F\0F\07\03\01\00", align 1
  @image_simple_expand.rmasks = internal unnamed_addr constant [9 x i8] c"\00\80\C0\E0\F0\F8\FC\FE\FF", align 1
  
  ; Function Attrs: norecurse nounwind
  define void @gs_gximage1_init(%struct.gs_memory_s* nocapture readnone %mem) #0 {
    store i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)* @image_strategy_simple, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)** getelementptr inbounds (%struct.gx_image_strategies_s, %struct.gx_image_strategies_s* @image_strategies, i32 0, i32 1), align 4, !tbaa !1
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* @image_strategy_simple(%struct.gx_image_enum_s* %penum) #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 0, i32 0, i32 0
    %2 = load i32, i32* %1, align 4, !tbaa !6
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 1, i32 0, i32 0
    %4 = load i32, i32* %3, align 4, !tbaa !21
    %5 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 24
    %6 = load i8, i8* %5, align 8, !tbaa !22
    %7 = icmp eq i8 %6, 0
    br i1 %7, label %8, label %114
  
  ; <label>:8                                       ; preds = %0
    %9 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 3
    %10 = load i8, i8* %9, align 1, !tbaa !23
    %11 = icmp eq i8 %10, 1
    br i1 %11, label %12, label %114
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %14 = load i8, i8* %13, align 8, !tbaa !24
    %15 = icmp eq i8 %14, 1
    br i1 %15, label %16, label %114
  
  ; <label>:16                                      ; preds = %12
    %17 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 23
    %18 = load i32, i32* %17, align 4, !tbaa !25
    switch i32 %18, label %114 [
      i32 0, label %19
      i32 1, label %56
    ]
  
  ; <label>:19                                      ; preds = %16
    %20 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %21 = load i32, i32* %20, align 8, !tbaa !26
    %22 = add i32 %2, 2047
    %23 = add i32 %22, %21
    %24 = ashr i32 %23, 12
    %25 = ashr i32 %22, 12
    %26 = sub nsw i32 %24, %25
    %27 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 9, i32 2
    %28 = load i32, i32* %27, align 8, !tbaa !27
    %29 = icmp eq i32 %26, %28
    br i1 %29, label %.thread16, label %30
  
  ; <label>:30                                      ; preds = %19
    %31 = icmp slt i32 %26, 0
    %32 = sub nsw i32 0, %26
    %33 = select i1 %31, i32 %32, i32 %26
    %34 = add nsw i32 %33, 31
    %35 = ashr i32 %34, 5
    %36 = shl nsw i32 %35, 2
    %37 = add nsw i32 %36, 4
    %38 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 31
    %39 = load i32, i32* %38, align 8, !tbaa !28
    %40 = icmp eq i32 %39, 0
    br i1 %40, label %41, label %114
  
  ; <label>:41                                      ; preds = %30
    %42 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    store i32 %33, i32* %42, align 8, !tbaa !29
    %43 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    store i32 %37, i32* %43, align 4, !tbaa !30
    %44 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 16
    %45 = load %struct.gs_memory_s*, %struct.gs_memory_s** %44, align 8, !tbaa !31
    %46 = bitcast %struct.gs_memory_s* %45 to i8* (%struct.gs_memory_s*, i32, i8*)**
    %47 = load i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)** %46, align 4, !tbaa !32
    %48 = tail call i8* %47(%struct.gs_memory_s* %45, i32 signext %37, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i32 0, i32 0)) #4
    %49 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    store i8* %48, i8** %49, align 8, !tbaa !35
    %50 = icmp eq i8* %48, null
    br i1 %50, label %51, label %.thread16
  
  ; <label>:51                                      ; preds = %41
    %52 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %53 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 17
    %54 = load %struct.gx_device_s*, %struct.gx_device_s** %53, align 4, !tbaa !36
    %55 = tail call i32 @gx_default_end_image(%struct.gx_device_s* %54, i8* nonnull %52, i32 signext 0) #4
    br label %114
  
  ; <label>:56                                      ; preds = %16
    %57 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 1
    %58 = load i32, i32* %57, align 4, !tbaa !37
    %59 = add i32 %4, 2048
    %60 = add i32 %59, %58
    %61 = ashr i32 %60, 12
    %62 = ashr i32 %59, 12
    %63 = sub nsw i32 %61, %62
    %64 = icmp slt i32 %63, 0
    %65 = sub nsw i32 0, %63
    %66 = select i1 %64, i32 %65, i32 %63
    %67 = add nsw i32 %66, 31
    %68 = and i32 %67, -32
    %69 = shl nsw i32 %66, 2
    %70 = add nsw i32 %69, 28
    %71 = and i32 %70, -32
    %72 = add i32 %71, %68
    %73 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 9, i32 2
    %74 = load i32, i32* %73, align 8, !tbaa !27
    %75 = icmp eq i32 %66, %74
    br i1 %75, label %80, label %76
  
  ; <label>:76                                      ; preds = %56
    %77 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 31
    %78 = load i32, i32* %77, align 8, !tbaa !28
    %79 = icmp eq i32 %78, 0
    br i1 %79, label %80, label %114
  
  ; <label>:80                                      ; preds = %76, %56
    %81 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    store i32 %66, i32* %81, align 8, !tbaa !29
    %82 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    store i32 %72, i32* %82, align 4, !tbaa !30
    %83 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 16
    %84 = load %struct.gs_memory_s*, %struct.gs_memory_s** %83, align 8, !tbaa !31
    %85 = bitcast %struct.gs_memory_s* %84 to i8* (%struct.gs_memory_s*, i32, i8*)**
    %86 = load i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)** %85, align 4, !tbaa !32
    %87 = tail call i8* %86(%struct.gs_memory_s* %84, i32 signext %72, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i32 0, i32 0)) #4
    %88 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    store i8* %87, i8** %88, align 8, !tbaa !35
    %89 = icmp eq i8* %87, null
    br i1 %89, label %.critedge, label %.critedge13
  
  .critedge:                                        ; preds = %80
    %90 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %91 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 17
    %92 = load %struct.gx_device_s*, %struct.gx_device_s** %91, align 4, !tbaa !36
    %93 = tail call i32 @gx_default_end_image(%struct.gx_device_s* %92, i8* nonnull %90, i32 signext 0) #4
    br label %114
  
  .critedge13:                                      ; preds = %80
    %94 = add nsw i32 %2, 2048
    %95 = ashr i32 %94, 12
    %96 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    store i32 %95, i32* %96, align 4, !tbaa !38
    %97 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 42
    store i32 %95, i32* %97, align 8, !tbaa !39
    %98 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 1
    %99 = load float, float* %98, align 4, !tbaa !40
    %100 = fpext float %99 to double
    %101 = fadd double %100, 0x3F20000000000000
    %102 = fmul double %101, 4.096000e+03
    %103 = fptosi double %102 to i32
    %104 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 33
    store i32 %103, i32* %104, align 8, !tbaa !41
    br label %.thread16
  
  .thread16:                                        ; preds = %.critedge13, %41, %19
    %rproc.2 = phi i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* [ @image_render_landscape, %.critedge13 ], [ @image_render_simple, %41 ], [ @image_render_simple, %19 ]
    %105 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 0
    %106 = load float, float* %105, align 8, !tbaa !42
    %107 = fpext float %106 to double
    %108 = fadd double %107, 0x3F20000000000000
    %109 = fmul double %108, 4.096000e+03
    %110 = fptosi double %109 to i32
    %111 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 32
    store i32 %110, i32* %111, align 4, !tbaa !43
    %112 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 12
    store i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)* @sample_unpack_copy, i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)** %112, align 8, !tbaa !44
    %113 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 1
    store i8 8, i8* %113, align 1, !tbaa !45
    br label %114
  
  ; <label>:114                                     ; preds = %.thread16, %.critedge, %76, %51, %30, %16, %12, %8, %0
    %.4 = phi i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* [ %rproc.2, %.thread16 ], [ null, %12 ], [ null, %8 ], [ null, %0 ], [ null, %.critedge ], [ null, %76 ], [ null, %16 ], [ null, %51 ], [ null, %30 ]
    ret i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* %.4
  }
  
  declare i32 @gx_default_end_image(%struct.gx_device_s*, i8*, i32 signext) #2
  
  ; Function Attrs: nounwind
  define internal i32 @image_render_simple(%struct.gx_image_enum_s* %penum, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) #1 {
    %1 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 0, i32 21, i32 9
    %2 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** %1, align 4, !tbaa !46
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 32
    %4 = load i32, i32* %3, align 4, !tbaa !43
    %5 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 0, i32 0, i32 0
    %6 = load i32, i32* %5, align 4, !tbaa !6
    %7 = add nsw i32 %6, 2047
    %8 = ashr i32 %7, 12
    %9 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 44
    %10 = load i32, i32* %9, align 4, !tbaa !52
    %11 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 45
    %12 = load i32, i32* %11, align 8, !tbaa !53
    %13 = icmp eq i32 %h, 0
    br i1 %13, label %.loopexit, label %14
  
  ; <label>:14                                      ; preds = %0
    %15 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %16 = load i8*, i8** %15, align 8, !tbaa !35
    %17 = icmp eq i8* %16, null
    br i1 %17, label %18, label %21
  
  ; <label>:18                                      ; preds = %14
    %19 = add i32 %w, 7
    %20 = lshr i32 %19, 3
    br label %121
  
  ; <label>:21                                      ; preds = %14
    %22 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** getelementptr inbounds (%struct.gx_device_memory_s, %struct.gx_device_memory_s* @mem_mono_device, i32 0, i32 21, i32 9), align 4, !tbaa !54
    %23 = icmp eq i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)* %2, %22
    %24 = icmp sgt i32 %4, 0
    %or.cond = and i1 %24, %23
    br i1 %or.cond, label %25, label %113
  
  ; <label>:25                                      ; preds = %21
    %26 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0, i32 0
    %27 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %26, align 8, !tbaa !59
    %28 = icmp eq %struct.gx_device_color_procs_s* %27, @gx_dc_procs_pure
    br i1 %28, label %29, label %113
  
  ; <label>:29                                      ; preds = %25
    %30 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0, i32 0
    %31 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %30, align 8, !tbaa !59
    %32 = icmp eq %struct.gx_device_color_procs_s* %31, @gx_dc_procs_pure
    br i1 %32, label %33, label %113
  
  ; <label>:33                                      ; preds = %29
    %34 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0, i32 1
    %35 = bitcast %union._c* %34 to i32*
    %36 = load i32, i32* %35, align 4, !tbaa !64
    %37 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0, i32 1
    %38 = bitcast %union._c* %37 to i32*
    %39 = load i32, i32* %38, align 4, !tbaa !64
    %40 = xor i32 %39, %36
    %41 = icmp eq i32 %40, 1
    br i1 %41, label %42, label %113
  
  ; <label>:42                                      ; preds = %33
    %43 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 25
    %44 = load i8, i8* %43, align 1, !tbaa !65
    %45 = icmp eq i8 %44, 0
    br i1 %45, label %46, label %113
  
  ; <label>:46                                      ; preds = %42
    %47 = mul i32 %4, %w
    %48 = add i32 %47, 2047
    %49 = add i32 %48, %6
    %50 = lshr i32 %49, 12
    %51 = add nsw i32 %50, -1
    %52 = ashr i32 %7, 15
    %53 = ashr i32 %51, 3
    %54 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 1, i32 7, i32 4
    %55 = bitcast i16* %54 to i8***
    %56 = load i8**, i8*** %55, align 4, !tbaa !66
    %57 = getelementptr inbounds i8*, i8** %56, i32 %10
    %58 = load i8*, i8** %57, align 4, !tbaa !67
    %59 = and i32 %8, 31
    %60 = sub nsw i32 %8, %59
    %61 = add nsw i32 %53, 1
    %62 = ashr i32 %60, 3
    %63 = sub nsw i32 %61, %62
    %64 = sub nsw i32 %50, %8
    %65 = getelementptr inbounds i8, i8* %58, i32 %52
    %66 = load i8, i8* %65, align 1, !tbaa !68
    %67 = zext i8 %66 to i32
    %68 = getelementptr inbounds i8, i8* %58, i32 %53
    %69 = load i8, i8* %68, align 1, !tbaa !68
    %70 = zext i8 %69 to i32
    %71 = getelementptr inbounds i8, i8* %58, i32 %62
    %72 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %73 = load i32, i32* %72, align 8, !tbaa !26
    %74 = icmp eq i32 %36, 0
    %75 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 48, i32 0, i32 0, i32 0, i32 0
    %76 = load i32, i32* %75, align 8, !tbaa !69
    %77 = icmp eq i32 %76, 0
    %78 = xor i1 %74, %77
    %79 = sext i1 %78 to i8
    tail call fastcc void @image_simple_expand(i8* %71, i32 signext %59, i32 signext %63, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %6, i32 signext %73, i8 zeroext %79)
    %80 = and i32 %8, 7
    %81 = icmp eq i32 %80, 0
    br i1 %81, label %91, label %82
  
  ; <label>:82                                      ; preds = %46
    %83 = lshr i32 65280, %80
    %84 = and i32 %67, %83
    %85 = load i8, i8* %65, align 1, !tbaa !68
    %86 = zext i8 %85 to i32
    %87 = xor i32 %83, 255
    %88 = and i32 %86, %87
    %89 = add nuw nsw i32 %88, %84
    %90 = trunc i32 %89 to i8
    store i8 %90, i8* %65, align 1, !tbaa !68
    br label %91
  
  ; <label>:91                                      ; preds = %82, %46
    %92 = and i32 %50, 7
    %93 = icmp eq i32 %92, 0
    br i1 %93, label %103, label %94
  
  ; <label>:94                                      ; preds = %91
    %95 = lshr i32 65280, %92
    %96 = load i8, i8* %68, align 1, !tbaa !68
    %97 = zext i8 %96 to i32
    %98 = and i32 %97, %95
    %99 = xor i32 %95, 255
    %100 = and i32 %70, %99
    %101 = add nuw nsw i32 %98, %100
    %102 = trunc i32 %101 to i8
    store i8 %102, i8* %68, align 1, !tbaa !68
    br label %103
  
  ; <label>:103                                     ; preds = %94, %91
    %104 = icmp slt i32 %12, 2
    br i1 %104, label %.loopexit, label %.lr.ph20.preheader
  
  .lr.ph20.preheader:                               ; preds = %103
    %105 = icmp slt i32 %4, 0
    %106 = select i1 %105, i32 %64, i32 0
    %. = sub nsw i32 %8, %106
    br label %.lr.ph20
  
  ; <label>:107                                     ; preds = %.lr.ph20
    %108 = icmp slt i32 %112, %12
    br i1 %108, label %.lr.ph20, label %.loopexit
  
  .lr.ph20:                                         ; preds = %107, %.lr.ph20.preheader
    %dy.018 = phi i32 [ %112, %107 ], [ 1, %.lr.ph20.preheader ]
    %109 = add i32 %10, %dy.018
    %110 = tail call i32 %2(%struct.gx_device_s* %dev, i8* %71, i32 signext %59, i32 signext %63, i32 signext 0, i32 signext %., i32 signext %109, i32 signext %64, i32 signext 1, i32 signext 0, i32 signext 1) #4
    %111 = icmp slt i32 %110, 0
    %112 = add nuw nsw i32 %dy.018, 1
    br i1 %111, label %.loopexit, label %107
  
  ; <label>:113                                     ; preds = %42, %33, %29, %25, %21
    %114 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    %115 = load i32, i32* %114, align 4, !tbaa !30
    %116 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %117 = load i32, i32* %116, align 8, !tbaa !29
    %118 = and i32 %8, 31
    %119 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %120 = load i32, i32* %119, align 8, !tbaa !26
    tail call fastcc void @image_simple_expand(i8* nonnull %16, i32 signext %118, i32 signext %115, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %6, i32 signext %120, i8 zeroext 0)
    br label %121
  
  ; <label>:121                                     ; preds = %113, %18
    %line_x.0 = phi i32 [ 0, %18 ], [ %118, %113 ]
    %line_size.0 = phi i32 [ %20, %18 ], [ %115, %113 ]
    %line_width.0 = phi i32 [ %w, %18 ], [ %117, %113 ]
    %line.0 = phi i8* [ %buffer, %18 ], [ %16, %113 ]
    %122 = icmp slt i32 %4, 0
    %123 = select i1 %122, i32 %line_width.0, i32 0
    %.9 = sub i32 %8, %123
    %124 = icmp sgt i32 %12, 0
    br i1 %124, label %.lr.ph, label %.loopexit
  
  ; <label>:125                                     ; preds = %.lr.ph
    %126 = icmp slt i32 %130, %12
    br i1 %126, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %121, %125
    %dy.114 = phi i32 [ %130, %125 ], [ 0, %121 ]
    %127 = add i32 %10, %dy.114
    %128 = tail call fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %line.0, i32 signext %line_x.0, i32 signext %line_size.0, i32 signext %.9, i32 signext %127, i32 signext %line_width.0, i32 signext 1, %struct.gx_device_s* %dev)
    %129 = icmp slt i32 %128, 0
    %130 = add nuw nsw i32 %dy.114, 1
    br i1 %129, label %.loopexit, label %125
  
  .loopexit:                                        ; preds = %107, %.lr.ph20, %125, %.lr.ph, %121, %103, %0
    %.5 = phi i32 [ 0, %0 ], [ 1, %103 ], [ 1, %121 ], [ 1, %125 ], [ %128, %.lr.ph ], [ 0, %107 ], [ %110, %.lr.ph20 ]
    ret i32 %.5
  }
  
  ; Function Attrs: nounwind
  define internal i32 @image_render_landscape(%struct.gx_image_enum_s* %penum, i8* readonly %buffer, i32 signext %data_x, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %2 = load i8*, i8** %1, align 8, !tbaa !35
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %4 = load i32, i32* %3, align 8, !tbaa !29
    %5 = add i32 %4, 31
    %6 = lshr i32 %5, 5
    %7 = shl nuw nsw i32 %6, 2
    %8 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 46
    %9 = load i32, i32* %8, align 4, !tbaa !70
    %10 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 47
    %11 = load i32, i32* %10, align 8, !tbaa !71
    %12 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 33
    %13 = load i32, i32* %12, align 8, !tbaa !41
    %.lobit = lshr i32 %13, 31
    %14 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 2
    %15 = load float, float* %14, align 8, !tbaa !72
    %16 = fcmp olt float %15, 0.000000e+00
    %17 = sub nsw i32 0, %11
    %xinc.0 = select i1 %16, i32 -1, i32 1
    %iw.0 = select i1 %16, i32 %17, i32 %11
    %18 = select i1 %16, i32 %11, i32 0
    %ix.0 = add nsw i32 %18, %9
    %19 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 42
    %20 = load i32, i32* %19, align 8, !tbaa !39
    %21 = icmp eq i32 %ix.0, %20
    br i1 %21, label %33, label %22
  
  ; <label>:22                                      ; preds = %0
    %23 = fcmp olt float %15, 0.000000e+00
    %24 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    %25 = load i32, i32* %24, align 4, !tbaa !38
    br i1 %23, label %28, label %26
  
  ; <label>:26                                      ; preds = %22
    %27 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %25, i32 signext %20, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %30
  
  ; <label>:28                                      ; preds = %22
    %29 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %20, i32 signext %25, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %30
  
  ; <label>:30                                      ; preds = %28, %26
    %31 = phi i32 [ %27, %26 ], [ %29, %28 ]
    %32 = icmp slt i32 %31, 0
    br i1 %32, label %.loopexit, label %.critedge
  
  .critedge:                                        ; preds = %30
    %sunkaddr = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr1 = add i32 %sunkaddr, 276
    %sunkaddr2 = inttoptr i32 %sunkaddr1 to i32*
    store i32 %ix.0, i32* %sunkaddr2, align 4, !tbaa !38
    br label %33
  
  ; <label>:33                                      ; preds = %.critedge, %0
    %34 = icmp eq i32 %h, 0
    br i1 %34, label %65, label %.preheader
  
  .preheader:                                       ; preds = %33
    %35 = icmp eq i32 %iw.0, 0
    br i1 %35, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader
    %36 = fcmp olt float %15, 0.000000e+00
    %37 = sext i1 %36 to i32
    %38 = sub i32 0, %iw.0
    br label %39
  
  ; <label>:39                                      ; preds = %63, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %63 ], [ %38, %.lr.ph ]
    %ix.116 = phi i32 [ %ix.0, %.lr.ph ], [ %ix.3, %63 ]
    %orig_row.014 = phi i8* [ null, %.lr.ph ], [ %orig_row.4, %63 ]
    %.ix.1 = add nsw i32 %ix.116, %37
    %40 = and i32 %.ix.1, 7
    %41 = mul nuw i32 %40, %7
    %42 = getelementptr inbounds i8, i8* %2, i32 %41
    %43 = icmp eq i8* %orig_row.014, null
    br i1 %43, label %44, label %47
  
  ; <label>:44                                      ; preds = %39
    %sunkaddr3 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr4 = add i32 %sunkaddr3, 256
    %sunkaddr5 = inttoptr i32 %sunkaddr4 to i32*
    %45 = load i32, i32* %sunkaddr5, align 4, !tbaa !21
    %sunkaddr6 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr7 = add i32 %sunkaddr6, 52
    %sunkaddr8 = inttoptr i32 %sunkaddr7 to i32*
    %46 = load i32, i32* %sunkaddr8, align 4, !tbaa !37
    tail call fastcc void @image_simple_expand(i8* %42, i32 signext 0, i32 signext %7, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %45, i32 signext %46, i8 zeroext 0)
    br label %48
  
  ; <label>:47                                      ; preds = %39
    tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %42, i8* nonnull %orig_row.014, i32 %7, i32 1, i1 false)
    br label %48
  
  ; <label>:48                                      ; preds = %47, %44
    %orig_row.1 = phi i8* [ %42, %44 ], [ %orig_row.014, %47 ]
    %49 = fcmp olt float %15, 0.000000e+00
    br i1 %49, label %57, label %50
  
  ; <label>:50                                      ; preds = %48
    %51 = add nsw i32 %.ix.1, 1
    %52 = icmp eq i32 %40, 7
    br i1 %52, label %53, label %63
  
  ; <label>:53                                      ; preds = %50
    %sunkaddr9 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr10 = add i32 %sunkaddr9, 276
    %sunkaddr11 = inttoptr i32 %sunkaddr10 to i32*
    %54 = load i32, i32* %sunkaddr11, align 4, !tbaa !38
    %55 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %54, i32 signext %51, i32 signext %.lobit, %struct.gx_device_s* %dev)
    %56 = icmp slt i32 %55, 0
    br i1 %56, label %.loopexit, label %.thread
  
  .thread:                                          ; preds = %53
    %sunkaddr12 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr13 = add i32 %sunkaddr12, 276
    %sunkaddr14 = inttoptr i32 %sunkaddr13 to i32*
    store i32 %51, i32* %sunkaddr14, align 4, !tbaa !38
    br label %63
  
  ; <label>:57                                      ; preds = %48
    %58 = icmp eq i32 %40, 0
    br i1 %58, label %59, label %63
  
  ; <label>:59                                      ; preds = %57
    %sunkaddr15 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr16 = add i32 %sunkaddr15, 276
    %sunkaddr17 = inttoptr i32 %sunkaddr16 to i32*
    %60 = load i32, i32* %sunkaddr17, align 4, !tbaa !38
    %61 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %.ix.1, i32 signext %60, i32 signext %.lobit, %struct.gx_device_s* %dev)
    %62 = icmp slt i32 %61, 0
    br i1 %62, label %.loopexit, label %.thread10
  
  .thread10:                                        ; preds = %59
    %sunkaddr18 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr19 = add i32 %sunkaddr18, 276
    %sunkaddr20 = inttoptr i32 %sunkaddr19 to i32*
    store i32 %.ix.1, i32* %sunkaddr20, align 4, !tbaa !38
    br label %63
  
  ; <label>:63                                      ; preds = %.thread10, %57, %.thread, %50
    %orig_row.4 = phi i8* [ %orig_row.1, %50 ], [ %orig_row.1, %57 ], [ null, %.thread ], [ null, %.thread10 ]
    %ix.3 = phi i32 [ %51, %50 ], [ %.ix.1, %57 ], [ %51, %.thread ], [ %.ix.1, %.thread10 ]
    %lsr.iv.next = add i32 %lsr.iv, %xinc.0
    %64 = icmp eq i32 %lsr.iv.next, 0
    br i1 %64, label %._crit_edge, label %39
  
  ._crit_edge:                                      ; preds = %63, %.preheader
    %ix.1.lcssa = phi i32 [ %ix.0, %.preheader ], [ %ix.3, %63 ]
    %sunkaddr21 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr22 = add i32 %sunkaddr21, 280
    %sunkaddr23 = inttoptr i32 %sunkaddr22 to i32*
    store i32 %ix.1.lcssa, i32* %sunkaddr23, align 8, !tbaa !39
    br label %.loopexit
  
  ; <label>:65                                      ; preds = %33
    %66 = fcmp olt float %15, 0.000000e+00
    %67 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    %68 = load i32, i32* %67, align 4, !tbaa !38
    br i1 %66, label %71, label %69
  
  ; <label>:69                                      ; preds = %65
    %70 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %68, i32 signext %ix.0, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %.loopexit
  
  ; <label>:71                                      ; preds = %65
    %72 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %ix.0, i32 signext %68, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %53, %59, %71, %69, %._crit_edge, %30
    %.6 = phi i32 [ 0, %._crit_edge ], [ %31, %30 ], [ %70, %69 ], [ %72, %71 ], [ %61, %59 ], [ %55, %53 ]
    ret i32 %.6
  }
  
  declare i8* @sample_unpack_copy(i8*, i32*, i8*, i32 signext, i32 signext, %union.sample_lookup_s*, i32 signext) #2
  
  ; Function Attrs: norecurse nounwind
  define internal fastcc void @image_simple_expand(i8* nocapture %line, i32 signext %line_x, i32 signext %raster, i8* readonly %buffer, i32 signext %data_x, i32 signext %w, i32 signext %xcur, i32 signext %x_extent, i8 zeroext %zero) unnamed_addr #0 {
    %1 = and i32 %data_x, 7
    %2 = lshr i32 128, %1
    %3 = lshr i32 255, %1
    %4 = add i32 %1, %w
    %5 = ashr i32 %data_x, 3
    %6 = getelementptr inbounds i8, i8* %buffer, i32 %5
    %7 = lshr i32 %4, 3
    %8 = getelementptr inbounds i8, i8* %6, i32 %7
    %9 = zext i8 %zero to i32
    %10 = xor i32 %9, 255
    %11 = icmp eq i32 %w, 0
    br i1 %11, label %.thread, label %12
  
  ; <label>:12                                      ; preds = %0
    %fold = add i32 %w, %data_x
    %13 = and i32 %fold, 7
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %15, label %17
  
  ; <label>:15                                      ; preds = %12
    %16 = getelementptr inbounds i8, i8* %8, i32 -1
    br label %21
  
  ; <label>:17                                      ; preds = %12
    %18 = xor i32 %13, 7
    %19 = shl i32 2, %18
    %20 = trunc i32 %19 to i8
    br label %21
  
  ; <label>:21                                      ; preds = %17, %15
    %stop.0 = phi i8* [ %16, %15 ], [ %8, %17 ]
    %stopbit.0 = phi i8 [ 1, %15 ], [ %20, %17 ]
    %22 = zext i8 %stopbit.0 to i32
    %23 = sub nsw i32 0, %22
    %24 = shl nsw i32 %23, 1
    %25 = load i8, i8* %stop.0, align 1, !tbaa !68
    %26 = icmp eq i8* %stop.0, %6
    %27 = select i1 %26, i32 %3, i32 -1
    %. = and i32 %24, %27
    %28 = zext i8 %25 to i32
    %29 = and i8 %25, %stopbit.0
    %30 = icmp eq i8 %29, 0
    br i1 %30, label %64, label %31
  
  ; <label>:31                                      ; preds = %21
    %32 = xor i32 %28, 254
    %33 = and i32 %32, %.
    %34 = icmp eq i32 %33, 0
    br i1 %34, label %.preheader16, label %35
  
  ; <label>:35                                      ; preds = %31
    %36 = add nuw nsw i32 %22, 255
    %37 = or i32 %28, %36
    %38 = trunc i32 %37 to i8
    br label %62
  
  .preheader16:                                     ; preds = %31, %40
    %stop.1 = phi i8* [ %41, %40 ], [ %stop.0, %31 ]
    %39 = icmp ugt i8* %stop.1, %6
    br i1 %39, label %40, label %.critedge
  
  ; <label>:40                                      ; preds = %.preheader16
    %41 = getelementptr inbounds i8, i8* %stop.1, i32 -1
    %scevgep11 = getelementptr i8, i8* %stop.1, i32 -1
    %42 = load i8, i8* %scevgep11, align 1, !tbaa !68
    %43 = icmp eq i8 %42, -1
    br i1 %43, label %.preheader16, label %.critedge
  
  .critedge:                                        ; preds = %.preheader16, %40
    %44 = icmp eq i8* %stop.1, %6
    br i1 %44, label %54, label %45
  
  ; <label>:45                                      ; preds = %.critedge
    %46 = getelementptr inbounds i8, i8* %6, i32 1
    %47 = icmp eq i8* %stop.1, %46
    br i1 %47, label %48, label %59
  
  ; <label>:48                                      ; preds = %45
    %49 = load i8, i8* %6, align 1, !tbaa !68
    %50 = zext i8 %49 to i32
    %51 = xor i32 %50, -1
    %52 = and i32 %3, %51
    %53 = icmp eq i32 %52, 0
    br i1 %53, label %54, label %59
  
  ; <label>:54                                      ; preds = %48, %.critedge
    %55 = trunc i32 %10 to i8
    %56 = ashr i32 %line_x, 3
    %57 = getelementptr inbounds i8, i8* %line, i32 %56
    %58 = sub i32 %raster, %56
    tail call void @llvm.memset.p0i8.i32(i8* %57, i8 %55, i32 %58, i32 1, i1 false)
    br label %.thread
  
  ; <label>:59                                      ; preds = %48, %45
    %60 = getelementptr inbounds i8, i8* %stop.1, i32 -1
    %61 = load i8, i8* %60, align 1, !tbaa !68
    br label %62
  
  ; <label>:62                                      ; preds = %59, %35
    %stop.2 = phi i8* [ %stop.0, %35 ], [ %60, %59 ]
    %last.0 = phi i8 [ %38, %35 ], [ %61, %59 ]
    %63 = zext i8 %last.0 to i32
    br label %94
  
  ; <label>:64                                      ; preds = %21
    %stopmask.0 = trunc i32 %. to i8
    %65 = and i8 %stopmask.0, %25
    %66 = icmp eq i8 %65, 0
    br i1 %66, label %.preheader15, label %67
  
  ; <label>:67                                      ; preds = %64
    %68 = and i32 %28, %23
    %69 = trunc i32 %68 to i8
    br label %91
  
  .preheader15:                                     ; preds = %64, %71
    %stop.3 = phi i8* [ %72, %71 ], [ %stop.0, %64 ]
    %70 = icmp ugt i8* %stop.3, %6
    br i1 %70, label %71, label %.critedge3
  
  ; <label>:71                                      ; preds = %.preheader15
    %72 = getelementptr inbounds i8, i8* %stop.3, i32 -1
    %scevgep10 = getelementptr i8, i8* %stop.3, i32 -1
    %73 = load i8, i8* %scevgep10, align 1, !tbaa !68
    %74 = icmp eq i8 %73, 0
    br i1 %74, label %.preheader15, label %.critedge3
  
  .critedge3:                                       ; preds = %.preheader15, %71
    %75 = icmp eq i8* %stop.3, %6
    br i1 %75, label %84, label %76
  
  ; <label>:76                                      ; preds = %.critedge3
    %77 = getelementptr inbounds i8, i8* %6, i32 1
    %78 = icmp eq i8* %stop.3, %77
    br i1 %78, label %79, label %88
  
  ; <label>:79                                      ; preds = %76
    %80 = load i8, i8* %6, align 1, !tbaa !68
    %81 = zext i8 %80 to i32
    %82 = and i32 %81, %3
    %83 = icmp eq i32 %82, 0
    br i1 %83, label %84, label %88
  
  ; <label>:84                                      ; preds = %79, %.critedge3
    %85 = ashr i32 %line_x, 3
    %86 = getelementptr inbounds i8, i8* %line, i32 %85
    %87 = sub i32 %raster, %85
    tail call void @llvm.memset.p0i8.i32(i8* %86, i8 %zero, i32 %87, i32 1, i1 false)
    br label %.thread
  
  ; <label>:88                                      ; preds = %79, %76
    %89 = getelementptr inbounds i8, i8* %stop.3, i32 -1
    %90 = load i8, i8* %89, align 1, !tbaa !68
    br label %91
  
  ; <label>:91                                      ; preds = %88, %67
    %stop.4 = phi i8* [ %stop.0, %67 ], [ %89, %88 ]
    %last.1 = phi i8 [ %69, %67 ], [ %90, %88 ]
    %92 = zext i8 %last.1 to i32
    %93 = xor i32 %92, 255
    br label %94
  
  ; <label>:94                                      ; preds = %91, %62
    %.pn87 = phi i32 [ %63, %62 ], [ %93, %91 ]
    %stop.5 = phi i8* [ %stop.2, %62 ], [ %stop.4, %91 ]
    %.sink8.in = getelementptr inbounds [256 x i8], [256 x i8]* @byte_reverse_bits, i32 0, i32 %.pn87
    %.sink8 = load i8, i8* %.sink8.in, align 1, !tbaa !68
    %95 = zext i8 %.sink8 to i32
    %.sink.in = getelementptr inbounds [256 x i8], [256 x i8]* @byte_bit_run_length_0, i32 0, i32 %95
    %.sink = load i8, i8* %.sink.in, align 1, !tbaa !68
    %96 = zext i8 %.sink to i32
    %stopx.0 = add nsw i32 %96, -1
    %97 = icmp eq i8 %.sink, 0
    %98 = getelementptr inbounds i8, i8* %stop.5, i32 1
    %.stop.5 = select i1 %97, i8* %98, i8* %stop.5
    %stopx.0.op = shl i32 1, %stopx.0
    %99 = trunc i32 %stopx.0.op to i8
    %100 = select i1 %97, i8 -128, i8 %99
    %101 = ashr i32 %line_x, 3
    %102 = getelementptr inbounds i8, i8* %line, i32 %101
    %103 = sub i32 %raster, %101
    tail call void @llvm.memset.p0i8.i32(i8* %102, i8 %zero, i32 %103, i32 1, i1 false)
    %104 = icmp sgt i32 %x_extent, -1
    %105 = add i32 %xcur, 2047
    br i1 %104, label %120, label %106
  
  ; <label>:106                                     ; preds = %94
    %107 = add i32 %105, %x_extent
    %108 = and i32 %107, 4095
    %109 = sub nsw i32 %108, %x_extent
    %110 = shl i32 %line_x, 12
    %111 = add nsw i32 %109, %110
    %112 = sub nsw i32 0, %x_extent
    %113 = udiv i32 %112, %w
    %114 = sub i32 0, %113
    %115 = urem i32 %112, %w
    %116 = icmp eq i32 %115, 0
    br i1 %116, label %126, label %117
  
  ; <label>:117                                     ; preds = %106
    %118 = xor i32 %113, -1
    %119 = sub i32 %w, %115
    br label %126
  
  ; <label>:120                                     ; preds = %94
    %121 = and i32 %105, 4095
    %122 = shl i32 %line_x, 12
    %123 = or i32 %121, %122
    %124 = udiv i32 %x_extent, %w
    %125 = urem i32 %x_extent, %w
    br label %126
  
  ; <label>:126                                     ; preds = %120, %117, %106
    %127 = phi i32 [ %111, %117 ], [ %111, %106 ], [ %123, %120 ]
    %xl.sroa.82.0 = phi i32 [ %118, %117 ], [ %114, %106 ], [ %124, %120 ]
    %xl.sroa.98.0 = phi i32 [ %119, %117 ], [ 0, %106 ], [ %125, %120 ]
    %128 = trunc i32 %2 to i8
    %129 = sub i32 %w, %xl.sroa.98.0
    %130 = icmp ult i32 %xl.sroa.98.0, %129
    %131 = shl i32 %xl.sroa.98.0, 1
    %132 = sub i32 %xl.sroa.98.0, %129
    %133 = add nsw i32 %xl.sroa.82.0, 1
    %dxx4.sroa.16.0 = select i1 %130, i32 %131, i32 %132
    %134 = select i1 %130, i32 %xl.sroa.82.0, i32 %133
    %135 = add nsw i32 %134, %xl.sroa.82.0
    %136 = icmp ult i32 %dxx4.sroa.16.0, %129
    %137 = shl i32 %dxx4.sroa.16.0, 1
    %138 = sub i32 %dxx4.sroa.16.0, %129
    %dxx4.sroa.16.1 = select i1 %136, i32 %137, i32 %138
    %139 = zext i1 %136 to i32
    %factor = shl i32 %135, 1
    %140 = or i32 %139, %factor
    %141 = xor i32 %140, 1
    %142 = icmp ult i32 %dxx4.sroa.16.1, %129
    %143 = shl i32 %dxx4.sroa.16.1, 1
    %144 = sub i32 %dxx4.sroa.16.1, %129
    %145 = add nsw i32 %141, 1
    %dxx8.sroa.16.0 = select i1 %142, i32 %143, i32 %144
    %146 = select i1 %142, i32 %141, i32 %145
    %147 = add nsw i32 %146, %141
    %148 = icmp ult i32 %dxx8.sroa.16.0, %129
    %149 = shl i32 %dxx8.sroa.16.0, 1
    %150 = sub i32 %dxx8.sroa.16.0, %129
    %151 = add nsw i32 %147, 1
    %dxx16.sroa.8.0 = select i1 %148, i32 %149, i32 %150
    %152 = select i1 %148, i32 %147, i32 %151
    %153 = add nsw i32 %152, %147
    %154 = icmp ult i32 %dxx16.sroa.8.0, %129
    %155 = sub i32 0, %129
    %dxx24.sroa.8.0.p = select i1 %154, i32 %dxx8.sroa.16.0, i32 %155
    %dxx24.sroa.8.0 = add i32 %dxx24.sroa.8.0.p, %dxx16.sroa.8.0
    %156 = select i1 %154, i32 %147, i32 %151
    %157 = add nsw i32 %153, %156
    %158 = icmp ult i32 %dxx24.sroa.8.0, %129
    %dxx32.sroa.7.0.p = select i1 %158, i32 %dxx8.sroa.16.0, i32 %155
    %dxx32.sroa.7.0 = add i32 %dxx32.sroa.7.0.p, %dxx24.sroa.8.0
    %159 = select i1 %158, i32 %147, i32 %151
    %160 = add nsw i32 %157, %159
    %161 = load i8, i8* %6, align 1, !tbaa !68
    %162 = add nsw i32 %127, %x_extent
    %163 = sub i32 0, %xl.sroa.98.0
    %164 = sub i32 0, %dxx4.sroa.16.1
    %165 = sub i32 0, %dxx8.sroa.16.0
    %166 = sub i32 0, %dxx32.sroa.7.0
    %167 = sub i32 0, %dxx24.sroa.8.0
    %168 = sub i32 0, %dxx16.sroa.8.0
    %scevgep = getelementptr i8, i8* %line, i32 2
    %scevgep128 = getelementptr i8, i8* %line, i32 1
    br label %.critedge5
  
  .critedge5:                                       ; preds = %334, %126
    %psrc.0 = phi i8* [ %6, %126 ], [ %psrc.6, %334 ]
    %xl.sroa.0.0 = phi i32 [ %127, %126 ], [ %xl.sroa.0.11, %334 ]
    %xl.sroa.27.0 = phi i32 [ %w, %126 ], [ %xl.sroa.27.22, %334 ]
    %data.0 = phi i8 [ %161, %126 ], [ %data.4, %334 ]
    %sbit.0 = phi i8 [ %128, %126 ], [ %sbit.8, %334 ]
    %169 = zext i8 %data.0 to i32
    %170 = xor i32 %169, 255
    %171 = zext i8 %sbit.0 to i32
    %172 = and i32 %171, %170
    %173 = icmp eq i32 %172, 0
    br i1 %173, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.critedge5, %.lr.ph
    %sbit.149 = phi i8 [ %177, %.lr.ph ], [ %sbit.0, %.critedge5 ]
    %xl.sroa.27.148 = phi i32 [ %xl.sroa.27.2, %.lr.ph ], [ %xl.sroa.27.0, %.critedge5 ]
    %xl.sroa.0.147 = phi i32 [ %176, %.lr.ph ], [ %xl.sroa.0.0, %.critedge5 ]
    %174 = icmp ult i32 %xl.sroa.27.148, %xl.sroa.98.0
    %xl.sroa.27.2.p = select i1 %174, i32 %129, i32 %163
    %xl.sroa.27.2 = add i32 %xl.sroa.27.2.p, %xl.sroa.27.148
    %175 = select i1 %174, i32 %133, i32 %xl.sroa.82.0
    %176 = add nsw i32 %175, %xl.sroa.0.147
    %177 = lshr i8 %sbit.149, 1
    %178 = zext i8 %177 to i32
    %179 = and i32 %178, %170
    %180 = icmp eq i32 %179, 0
    br i1 %180, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.critedge5
    %sbit.1.lcssa = phi i8 [ %sbit.0, %.critedge5 ], [ %177, %.lr.ph ]
    %xl.sroa.27.1.lcssa = phi i32 [ %xl.sroa.27.0, %.critedge5 ], [ %xl.sroa.27.2, %.lr.ph ]
    %xl.sroa.0.1.lcssa = phi i32 [ %xl.sroa.0.0, %.critedge5 ], [ %176, %.lr.ph ]
    %181 = icmp eq i8 %sbit.1.lcssa, 0
    br i1 %181, label %.preheader13, label %.loopexit12
  
  .preheader13:                                     ; preds = %._crit_edge
    %182 = getelementptr inbounds i8, i8* %psrc.0, i32 1
    %183 = load i8, i8* %182, align 1, !tbaa !68
    %184 = icmp eq i8 %183, 0
    br i1 %184, label %.lr.ph55.preheader, label %.loopexit14
  
  .lr.ph55.preheader:                               ; preds = %.preheader13
    %scevgep1 = getelementptr i8, i8* %psrc.0, i32 2
    br label %.lr.ph55
  
  .lr.ph55:                                         ; preds = %207, %.lr.ph55.preheader
    %lsr.iv = phi i8* [ %scevgep2, %207 ], [ %scevgep1, %.lr.ph55.preheader ]
    %xl.sroa.27.354 = phi i32 [ %xl.sroa.27.7, %207 ], [ %xl.sroa.27.1.lcssa, %.lr.ph55.preheader ]
    %xl.sroa.0.253 = phi i32 [ %211, %207 ], [ %xl.sroa.0.1.lcssa, %.lr.ph55.preheader ]
    %185 = load i8, i8* %lsr.iv, align 1, !tbaa !68
    %186 = icmp eq i8 %185, 0
    br i1 %186, label %191, label %187
  
  ; <label>:187                                     ; preds = %.lr.ph55
    %188 = icmp ult i32 %xl.sroa.27.354, %dxx8.sroa.16.0
    %xl.sroa.27.4.p = select i1 %188, i32 %129, i32 %165
    %xl.sroa.27.4 = add i32 %xl.sroa.27.4.p, %xl.sroa.27.354
    %189 = select i1 %188, i32 %151, i32 %147
    %190 = add nsw i32 %189, %xl.sroa.0.253
    br label %.loopexit14
  
  ; <label>:191                                     ; preds = %.lr.ph55
    %scevgep8 = getelementptr i8, i8* %lsr.iv, i32 1
    %192 = load i8, i8* %scevgep8, align 1, !tbaa !68
    %193 = icmp eq i8 %192, 0
    %scevgep7 = getelementptr i8, i8* %lsr.iv, i32 1
    br i1 %193, label %199, label %194
  
  ; <label>:194                                     ; preds = %191
    %195 = icmp ult i32 %xl.sroa.27.354, %dxx16.sroa.8.0
    %xl.sroa.27.5.p = select i1 %195, i32 %129, i32 %168
    %xl.sroa.27.5 = add i32 %xl.sroa.27.5.p, %xl.sroa.27.354
    %196 = zext i1 %195 to i32
    %197 = add i32 %xl.sroa.0.253, %153
    %198 = add i32 %197, %196
    br label %.loopexit14
  
  ; <label>:199                                     ; preds = %191
    %scevgep6 = getelementptr i8, i8* %lsr.iv, i32 2
    %200 = load i8, i8* %scevgep6, align 1, !tbaa !68
    %201 = icmp eq i8 %200, 0
    %scevgep5 = getelementptr i8, i8* %lsr.iv, i32 2
    br i1 %201, label %207, label %202
  
  ; <label>:202                                     ; preds = %199
    %203 = icmp ult i32 %xl.sroa.27.354, %dxx24.sroa.8.0
    %xl.sroa.27.6.p = select i1 %203, i32 %129, i32 %167
    %xl.sroa.27.6 = add i32 %xl.sroa.27.6.p, %xl.sroa.27.354
    %204 = zext i1 %203 to i32
    %205 = add i32 %xl.sroa.0.253, %157
    %206 = add i32 %205, %204
    br label %.loopexit14
  
  ; <label>:207                                     ; preds = %199
    %208 = icmp ult i32 %xl.sroa.27.354, %dxx32.sroa.7.0
    %xl.sroa.27.7.p = select i1 %208, i32 %129, i32 %166
    %xl.sroa.27.7 = add i32 %xl.sroa.27.7.p, %xl.sroa.27.354
    %209 = zext i1 %208 to i32
    %210 = add i32 %160, %xl.sroa.0.253
    %211 = add i32 %210, %209
    %scevgep4 = getelementptr i8, i8* %lsr.iv, i32 3
    %212 = load i8, i8* %scevgep4, align 1, !tbaa !68
    %213 = icmp eq i8 %212, 0
    %scevgep2 = getelementptr i8, i8* %lsr.iv, i32 4
    %scevgep3 = getelementptr i8, i8* %scevgep2, i32 -1
    br i1 %213, label %.lr.ph55, label %.loopexit14
  
  .loopexit14:                                      ; preds = %207, %202, %194, %187, %.preheader13
    %psrc.2 = phi i8* [ %lsr.iv, %187 ], [ %scevgep7, %194 ], [ %scevgep5, %202 ], [ %182, %.preheader13 ], [ %scevgep3, %207 ]
    %xl.sroa.0.3 = phi i32 [ %190, %187 ], [ %198, %194 ], [ %206, %202 ], [ %xl.sroa.0.1.lcssa, %.preheader13 ], [ %211, %207 ]
    %xl.sroa.27.8 = phi i32 [ %xl.sroa.27.4, %187 ], [ %xl.sroa.27.5, %194 ], [ %xl.sroa.27.6, %202 ], [ %xl.sroa.27.1.lcssa, %.preheader13 ], [ %xl.sroa.27.7, %207 ]
    %data.1 = phi i8 [ %185, %187 ], [ %192, %194 ], [ %200, %202 ], [ %183, %.preheader13 ], [ %212, %207 ]
    %214 = zext i8 %data.1 to i32
    %215 = icmp ugt i8 %data.1, 15
    br i1 %215, label %220, label %216
  
  ; <label>:216                                     ; preds = %.loopexit14
    %217 = icmp ult i32 %xl.sroa.27.8, %dxx4.sroa.16.1
    %xl.sroa.27.9.p = select i1 %217, i32 %129, i32 %164
    %xl.sroa.27.9 = add i32 %xl.sroa.27.9.p, %xl.sroa.27.8
    %218 = select i1 %217, i32 %145, i32 %141
    %219 = add nsw i32 %218, %xl.sroa.0.3
    br label %220
  
  ; <label>:220                                     ; preds = %216, %.loopexit14
    %xl.sroa.0.4 = phi i32 [ %219, %216 ], [ %xl.sroa.0.3, %.loopexit14 ]
    %xl.sroa.27.10 = phi i32 [ %xl.sroa.27.9, %216 ], [ %xl.sroa.27.8, %.loopexit14 ]
    %sbit.2 = phi i8 [ 8, %216 ], [ -128, %.loopexit14 ]
    %221 = xor i32 %214, 255
    %222 = zext i8 %sbit.2 to i32
    %223 = and i32 %222, %221
    %224 = icmp eq i32 %223, 0
    br i1 %224, label %.loopexit12, label %.lr.ph64
  
  .lr.ph64:                                         ; preds = %220, %.lr.ph64
    %sbit.362 = phi i8 [ %228, %.lr.ph64 ], [ %sbit.2, %220 ]
    %xl.sroa.27.1161 = phi i32 [ %xl.sroa.27.12, %.lr.ph64 ], [ %xl.sroa.27.10, %220 ]
    %xl.sroa.0.560 = phi i32 [ %227, %.lr.ph64 ], [ %xl.sroa.0.4, %220 ]
    %225 = icmp ult i32 %xl.sroa.27.1161, %xl.sroa.98.0
    %xl.sroa.27.12.p = select i1 %225, i32 %129, i32 %163
    %xl.sroa.27.12 = add i32 %xl.sroa.27.12.p, %xl.sroa.27.1161
    %226 = select i1 %225, i32 %133, i32 %xl.sroa.82.0
    %227 = add nsw i32 %226, %xl.sroa.0.560
    %228 = lshr i8 %sbit.362, 1
    %229 = zext i8 %228 to i32
    %230 = and i32 %229, %221
    %231 = icmp eq i32 %230, 0
    br i1 %231, label %.loopexit12, label %.lr.ph64
  
  .loopexit12:                                      ; preds = %.lr.ph64, %220, %._crit_edge
    %psrc.3 = phi i8* [ %psrc.0, %._crit_edge ], [ %psrc.2, %220 ], [ %psrc.2, %.lr.ph64 ]
    %xl.sroa.0.6 = phi i32 [ %xl.sroa.0.1.lcssa, %._crit_edge ], [ %xl.sroa.0.4, %220 ], [ %227, %.lr.ph64 ]
    %xl.sroa.27.13 = phi i32 [ %xl.sroa.27.1.lcssa, %._crit_edge ], [ %xl.sroa.27.10, %220 ], [ %xl.sroa.27.12, %.lr.ph64 ]
    %data.2.in = phi i32 [ %170, %._crit_edge ], [ %221, %220 ], [ %221, %.lr.ph64 ]
    %sbit.4 = phi i8 [ %sbit.1.lcssa, %._crit_edge ], [ %sbit.2, %220 ], [ %228, %.lr.ph64 ]
    %232 = ashr i32 %xl.sroa.0.6, 12
    %233 = icmp uge i8* %psrc.3, %.stop.5
    %234 = icmp eq i8 %sbit.4, %100
    %or.cond = and i1 %233, %234
    br i1 %or.cond, label %235, label %236
  
  ; <label>:235                                     ; preds = %.loopexit12
    %data.2 = trunc i32 %data.2.in to i8
    br label %.loopexit10
  
  ; <label>:236                                     ; preds = %.loopexit12
    %237 = xor i32 %data.2.in, 255
    br label %238
  
  ; <label>:238                                     ; preds = %238, %236
    %xl.sroa.0.7 = phi i32 [ %xl.sroa.0.6, %236 ], [ %241, %238 ]
    %xl.sroa.27.14 = phi i32 [ %xl.sroa.27.13, %236 ], [ %xl.sroa.27.15, %238 ]
    %sbit.5 = phi i8 [ %sbit.4, %236 ], [ %242, %238 ]
    %239 = icmp ult i32 %xl.sroa.27.14, %xl.sroa.98.0
    %xl.sroa.27.15.p = select i1 %239, i32 %129, i32 %163
    %xl.sroa.27.15 = add i32 %xl.sroa.27.15.p, %xl.sroa.27.14
    %240 = select i1 %239, i32 %133, i32 %xl.sroa.82.0
    %241 = add nsw i32 %240, %xl.sroa.0.7
    %242 = lshr i8 %sbit.5, 1
    %243 = zext i8 %242 to i32
    %244 = and i32 %243, %237
    %245 = icmp eq i32 %244, 0
    br i1 %245, label %246, label %238
  
  ; <label>:246                                     ; preds = %238
    %247 = trunc i32 %237 to i8
    %248 = icmp eq i8 %242, 0
    br i1 %248, label %.preheader11, label %.loopexit10
  
  .preheader11:                                     ; preds = %246
    %249 = getelementptr inbounds i8, i8* %psrc.3, i32 1
    %250 = load i8, i8* %249, align 1, !tbaa !68
    %251 = icmp eq i8 %250, -1
    br i1 %251, label %.lr.ph70, label %._crit_edge71
  
  .lr.ph70:                                         ; preds = %.preheader11, %.lr.ph70
    %252 = phi i8* [ %256, %.lr.ph70 ], [ %249, %.preheader11 ]
    %xl.sroa.27.1669 = phi i32 [ %xl.sroa.27.17, %.lr.ph70 ], [ %xl.sroa.27.15, %.preheader11 ]
    %xl.sroa.0.868 = phi i32 [ %255, %.lr.ph70 ], [ %241, %.preheader11 ]
    %253 = icmp ult i32 %xl.sroa.27.1669, %dxx8.sroa.16.0
    %xl.sroa.27.17.p = select i1 %253, i32 %129, i32 %165
    %xl.sroa.27.17 = add i32 %xl.sroa.27.17.p, %xl.sroa.27.1669
    %254 = select i1 %253, i32 %151, i32 %147
    %255 = add nsw i32 %254, %xl.sroa.0.868
    %256 = getelementptr inbounds i8, i8* %252, i32 1
    %scevgep9 = getelementptr i8, i8* %252, i32 1
    %257 = load i8, i8* %scevgep9, align 1, !tbaa !68
    %258 = icmp eq i8 %257, -1
    br i1 %258, label %.lr.ph70, label %._crit_edge71
  
  ._crit_edge71:                                    ; preds = %.lr.ph70, %.preheader11
    %.lcssa45 = phi i8 [ %250, %.preheader11 ], [ %257, %.lr.ph70 ]
    %.lcssa44 = phi i8* [ %249, %.preheader11 ], [ %256, %.lr.ph70 ]
    %xl.sroa.27.16.lcssa = phi i32 [ %xl.sroa.27.15, %.preheader11 ], [ %xl.sroa.27.17, %.lr.ph70 ]
    %xl.sroa.0.8.lcssa = phi i32 [ %241, %.preheader11 ], [ %255, %.lr.ph70 ]
    %259 = icmp ult i8 %.lcssa45, -16
    br i1 %259, label %.preheader9, label %260
  
  ; <label>:260                                     ; preds = %._crit_edge71
    %261 = icmp ult i32 %xl.sroa.27.16.lcssa, %dxx4.sroa.16.1
    %xl.sroa.27.18.p = select i1 %261, i32 %129, i32 %164
    %xl.sroa.27.18 = add i32 %xl.sroa.27.18.p, %xl.sroa.27.16.lcssa
    %262 = select i1 %261, i32 %145, i32 %141
    %263 = add nsw i32 %262, %xl.sroa.0.8.lcssa
    br label %.preheader9
  
  .preheader9:                                      ; preds = %260, %._crit_edge71
    %xl.sroa.0.9.ph = phi i32 [ %xl.sroa.0.8.lcssa, %._crit_edge71 ], [ %263, %260 ]
    %xl.sroa.27.19.ph = phi i32 [ %xl.sroa.27.16.lcssa, %._crit_edge71 ], [ %xl.sroa.27.18, %260 ]
    %sbit.6.ph = phi i8 [ -128, %._crit_edge71 ], [ 8, %260 ]
    %264 = and i8 %sbit.6.ph, %.lcssa45
    %265 = icmp eq i8 %264, 0
    br i1 %265, label %.loopexit10, label %.lr.ph79
  
  .lr.ph79:                                         ; preds = %.preheader9, %.lr.ph79
    %sbit.678 = phi i8 [ %269, %.lr.ph79 ], [ %sbit.6.ph, %.preheader9 ]
    %xl.sroa.27.1977 = phi i32 [ %xl.sroa.27.20, %.lr.ph79 ], [ %xl.sroa.27.19.ph, %.preheader9 ]
    %xl.sroa.0.976 = phi i32 [ %268, %.lr.ph79 ], [ %xl.sroa.0.9.ph, %.preheader9 ]
    %266 = icmp ult i32 %xl.sroa.27.1977, %xl.sroa.98.0
    %xl.sroa.27.20.p = select i1 %266, i32 %129, i32 %163
    %xl.sroa.27.20 = add i32 %xl.sroa.27.20.p, %xl.sroa.27.1977
    %267 = select i1 %266, i32 %133, i32 %xl.sroa.82.0
    %268 = add nsw i32 %267, %xl.sroa.0.976
    %269 = lshr i8 %sbit.678, 1
    %270 = and i8 %269, %.lcssa45
    %271 = icmp eq i8 %270, 0
    br i1 %271, label %.loopexit10, label %.lr.ph79
  
  .loopexit10:                                      ; preds = %.lr.ph79, %.preheader9, %246, %235
    %psrc.6 = phi i8* [ %psrc.3, %235 ], [ %psrc.3, %246 ], [ %.lcssa44, %.preheader9 ], [ %.lcssa44, %.lr.ph79 ]
    %xl.sroa.0.11 = phi i32 [ %xl.sroa.0.6, %235 ], [ %241, %246 ], [ %xl.sroa.0.9.ph, %.preheader9 ], [ %268, %.lr.ph79 ]
    %xl.sroa.27.22 = phi i32 [ %xl.sroa.27.13, %235 ], [ %xl.sroa.27.15, %246 ], [ %xl.sroa.27.19.ph, %.preheader9 ], [ %xl.sroa.27.20, %.lr.ph79 ]
    %data.4 = phi i8 [ %data.2, %235 ], [ %247, %246 ], [ %.lcssa45, %.preheader9 ], [ %.lcssa45, %.lr.ph79 ]
    %.pn.in = phi i32 [ %162, %235 ], [ %241, %246 ], [ %xl.sroa.0.9.ph, %.preheader9 ], [ %268, %.lr.ph79 ]
    %sbit.8 = phi i8 [ %100, %235 ], [ %242, %246 ], [ %sbit.6.ph, %.preheader9 ], [ %269, %.lr.ph79 ]
    %.pn = ashr i32 %.pn.in, 12
    %n.0 = sub nsw i32 %.pn, %232
    %272 = icmp slt i32 %n.0, 0
    %273 = sub nsw i32 0, %n.0
    %.pn. = select i1 %272, i32 %.pn, i32 %232
    %.n.0 = select i1 %272, i32 %273, i32 %n.0
    %274 = ashr i32 %.pn., 3
    %275 = getelementptr inbounds i8, i8* %line, i32 %274
    %276 = and i32 %.pn., 7
    %277 = add nsw i32 %276, %.n.0
    %278 = icmp slt i32 %277, 9
    br i1 %278, label %279, label %291
  
  ; <label>:279                                     ; preds = %.loopexit10
    %280 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %276
    %281 = load i8, i8* %280, align 1, !tbaa !68
    %282 = zext i8 %281 to i32
    %283 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %277
    %284 = load i8, i8* %283, align 1, !tbaa !68
    %285 = zext i8 %284 to i32
    %286 = sub nsw i32 %282, %285
    %287 = load i8, i8* %275, align 1, !tbaa !68
    %288 = zext i8 %287 to i32
    %289 = xor i32 %288, %286
    %290 = trunc i32 %289 to i8
    store i8 %290, i8* %275, align 1, !tbaa !68
    br label %334
  
  ; <label>:291                                     ; preds = %.loopexit10
    %292 = add nsw i32 %277, -8
    %293 = icmp slt i32 %292, 9
    %294 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %276
    %295 = load i8, i8* %294, align 1, !tbaa !68
    br i1 %293, label %296, label %304
  
  ; <label>:296                                     ; preds = %291
    %297 = load i8, i8* %275, align 1, !tbaa !68
    %298 = xor i8 %297, %295
    store i8 %298, i8* %275, align 1, !tbaa !68
    %299 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.rmasks, i32 0, i32 %292
    %300 = load i8, i8* %299, align 1, !tbaa !68
    %301 = getelementptr inbounds i8, i8* %275, i32 1
    %302 = load i8, i8* %301, align 1, !tbaa !68
    %303 = xor i8 %302, %300
    store i8 %303, i8* %301, align 1, !tbaa !68
    br label %334
  
  ; <label>:304                                     ; preds = %291
    %305 = getelementptr inbounds i8, i8* %275, i32 1
    %306 = load i8, i8* %275, align 1, !tbaa !68
    %307 = xor i8 %306, %295
    store i8 %307, i8* %275, align 1, !tbaa !68
    %308 = icmp sgt i32 %292, 55
    br i1 %308, label %322, label %.preheader
  
  .preheader:                                       ; preds = %304
    %309 = add nsw i32 %277, -16
    %310 = icmp sgt i32 %309, -1
    br i1 %310, label %.lr.ph84.preheader, label %.loopexit
  
  .lr.ph84.preheader:                               ; preds = %.preheader
    %311 = trunc i32 %10 to i8
    %312 = add nsw i32 %232, -1
    %313 = sub nsw i32 %312, %.pn
    %314 = icmp sgt i32 %313, -1
    %smax = select i1 %314, i32 %313, i32 -1
    %315 = sub nsw i32 %312, %smax
    %316 = and i32 %315, 7
    %317 = add nsw i32 %.n.0, -16
    %318 = add nsw i32 %317, %316
    %319 = lshr i32 %318, 3
    %320 = add nsw i32 %274, %319
    %scevgep129 = getelementptr i8, i8* %scevgep128, i32 %274
    %321 = add nuw nsw i32 %319, 1
    call void @llvm.memset.p0i8.i32(i8* %scevgep129, i8 %311, i32 %321, i32 1, i1 false)
    br label %.lr.ph84
  
  ; <label>:322                                     ; preds = %304
    %323 = trunc i32 %10 to i8
    %324 = ashr i32 %292, 3
    tail call void @llvm.memset.p0i8.i32(i8* %305, i8 %323, i32 %324, i32 1, i1 false)
    %325 = getelementptr inbounds i8, i8* %305, i32 %324
    br label %.loopexit
  
  .lr.ph84:                                         ; preds = %.lr.ph84, %.lr.ph84.preheader
    %326 = phi i32 [ %327, %.lr.ph84 ], [ %309, %.lr.ph84.preheader ]
    %327 = add nsw i32 %326, -8
    %328 = icmp sgt i32 %327, -1
    br i1 %328, label %.lr.ph84, label %.loopexit.loopexit
  
  .loopexit.loopexit:                               ; preds = %.lr.ph84
    %scevgep127 = getelementptr i8, i8* %scevgep, i32 %320
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.loopexit.loopexit, %322, %.preheader
    %n.3 = phi i32 [ %292, %322 ], [ %309, %.preheader ], [ %327, %.loopexit.loopexit ]
    %bp.1 = phi i8* [ %325, %322 ], [ %305, %.preheader ], [ %scevgep127, %.loopexit.loopexit ]
    %329 = and i32 %n.3, 7
    %330 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.rmasks, i32 0, i32 %329
    %331 = load i8, i8* %330, align 1, !tbaa !68
    %332 = load i8, i8* %bp.1, align 1, !tbaa !68
    %333 = xor i8 %332, %331
    store i8 %333, i8* %bp.1, align 1, !tbaa !68
    br label %334
  
  ; <label>:334                                     ; preds = %.loopexit, %296, %279
    %335 = icmp uge i8* %psrc.6, %.stop.5
    %336 = icmp eq i8 %sbit.8, %100
    %or.cond4 = and i1 %335, %336
    br i1 %or.cond4, label %.thread, label %.critedge5
  
  .thread:                                          ; preds = %334, %84, %54, %0
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %data, i32 signext %dx, i32 signext %raster, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) unnamed_addr #1 {
    %1 = ptrtoint i8* %data to i32
    %2 = and i32 %1, 3
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 48, i32 0, i32 0, i32 0, i32 0
    %4 = load i32, i32* %3, align 8, !tbaa !69
    %5 = icmp eq i32 %4, 0
    %6 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0
    %7 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0
    %pdc0.0 = select i1 %5, %struct.gx_device_color_s* %7, %struct.gx_device_color_s* %6
    %pdc1.0 = select i1 %5, %struct.gx_device_color_s* %6, %struct.gx_device_color_s* %7
    %8 = sub nsw i32 0, %2
    %9 = getelementptr inbounds i8, i8* %data, i32 %8
    %10 = shl nuw nsw i32 %2, 3
    %11 = add i32 %10, %dx
    %12 = bitcast %struct.gx_device_color_s* %pdc0.0 to %struct.gx_device_color_procs_s**
    %13 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %12, align 4, !tbaa !59
    %14 = icmp eq %struct.gx_device_color_procs_s* %13, @gx_dc_procs_pure
    %15 = bitcast %struct.gx_device_color_s* %pdc1.0 to %struct.gx_device_color_procs_s**
    %16 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %15, align 4, !tbaa !59
    br i1 %14, label %17, label %35
  
  ; <label>:17                                      ; preds = %0
    %18 = icmp eq %struct.gx_device_color_procs_s* %16, @gx_dc_procs_pure
    br i1 %18, label %19, label %42
  
  ; <label>:19                                      ; preds = %17
    %20 = icmp eq i32 %h, 1
    %21 = and i32 %raster, 3
    %22 = icmp eq i32 %21, 0
    %or.cond = or i1 %22, %20
    br i1 %or.cond, label %23, label %26
  
  ; <label>:23                                      ; preds = %19
    %24 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 0, i32 21, i32 9
    %25 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** %24, align 4, !tbaa !46
    br label %26
  
  ; <label>:26                                      ; preds = %23, %19
    %27 = phi i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)* [ %25, %23 ], [ @gx_copy_mono_unaligned, %19 ]
    %28 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc0.0, i32 0, i32 1
    %29 = bitcast %union._c* %28 to i32*
    %30 = load i32, i32* %29, align 4, !tbaa !64
    %31 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc1.0, i32 0, i32 1
    %32 = bitcast %union._c* %31 to i32*
    %33 = load i32, i32* %32, align 4, !tbaa !64
    %34 = tail call i32 %27(%struct.gx_device_s* %dev, i8* %9, i32 signext %11, i32 signext %raster, i32 signext 0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, i32 signext %30, i32 signext %33) #4
    br label %56
  
  ; <label>:35                                      ; preds = %0
    %36 = icmp eq %struct.gx_device_color_procs_s* %16, @gx_dc_procs_pure
    br i1 %36, label %37, label %.thread3
  
  ; <label>:37                                      ; preds = %35
    %38 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc1.0, i32 0, i32 1
    %39 = bitcast %union._c* %38 to i32*
    %40 = load i32, i32* %39, align 4, !tbaa !64
    %41 = icmp eq i32 %40, -1
    br i1 %41, label %50, label %.thread3
  
  ; <label>:42                                      ; preds = %17
    %43 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc0.0, i32 0, i32 1
    %44 = bitcast %union._c* %43 to i32*
    %45 = load i32, i32* %44, align 4, !tbaa !64
    %46 = icmp eq i32 %45, -1
    br i1 %46, label %50, label %.thread3
  
  .thread3:                                         ; preds = %42, %37, %35
    %47 = getelementptr inbounds %struct.gx_device_color_procs_s, %struct.gx_device_color_procs_s* %13, i32 0, i32 1
    %48 = load i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)*, i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)** %47, align 4, !tbaa !73
    %49 = tail call i32 %48(%struct.gx_device_color_s* nonnull %pdc0.0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev, i32 signext 252, %struct.gx_rop_source_s* null) #4
    %not. = icmp sgt i32 %49, -1
    br i1 %not., label %50, label %56
  
  ; <label>:50                                      ; preds = %.thread3, %42, %37
    %pdc.0 = phi %struct.gx_device_color_s* [ %pdc0.0, %37 ], [ %pdc1.0, %.thread3 ], [ %pdc1.0, %42 ]
    %invert.0 = phi i32 [ 1, %37 ], [ 0, %.thread3 ], [ 0, %42 ]
    %51 = bitcast %struct.gx_device_color_s* %pdc.0 to %struct.gx_device_color_procs_s**
    %52 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %51, align 4, !tbaa !59
    %53 = getelementptr inbounds %struct.gx_device_color_procs_s, %struct.gx_device_color_procs_s* %52, i32 0, i32 2
    %54 = load i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)*, i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)** %53, align 4, !tbaa !75
    %55 = tail call i32 %54(%struct.gx_device_color_s* %pdc.0, i8* %9, i32 signext %11, i32 signext %raster, i32 signext 0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev, i32 signext 252, i32 signext %invert.0) #4
    br label %56
  
  ; <label>:56                                      ; preds = %50, %.thread3, %26
    %.2 = phi i32 [ %34, %26 ], [ %55, %50 ], [ %49, %.thread3 ]
    ret i32 %.2
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture readonly, i32, i32, i1) #3
  
  declare i32 @gx_copy_mono_unaligned(%struct.gx_device_s*, i8*, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %x0, i32 signext %x1, i32 signext %y_neg, %struct.gx_device_s* %dev) unnamed_addr #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %2 = load i8*, i8** %1, align 8, !tbaa !35
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %4 = load i32, i32* %3, align 8, !tbaa !29
    %5 = add i32 %4, 31
    %6 = lshr i32 %5, 5
    %7 = shl nuw nsw i32 %6, 2
    %8 = shl nuw i32 %6, 5
    %9 = getelementptr inbounds i8, i8* %2, i32 %8
    %10 = sub nsw i32 %x1, %x0
    %11 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 1, i32 0, i32 0
    %12 = load i32, i32* %11, align 4, !tbaa !21
    %13 = add nsw i32 %12, 2047
    %14 = ashr i32 %13, 12
    %15 = icmp eq i32 %x1, %x0
    %16 = icmp eq i32 %4, 0
    %or.cond = or i1 %15, %16
    br i1 %or.cond, label %34, label %17
  
  ; <label>:17                                      ; preds = %0
    %18 = add i32 %4, -1
    %19 = lshr i32 %18, 3
    %20 = add i32 %19, 1
    %21 = shl i32 %19, 5
    %22 = add i32 %4, 31
    %23 = lshr i32 %22, 5
    %24 = shl i32 %23, 5
    %25 = add i32 %21, %24
    %scevgep = getelementptr i8, i8* %2, i32 %25
    br label %26
  
  ; <label>:26                                      ; preds = %26, %17
    %lsr.iv1 = phi i8* [ %scevgep2, %26 ], [ %scevgep, %17 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %26 ], [ %20, %17 ]
    %scevgep3 = getelementptr i8, i8* %2, i32 %lsr.iv
    %scevgep4 = getelementptr i8, i8* %scevgep3, i32 -1
    tail call void @memflip8x8(i8* %scevgep4, i32 signext %7, i8* %lsr.iv1, i32 signext 4) #4
    %lsr.iv.next = add nsw i32 %lsr.iv, -1
    %scevgep2 = getelementptr i8, i8* %lsr.iv1, i32 -32
    %27 = icmp sgt i32 %lsr.iv.next, 0
    br i1 %27, label %26, label %.loopexit
  
  .loopexit:                                        ; preds = %26
    %28 = icmp slt i32 %10, 0
    %29 = sub nsw i32 0, %10
    %x1.x0 = select i1 %28, i32 %x1, i32 %x0
    %. = select i1 %28, i32 %29, i32 %10
    %30 = icmp eq i32 %y_neg, 0
    %31 = select i1 %30, i32 0, i32 %4
    %y.0 = sub i32 %14, %31
    %32 = and i32 %x1.x0, 7
    %33 = tail call fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %9, i32 signext %32, i32 signext 4, i32 signext %x1.x0, i32 signext %y.0, i32 signext %., i32 signext %4, %struct.gx_device_s* %dev)
    br label %34
  
  ; <label>:34                                      ; preds = %.loopexit, %0
    %.0 = phi i32 [ %33, %.loopexit ], [ 0, %0 ]
    ret i32 %.0
  }
  
  declare void @memflip8x8(i8*, i32 signext, i8*, i32 signext) #2
  
  attributes #0 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #4 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"gx_image_strategies_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !13, i64 236}
  !7 = !{!"gx_image_enum_s", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3, !4, i64 4, !4, i64 5, !4, i64 6, !4, i64 7, !8, i64 8, !10, i64 32, !12, i64 48, !12, i64 56, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76, !3, i64 80, !3, i64 84, !3, i64 88, !11, i64 92, !3, i64 96, !11, i64 100, !11, i64 104, !4, i64 108, !4, i64 112, !4, i64 113, !4, i64 114, !4, i64 115, !14, i64 116, !14, i64 132, !11, i64 148, !13, i64 152, !13, i64 156, !13, i64 160, !3, i64 164, !3, i64 168, !3, i64 172, !11, i64 176, !12, i64 180, !12, i64 188, !15, i64 196, !11, i64 276, !11, i64 280, !20, i64 284, !11, i64 292, !11, i64 296, !11, i64 300, !11, i64 304, !4, i64 312, !4, i64 1656}
  !8 = !{!"gs_matrix_s", !9, i64 0, !9, i64 4, !9, i64 8, !9, i64 12, !9, i64 16, !9, i64 20}
  !9 = !{!"float", !4, i64 0}
  !10 = !{!"r_", !11, i64 0, !11, i64 4, !11, i64 8, !11, i64 12}
  !11 = !{!"int", !4, i64 0}
  !12 = !{!"gs_fixed_point_s", !13, i64 0, !13, i64 4}
  !13 = !{!"long", !4, i64 0}
  !14 = !{!"gs_fixed_rect_s", !12, i64 0, !12, i64 8}
  !15 = !{!"dd_", !16, i64 0, !16, i64 40}
  !16 = !{!"gx_dda_fixed_point_s", !17, i64 0, !17, i64 20}
  !17 = !{!"gx_dda_fixed_s", !18, i64 0, !19, i64 8}
  !18 = !{!"_a", !13, i64 0, !11, i64 4}
  !19 = !{!"_e", !13, i64 0, !11, i64 4, !11, i64 8}
  !20 = !{!"gs_int_point_s", !11, i64 0, !11, i64 4}
  !21 = !{!7, !13, i64 256}
  !22 = !{!7, !4, i64 112}
  !23 = !{!7, !4, i64 3}
  !24 = !{!7, !4, i64 0}
  !25 = !{!7, !4, i64 108}
  !26 = !{!7, !13, i64 48}
  !27 = !{!7, !11, i64 40}
  !28 = !{!7, !13, i64 152}
  !29 = !{!7, !11, i64 104}
  !30 = !{!7, !11, i64 100}
  !31 = !{!7, !3, i64 80}
  !32 = !{!33, !3, i64 0}
  !33 = !{!"gs_memory_s", !34, i64 0}
  !34 = !{!"gs_memory_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !3, i64 24, !3, i64 28, !3, i64 32, !3, i64 36, !3, i64 40, !3, i64 44, !3, i64 48, !3, i64 52, !3, i64 56, !3, i64 60, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76}
  !35 = !{!7, !3, i64 96}
  !36 = !{!7, !3, i64 84}
  !37 = !{!7, !13, i64 52}
  !38 = !{!7, !11, i64 276}
  !39 = !{!7, !11, i64 280}
  !40 = !{!7, !9, i64 12}
  !41 = !{!7, !13, i64 160}
  !42 = !{!7, !9, i64 8}
  !43 = !{!7, !13, i64 156}
  !44 = !{!7, !3, i64 64}
  !45 = !{!7, !4, i64 1}
  !46 = !{!47, !3, i64 180}
  !47 = !{!"gx_device_s", !11, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !11, i64 20, !11, i64 24, !48, i64 28, !11, i64 44, !11, i64 48, !4, i64 52, !4, i64 60, !11, i64 76, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !13, i64 120, !13, i64 124, !11, i64 128, !50, i64 132, !51, i64 144}
  !48 = !{!"gx_device_color_info_s", !11, i64 0, !11, i64 4, !49, i64 8, !49, i64 10, !49, i64 12, !49, i64 14}
  !49 = !{!"short", !4, i64 0}
  !50 = !{!"gx_page_device_procs_s", !3, i64 0, !3, i64 4, !3, i64 8}
  !51 = !{!"gx_device_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !3, i64 24, !3, i64 28, !3, i64 32, !3, i64 36, !3, i64 40, !3, i64 44, !3, i64 48, !3, i64 52, !3, i64 56, !3, i64 60, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76, !3, i64 80, !3, i64 84, !3, i64 88, !3, i64 92, !3, i64 96, !3, i64 100, !3, i64 104, !3, i64 108, !3, i64 112, !3, i64 116, !3, i64 120, !3, i64 124, !3, i64 128, !3, i64 132, !3, i64 136, !3, i64 140, !3, i64 144}
  !52 = !{!7, !11, i64 292}
  !53 = !{!7, !11, i64 296}
  !54 = !{!55, !3, i64 180}
  !55 = !{!"gx_device_memory_s", !11, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !11, i64 20, !11, i64 24, !48, i64 28, !11, i64 44, !11, i64 48, !4, i64 52, !4, i64 60, !11, i64 76, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !13, i64 120, !13, i64 124, !11, i64 128, !50, i64 132, !51, i64 144, !3, i64 292, !8, i64 296, !11, i64 320, !11, i64 324, !3, i64 328, !3, i64 332, !3, i64 336, !56, i64 340, !57, i64 348, !58, i64 364, !11, i64 372, !11, i64 376, !11, i64 380, !11, i64 384, !11, i64 388, !13, i64 392}
  !56 = !{!"gs_const_string_s", !3, i64 0, !11, i64 4}
  !57 = !{!"_c24", !13, i64 0, !11, i64 4, !11, i64 8, !11, i64 12}
  !58 = !{!"gs_log2_scale_point_s", !11, i64 0, !11, i64 4}
  !59 = !{!60, !3, i64 0}
  !60 = !{!"gx_device_color_s", !3, i64 0, !4, i64 4, !20, i64 32, !61, i64 40}
  !61 = !{!"_mask", !62, i64 0, !13, i64 20, !3, i64 24}
  !62 = !{!"gs_client_color_s", !63, i64 0, !3, i64 16}
  !63 = !{!"gs_paint_color_s", !4, i64 0}
  !64 = !{!13, !13, i64 0}
  !65 = !{!7, !4, i64 113}
  !66 = !{!55, !3, i64 332}
  !67 = !{!3, !3, i64 0}
  !68 = !{!4, !4, i64 0}
  !69 = !{!11, !11, i64 0}
  !70 = !{!7, !11, i64 300}
  !71 = !{!7, !11, i64 304}
  !72 = !{!7, !9, i64 16}
  !73 = !{!74, !3, i64 4}
  !74 = !{!"gx_device_color_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16}
  !75 = !{!74, !3, i64 8}

...
---
name:            image_strategy_simple
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: afgr64 }
  - { id: 49, class: fgr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: afgr64 }
  - { id: 52, class: afgr64 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: afgr64 }
  - { id: 55, class: afgr64 }
  - { id: 56, class: fgr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: gpr32 }
  - { id: 75, class: gpr32 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: gpr32 }
  - { id: 78, class: gpr32 }
  - { id: 79, class: gpr32 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: gpr32 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: gpr32 }
  - { id: 84, class: gpr32 }
  - { id: 85, class: gpr32 }
  - { id: 86, class: gpr32 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: afgr64 }
  - { id: 89, class: fgr32 }
  - { id: 90, class: afgr64 }
  - { id: 91, class: afgr64 }
  - { id: 92, class: gpr32 }
  - { id: 93, class: afgr64 }
  - { id: 94, class: gpr32 }
  - { id: 95, class: gpr32 }
  - { id: 96, class: afgr64 }
  - { id: 97, class: fgr32 }
  - { id: 98, class: gpr32 }
  - { id: 99, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%9' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
constants:       
  - id:              0
    value:           double 0x3F20000000000000
    alignment:       8
  - id:              1
    value:           'double 4.096000e+03'
    alignment:       8
body:             |
  bb.0 (%ir-block.0, freq 3640):
    successors: %bb.1(37), %bb.14(62)
    liveins: %a0, %t9, %v0
  
    %38 = ADDu %v0, %t9
    %9 = COPY %a0
    %11 = LBu %9, 112, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.5, align 8, !tbaa !22)
    %10 = ADDiu %zero, 0
    BNE killed %11, %zero, %bb.14, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.8, freq 1365):
    successors: %bb.2(50), %bb.14(50)
  
    %13 = LBu %9, 3, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.9, !tbaa !23)
    %14 = ADDiu %zero, 1
    BNE killed %13, %14, %bb.14, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.12, freq 682):
    successors: %bb.3(50), %bb.14(50)
  
    %16 = LBu %9, 0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.13, align 8, !tbaa !24)
    BNE killed %16, %14, %bb.14, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.16, freq 341):
    successors: %bb.8(33), %bb.15(66)
  
    %0 = LW %9, 236, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.1, !tbaa !6)
    %19 = LW %9, 108, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.17, !tbaa !25)
    %20 = ADDiu %zero, 1
    BEQ %19, killed %20, %bb.8, implicit-def dead %at
    B %bb.15, implicit-def dead %at
  
  bb.15 (%ir-block.16, freq 227):
    successors: %bb.4(50), %bb.14(49)
  
    BNE %19, %zero, %bb.14, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.19, freq 113):
    successors: %bb.13..thread16(50), %bb.5(50)
  
    %62 = LW %9, 48, <0x32f1280> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.20, align 8, !tbaa !26)
    %63 = ADDiu %0, 2047
    %64 = ADDu %63, killed %62
    %65 = SRA killed %64, 12
    %66 = SRA %63, 12
    %2 = SUBu killed %65, killed %66
    %67 = LW %38, target-flags(<unknown>) @image_render_simple, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %61 = ADDiu %67, target-flags(<unknown>) @image_render_simple
    %68 = LW %9, 40, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.27, align 8, !tbaa !27)
    BEQ %2, killed %68, %bb.13..thread16, implicit-def dead %at
    B %bb.5, implicit-def dead %at
  
  bb.5 (%ir-block.30, freq 56):
    successors: %bb.6(37), %bb.14(62)
  
    %75 = LW %9, 152, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.38, align 8, !tbaa !28)
    BNE killed %75, %zero, %bb.14, implicit-def dead %at
    B %bb.6, implicit-def dead %at
  
  bb.6 (%ir-block.41, freq 21):
    successors: %bb.7(37), %bb.13..thread16(62)
  
    %70 = SRA %2, 31
    %71 = ADDu %2, %70
    %3 = XOR %71, %70
    %72 = ADDiu %3, 31
    %73 = SRA %72, 5
    %74 = SLL %73, 2
    %4 = ADDiu %74, 4
    SW %3, %9, 104, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.42, align 8, !tbaa !29)
    SW %4, %9, 100, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.43, !tbaa !30)
    %77 = LW %9, 80, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.44, align 8, !tbaa !31)
    %78 = LW %77, 0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.46, !tbaa !32)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %79 = LW %38, target-flags(<unknown>) @.str, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %80 = ADDiu killed %79, target-flags(<unknown>) @.str
    %a0 = COPY %77
    %a1 = COPY %4
    %a2 = COPY %80
    %t9 = COPY %78
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %81 = COPY %v0
    SW %81, %9, 96, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.49, align 8, !tbaa !35)
    BNE %81, %zero, %bb.13..thread16, implicit-def dead %at
    B %bb.7, implicit-def dead %at
  
  bb.7 (%ir-block.51, freq 8):
    successors: %bb.14(100)
  
    %84 = LW %9, 84, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.53, !tbaa !36)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %85 = LW %38, target-flags(<unknown>) @gx_default_end_image, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @gx_default_end_image)
    %83 = ADDiu %zero, 0
    %a0 = COPY %84
    %a1 = COPY %9
    %a2 = COPY %83
    %gp = COPY %38
    %t9 = COPY %85
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.14, implicit-def dead %at
  
  bb.8 (%ir-block.56, freq 113):
    successors: %bb.10(50), %bb.9(50)
  
    %1 = LW %9, 256, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.3, !tbaa !21)
    %21 = LW %9, 52, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.57, !tbaa !37)
    %22 = ADDiu %1, 2048
    %23 = ADDu %22, killed %21
    %24 = SRA killed %23, 12
    %25 = SRA %22, 12
    %26 = SUBu killed %24, killed %25
    %27 = SRA %26, 31
    %28 = LW %9, 40, <0x32f1280> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.73, align 8, !tbaa !27)
    %30 = ADDu %26, %27
    %5 = XOR killed %30, %27
    BEQ %5, killed %28, %bb.10, implicit-def dead %at
    B %bb.9, implicit-def dead %at
  
  bb.9 (%ir-block.76, freq 56):
    successors: %bb.10(37), %bb.14(62)
  
    %37 = LW %9, 152, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.77, align 8, !tbaa !28)
    BNE killed %37, %zero, %bb.14, implicit-def dead %at
    B %bb.10, implicit-def dead %at
  
  bb.10 (%ir-block.80, freq 78):
    successors: %bb.11..critedge(37), %bb.12..critedge13(62)
  
    %29 = ADDiu %zero, -32
    %31 = ADDiu %5, 31
    %32 = AND %31, %29
    %33 = SLL %5, 2
    %34 = ADDiu %33, 28
    %35 = AND %34, %29
    %6 = ADDu %35, %32
    SW %5, %9, 104, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.81, align 8, !tbaa !29)
    SW %6, %9, 100, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.82, !tbaa !30)
    %39 = LW %9, 80, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.83, align 8, !tbaa !31)
    %40 = LW %39, 0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.85, !tbaa !32)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %41 = LW %38, target-flags(<unknown>) @.str, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %42 = ADDiu killed %41, target-flags(<unknown>) @.str
    %a0 = COPY %39
    %a1 = COPY %6
    %a2 = COPY %42
    %t9 = COPY %40
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %43 = COPY %v0
    SW %43, %9, 96, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.88, align 8, !tbaa !35)
    BNE %43, %zero, %bb.12..critedge13, implicit-def dead %at
    B %bb.11..critedge, implicit-def dead %at
  
  bb.11..critedge (freq 29):
    successors: %bb.14(100)
  
    %58 = LW %9, 84, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.91, !tbaa !36)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %59 = LW %38, target-flags(<unknown>) @gx_default_end_image, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @gx_default_end_image)
    %57 = ADDiu %zero, 0
    %a0 = COPY %58
    %a1 = COPY %9
    %a2 = COPY %57
    %gp = COPY %38
    %t9 = COPY %59
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.14, implicit-def dead %at
  
  bb.12..critedge13 (freq 48):
    successors: %bb.13..thread16(100)
  
    %45 = ADDiu %0, 2048
    %46 = SRA killed %45, 12
    SW %46, %9, 276, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.96, !tbaa !38)
    SW %46, %9, 280, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.97, align 8, !tbaa !39)
    %47 = LW %38, target-flags(<unknown>) %const.0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %48 = LDC1 killed %47, target-flags(<unknown>) %const.0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %49 = LWC1 %9, 12, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.98, !tbaa !40)
    %50 = LW %38, target-flags(<unknown>) @image_render_landscape, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %51 = CVT_D32_S killed %49
    %52 = FADD_D32 killed %51, killed %48
    %44 = ADDiu killed %50, target-flags(<unknown>) @image_render_landscape
    %53 = LW %38, target-flags(<unknown>) %const.1, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %54 = LDC1 killed %53, target-flags(<unknown>) %const.1, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %55 = FMUL_D32 killed %52, killed %54
    %56 = TRUNC_W_D32 killed %55
    SWC1 killed %56, %9, 160, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.104, align 8)
  
  bb.13..thread16 (freq 119):
    successors: %bb.14(100)
  
    %7 = PHI %44, %bb.12..critedge13, %61, %bb.4, %61, %bb.6
    %87 = LW %38, target-flags(<unknown>) %const.0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %88 = LDC1 killed %87, target-flags(<unknown>) %const.0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %89 = LWC1 %9, 8, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.105, align 8, !tbaa !42)
    %90 = CVT_D32_S killed %89
    %91 = FADD_D32 killed %90, killed %88
    %92 = LW %38, target-flags(<unknown>) %const.1, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %93 = LDC1 killed %92, target-flags(<unknown>) %const.1, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %94 = ADDiu %zero, 8
    %95 = LW %38, target-flags(<unknown>) @sample_unpack_copy, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %96 = FMUL_D32 killed %91, killed %93
    %97 = TRUNC_W_D32 killed %96
    SWC1 killed %97, %9, 156, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.111)
    SW killed %95, %9, 64, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.112, align 8, !tbaa !44)
    SB killed %94, %9, 1, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.113, !tbaa !45)
  
  bb.14 (%ir-block.114, freq 3640):
    liveouts: %v0
  
    %8 = PHI %10, %bb.0, %10, %bb.1, %10, %bb.2, %10, %bb.15, %10, %bb.9, %57, %bb.11..critedge, %10, %bb.5, %83, %bb.7, %7, %bb.13..thread16
    %v0 = COPY %8
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/ghostscript/ghostscript.gximage1.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.gx_image_strategies_s = type { i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)* }
  %struct.gx_device_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s }
  %struct.gs_memory_s = type { %struct.gs_memory_procs_s }
  %struct.gs_memory_procs_s = type { i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i32, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i32, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i8*, i32, i8*)*, i32 (%struct.gs_memory_s*, i8*)*, %struct.gs_memory_struct_type_s* (%struct.gs_memory_s*, i8*)*, void (%struct.gs_memory_s*, i8*, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i8*, i32, i32, i8*)*, void (%struct.gs_memory_s*, i8*, i32, i8*)*, void (%struct.gs_memory_s*, %struct.gs_gc_root_s*, %struct.gs_ptr_procs_s*, i8**, i8*)*, void (%struct.gs_memory_s*, %struct.gs_gc_root_s*, i8*)*, void (%struct.gs_memory_s*, %struct.gs_memory_status_s*)*, void (%struct.gs_memory_s*, i32)* }
  %struct.gs_gc_root_s = type { %struct.gs_gc_root_s*, %struct.gs_ptr_procs_s*, i8** }
  %struct.gs_ptr_procs_s = type { void (i8*, %struct.gc_state_s*)*, i32 (i8*, %struct.gc_state_s*)*, i8* (i8*, %struct.gc_state_s*)* }
  %struct.gc_state_s = type opaque
  %struct.gs_memory_status_s = type { i32, i32 }
  %struct.gs_memory_struct_type_s = type { i32, i8*, %struct.struct_shared_procs_s*, void (i8*, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)*, void (i8*)* }
  %struct.struct_shared_procs_s = type opaque
  %struct.gx_device_color_info_s = type { i32, i32, i16, i16, i16, i16 }
  %struct.gx_page_device_procs_s = type { i32 (%struct.gx_device_s*, %struct.gs_state_s*)*, i32 (%struct.gx_device_s*, %struct.gs_state_s*)*, i32 (%struct.gx_device_s*, i32, %struct.gs_state_s*)* }
  %struct.gs_state_s = type opaque
  %struct.gx_device_procs_s = type { i32 (%struct.gx_device_s*)*, void (%struct.gx_device_s*, %struct.gs_matrix_s*)*, i32 (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i32, i32)*, i32 (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16)*, i32 (%struct.gx_device_s*, i32, i16*)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, %struct.gx_tile_bitmap_s*, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i8*, i8**)*, i32 (%struct.gx_device_s*, %struct.gs_param_list_s*)*, i32 (%struct.gx_device_s*, %struct.gs_param_list_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16, i16)*, %struct.gx_xfont_procs_s* (%struct.gx_device_s*)*, %struct.gx_device_s* (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16, i16)*, %struct.gx_device_s* (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i32*)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32*, %struct.gx_tile_bitmap_s*, i32*, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gx_path_s*, %struct.gx_fill_params_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gx_path_s*, %struct.gx_stroke_params_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32, i32, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, %struct.gs_fixed_edge_s*, %struct.gs_fixed_edge_s*, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gs_image_s*, i32, %struct.gs_int_rect_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*, %struct.gs_memory_s*, i8**)*, i32 (%struct.gx_device_s*, i8*, i8**, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32)*, i32 (%struct.gx_device_s*, %struct.gx_strip_bitmap_s*, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32*, %struct.gx_strip_bitmap_s*, i32*, i32, i32, i32, i32, i32, i32, i32)*, void (%struct.gx_device_s*, %struct.gs_fixed_rect_s*)* }
  %struct.gs_matrix_s = type { float, float, float, float, float, float }
  %struct.gx_tile_bitmap_s = type { i8*, i32, %struct.gs_int_point_s, i32, i16, i16 }
  %struct.gs_int_point_s = type { i32, i32 }
  %struct.gs_param_list_s = type opaque
  %struct.gx_xfont_procs_s = type opaque
  %struct.gs_imager_state_s = type { %struct.gs_memory_s*, %struct.gx_line_params_s, %struct.gs_matrix_fixed_s, i32, i16, i32, float, %struct.gs_fixed_point_s, i32, i32, %struct.gs_halftone_s*, [2 x %struct.gs_int_point_s], %struct.gx_device_halftone_s*, %struct.gx_ht_cache_s*, %struct.gs_cie_render_s*, %struct.gx_transfer_map_s*, %struct.gx_transfer_map_s*, %union.gx_transfer_s, %union.gx_transfer_s, %struct.gx_cie_joint_caches_s*, %struct.gx_color_map_procs_s*, %struct.gx_pattern_cache_s* }
  %struct.gx_line_params_s = type { float, i32, i32, float, float, float, float, %struct.gx_dash_params_s }
  %struct.gx_dash_params_s = type { float*, i32, float, i32, float, i32, i32, float }
  %struct.gs_matrix_fixed_s = type { float, float, float, float, float, float, i32, i32, i32 }
  %struct.gs_fixed_point_s = type { i32, i32 }
  %struct.gs_halftone_s = type { i32, %struct.rc_header_s, %union.anon }
  %struct.rc_header_s = type { i32, %struct.gs_memory_s*, void (%struct.gs_memory_s*, i8*, i8*)* }
  %union.anon = type { %struct.gs_colorscreen_halftone_s }
  %struct.gs_colorscreen_halftone_s = type { %union._css }
  %union._css = type { [4 x %struct.gs_screen_halftone_s] }
  %struct.gs_screen_halftone_s = type { float, float, float (double, double)*, float, float }
  %struct.gx_device_halftone_s = type { %struct.gx_ht_order_s, %struct.rc_header_s, i32, %struct.gx_ht_order_component_s*, i32, [4 x i32], i32, i32 }
  %struct.gx_ht_order_s = type { %struct.gx_ht_cell_params_s, i16, i16, i16, i16, i16, i16, i32, i32, i32, i32*, %struct.gx_ht_bit_s*, %struct.gx_ht_cache_s*, %struct.gx_transfer_map_s* }
  %struct.gx_ht_cell_params_s = type { i16, i16, i16, i16, i16, i16, i32, i16, i16, i32, i32, i32 }
  %struct.gx_ht_bit_s = type { i32, i32 }
  %struct.gx_ht_order_component_s = type { %struct.gx_ht_order_s, i32 }
  %struct.gx_ht_cache_s = type { i8*, i32, %struct.gx_ht_tile_s*, i32, %struct.gx_ht_order_s, i32, i32, i32 }
  %struct.gx_ht_tile_s = type { %struct.gx_strip_bitmap_s, i32, i32 }
  %struct.gx_strip_bitmap_s = type { i8*, i32, %struct.gs_int_point_s, i32, i16, i16, i16, i16 }
  %struct.gs_cie_render_s = type opaque
  %struct.gx_transfer_map_s = type { %struct.rc_header_s, {}*, i32, [256 x i16] }
  %union.gx_transfer_s = type { [4 x %struct.gx_transfer_map_s*] }
  %struct.gx_cie_joint_caches_s = type opaque
  %struct.gx_color_map_procs_s = type { void (i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, void (i16, i16, i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, void (i16, i16, i16, i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)* }
  %struct.gx_pattern_cache_s = type opaque
  %struct.gx_path_s = type { %struct.gs_memory_s*, %struct.gs_fixed_rect_s, %struct.segment_s*, %struct.subpath_s*, %struct.subpath_s*, i32, i32, %struct.gs_fixed_point_s, %struct.gs_point_s, %struct.gs_point_s, i8, i8, i8, i8 }
  %struct.gs_fixed_rect_s = type { %struct.gs_fixed_point_s, %struct.gs_fixed_point_s }
  %struct.segment_s = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s }
  %struct.subpath_s = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s, %struct.segment_s*, i32, %struct.line_close_segment, i8 }
  %struct.line_close_segment = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s, %struct.subpath_s* }
  %struct.gs_point_s = type { double, double }
  %struct.gx_fill_params_s = type opaque
  %struct.gx_device_color_s = type { %struct.gx_device_color_procs_s*, %union._c, %struct.gs_int_point_s, %struct._mask }
  %struct.gx_device_color_procs_s = type { i32 (%struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)*, i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)* }
  %struct.gx_rop_source_s = type { i8*, i32, i32, i32, [2 x i32], i32 }
  %union._c = type { %struct._col }
  %struct._col = type { %struct.gx_device_halftone_s*, [4 x i8], [4 x i32], i16 }
  %struct._mask = type { %struct.gs_client_color_s, i32, %struct.gx_color_tile_s* }
  %struct.gs_client_color_s = type { %struct.gs_paint_color_s, %struct.gs_pattern_instance_s* }
  %struct.gs_paint_color_s = type { [4 x float] }
  %struct.gs_pattern_instance_s = type opaque
  %struct.gx_color_tile_s = type opaque
  %struct.gx_clip_path_s = type opaque
  %struct.gx_stroke_params_s = type opaque
  %struct.gs_fixed_edge_s = type { %struct.gs_fixed_point_s, %struct.gs_fixed_point_s }
  %struct.gs_image_s = type { i32, i32, %struct.gs_matrix_s, i32, %struct.gs_color_space_s*, [8 x float], i32, i32, i32, i32 }
  %struct.gs_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.1 }
  %struct.gs_color_space_type_s = type { i32, i32, i32, void (%struct.gs_client_color_s*, %struct.gs_color_space_s*)*, %struct.gs_color_space_s* (%struct.gs_color_space_s*, %struct.gs_imager_state_s*)*, i32 (%struct.gs_client_color_s*, %struct.gs_color_space_s*, i16*, %struct.gs_imager_state_s*)*, i32 (i16*, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gs_client_color_s*, %struct.gs_color_space_s*, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gs_color_space_s*, %struct.gs_state_s*)*, void (%struct.gs_color_space_s*, %struct.gs_memory_s*, i32)*, void (%struct.gs_client_color_s*, %struct.gs_color_space_s*, %struct.gs_memory_s*, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)* }
  %union.anon.1 = type { %struct.gs_pattern_params_s }
  %struct.gs_pattern_params_s = type { i32, %struct.gs_paint_color_space_s }
  %struct.gs_paint_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.4 }
  %union.anon.4 = type { %struct.gs_indexed_params_s }
  %struct.gs_indexed_params_s = type { %struct.gs_base_color_space_s, i32, %union.anon.3, i32 }
  %struct.gs_base_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.2 }
  %union.anon.2 = type { %struct.gs_cie_defg_s* }
  %struct.gs_cie_defg_s = type opaque
  %union.anon.3 = type { %struct.gs_const_string_s }
  %struct.gs_const_string_s = type { i8*, i32 }
  %struct.gs_int_rect_s = type { %struct.gs_int_point_s, %struct.gs_int_point_s }
  %struct.gx_image_enum_s = type { i8, i8, i8, i8, i8, i8, i8, i8, %struct.gs_matrix_s, %struct.r_, %struct.gs_fixed_point_s, %struct.gs_fixed_point_s, i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)*, {}*, %struct.gs_imager_state_s*, %struct.gs_color_space_s*, %struct.gs_memory_s*, %struct.gx_device_s*, i8*, i32, i8*, i32, i32, i32, i8, i8, i8, i8, %struct.gs_fixed_rect_s, %struct.gs_fixed_rect_s, i32, i32, i32, i32, %struct.gx_device_clip_s*, %struct.gx_device_rop_texture_s*, %struct.stream_IScale_state_s*, i32, %struct.gs_fixed_point_s, %struct.gs_fixed_point_s, %struct.dd_, i32, i32, %struct.gs_int_point_s, i32, i32, i32, i32, [4 x %struct.sample_map_s], [256 x %struct.gx_image_clue_s] }
  %struct.r_ = type { i32, i32, i32, i32 }
  %union.sample_lookup_s = type { [16 x i32], [192 x i8] }
  %struct.gx_device_clip_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s, %struct.gx_device_s*, %struct.gx_clip_list_s, %struct.gx_clip_rect_s*, %struct.gs_int_point_s }
  %struct.gx_clip_list_s = type { %struct.gx_clip_rect_s, %struct.gx_clip_rect_s*, %struct.gx_clip_rect_s*, i32, i32 }
  %struct.gx_clip_rect_s = type { %struct.gx_clip_rect_s*, %struct.gx_clip_rect_s*, i32, i32, i32, i32, i8 }
  %struct.gx_device_rop_texture_s = type opaque
  %struct.stream_IScale_state_s = type { %struct.stream_template_s*, %struct.gs_memory_s*, i32 (%struct.stream_state_s*, i8*)*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, double, double, i8*, i8*, i8*, %struct.CLIST*, %struct.CONTRIB*, i32, i32, i32, i32, i32, i32, %struct.CLIST, i32, [8 x %struct.CONTRIB] }
  %struct.stream_template_s = type { %struct.gs_memory_struct_type_s*, i32 (%struct.stream_state_s*)*, i32 (%struct.stream_state_s*, %struct.stream_cursor_read_s*, %struct.stream_cursor_write_s*, i32)*, i32, i32, void (%struct.stream_state_s*)*, void (%struct.stream_state_s*)*, i32 (%struct.stream_state_s*)* }
  %struct.stream_state_s = type { %struct.stream_template_s*, %struct.gs_memory_s*, i32 (%struct.stream_state_s*, i8*)* }
  %struct.stream_cursor_read_s = type { i8*, i8*, i8* }
  %struct.stream_cursor_write_s = type { i8*, i8*, i8* }
  %struct.CONTRIB = type { float }
  %struct.CLIST = type { i32, i32, i32 }
  %struct.dd_ = type { %struct.gx_dda_fixed_point_s, %struct.gx_dda_fixed_point_s }
  %struct.gx_dda_fixed_point_s = type { %struct.gx_dda_fixed_s, %struct.gx_dda_fixed_s }
  %struct.gx_dda_fixed_s = type { %struct._a, %struct._e }
  %struct._a = type { i32, i32 }
  %struct._e = type { i32, i32, i32 }
  %struct.sample_map_s = type { %union.sample_lookup_s, [16 x float], double, i32 }
  %struct.gx_image_clue_s = type { %struct.gx_device_color_s, i32 }
  %struct.gx_device_memory_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s, %struct.gx_device_s*, %struct.gs_matrix_s, i32, i32, i8*, i8**, %struct.gs_memory_s*, %struct.gs_const_string_s, %struct._c24, %struct.gs_log2_scale_point_s, i32, i32, i32, i32, i32, i32 }
  %struct._c24 = type { i32, i32, i32, i32 }
  %struct.gs_log2_scale_point_s = type { i32, i32 }
  
  @image_strategies = external global %struct.gx_image_strategies_s, align 4
  @.str = private unnamed_addr constant [11 x i8] c"image line\00", align 1
  @mem_mono_device = external global %struct.gx_device_memory_s, align 4
  @gx_dc_procs_pure = external global %struct.gx_device_color_procs_s, align 4
  @byte_reverse_bits = external global [256 x i8], align 1
  @byte_bit_run_length_0 = external global [256 x i8], align 1
  @image_simple_expand.lmasks = internal unnamed_addr constant [9 x i8] c"\FF\7F?\1F\0F\07\03\01\00", align 1
  @image_simple_expand.rmasks = internal unnamed_addr constant [9 x i8] c"\00\80\C0\E0\F0\F8\FC\FE\FF", align 1
  
  ; Function Attrs: norecurse nounwind
  define void @gs_gximage1_init(%struct.gs_memory_s* nocapture readnone %mem) #0 {
    store i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)* @image_strategy_simple, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)** getelementptr inbounds (%struct.gx_image_strategies_s, %struct.gx_image_strategies_s* @image_strategies, i32 0, i32 1), align 4, !tbaa !1
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* @image_strategy_simple(%struct.gx_image_enum_s* %penum) #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 0, i32 0, i32 0
    %2 = load i32, i32* %1, align 4, !tbaa !6
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 1, i32 0, i32 0
    %4 = load i32, i32* %3, align 4, !tbaa !21
    %5 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 24
    %6 = load i8, i8* %5, align 8, !tbaa !22
    %7 = icmp eq i8 %6, 0
    br i1 %7, label %8, label %114
  
  ; <label>:8                                       ; preds = %0
    %9 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 3
    %10 = load i8, i8* %9, align 1, !tbaa !23
    %11 = icmp eq i8 %10, 1
    br i1 %11, label %12, label %114
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %14 = load i8, i8* %13, align 8, !tbaa !24
    %15 = icmp eq i8 %14, 1
    br i1 %15, label %16, label %114
  
  ; <label>:16                                      ; preds = %12
    %17 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 23
    %18 = load i32, i32* %17, align 4, !tbaa !25
    switch i32 %18, label %114 [
      i32 0, label %19
      i32 1, label %56
    ]
  
  ; <label>:19                                      ; preds = %16
    %20 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %21 = load i32, i32* %20, align 8, !tbaa !26
    %22 = add i32 %2, 2047
    %23 = add i32 %22, %21
    %24 = ashr i32 %23, 12
    %25 = ashr i32 %22, 12
    %26 = sub nsw i32 %24, %25
    %27 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 9, i32 2
    %28 = load i32, i32* %27, align 8, !tbaa !27
    %29 = icmp eq i32 %26, %28
    br i1 %29, label %.thread16, label %30
  
  ; <label>:30                                      ; preds = %19
    %31 = icmp slt i32 %26, 0
    %32 = sub nsw i32 0, %26
    %33 = select i1 %31, i32 %32, i32 %26
    %34 = add nsw i32 %33, 31
    %35 = ashr i32 %34, 5
    %36 = shl nsw i32 %35, 2
    %37 = add nsw i32 %36, 4
    %38 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 31
    %39 = load i32, i32* %38, align 8, !tbaa !28
    %40 = icmp eq i32 %39, 0
    br i1 %40, label %41, label %114
  
  ; <label>:41                                      ; preds = %30
    %42 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    store i32 %33, i32* %42, align 8, !tbaa !29
    %43 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    store i32 %37, i32* %43, align 4, !tbaa !30
    %44 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 16
    %45 = load %struct.gs_memory_s*, %struct.gs_memory_s** %44, align 8, !tbaa !31
    %46 = bitcast %struct.gs_memory_s* %45 to i8* (%struct.gs_memory_s*, i32, i8*)**
    %47 = load i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)** %46, align 4, !tbaa !32
    %48 = tail call i8* %47(%struct.gs_memory_s* %45, i32 signext %37, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i32 0, i32 0)) #4
    %49 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    store i8* %48, i8** %49, align 8, !tbaa !35
    %50 = icmp eq i8* %48, null
    br i1 %50, label %51, label %.thread16
  
  ; <label>:51                                      ; preds = %41
    %52 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %53 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 17
    %54 = load %struct.gx_device_s*, %struct.gx_device_s** %53, align 4, !tbaa !36
    %55 = tail call i32 @gx_default_end_image(%struct.gx_device_s* %54, i8* nonnull %52, i32 signext 0) #4
    br label %114
  
  ; <label>:56                                      ; preds = %16
    %57 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 1
    %58 = load i32, i32* %57, align 4, !tbaa !37
    %59 = add i32 %4, 2048
    %60 = add i32 %59, %58
    %61 = ashr i32 %60, 12
    %62 = ashr i32 %59, 12
    %63 = sub nsw i32 %61, %62
    %64 = icmp slt i32 %63, 0
    %65 = sub nsw i32 0, %63
    %66 = select i1 %64, i32 %65, i32 %63
    %67 = add nsw i32 %66, 31
    %68 = and i32 %67, -32
    %69 = shl nsw i32 %66, 2
    %70 = add nsw i32 %69, 28
    %71 = and i32 %70, -32
    %72 = add i32 %71, %68
    %73 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 9, i32 2
    %74 = load i32, i32* %73, align 8, !tbaa !27
    %75 = icmp eq i32 %66, %74
    br i1 %75, label %80, label %76
  
  ; <label>:76                                      ; preds = %56
    %77 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 31
    %78 = load i32, i32* %77, align 8, !tbaa !28
    %79 = icmp eq i32 %78, 0
    br i1 %79, label %80, label %114
  
  ; <label>:80                                      ; preds = %76, %56
    %81 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    store i32 %66, i32* %81, align 8, !tbaa !29
    %82 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    store i32 %72, i32* %82, align 4, !tbaa !30
    %83 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 16
    %84 = load %struct.gs_memory_s*, %struct.gs_memory_s** %83, align 8, !tbaa !31
    %85 = bitcast %struct.gs_memory_s* %84 to i8* (%struct.gs_memory_s*, i32, i8*)**
    %86 = load i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)** %85, align 4, !tbaa !32
    %87 = tail call i8* %86(%struct.gs_memory_s* %84, i32 signext %72, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i32 0, i32 0)) #4
    %88 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    store i8* %87, i8** %88, align 8, !tbaa !35
    %89 = icmp eq i8* %87, null
    br i1 %89, label %.critedge, label %.critedge13
  
  .critedge:                                        ; preds = %80
    %90 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %91 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 17
    %92 = load %struct.gx_device_s*, %struct.gx_device_s** %91, align 4, !tbaa !36
    %93 = tail call i32 @gx_default_end_image(%struct.gx_device_s* %92, i8* nonnull %90, i32 signext 0) #4
    br label %114
  
  .critedge13:                                      ; preds = %80
    %94 = add nsw i32 %2, 2048
    %95 = ashr i32 %94, 12
    %96 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    store i32 %95, i32* %96, align 4, !tbaa !38
    %97 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 42
    store i32 %95, i32* %97, align 8, !tbaa !39
    %98 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 1
    %99 = load float, float* %98, align 4, !tbaa !40
    %100 = fpext float %99 to double
    %101 = fadd double %100, 0x3F20000000000000
    %102 = fmul double %101, 4.096000e+03
    %103 = fptosi double %102 to i32
    %104 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 33
    store i32 %103, i32* %104, align 8, !tbaa !41
    br label %.thread16
  
  .thread16:                                        ; preds = %.critedge13, %41, %19
    %rproc.2 = phi i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* [ @image_render_landscape, %.critedge13 ], [ @image_render_simple, %41 ], [ @image_render_simple, %19 ]
    %105 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 0
    %106 = load float, float* %105, align 8, !tbaa !42
    %107 = fpext float %106 to double
    %108 = fadd double %107, 0x3F20000000000000
    %109 = fmul double %108, 4.096000e+03
    %110 = fptosi double %109 to i32
    %111 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 32
    store i32 %110, i32* %111, align 4, !tbaa !43
    %112 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 12
    store i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)* @sample_unpack_copy, i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)** %112, align 8, !tbaa !44
    %113 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 1
    store i8 8, i8* %113, align 1, !tbaa !45
    br label %114
  
  ; <label>:114                                     ; preds = %.thread16, %.critedge, %76, %51, %30, %16, %12, %8, %0
    %.4 = phi i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* [ %rproc.2, %.thread16 ], [ null, %12 ], [ null, %8 ], [ null, %0 ], [ null, %.critedge ], [ null, %76 ], [ null, %16 ], [ null, %51 ], [ null, %30 ]
    ret i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* %.4
  }
  
  declare i32 @gx_default_end_image(%struct.gx_device_s*, i8*, i32 signext) #2
  
  ; Function Attrs: nounwind
  define internal i32 @image_render_simple(%struct.gx_image_enum_s* %penum, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) #1 {
    %1 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 0, i32 21, i32 9
    %2 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** %1, align 4, !tbaa !46
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 32
    %4 = load i32, i32* %3, align 4, !tbaa !43
    %5 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 0, i32 0, i32 0
    %6 = load i32, i32* %5, align 4, !tbaa !6
    %7 = add nsw i32 %6, 2047
    %8 = ashr i32 %7, 12
    %9 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 44
    %10 = load i32, i32* %9, align 4, !tbaa !52
    %11 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 45
    %12 = load i32, i32* %11, align 8, !tbaa !53
    %13 = icmp eq i32 %h, 0
    br i1 %13, label %.loopexit, label %14
  
  ; <label>:14                                      ; preds = %0
    %15 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %16 = load i8*, i8** %15, align 8, !tbaa !35
    %17 = icmp eq i8* %16, null
    br i1 %17, label %18, label %21
  
  ; <label>:18                                      ; preds = %14
    %19 = add i32 %w, 7
    %20 = lshr i32 %19, 3
    br label %121
  
  ; <label>:21                                      ; preds = %14
    %22 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** getelementptr inbounds (%struct.gx_device_memory_s, %struct.gx_device_memory_s* @mem_mono_device, i32 0, i32 21, i32 9), align 4, !tbaa !54
    %23 = icmp eq i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)* %2, %22
    %24 = icmp sgt i32 %4, 0
    %or.cond = and i1 %24, %23
    br i1 %or.cond, label %25, label %113
  
  ; <label>:25                                      ; preds = %21
    %26 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0, i32 0
    %27 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %26, align 8, !tbaa !59
    %28 = icmp eq %struct.gx_device_color_procs_s* %27, @gx_dc_procs_pure
    br i1 %28, label %29, label %113
  
  ; <label>:29                                      ; preds = %25
    %30 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0, i32 0
    %31 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %30, align 8, !tbaa !59
    %32 = icmp eq %struct.gx_device_color_procs_s* %31, @gx_dc_procs_pure
    br i1 %32, label %33, label %113
  
  ; <label>:33                                      ; preds = %29
    %34 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0, i32 1
    %35 = bitcast %union._c* %34 to i32*
    %36 = load i32, i32* %35, align 4, !tbaa !64
    %37 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0, i32 1
    %38 = bitcast %union._c* %37 to i32*
    %39 = load i32, i32* %38, align 4, !tbaa !64
    %40 = xor i32 %39, %36
    %41 = icmp eq i32 %40, 1
    br i1 %41, label %42, label %113
  
  ; <label>:42                                      ; preds = %33
    %43 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 25
    %44 = load i8, i8* %43, align 1, !tbaa !65
    %45 = icmp eq i8 %44, 0
    br i1 %45, label %46, label %113
  
  ; <label>:46                                      ; preds = %42
    %47 = mul i32 %4, %w
    %48 = add i32 %47, 2047
    %49 = add i32 %48, %6
    %50 = lshr i32 %49, 12
    %51 = add nsw i32 %50, -1
    %52 = ashr i32 %7, 15
    %53 = ashr i32 %51, 3
    %54 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 1, i32 7, i32 4
    %55 = bitcast i16* %54 to i8***
    %56 = load i8**, i8*** %55, align 4, !tbaa !66
    %57 = getelementptr inbounds i8*, i8** %56, i32 %10
    %58 = load i8*, i8** %57, align 4, !tbaa !67
    %59 = and i32 %8, 31
    %60 = sub nsw i32 %8, %59
    %61 = add nsw i32 %53, 1
    %62 = ashr i32 %60, 3
    %63 = sub nsw i32 %61, %62
    %64 = sub nsw i32 %50, %8
    %65 = getelementptr inbounds i8, i8* %58, i32 %52
    %66 = load i8, i8* %65, align 1, !tbaa !68
    %67 = zext i8 %66 to i32
    %68 = getelementptr inbounds i8, i8* %58, i32 %53
    %69 = load i8, i8* %68, align 1, !tbaa !68
    %70 = zext i8 %69 to i32
    %71 = getelementptr inbounds i8, i8* %58, i32 %62
    %72 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %73 = load i32, i32* %72, align 8, !tbaa !26
    %74 = icmp eq i32 %36, 0
    %75 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 48, i32 0, i32 0, i32 0, i32 0
    %76 = load i32, i32* %75, align 8, !tbaa !69
    %77 = icmp eq i32 %76, 0
    %78 = xor i1 %74, %77
    %79 = sext i1 %78 to i8
    tail call fastcc void @image_simple_expand(i8* %71, i32 signext %59, i32 signext %63, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %6, i32 signext %73, i8 zeroext %79)
    %80 = and i32 %8, 7
    %81 = icmp eq i32 %80, 0
    br i1 %81, label %91, label %82
  
  ; <label>:82                                      ; preds = %46
    %83 = lshr i32 65280, %80
    %84 = and i32 %67, %83
    %85 = load i8, i8* %65, align 1, !tbaa !68
    %86 = zext i8 %85 to i32
    %87 = xor i32 %83, 255
    %88 = and i32 %86, %87
    %89 = add nuw nsw i32 %88, %84
    %90 = trunc i32 %89 to i8
    store i8 %90, i8* %65, align 1, !tbaa !68
    br label %91
  
  ; <label>:91                                      ; preds = %82, %46
    %92 = and i32 %50, 7
    %93 = icmp eq i32 %92, 0
    br i1 %93, label %103, label %94
  
  ; <label>:94                                      ; preds = %91
    %95 = lshr i32 65280, %92
    %96 = load i8, i8* %68, align 1, !tbaa !68
    %97 = zext i8 %96 to i32
    %98 = and i32 %97, %95
    %99 = xor i32 %95, 255
    %100 = and i32 %70, %99
    %101 = add nuw nsw i32 %98, %100
    %102 = trunc i32 %101 to i8
    store i8 %102, i8* %68, align 1, !tbaa !68
    br label %103
  
  ; <label>:103                                     ; preds = %94, %91
    %104 = icmp slt i32 %12, 2
    br i1 %104, label %.loopexit, label %.lr.ph20.preheader
  
  .lr.ph20.preheader:                               ; preds = %103
    %105 = icmp slt i32 %4, 0
    %106 = select i1 %105, i32 %64, i32 0
    %. = sub nsw i32 %8, %106
    br label %.lr.ph20
  
  ; <label>:107                                     ; preds = %.lr.ph20
    %108 = icmp slt i32 %112, %12
    br i1 %108, label %.lr.ph20, label %.loopexit
  
  .lr.ph20:                                         ; preds = %107, %.lr.ph20.preheader
    %dy.018 = phi i32 [ %112, %107 ], [ 1, %.lr.ph20.preheader ]
    %109 = add i32 %10, %dy.018
    %110 = tail call i32 %2(%struct.gx_device_s* %dev, i8* %71, i32 signext %59, i32 signext %63, i32 signext 0, i32 signext %., i32 signext %109, i32 signext %64, i32 signext 1, i32 signext 0, i32 signext 1) #4
    %111 = icmp slt i32 %110, 0
    %112 = add nuw nsw i32 %dy.018, 1
    br i1 %111, label %.loopexit, label %107
  
  ; <label>:113                                     ; preds = %42, %33, %29, %25, %21
    %114 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    %115 = load i32, i32* %114, align 4, !tbaa !30
    %116 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %117 = load i32, i32* %116, align 8, !tbaa !29
    %118 = and i32 %8, 31
    %119 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %120 = load i32, i32* %119, align 8, !tbaa !26
    tail call fastcc void @image_simple_expand(i8* nonnull %16, i32 signext %118, i32 signext %115, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %6, i32 signext %120, i8 zeroext 0)
    br label %121
  
  ; <label>:121                                     ; preds = %113, %18
    %line_x.0 = phi i32 [ 0, %18 ], [ %118, %113 ]
    %line_size.0 = phi i32 [ %20, %18 ], [ %115, %113 ]
    %line_width.0 = phi i32 [ %w, %18 ], [ %117, %113 ]
    %line.0 = phi i8* [ %buffer, %18 ], [ %16, %113 ]
    %122 = icmp slt i32 %4, 0
    %123 = select i1 %122, i32 %line_width.0, i32 0
    %.9 = sub i32 %8, %123
    %124 = icmp sgt i32 %12, 0
    br i1 %124, label %.lr.ph, label %.loopexit
  
  ; <label>:125                                     ; preds = %.lr.ph
    %126 = icmp slt i32 %130, %12
    br i1 %126, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %121, %125
    %dy.114 = phi i32 [ %130, %125 ], [ 0, %121 ]
    %127 = add i32 %10, %dy.114
    %128 = tail call fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %line.0, i32 signext %line_x.0, i32 signext %line_size.0, i32 signext %.9, i32 signext %127, i32 signext %line_width.0, i32 signext 1, %struct.gx_device_s* %dev)
    %129 = icmp slt i32 %128, 0
    %130 = add nuw nsw i32 %dy.114, 1
    br i1 %129, label %.loopexit, label %125
  
  .loopexit:                                        ; preds = %107, %.lr.ph20, %125, %.lr.ph, %121, %103, %0
    %.5 = phi i32 [ 0, %0 ], [ 1, %103 ], [ 1, %121 ], [ 1, %125 ], [ %128, %.lr.ph ], [ 0, %107 ], [ %110, %.lr.ph20 ]
    ret i32 %.5
  }
  
  ; Function Attrs: nounwind
  define internal i32 @image_render_landscape(%struct.gx_image_enum_s* %penum, i8* readonly %buffer, i32 signext %data_x, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %2 = load i8*, i8** %1, align 8, !tbaa !35
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %4 = load i32, i32* %3, align 8, !tbaa !29
    %5 = add i32 %4, 31
    %6 = lshr i32 %5, 5
    %7 = shl nuw nsw i32 %6, 2
    %8 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 46
    %9 = load i32, i32* %8, align 4, !tbaa !70
    %10 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 47
    %11 = load i32, i32* %10, align 8, !tbaa !71
    %12 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 33
    %13 = load i32, i32* %12, align 8, !tbaa !41
    %.lobit = lshr i32 %13, 31
    %14 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 2
    %15 = load float, float* %14, align 8, !tbaa !72
    %16 = fcmp olt float %15, 0.000000e+00
    %17 = sub nsw i32 0, %11
    %xinc.0 = select i1 %16, i32 -1, i32 1
    %iw.0 = select i1 %16, i32 %17, i32 %11
    %18 = select i1 %16, i32 %11, i32 0
    %ix.0 = add nsw i32 %18, %9
    %19 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 42
    %20 = load i32, i32* %19, align 8, !tbaa !39
    %21 = icmp eq i32 %ix.0, %20
    br i1 %21, label %33, label %22
  
  ; <label>:22                                      ; preds = %0
    %23 = fcmp olt float %15, 0.000000e+00
    %24 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    %25 = load i32, i32* %24, align 4, !tbaa !38
    br i1 %23, label %28, label %26
  
  ; <label>:26                                      ; preds = %22
    %27 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %25, i32 signext %20, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %30
  
  ; <label>:28                                      ; preds = %22
    %29 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %20, i32 signext %25, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %30
  
  ; <label>:30                                      ; preds = %28, %26
    %31 = phi i32 [ %27, %26 ], [ %29, %28 ]
    %32 = icmp slt i32 %31, 0
    br i1 %32, label %.loopexit, label %.critedge
  
  .critedge:                                        ; preds = %30
    %sunkaddr = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr1 = add i32 %sunkaddr, 276
    %sunkaddr2 = inttoptr i32 %sunkaddr1 to i32*
    store i32 %ix.0, i32* %sunkaddr2, align 4, !tbaa !38
    br label %33
  
  ; <label>:33                                      ; preds = %.critedge, %0
    %34 = icmp eq i32 %h, 0
    br i1 %34, label %65, label %.preheader
  
  .preheader:                                       ; preds = %33
    %35 = icmp eq i32 %iw.0, 0
    br i1 %35, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader
    %36 = fcmp olt float %15, 0.000000e+00
    %37 = sext i1 %36 to i32
    %38 = sub i32 0, %iw.0
    br label %39
  
  ; <label>:39                                      ; preds = %63, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %63 ], [ %38, %.lr.ph ]
    %ix.116 = phi i32 [ %ix.0, %.lr.ph ], [ %ix.3, %63 ]
    %orig_row.014 = phi i8* [ null, %.lr.ph ], [ %orig_row.4, %63 ]
    %.ix.1 = add nsw i32 %ix.116, %37
    %40 = and i32 %.ix.1, 7
    %41 = mul nuw i32 %40, %7
    %42 = getelementptr inbounds i8, i8* %2, i32 %41
    %43 = icmp eq i8* %orig_row.014, null
    br i1 %43, label %44, label %47
  
  ; <label>:44                                      ; preds = %39
    %sunkaddr3 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr4 = add i32 %sunkaddr3, 256
    %sunkaddr5 = inttoptr i32 %sunkaddr4 to i32*
    %45 = load i32, i32* %sunkaddr5, align 4, !tbaa !21
    %sunkaddr6 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr7 = add i32 %sunkaddr6, 52
    %sunkaddr8 = inttoptr i32 %sunkaddr7 to i32*
    %46 = load i32, i32* %sunkaddr8, align 4, !tbaa !37
    tail call fastcc void @image_simple_expand(i8* %42, i32 signext 0, i32 signext %7, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %45, i32 signext %46, i8 zeroext 0)
    br label %48
  
  ; <label>:47                                      ; preds = %39
    tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %42, i8* nonnull %orig_row.014, i32 %7, i32 1, i1 false)
    br label %48
  
  ; <label>:48                                      ; preds = %47, %44
    %orig_row.1 = phi i8* [ %42, %44 ], [ %orig_row.014, %47 ]
    %49 = fcmp olt float %15, 0.000000e+00
    br i1 %49, label %57, label %50
  
  ; <label>:50                                      ; preds = %48
    %51 = add nsw i32 %.ix.1, 1
    %52 = icmp eq i32 %40, 7
    br i1 %52, label %53, label %63
  
  ; <label>:53                                      ; preds = %50
    %sunkaddr9 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr10 = add i32 %sunkaddr9, 276
    %sunkaddr11 = inttoptr i32 %sunkaddr10 to i32*
    %54 = load i32, i32* %sunkaddr11, align 4, !tbaa !38
    %55 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %54, i32 signext %51, i32 signext %.lobit, %struct.gx_device_s* %dev)
    %56 = icmp slt i32 %55, 0
    br i1 %56, label %.loopexit, label %.thread
  
  .thread:                                          ; preds = %53
    %sunkaddr12 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr13 = add i32 %sunkaddr12, 276
    %sunkaddr14 = inttoptr i32 %sunkaddr13 to i32*
    store i32 %51, i32* %sunkaddr14, align 4, !tbaa !38
    br label %63
  
  ; <label>:57                                      ; preds = %48
    %58 = icmp eq i32 %40, 0
    br i1 %58, label %59, label %63
  
  ; <label>:59                                      ; preds = %57
    %sunkaddr15 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr16 = add i32 %sunkaddr15, 276
    %sunkaddr17 = inttoptr i32 %sunkaddr16 to i32*
    %60 = load i32, i32* %sunkaddr17, align 4, !tbaa !38
    %61 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %.ix.1, i32 signext %60, i32 signext %.lobit, %struct.gx_device_s* %dev)
    %62 = icmp slt i32 %61, 0
    br i1 %62, label %.loopexit, label %.thread10
  
  .thread10:                                        ; preds = %59
    %sunkaddr18 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr19 = add i32 %sunkaddr18, 276
    %sunkaddr20 = inttoptr i32 %sunkaddr19 to i32*
    store i32 %.ix.1, i32* %sunkaddr20, align 4, !tbaa !38
    br label %63
  
  ; <label>:63                                      ; preds = %.thread10, %57, %.thread, %50
    %orig_row.4 = phi i8* [ %orig_row.1, %50 ], [ %orig_row.1, %57 ], [ null, %.thread ], [ null, %.thread10 ]
    %ix.3 = phi i32 [ %51, %50 ], [ %.ix.1, %57 ], [ %51, %.thread ], [ %.ix.1, %.thread10 ]
    %lsr.iv.next = add i32 %lsr.iv, %xinc.0
    %64 = icmp eq i32 %lsr.iv.next, 0
    br i1 %64, label %._crit_edge, label %39
  
  ._crit_edge:                                      ; preds = %63, %.preheader
    %ix.1.lcssa = phi i32 [ %ix.0, %.preheader ], [ %ix.3, %63 ]
    %sunkaddr21 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr22 = add i32 %sunkaddr21, 280
    %sunkaddr23 = inttoptr i32 %sunkaddr22 to i32*
    store i32 %ix.1.lcssa, i32* %sunkaddr23, align 8, !tbaa !39
    br label %.loopexit
  
  ; <label>:65                                      ; preds = %33
    %66 = fcmp olt float %15, 0.000000e+00
    %67 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    %68 = load i32, i32* %67, align 4, !tbaa !38
    br i1 %66, label %71, label %69
  
  ; <label>:69                                      ; preds = %65
    %70 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %68, i32 signext %ix.0, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %.loopexit
  
  ; <label>:71                                      ; preds = %65
    %72 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %ix.0, i32 signext %68, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %53, %59, %71, %69, %._crit_edge, %30
    %.6 = phi i32 [ 0, %._crit_edge ], [ %31, %30 ], [ %70, %69 ], [ %72, %71 ], [ %61, %59 ], [ %55, %53 ]
    ret i32 %.6
  }
  
  declare i8* @sample_unpack_copy(i8*, i32*, i8*, i32 signext, i32 signext, %union.sample_lookup_s*, i32 signext) #2
  
  ; Function Attrs: norecurse nounwind
  define internal fastcc void @image_simple_expand(i8* nocapture %line, i32 signext %line_x, i32 signext %raster, i8* readonly %buffer, i32 signext %data_x, i32 signext %w, i32 signext %xcur, i32 signext %x_extent, i8 zeroext %zero) unnamed_addr #0 {
    %1 = and i32 %data_x, 7
    %2 = lshr i32 128, %1
    %3 = lshr i32 255, %1
    %4 = add i32 %1, %w
    %5 = ashr i32 %data_x, 3
    %6 = getelementptr inbounds i8, i8* %buffer, i32 %5
    %7 = lshr i32 %4, 3
    %8 = getelementptr inbounds i8, i8* %6, i32 %7
    %9 = zext i8 %zero to i32
    %10 = xor i32 %9, 255
    %11 = icmp eq i32 %w, 0
    br i1 %11, label %.thread, label %12
  
  ; <label>:12                                      ; preds = %0
    %fold = add i32 %w, %data_x
    %13 = and i32 %fold, 7
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %15, label %17
  
  ; <label>:15                                      ; preds = %12
    %16 = getelementptr inbounds i8, i8* %8, i32 -1
    br label %21
  
  ; <label>:17                                      ; preds = %12
    %18 = xor i32 %13, 7
    %19 = shl i32 2, %18
    %20 = trunc i32 %19 to i8
    br label %21
  
  ; <label>:21                                      ; preds = %17, %15
    %stop.0 = phi i8* [ %16, %15 ], [ %8, %17 ]
    %stopbit.0 = phi i8 [ 1, %15 ], [ %20, %17 ]
    %22 = zext i8 %stopbit.0 to i32
    %23 = sub nsw i32 0, %22
    %24 = shl nsw i32 %23, 1
    %25 = load i8, i8* %stop.0, align 1, !tbaa !68
    %26 = icmp eq i8* %stop.0, %6
    %27 = select i1 %26, i32 %3, i32 -1
    %. = and i32 %24, %27
    %28 = zext i8 %25 to i32
    %29 = and i8 %25, %stopbit.0
    %30 = icmp eq i8 %29, 0
    br i1 %30, label %64, label %31
  
  ; <label>:31                                      ; preds = %21
    %32 = xor i32 %28, 254
    %33 = and i32 %32, %.
    %34 = icmp eq i32 %33, 0
    br i1 %34, label %.preheader16, label %35
  
  ; <label>:35                                      ; preds = %31
    %36 = add nuw nsw i32 %22, 255
    %37 = or i32 %28, %36
    %38 = trunc i32 %37 to i8
    br label %62
  
  .preheader16:                                     ; preds = %31, %40
    %stop.1 = phi i8* [ %41, %40 ], [ %stop.0, %31 ]
    %39 = icmp ugt i8* %stop.1, %6
    br i1 %39, label %40, label %.critedge
  
  ; <label>:40                                      ; preds = %.preheader16
    %41 = getelementptr inbounds i8, i8* %stop.1, i32 -1
    %scevgep11 = getelementptr i8, i8* %stop.1, i32 -1
    %42 = load i8, i8* %scevgep11, align 1, !tbaa !68
    %43 = icmp eq i8 %42, -1
    br i1 %43, label %.preheader16, label %.critedge
  
  .critedge:                                        ; preds = %.preheader16, %40
    %44 = icmp eq i8* %stop.1, %6
    br i1 %44, label %54, label %45
  
  ; <label>:45                                      ; preds = %.critedge
    %46 = getelementptr inbounds i8, i8* %6, i32 1
    %47 = icmp eq i8* %stop.1, %46
    br i1 %47, label %48, label %59
  
  ; <label>:48                                      ; preds = %45
    %49 = load i8, i8* %6, align 1, !tbaa !68
    %50 = zext i8 %49 to i32
    %51 = xor i32 %50, -1
    %52 = and i32 %3, %51
    %53 = icmp eq i32 %52, 0
    br i1 %53, label %54, label %59
  
  ; <label>:54                                      ; preds = %48, %.critedge
    %55 = trunc i32 %10 to i8
    %56 = ashr i32 %line_x, 3
    %57 = getelementptr inbounds i8, i8* %line, i32 %56
    %58 = sub i32 %raster, %56
    tail call void @llvm.memset.p0i8.i32(i8* %57, i8 %55, i32 %58, i32 1, i1 false)
    br label %.thread
  
  ; <label>:59                                      ; preds = %48, %45
    %60 = getelementptr inbounds i8, i8* %stop.1, i32 -1
    %61 = load i8, i8* %60, align 1, !tbaa !68
    br label %62
  
  ; <label>:62                                      ; preds = %59, %35
    %stop.2 = phi i8* [ %stop.0, %35 ], [ %60, %59 ]
    %last.0 = phi i8 [ %38, %35 ], [ %61, %59 ]
    %63 = zext i8 %last.0 to i32
    br label %94
  
  ; <label>:64                                      ; preds = %21
    %stopmask.0 = trunc i32 %. to i8
    %65 = and i8 %stopmask.0, %25
    %66 = icmp eq i8 %65, 0
    br i1 %66, label %.preheader15, label %67
  
  ; <label>:67                                      ; preds = %64
    %68 = and i32 %28, %23
    %69 = trunc i32 %68 to i8
    br label %91
  
  .preheader15:                                     ; preds = %64, %71
    %stop.3 = phi i8* [ %72, %71 ], [ %stop.0, %64 ]
    %70 = icmp ugt i8* %stop.3, %6
    br i1 %70, label %71, label %.critedge3
  
  ; <label>:71                                      ; preds = %.preheader15
    %72 = getelementptr inbounds i8, i8* %stop.3, i32 -1
    %scevgep10 = getelementptr i8, i8* %stop.3, i32 -1
    %73 = load i8, i8* %scevgep10, align 1, !tbaa !68
    %74 = icmp eq i8 %73, 0
    br i1 %74, label %.preheader15, label %.critedge3
  
  .critedge3:                                       ; preds = %.preheader15, %71
    %75 = icmp eq i8* %stop.3, %6
    br i1 %75, label %84, label %76
  
  ; <label>:76                                      ; preds = %.critedge3
    %77 = getelementptr inbounds i8, i8* %6, i32 1
    %78 = icmp eq i8* %stop.3, %77
    br i1 %78, label %79, label %88
  
  ; <label>:79                                      ; preds = %76
    %80 = load i8, i8* %6, align 1, !tbaa !68
    %81 = zext i8 %80 to i32
    %82 = and i32 %81, %3
    %83 = icmp eq i32 %82, 0
    br i1 %83, label %84, label %88
  
  ; <label>:84                                      ; preds = %79, %.critedge3
    %85 = ashr i32 %line_x, 3
    %86 = getelementptr inbounds i8, i8* %line, i32 %85
    %87 = sub i32 %raster, %85
    tail call void @llvm.memset.p0i8.i32(i8* %86, i8 %zero, i32 %87, i32 1, i1 false)
    br label %.thread
  
  ; <label>:88                                      ; preds = %79, %76
    %89 = getelementptr inbounds i8, i8* %stop.3, i32 -1
    %90 = load i8, i8* %89, align 1, !tbaa !68
    br label %91
  
  ; <label>:91                                      ; preds = %88, %67
    %stop.4 = phi i8* [ %stop.0, %67 ], [ %89, %88 ]
    %last.1 = phi i8 [ %69, %67 ], [ %90, %88 ]
    %92 = zext i8 %last.1 to i32
    %93 = xor i32 %92, 255
    br label %94
  
  ; <label>:94                                      ; preds = %91, %62
    %.pn87 = phi i32 [ %63, %62 ], [ %93, %91 ]
    %stop.5 = phi i8* [ %stop.2, %62 ], [ %stop.4, %91 ]
    %.sink8.in = getelementptr inbounds [256 x i8], [256 x i8]* @byte_reverse_bits, i32 0, i32 %.pn87
    %.sink8 = load i8, i8* %.sink8.in, align 1, !tbaa !68
    %95 = zext i8 %.sink8 to i32
    %.sink.in = getelementptr inbounds [256 x i8], [256 x i8]* @byte_bit_run_length_0, i32 0, i32 %95
    %.sink = load i8, i8* %.sink.in, align 1, !tbaa !68
    %96 = zext i8 %.sink to i32
    %stopx.0 = add nsw i32 %96, -1
    %97 = icmp eq i8 %.sink, 0
    %98 = getelementptr inbounds i8, i8* %stop.5, i32 1
    %.stop.5 = select i1 %97, i8* %98, i8* %stop.5
    %stopx.0.op = shl i32 1, %stopx.0
    %99 = trunc i32 %stopx.0.op to i8
    %100 = select i1 %97, i8 -128, i8 %99
    %101 = ashr i32 %line_x, 3
    %102 = getelementptr inbounds i8, i8* %line, i32 %101
    %103 = sub i32 %raster, %101
    tail call void @llvm.memset.p0i8.i32(i8* %102, i8 %zero, i32 %103, i32 1, i1 false)
    %104 = icmp sgt i32 %x_extent, -1
    %105 = add i32 %xcur, 2047
    br i1 %104, label %120, label %106
  
  ; <label>:106                                     ; preds = %94
    %107 = add i32 %105, %x_extent
    %108 = and i32 %107, 4095
    %109 = sub nsw i32 %108, %x_extent
    %110 = shl i32 %line_x, 12
    %111 = add nsw i32 %109, %110
    %112 = sub nsw i32 0, %x_extent
    %113 = udiv i32 %112, %w
    %114 = sub i32 0, %113
    %115 = urem i32 %112, %w
    %116 = icmp eq i32 %115, 0
    br i1 %116, label %126, label %117
  
  ; <label>:117                                     ; preds = %106
    %118 = xor i32 %113, -1
    %119 = sub i32 %w, %115
    br label %126
  
  ; <label>:120                                     ; preds = %94
    %121 = and i32 %105, 4095
    %122 = shl i32 %line_x, 12
    %123 = or i32 %121, %122
    %124 = udiv i32 %x_extent, %w
    %125 = urem i32 %x_extent, %w
    br label %126
  
  ; <label>:126                                     ; preds = %120, %117, %106
    %127 = phi i32 [ %111, %117 ], [ %111, %106 ], [ %123, %120 ]
    %xl.sroa.82.0 = phi i32 [ %118, %117 ], [ %114, %106 ], [ %124, %120 ]
    %xl.sroa.98.0 = phi i32 [ %119, %117 ], [ 0, %106 ], [ %125, %120 ]
    %128 = trunc i32 %2 to i8
    %129 = sub i32 %w, %xl.sroa.98.0
    %130 = icmp ult i32 %xl.sroa.98.0, %129
    %131 = shl i32 %xl.sroa.98.0, 1
    %132 = sub i32 %xl.sroa.98.0, %129
    %133 = add nsw i32 %xl.sroa.82.0, 1
    %dxx4.sroa.16.0 = select i1 %130, i32 %131, i32 %132
    %134 = select i1 %130, i32 %xl.sroa.82.0, i32 %133
    %135 = add nsw i32 %134, %xl.sroa.82.0
    %136 = icmp ult i32 %dxx4.sroa.16.0, %129
    %137 = shl i32 %dxx4.sroa.16.0, 1
    %138 = sub i32 %dxx4.sroa.16.0, %129
    %dxx4.sroa.16.1 = select i1 %136, i32 %137, i32 %138
    %139 = zext i1 %136 to i32
    %factor = shl i32 %135, 1
    %140 = or i32 %139, %factor
    %141 = xor i32 %140, 1
    %142 = icmp ult i32 %dxx4.sroa.16.1, %129
    %143 = shl i32 %dxx4.sroa.16.1, 1
    %144 = sub i32 %dxx4.sroa.16.1, %129
    %145 = add nsw i32 %141, 1
    %dxx8.sroa.16.0 = select i1 %142, i32 %143, i32 %144
    %146 = select i1 %142, i32 %141, i32 %145
    %147 = add nsw i32 %146, %141
    %148 = icmp ult i32 %dxx8.sroa.16.0, %129
    %149 = shl i32 %dxx8.sroa.16.0, 1
    %150 = sub i32 %dxx8.sroa.16.0, %129
    %151 = add nsw i32 %147, 1
    %dxx16.sroa.8.0 = select i1 %148, i32 %149, i32 %150
    %152 = select i1 %148, i32 %147, i32 %151
    %153 = add nsw i32 %152, %147
    %154 = icmp ult i32 %dxx16.sroa.8.0, %129
    %155 = sub i32 0, %129
    %dxx24.sroa.8.0.p = select i1 %154, i32 %dxx8.sroa.16.0, i32 %155
    %dxx24.sroa.8.0 = add i32 %dxx24.sroa.8.0.p, %dxx16.sroa.8.0
    %156 = select i1 %154, i32 %147, i32 %151
    %157 = add nsw i32 %153, %156
    %158 = icmp ult i32 %dxx24.sroa.8.0, %129
    %dxx32.sroa.7.0.p = select i1 %158, i32 %dxx8.sroa.16.0, i32 %155
    %dxx32.sroa.7.0 = add i32 %dxx32.sroa.7.0.p, %dxx24.sroa.8.0
    %159 = select i1 %158, i32 %147, i32 %151
    %160 = add nsw i32 %157, %159
    %161 = load i8, i8* %6, align 1, !tbaa !68
    %162 = add nsw i32 %127, %x_extent
    %163 = sub i32 0, %xl.sroa.98.0
    %164 = sub i32 0, %dxx4.sroa.16.1
    %165 = sub i32 0, %dxx8.sroa.16.0
    %166 = sub i32 0, %dxx32.sroa.7.0
    %167 = sub i32 0, %dxx24.sroa.8.0
    %168 = sub i32 0, %dxx16.sroa.8.0
    %scevgep = getelementptr i8, i8* %line, i32 2
    %scevgep128 = getelementptr i8, i8* %line, i32 1
    br label %.critedge5
  
  .critedge5:                                       ; preds = %334, %126
    %psrc.0 = phi i8* [ %6, %126 ], [ %psrc.6, %334 ]
    %xl.sroa.0.0 = phi i32 [ %127, %126 ], [ %xl.sroa.0.11, %334 ]
    %xl.sroa.27.0 = phi i32 [ %w, %126 ], [ %xl.sroa.27.22, %334 ]
    %data.0 = phi i8 [ %161, %126 ], [ %data.4, %334 ]
    %sbit.0 = phi i8 [ %128, %126 ], [ %sbit.8, %334 ]
    %169 = zext i8 %data.0 to i32
    %170 = xor i32 %169, 255
    %171 = zext i8 %sbit.0 to i32
    %172 = and i32 %171, %170
    %173 = icmp eq i32 %172, 0
    br i1 %173, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.critedge5, %.lr.ph
    %sbit.149 = phi i8 [ %177, %.lr.ph ], [ %sbit.0, %.critedge5 ]
    %xl.sroa.27.148 = phi i32 [ %xl.sroa.27.2, %.lr.ph ], [ %xl.sroa.27.0, %.critedge5 ]
    %xl.sroa.0.147 = phi i32 [ %176, %.lr.ph ], [ %xl.sroa.0.0, %.critedge5 ]
    %174 = icmp ult i32 %xl.sroa.27.148, %xl.sroa.98.0
    %xl.sroa.27.2.p = select i1 %174, i32 %129, i32 %163
    %xl.sroa.27.2 = add i32 %xl.sroa.27.2.p, %xl.sroa.27.148
    %175 = select i1 %174, i32 %133, i32 %xl.sroa.82.0
    %176 = add nsw i32 %175, %xl.sroa.0.147
    %177 = lshr i8 %sbit.149, 1
    %178 = zext i8 %177 to i32
    %179 = and i32 %178, %170
    %180 = icmp eq i32 %179, 0
    br i1 %180, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.critedge5
    %sbit.1.lcssa = phi i8 [ %sbit.0, %.critedge5 ], [ %177, %.lr.ph ]
    %xl.sroa.27.1.lcssa = phi i32 [ %xl.sroa.27.0, %.critedge5 ], [ %xl.sroa.27.2, %.lr.ph ]
    %xl.sroa.0.1.lcssa = phi i32 [ %xl.sroa.0.0, %.critedge5 ], [ %176, %.lr.ph ]
    %181 = icmp eq i8 %sbit.1.lcssa, 0
    br i1 %181, label %.preheader13, label %.loopexit12
  
  .preheader13:                                     ; preds = %._crit_edge
    %182 = getelementptr inbounds i8, i8* %psrc.0, i32 1
    %183 = load i8, i8* %182, align 1, !tbaa !68
    %184 = icmp eq i8 %183, 0
    br i1 %184, label %.lr.ph55.preheader, label %.loopexit14
  
  .lr.ph55.preheader:                               ; preds = %.preheader13
    %scevgep1 = getelementptr i8, i8* %psrc.0, i32 2
    br label %.lr.ph55
  
  .lr.ph55:                                         ; preds = %207, %.lr.ph55.preheader
    %lsr.iv = phi i8* [ %scevgep2, %207 ], [ %scevgep1, %.lr.ph55.preheader ]
    %xl.sroa.27.354 = phi i32 [ %xl.sroa.27.7, %207 ], [ %xl.sroa.27.1.lcssa, %.lr.ph55.preheader ]
    %xl.sroa.0.253 = phi i32 [ %211, %207 ], [ %xl.sroa.0.1.lcssa, %.lr.ph55.preheader ]
    %185 = load i8, i8* %lsr.iv, align 1, !tbaa !68
    %186 = icmp eq i8 %185, 0
    br i1 %186, label %191, label %187
  
  ; <label>:187                                     ; preds = %.lr.ph55
    %188 = icmp ult i32 %xl.sroa.27.354, %dxx8.sroa.16.0
    %xl.sroa.27.4.p = select i1 %188, i32 %129, i32 %165
    %xl.sroa.27.4 = add i32 %xl.sroa.27.4.p, %xl.sroa.27.354
    %189 = select i1 %188, i32 %151, i32 %147
    %190 = add nsw i32 %189, %xl.sroa.0.253
    br label %.loopexit14
  
  ; <label>:191                                     ; preds = %.lr.ph55
    %scevgep8 = getelementptr i8, i8* %lsr.iv, i32 1
    %192 = load i8, i8* %scevgep8, align 1, !tbaa !68
    %193 = icmp eq i8 %192, 0
    %scevgep7 = getelementptr i8, i8* %lsr.iv, i32 1
    br i1 %193, label %199, label %194
  
  ; <label>:194                                     ; preds = %191
    %195 = icmp ult i32 %xl.sroa.27.354, %dxx16.sroa.8.0
    %xl.sroa.27.5.p = select i1 %195, i32 %129, i32 %168
    %xl.sroa.27.5 = add i32 %xl.sroa.27.5.p, %xl.sroa.27.354
    %196 = zext i1 %195 to i32
    %197 = add i32 %xl.sroa.0.253, %153
    %198 = add i32 %197, %196
    br label %.loopexit14
  
  ; <label>:199                                     ; preds = %191
    %scevgep6 = getelementptr i8, i8* %lsr.iv, i32 2
    %200 = load i8, i8* %scevgep6, align 1, !tbaa !68
    %201 = icmp eq i8 %200, 0
    %scevgep5 = getelementptr i8, i8* %lsr.iv, i32 2
    br i1 %201, label %207, label %202
  
  ; <label>:202                                     ; preds = %199
    %203 = icmp ult i32 %xl.sroa.27.354, %dxx24.sroa.8.0
    %xl.sroa.27.6.p = select i1 %203, i32 %129, i32 %167
    %xl.sroa.27.6 = add i32 %xl.sroa.27.6.p, %xl.sroa.27.354
    %204 = zext i1 %203 to i32
    %205 = add i32 %xl.sroa.0.253, %157
    %206 = add i32 %205, %204
    br label %.loopexit14
  
  ; <label>:207                                     ; preds = %199
    %208 = icmp ult i32 %xl.sroa.27.354, %dxx32.sroa.7.0
    %xl.sroa.27.7.p = select i1 %208, i32 %129, i32 %166
    %xl.sroa.27.7 = add i32 %xl.sroa.27.7.p, %xl.sroa.27.354
    %209 = zext i1 %208 to i32
    %210 = add i32 %160, %xl.sroa.0.253
    %211 = add i32 %210, %209
    %scevgep4 = getelementptr i8, i8* %lsr.iv, i32 3
    %212 = load i8, i8* %scevgep4, align 1, !tbaa !68
    %213 = icmp eq i8 %212, 0
    %scevgep2 = getelementptr i8, i8* %lsr.iv, i32 4
    %scevgep3 = getelementptr i8, i8* %scevgep2, i32 -1
    br i1 %213, label %.lr.ph55, label %.loopexit14
  
  .loopexit14:                                      ; preds = %207, %202, %194, %187, %.preheader13
    %psrc.2 = phi i8* [ %lsr.iv, %187 ], [ %scevgep7, %194 ], [ %scevgep5, %202 ], [ %182, %.preheader13 ], [ %scevgep3, %207 ]
    %xl.sroa.0.3 = phi i32 [ %190, %187 ], [ %198, %194 ], [ %206, %202 ], [ %xl.sroa.0.1.lcssa, %.preheader13 ], [ %211, %207 ]
    %xl.sroa.27.8 = phi i32 [ %xl.sroa.27.4, %187 ], [ %xl.sroa.27.5, %194 ], [ %xl.sroa.27.6, %202 ], [ %xl.sroa.27.1.lcssa, %.preheader13 ], [ %xl.sroa.27.7, %207 ]
    %data.1 = phi i8 [ %185, %187 ], [ %192, %194 ], [ %200, %202 ], [ %183, %.preheader13 ], [ %212, %207 ]
    %214 = zext i8 %data.1 to i32
    %215 = icmp ugt i8 %data.1, 15
    br i1 %215, label %220, label %216
  
  ; <label>:216                                     ; preds = %.loopexit14
    %217 = icmp ult i32 %xl.sroa.27.8, %dxx4.sroa.16.1
    %xl.sroa.27.9.p = select i1 %217, i32 %129, i32 %164
    %xl.sroa.27.9 = add i32 %xl.sroa.27.9.p, %xl.sroa.27.8
    %218 = select i1 %217, i32 %145, i32 %141
    %219 = add nsw i32 %218, %xl.sroa.0.3
    br label %220
  
  ; <label>:220                                     ; preds = %216, %.loopexit14
    %xl.sroa.0.4 = phi i32 [ %219, %216 ], [ %xl.sroa.0.3, %.loopexit14 ]
    %xl.sroa.27.10 = phi i32 [ %xl.sroa.27.9, %216 ], [ %xl.sroa.27.8, %.loopexit14 ]
    %sbit.2 = phi i8 [ 8, %216 ], [ -128, %.loopexit14 ]
    %221 = xor i32 %214, 255
    %222 = zext i8 %sbit.2 to i32
    %223 = and i32 %222, %221
    %224 = icmp eq i32 %223, 0
    br i1 %224, label %.loopexit12, label %.lr.ph64
  
  .lr.ph64:                                         ; preds = %220, %.lr.ph64
    %sbit.362 = phi i8 [ %228, %.lr.ph64 ], [ %sbit.2, %220 ]
    %xl.sroa.27.1161 = phi i32 [ %xl.sroa.27.12, %.lr.ph64 ], [ %xl.sroa.27.10, %220 ]
    %xl.sroa.0.560 = phi i32 [ %227, %.lr.ph64 ], [ %xl.sroa.0.4, %220 ]
    %225 = icmp ult i32 %xl.sroa.27.1161, %xl.sroa.98.0
    %xl.sroa.27.12.p = select i1 %225, i32 %129, i32 %163
    %xl.sroa.27.12 = add i32 %xl.sroa.27.12.p, %xl.sroa.27.1161
    %226 = select i1 %225, i32 %133, i32 %xl.sroa.82.0
    %227 = add nsw i32 %226, %xl.sroa.0.560
    %228 = lshr i8 %sbit.362, 1
    %229 = zext i8 %228 to i32
    %230 = and i32 %229, %221
    %231 = icmp eq i32 %230, 0
    br i1 %231, label %.loopexit12, label %.lr.ph64
  
  .loopexit12:                                      ; preds = %.lr.ph64, %220, %._crit_edge
    %psrc.3 = phi i8* [ %psrc.0, %._crit_edge ], [ %psrc.2, %220 ], [ %psrc.2, %.lr.ph64 ]
    %xl.sroa.0.6 = phi i32 [ %xl.sroa.0.1.lcssa, %._crit_edge ], [ %xl.sroa.0.4, %220 ], [ %227, %.lr.ph64 ]
    %xl.sroa.27.13 = phi i32 [ %xl.sroa.27.1.lcssa, %._crit_edge ], [ %xl.sroa.27.10, %220 ], [ %xl.sroa.27.12, %.lr.ph64 ]
    %data.2.in = phi i32 [ %170, %._crit_edge ], [ %221, %220 ], [ %221, %.lr.ph64 ]
    %sbit.4 = phi i8 [ %sbit.1.lcssa, %._crit_edge ], [ %sbit.2, %220 ], [ %228, %.lr.ph64 ]
    %232 = ashr i32 %xl.sroa.0.6, 12
    %233 = icmp uge i8* %psrc.3, %.stop.5
    %234 = icmp eq i8 %sbit.4, %100
    %or.cond = and i1 %233, %234
    br i1 %or.cond, label %235, label %236
  
  ; <label>:235                                     ; preds = %.loopexit12
    %data.2 = trunc i32 %data.2.in to i8
    br label %.loopexit10
  
  ; <label>:236                                     ; preds = %.loopexit12
    %237 = xor i32 %data.2.in, 255
    br label %238
  
  ; <label>:238                                     ; preds = %238, %236
    %xl.sroa.0.7 = phi i32 [ %xl.sroa.0.6, %236 ], [ %241, %238 ]
    %xl.sroa.27.14 = phi i32 [ %xl.sroa.27.13, %236 ], [ %xl.sroa.27.15, %238 ]
    %sbit.5 = phi i8 [ %sbit.4, %236 ], [ %242, %238 ]
    %239 = icmp ult i32 %xl.sroa.27.14, %xl.sroa.98.0
    %xl.sroa.27.15.p = select i1 %239, i32 %129, i32 %163
    %xl.sroa.27.15 = add i32 %xl.sroa.27.15.p, %xl.sroa.27.14
    %240 = select i1 %239, i32 %133, i32 %xl.sroa.82.0
    %241 = add nsw i32 %240, %xl.sroa.0.7
    %242 = lshr i8 %sbit.5, 1
    %243 = zext i8 %242 to i32
    %244 = and i32 %243, %237
    %245 = icmp eq i32 %244, 0
    br i1 %245, label %246, label %238
  
  ; <label>:246                                     ; preds = %238
    %247 = trunc i32 %237 to i8
    %248 = icmp eq i8 %242, 0
    br i1 %248, label %.preheader11, label %.loopexit10
  
  .preheader11:                                     ; preds = %246
    %249 = getelementptr inbounds i8, i8* %psrc.3, i32 1
    %250 = load i8, i8* %249, align 1, !tbaa !68
    %251 = icmp eq i8 %250, -1
    br i1 %251, label %.lr.ph70, label %._crit_edge71
  
  .lr.ph70:                                         ; preds = %.preheader11, %.lr.ph70
    %252 = phi i8* [ %256, %.lr.ph70 ], [ %249, %.preheader11 ]
    %xl.sroa.27.1669 = phi i32 [ %xl.sroa.27.17, %.lr.ph70 ], [ %xl.sroa.27.15, %.preheader11 ]
    %xl.sroa.0.868 = phi i32 [ %255, %.lr.ph70 ], [ %241, %.preheader11 ]
    %253 = icmp ult i32 %xl.sroa.27.1669, %dxx8.sroa.16.0
    %xl.sroa.27.17.p = select i1 %253, i32 %129, i32 %165
    %xl.sroa.27.17 = add i32 %xl.sroa.27.17.p, %xl.sroa.27.1669
    %254 = select i1 %253, i32 %151, i32 %147
    %255 = add nsw i32 %254, %xl.sroa.0.868
    %256 = getelementptr inbounds i8, i8* %252, i32 1
    %scevgep9 = getelementptr i8, i8* %252, i32 1
    %257 = load i8, i8* %scevgep9, align 1, !tbaa !68
    %258 = icmp eq i8 %257, -1
    br i1 %258, label %.lr.ph70, label %._crit_edge71
  
  ._crit_edge71:                                    ; preds = %.lr.ph70, %.preheader11
    %.lcssa45 = phi i8 [ %250, %.preheader11 ], [ %257, %.lr.ph70 ]
    %.lcssa44 = phi i8* [ %249, %.preheader11 ], [ %256, %.lr.ph70 ]
    %xl.sroa.27.16.lcssa = phi i32 [ %xl.sroa.27.15, %.preheader11 ], [ %xl.sroa.27.17, %.lr.ph70 ]
    %xl.sroa.0.8.lcssa = phi i32 [ %241, %.preheader11 ], [ %255, %.lr.ph70 ]
    %259 = icmp ult i8 %.lcssa45, -16
    br i1 %259, label %.preheader9, label %260
  
  ; <label>:260                                     ; preds = %._crit_edge71
    %261 = icmp ult i32 %xl.sroa.27.16.lcssa, %dxx4.sroa.16.1
    %xl.sroa.27.18.p = select i1 %261, i32 %129, i32 %164
    %xl.sroa.27.18 = add i32 %xl.sroa.27.18.p, %xl.sroa.27.16.lcssa
    %262 = select i1 %261, i32 %145, i32 %141
    %263 = add nsw i32 %262, %xl.sroa.0.8.lcssa
    br label %.preheader9
  
  .preheader9:                                      ; preds = %260, %._crit_edge71
    %xl.sroa.0.9.ph = phi i32 [ %xl.sroa.0.8.lcssa, %._crit_edge71 ], [ %263, %260 ]
    %xl.sroa.27.19.ph = phi i32 [ %xl.sroa.27.16.lcssa, %._crit_edge71 ], [ %xl.sroa.27.18, %260 ]
    %sbit.6.ph = phi i8 [ -128, %._crit_edge71 ], [ 8, %260 ]
    %264 = and i8 %sbit.6.ph, %.lcssa45
    %265 = icmp eq i8 %264, 0
    br i1 %265, label %.loopexit10, label %.lr.ph79
  
  .lr.ph79:                                         ; preds = %.preheader9, %.lr.ph79
    %sbit.678 = phi i8 [ %269, %.lr.ph79 ], [ %sbit.6.ph, %.preheader9 ]
    %xl.sroa.27.1977 = phi i32 [ %xl.sroa.27.20, %.lr.ph79 ], [ %xl.sroa.27.19.ph, %.preheader9 ]
    %xl.sroa.0.976 = phi i32 [ %268, %.lr.ph79 ], [ %xl.sroa.0.9.ph, %.preheader9 ]
    %266 = icmp ult i32 %xl.sroa.27.1977, %xl.sroa.98.0
    %xl.sroa.27.20.p = select i1 %266, i32 %129, i32 %163
    %xl.sroa.27.20 = add i32 %xl.sroa.27.20.p, %xl.sroa.27.1977
    %267 = select i1 %266, i32 %133, i32 %xl.sroa.82.0
    %268 = add nsw i32 %267, %xl.sroa.0.976
    %269 = lshr i8 %sbit.678, 1
    %270 = and i8 %269, %.lcssa45
    %271 = icmp eq i8 %270, 0
    br i1 %271, label %.loopexit10, label %.lr.ph79
  
  .loopexit10:                                      ; preds = %.lr.ph79, %.preheader9, %246, %235
    %psrc.6 = phi i8* [ %psrc.3, %235 ], [ %psrc.3, %246 ], [ %.lcssa44, %.preheader9 ], [ %.lcssa44, %.lr.ph79 ]
    %xl.sroa.0.11 = phi i32 [ %xl.sroa.0.6, %235 ], [ %241, %246 ], [ %xl.sroa.0.9.ph, %.preheader9 ], [ %268, %.lr.ph79 ]
    %xl.sroa.27.22 = phi i32 [ %xl.sroa.27.13, %235 ], [ %xl.sroa.27.15, %246 ], [ %xl.sroa.27.19.ph, %.preheader9 ], [ %xl.sroa.27.20, %.lr.ph79 ]
    %data.4 = phi i8 [ %data.2, %235 ], [ %247, %246 ], [ %.lcssa45, %.preheader9 ], [ %.lcssa45, %.lr.ph79 ]
    %.pn.in = phi i32 [ %162, %235 ], [ %241, %246 ], [ %xl.sroa.0.9.ph, %.preheader9 ], [ %268, %.lr.ph79 ]
    %sbit.8 = phi i8 [ %100, %235 ], [ %242, %246 ], [ %sbit.6.ph, %.preheader9 ], [ %269, %.lr.ph79 ]
    %.pn = ashr i32 %.pn.in, 12
    %n.0 = sub nsw i32 %.pn, %232
    %272 = icmp slt i32 %n.0, 0
    %273 = sub nsw i32 0, %n.0
    %.pn. = select i1 %272, i32 %.pn, i32 %232
    %.n.0 = select i1 %272, i32 %273, i32 %n.0
    %274 = ashr i32 %.pn., 3
    %275 = getelementptr inbounds i8, i8* %line, i32 %274
    %276 = and i32 %.pn., 7
    %277 = add nsw i32 %276, %.n.0
    %278 = icmp slt i32 %277, 9
    br i1 %278, label %279, label %291
  
  ; <label>:279                                     ; preds = %.loopexit10
    %280 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %276
    %281 = load i8, i8* %280, align 1, !tbaa !68
    %282 = zext i8 %281 to i32
    %283 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %277
    %284 = load i8, i8* %283, align 1, !tbaa !68
    %285 = zext i8 %284 to i32
    %286 = sub nsw i32 %282, %285
    %287 = load i8, i8* %275, align 1, !tbaa !68
    %288 = zext i8 %287 to i32
    %289 = xor i32 %288, %286
    %290 = trunc i32 %289 to i8
    store i8 %290, i8* %275, align 1, !tbaa !68
    br label %334
  
  ; <label>:291                                     ; preds = %.loopexit10
    %292 = add nsw i32 %277, -8
    %293 = icmp slt i32 %292, 9
    %294 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %276
    %295 = load i8, i8* %294, align 1, !tbaa !68
    br i1 %293, label %296, label %304
  
  ; <label>:296                                     ; preds = %291
    %297 = load i8, i8* %275, align 1, !tbaa !68
    %298 = xor i8 %297, %295
    store i8 %298, i8* %275, align 1, !tbaa !68
    %299 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.rmasks, i32 0, i32 %292
    %300 = load i8, i8* %299, align 1, !tbaa !68
    %301 = getelementptr inbounds i8, i8* %275, i32 1
    %302 = load i8, i8* %301, align 1, !tbaa !68
    %303 = xor i8 %302, %300
    store i8 %303, i8* %301, align 1, !tbaa !68
    br label %334
  
  ; <label>:304                                     ; preds = %291
    %305 = getelementptr inbounds i8, i8* %275, i32 1
    %306 = load i8, i8* %275, align 1, !tbaa !68
    %307 = xor i8 %306, %295
    store i8 %307, i8* %275, align 1, !tbaa !68
    %308 = icmp sgt i32 %292, 55
    br i1 %308, label %322, label %.preheader
  
  .preheader:                                       ; preds = %304
    %309 = add nsw i32 %277, -16
    %310 = icmp sgt i32 %309, -1
    br i1 %310, label %.lr.ph84.preheader, label %.loopexit
  
  .lr.ph84.preheader:                               ; preds = %.preheader
    %311 = trunc i32 %10 to i8
    %312 = add nsw i32 %232, -1
    %313 = sub nsw i32 %312, %.pn
    %314 = icmp sgt i32 %313, -1
    %smax = select i1 %314, i32 %313, i32 -1
    %315 = sub nsw i32 %312, %smax
    %316 = and i32 %315, 7
    %317 = add nsw i32 %.n.0, -16
    %318 = add nsw i32 %317, %316
    %319 = lshr i32 %318, 3
    %320 = add nsw i32 %274, %319
    %scevgep129 = getelementptr i8, i8* %scevgep128, i32 %274
    %321 = add nuw nsw i32 %319, 1
    call void @llvm.memset.p0i8.i32(i8* %scevgep129, i8 %311, i32 %321, i32 1, i1 false)
    br label %.lr.ph84
  
  ; <label>:322                                     ; preds = %304
    %323 = trunc i32 %10 to i8
    %324 = ashr i32 %292, 3
    tail call void @llvm.memset.p0i8.i32(i8* %305, i8 %323, i32 %324, i32 1, i1 false)
    %325 = getelementptr inbounds i8, i8* %305, i32 %324
    br label %.loopexit
  
  .lr.ph84:                                         ; preds = %.lr.ph84, %.lr.ph84.preheader
    %326 = phi i32 [ %327, %.lr.ph84 ], [ %309, %.lr.ph84.preheader ]
    %327 = add nsw i32 %326, -8
    %328 = icmp sgt i32 %327, -1
    br i1 %328, label %.lr.ph84, label %.loopexit.loopexit
  
  .loopexit.loopexit:                               ; preds = %.lr.ph84
    %scevgep127 = getelementptr i8, i8* %scevgep, i32 %320
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.loopexit.loopexit, %322, %.preheader
    %n.3 = phi i32 [ %292, %322 ], [ %309, %.preheader ], [ %327, %.loopexit.loopexit ]
    %bp.1 = phi i8* [ %325, %322 ], [ %305, %.preheader ], [ %scevgep127, %.loopexit.loopexit ]
    %329 = and i32 %n.3, 7
    %330 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.rmasks, i32 0, i32 %329
    %331 = load i8, i8* %330, align 1, !tbaa !68
    %332 = load i8, i8* %bp.1, align 1, !tbaa !68
    %333 = xor i8 %332, %331
    store i8 %333, i8* %bp.1, align 1, !tbaa !68
    br label %334
  
  ; <label>:334                                     ; preds = %.loopexit, %296, %279
    %335 = icmp uge i8* %psrc.6, %.stop.5
    %336 = icmp eq i8 %sbit.8, %100
    %or.cond4 = and i1 %335, %336
    br i1 %or.cond4, label %.thread, label %.critedge5
  
  .thread:                                          ; preds = %334, %84, %54, %0
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %data, i32 signext %dx, i32 signext %raster, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) unnamed_addr #1 {
    %1 = ptrtoint i8* %data to i32
    %2 = and i32 %1, 3
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 48, i32 0, i32 0, i32 0, i32 0
    %4 = load i32, i32* %3, align 8, !tbaa !69
    %5 = icmp eq i32 %4, 0
    %6 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0
    %7 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0
    %pdc0.0 = select i1 %5, %struct.gx_device_color_s* %7, %struct.gx_device_color_s* %6
    %pdc1.0 = select i1 %5, %struct.gx_device_color_s* %6, %struct.gx_device_color_s* %7
    %8 = sub nsw i32 0, %2
    %9 = getelementptr inbounds i8, i8* %data, i32 %8
    %10 = shl nuw nsw i32 %2, 3
    %11 = add i32 %10, %dx
    %12 = bitcast %struct.gx_device_color_s* %pdc0.0 to %struct.gx_device_color_procs_s**
    %13 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %12, align 4, !tbaa !59
    %14 = icmp eq %struct.gx_device_color_procs_s* %13, @gx_dc_procs_pure
    %15 = bitcast %struct.gx_device_color_s* %pdc1.0 to %struct.gx_device_color_procs_s**
    %16 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %15, align 4, !tbaa !59
    br i1 %14, label %17, label %35
  
  ; <label>:17                                      ; preds = %0
    %18 = icmp eq %struct.gx_device_color_procs_s* %16, @gx_dc_procs_pure
    br i1 %18, label %19, label %42
  
  ; <label>:19                                      ; preds = %17
    %20 = icmp eq i32 %h, 1
    %21 = and i32 %raster, 3
    %22 = icmp eq i32 %21, 0
    %or.cond = or i1 %22, %20
    br i1 %or.cond, label %23, label %26
  
  ; <label>:23                                      ; preds = %19
    %24 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 0, i32 21, i32 9
    %25 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** %24, align 4, !tbaa !46
    br label %26
  
  ; <label>:26                                      ; preds = %23, %19
    %27 = phi i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)* [ %25, %23 ], [ @gx_copy_mono_unaligned, %19 ]
    %28 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc0.0, i32 0, i32 1
    %29 = bitcast %union._c* %28 to i32*
    %30 = load i32, i32* %29, align 4, !tbaa !64
    %31 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc1.0, i32 0, i32 1
    %32 = bitcast %union._c* %31 to i32*
    %33 = load i32, i32* %32, align 4, !tbaa !64
    %34 = tail call i32 %27(%struct.gx_device_s* %dev, i8* %9, i32 signext %11, i32 signext %raster, i32 signext 0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, i32 signext %30, i32 signext %33) #4
    br label %56
  
  ; <label>:35                                      ; preds = %0
    %36 = icmp eq %struct.gx_device_color_procs_s* %16, @gx_dc_procs_pure
    br i1 %36, label %37, label %.thread3
  
  ; <label>:37                                      ; preds = %35
    %38 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc1.0, i32 0, i32 1
    %39 = bitcast %union._c* %38 to i32*
    %40 = load i32, i32* %39, align 4, !tbaa !64
    %41 = icmp eq i32 %40, -1
    br i1 %41, label %50, label %.thread3
  
  ; <label>:42                                      ; preds = %17
    %43 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc0.0, i32 0, i32 1
    %44 = bitcast %union._c* %43 to i32*
    %45 = load i32, i32* %44, align 4, !tbaa !64
    %46 = icmp eq i32 %45, -1
    br i1 %46, label %50, label %.thread3
  
  .thread3:                                         ; preds = %42, %37, %35
    %47 = getelementptr inbounds %struct.gx_device_color_procs_s, %struct.gx_device_color_procs_s* %13, i32 0, i32 1
    %48 = load i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)*, i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)** %47, align 4, !tbaa !73
    %49 = tail call i32 %48(%struct.gx_device_color_s* nonnull %pdc0.0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev, i32 signext 252, %struct.gx_rop_source_s* null) #4
    %not. = icmp sgt i32 %49, -1
    br i1 %not., label %50, label %56
  
  ; <label>:50                                      ; preds = %.thread3, %42, %37
    %pdc.0 = phi %struct.gx_device_color_s* [ %pdc0.0, %37 ], [ %pdc1.0, %.thread3 ], [ %pdc1.0, %42 ]
    %invert.0 = phi i32 [ 1, %37 ], [ 0, %.thread3 ], [ 0, %42 ]
    %51 = bitcast %struct.gx_device_color_s* %pdc.0 to %struct.gx_device_color_procs_s**
    %52 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %51, align 4, !tbaa !59
    %53 = getelementptr inbounds %struct.gx_device_color_procs_s, %struct.gx_device_color_procs_s* %52, i32 0, i32 2
    %54 = load i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)*, i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)** %53, align 4, !tbaa !75
    %55 = tail call i32 %54(%struct.gx_device_color_s* %pdc.0, i8* %9, i32 signext %11, i32 signext %raster, i32 signext 0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev, i32 signext 252, i32 signext %invert.0) #4
    br label %56
  
  ; <label>:56                                      ; preds = %50, %.thread3, %26
    %.2 = phi i32 [ %34, %26 ], [ %55, %50 ], [ %49, %.thread3 ]
    ret i32 %.2
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture readonly, i32, i32, i1) #3
  
  declare i32 @gx_copy_mono_unaligned(%struct.gx_device_s*, i8*, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %x0, i32 signext %x1, i32 signext %y_neg, %struct.gx_device_s* %dev) unnamed_addr #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %2 = load i8*, i8** %1, align 8, !tbaa !35
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %4 = load i32, i32* %3, align 8, !tbaa !29
    %5 = add i32 %4, 31
    %6 = lshr i32 %5, 5
    %7 = shl nuw nsw i32 %6, 2
    %8 = shl nuw i32 %6, 5
    %9 = getelementptr inbounds i8, i8* %2, i32 %8
    %10 = sub nsw i32 %x1, %x0
    %11 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 1, i32 0, i32 0
    %12 = load i32, i32* %11, align 4, !tbaa !21
    %13 = add nsw i32 %12, 2047
    %14 = ashr i32 %13, 12
    %15 = icmp eq i32 %x1, %x0
    %16 = icmp eq i32 %4, 0
    %or.cond = or i1 %15, %16
    br i1 %or.cond, label %34, label %17
  
  ; <label>:17                                      ; preds = %0
    %18 = add i32 %4, -1
    %19 = lshr i32 %18, 3
    %20 = add i32 %19, 1
    %21 = shl i32 %19, 5
    %22 = add i32 %4, 31
    %23 = lshr i32 %22, 5
    %24 = shl i32 %23, 5
    %25 = add i32 %21, %24
    %scevgep = getelementptr i8, i8* %2, i32 %25
    br label %26
  
  ; <label>:26                                      ; preds = %26, %17
    %lsr.iv1 = phi i8* [ %scevgep2, %26 ], [ %scevgep, %17 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %26 ], [ %20, %17 ]
    %scevgep3 = getelementptr i8, i8* %2, i32 %lsr.iv
    %scevgep4 = getelementptr i8, i8* %scevgep3, i32 -1
    tail call void @memflip8x8(i8* %scevgep4, i32 signext %7, i8* %lsr.iv1, i32 signext 4) #4
    %lsr.iv.next = add nsw i32 %lsr.iv, -1
    %scevgep2 = getelementptr i8, i8* %lsr.iv1, i32 -32
    %27 = icmp sgt i32 %lsr.iv.next, 0
    br i1 %27, label %26, label %.loopexit
  
  .loopexit:                                        ; preds = %26
    %28 = icmp slt i32 %10, 0
    %29 = sub nsw i32 0, %10
    %x1.x0 = select i1 %28, i32 %x1, i32 %x0
    %. = select i1 %28, i32 %29, i32 %10
    %30 = icmp eq i32 %y_neg, 0
    %31 = select i1 %30, i32 0, i32 %4
    %y.0 = sub i32 %14, %31
    %32 = and i32 %x1.x0, 7
    %33 = tail call fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %9, i32 signext %32, i32 signext 4, i32 signext %x1.x0, i32 signext %y.0, i32 signext %., i32 signext %4, %struct.gx_device_s* %dev)
    br label %34
  
  ; <label>:34                                      ; preds = %.loopexit, %0
    %.0 = phi i32 [ %33, %.loopexit ], [ 0, %0 ]
    ret i32 %.0
  }
  
  declare void @memflip8x8(i8*, i32 signext, i8*, i32 signext) #2
  
  attributes #0 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #4 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"gx_image_strategies_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !13, i64 236}
  !7 = !{!"gx_image_enum_s", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3, !4, i64 4, !4, i64 5, !4, i64 6, !4, i64 7, !8, i64 8, !10, i64 32, !12, i64 48, !12, i64 56, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76, !3, i64 80, !3, i64 84, !3, i64 88, !11, i64 92, !3, i64 96, !11, i64 100, !11, i64 104, !4, i64 108, !4, i64 112, !4, i64 113, !4, i64 114, !4, i64 115, !14, i64 116, !14, i64 132, !11, i64 148, !13, i64 152, !13, i64 156, !13, i64 160, !3, i64 164, !3, i64 168, !3, i64 172, !11, i64 176, !12, i64 180, !12, i64 188, !15, i64 196, !11, i64 276, !11, i64 280, !20, i64 284, !11, i64 292, !11, i64 296, !11, i64 300, !11, i64 304, !4, i64 312, !4, i64 1656}
  !8 = !{!"gs_matrix_s", !9, i64 0, !9, i64 4, !9, i64 8, !9, i64 12, !9, i64 16, !9, i64 20}
  !9 = !{!"float", !4, i64 0}
  !10 = !{!"r_", !11, i64 0, !11, i64 4, !11, i64 8, !11, i64 12}
  !11 = !{!"int", !4, i64 0}
  !12 = !{!"gs_fixed_point_s", !13, i64 0, !13, i64 4}
  !13 = !{!"long", !4, i64 0}
  !14 = !{!"gs_fixed_rect_s", !12, i64 0, !12, i64 8}
  !15 = !{!"dd_", !16, i64 0, !16, i64 40}
  !16 = !{!"gx_dda_fixed_point_s", !17, i64 0, !17, i64 20}
  !17 = !{!"gx_dda_fixed_s", !18, i64 0, !19, i64 8}
  !18 = !{!"_a", !13, i64 0, !11, i64 4}
  !19 = !{!"_e", !13, i64 0, !11, i64 4, !11, i64 8}
  !20 = !{!"gs_int_point_s", !11, i64 0, !11, i64 4}
  !21 = !{!7, !13, i64 256}
  !22 = !{!7, !4, i64 112}
  !23 = !{!7, !4, i64 3}
  !24 = !{!7, !4, i64 0}
  !25 = !{!7, !4, i64 108}
  !26 = !{!7, !13, i64 48}
  !27 = !{!7, !11, i64 40}
  !28 = !{!7, !13, i64 152}
  !29 = !{!7, !11, i64 104}
  !30 = !{!7, !11, i64 100}
  !31 = !{!7, !3, i64 80}
  !32 = !{!33, !3, i64 0}
  !33 = !{!"gs_memory_s", !34, i64 0}
  !34 = !{!"gs_memory_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !3, i64 24, !3, i64 28, !3, i64 32, !3, i64 36, !3, i64 40, !3, i64 44, !3, i64 48, !3, i64 52, !3, i64 56, !3, i64 60, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76}
  !35 = !{!7, !3, i64 96}
  !36 = !{!7, !3, i64 84}
  !37 = !{!7, !13, i64 52}
  !38 = !{!7, !11, i64 276}
  !39 = !{!7, !11, i64 280}
  !40 = !{!7, !9, i64 12}
  !41 = !{!7, !13, i64 160}
  !42 = !{!7, !9, i64 8}
  !43 = !{!7, !13, i64 156}
  !44 = !{!7, !3, i64 64}
  !45 = !{!7, !4, i64 1}
  !46 = !{!47, !3, i64 180}
  !47 = !{!"gx_device_s", !11, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !11, i64 20, !11, i64 24, !48, i64 28, !11, i64 44, !11, i64 48, !4, i64 52, !4, i64 60, !11, i64 76, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !13, i64 120, !13, i64 124, !11, i64 128, !50, i64 132, !51, i64 144}
  !48 = !{!"gx_device_color_info_s", !11, i64 0, !11, i64 4, !49, i64 8, !49, i64 10, !49, i64 12, !49, i64 14}
  !49 = !{!"short", !4, i64 0}
  !50 = !{!"gx_page_device_procs_s", !3, i64 0, !3, i64 4, !3, i64 8}
  !51 = !{!"gx_device_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !3, i64 24, !3, i64 28, !3, i64 32, !3, i64 36, !3, i64 40, !3, i64 44, !3, i64 48, !3, i64 52, !3, i64 56, !3, i64 60, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76, !3, i64 80, !3, i64 84, !3, i64 88, !3, i64 92, !3, i64 96, !3, i64 100, !3, i64 104, !3, i64 108, !3, i64 112, !3, i64 116, !3, i64 120, !3, i64 124, !3, i64 128, !3, i64 132, !3, i64 136, !3, i64 140, !3, i64 144}
  !52 = !{!7, !11, i64 292}
  !53 = !{!7, !11, i64 296}
  !54 = !{!55, !3, i64 180}
  !55 = !{!"gx_device_memory_s", !11, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !11, i64 20, !11, i64 24, !48, i64 28, !11, i64 44, !11, i64 48, !4, i64 52, !4, i64 60, !11, i64 76, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !13, i64 120, !13, i64 124, !11, i64 128, !50, i64 132, !51, i64 144, !3, i64 292, !8, i64 296, !11, i64 320, !11, i64 324, !3, i64 328, !3, i64 332, !3, i64 336, !56, i64 340, !57, i64 348, !58, i64 364, !11, i64 372, !11, i64 376, !11, i64 380, !11, i64 384, !11, i64 388, !13, i64 392}
  !56 = !{!"gs_const_string_s", !3, i64 0, !11, i64 4}
  !57 = !{!"_c24", !13, i64 0, !11, i64 4, !11, i64 8, !11, i64 12}
  !58 = !{!"gs_log2_scale_point_s", !11, i64 0, !11, i64 4}
  !59 = !{!60, !3, i64 0}
  !60 = !{!"gx_device_color_s", !3, i64 0, !4, i64 4, !20, i64 32, !61, i64 40}
  !61 = !{!"_mask", !62, i64 0, !13, i64 20, !3, i64 24}
  !62 = !{!"gs_client_color_s", !63, i64 0, !3, i64 16}
  !63 = !{!"gs_paint_color_s", !4, i64 0}
  !64 = !{!13, !13, i64 0}
  !65 = !{!7, !4, i64 113}
  !66 = !{!55, !3, i64 332}
  !67 = !{!3, !3, i64 0}
  !68 = !{!4, !4, i64 0}
  !69 = !{!11, !11, i64 0}
  !70 = !{!7, !11, i64 300}
  !71 = !{!7, !11, i64 304}
  !72 = !{!7, !9, i64 16}
  !73 = !{!74, !3, i64 4}
  !74 = !{!"gx_device_color_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16}
  !75 = !{!74, !3, i64 8}

...
---
name:            image_render_simple
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: gpr32 }
  - { id: 75, class: gpr32 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: gpr32 }
  - { id: 78, class: gpr32 }
  - { id: 79, class: gpr32 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: gpr32 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: gpr32 }
  - { id: 84, class: gpr32 }
  - { id: 85, class: gpr32 }
  - { id: 86, class: gpr32 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: gpr32 }
  - { id: 89, class: gpr32 }
  - { id: 90, class: gpr32 }
  - { id: 91, class: gpr32 }
  - { id: 92, class: gpr32 }
  - { id: 93, class: gpr32 }
  - { id: 94, class: gpr32 }
  - { id: 95, class: gpr32 }
  - { id: 96, class: gpr32 }
  - { id: 97, class: gpr32 }
  - { id: 98, class: gpr32 }
  - { id: 99, class: gpr32 }
  - { id: 100, class: gpr32 }
  - { id: 101, class: gpr32 }
  - { id: 102, class: gpr32 }
  - { id: 103, class: gpr32 }
  - { id: 104, class: gpr32 }
  - { id: 105, class: gpr32 }
  - { id: 106, class: gpr32 }
  - { id: 107, class: gpr32 }
  - { id: 108, class: gpr32 }
  - { id: 109, class: gpr32 }
  - { id: 110, class: gpr32 }
  - { id: 111, class: gpr32 }
  - { id: 112, class: gpr32 }
  - { id: 113, class: gpr32 }
  - { id: 114, class: gpr32 }
  - { id: 115, class: gpr32 }
  - { id: 116, class: gpr32 }
  - { id: 117, class: gpr32 }
  - { id: 118, class: gpr32 }
  - { id: 119, class: gpr32 }
  - { id: 120, class: gpr32 }
  - { id: 121, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%37' }
  - { reg: '%a1', virtual-reg: '%38' }
  - { reg: '%a2', virtual-reg: '%39' }
  - { reg: '%a3', virtual-reg: '%40' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 20, size: 4, alignment: 4, isImmutable: true, isAliased: false }
  - { id: 1, offset: 16, size: 4, alignment: 8, isImmutable: true, isAliased: false }
body:             |
  bb.0 (%ir-block.0, freq 3106):
    successors: %bb.20..loopexit(37), %bb.1(62)
    liveins: %a0, %a1, %a2, %a3, %t9, %v0
  
    %45 = ADDu %v0, %t9
    %40 = COPY %a3
    %39 = COPY %a2
    %38 = COPY %a1
    %37 = COPY %a0
    %43 = LW %fixed-stack.1, 0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    %42 = ADDiu %zero, 0
    BEQ killed %43, %zero, %bb.20..loopexit, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.14, freq 1941):
    successors: %bb.2(37), %bb.3(62)
  
    %41 = LW %fixed-stack.0, 0, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from stack)
    %6 = LW %37, 296, <0x32f1280> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.11, align 8, !tbaa !53)
    %2 = LW %37, 236, <0x32368d0> = !{!"unison-memory-partition", i32 3} :: (load 4 from %ir.5, !tbaa !6)
    %5 = LW %37, 292, <0x32ade80> = !{!"unison-memory-partition", i32 4} :: (load 4 from %ir.9, !tbaa !52)
    %1 = LW %37, 156, <0x33082d0> = !{!"unison-memory-partition", i32 5} :: (load 4 from %ir.3, !tbaa !43)
    %3 = ADDiu %2, 2047
    %4 = SRA %3, 12
    %7 = LW %37, 96, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.15, align 8, !tbaa !35)
    BNE %7, %zero, %bb.3, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.18, freq 728):
    successors: %bb.17(100)
  
    %108 = ADDiu %40, 7
    %8 = SRL killed %108, 3
    %107 = ADDiu %zero, 0
    B %bb.17, implicit-def dead %at
  
  bb.3 (%ir-block.21, freq 1213):
    successors: %bb.21(75), %bb.16(25)
  
    BLEZ %1, %bb.16, implicit-def dead %at
    B %bb.21, implicit-def dead %at
  
  bb.21 (%ir-block.21, freq 910):
    successors: %bb.4(66), %bb.16(33)
  
    %0 = LW %41, 180, <0x32f1280> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.1, !tbaa !46)
    %46 = LW %45, target-flags(<unknown>) @mem_mono_device, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %44 = LW %46, 180, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from `i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** getelementptr inbounds (%struct.gx_device_memory_s, %struct.gx_device_memory_s* @mem_mono_device, i32 0, i32 21, i32 9)`, !tbaa !54)
    BNE %0, %44, %bb.16, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.25, freq 606):
    successors: %bb.5(37), %bb.16(62)
  
    %47 = LW %37, 20016, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.26, align 8, !tbaa !59)
    %48 = LW %45, target-flags(<unknown>) @gx_dc_procs_pure, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    BNE killed %47, %48, %bb.16, implicit-def dead %at
    B %bb.5, implicit-def dead %at
  
  bb.5 (%ir-block.29, freq 227):
    successors: %bb.6(37), %bb.16(62)
  
    %49 = LW %37, 1656, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.30, align 8, !tbaa !59)
    BNE killed %49, %48, %bb.16, implicit-def dead %at
    B %bb.6, implicit-def dead %at
  
  bb.6 (%ir-block.33, freq 85):
    successors: %bb.7(50), %bb.16(50)
  
    %9 = LW %37, 1660, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.35, !tbaa !64)
    %51 = LW %37, 20020, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.38, !tbaa !64)
    %52 = XOR killed %51, %9
    %53 = ADDiu %zero, 1
    BNE killed %52, killed %53, %bb.16, implicit-def dead %at
    B %bb.7, implicit-def dead %at
  
  bb.7 (%ir-block.42, freq 42):
    successors: %bb.8(37), %bb.16(62)
  
    %54 = LBu %37, 113, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.43, !tbaa !65)
    BNE killed %54, %zero, %bb.16, implicit-def dead %at
    B %bb.8, implicit-def dead %at
  
  bb.8 (%ir-block.46, freq 15):
    successors: %bb.10(37), %bb.9(62)
  
    %59 = LW %41, 332, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.55, !tbaa !66)
    %60 = SLL %5, 2
    %61 = MUL %1, %40, implicit-def dead %hi0, implicit-def dead %lo0
    %62 = ADDu killed %59, killed %60
    %63 = SLTiu %9, 1
    %64 = LW %37, 312, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.75, align 8, !tbaa !69)
    %65 = SLTiu killed %64, 1
    %66 = XOR killed %63, killed %65
    %67 = SLL killed %66, 31
    %68 = SRA killed %67, 31
    %69 = LW killed %62, 0, <0x32f1280> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.57, !tbaa !67)
    %11 = ANDi %4, 31
    %70 = SUBu %4, %11
    %71 = SRA killed %70, 3
    %72 = SRA %3, 15
    %73 = LW %45, target-flags(<unknown>) @image_simple_expand, <0x32368d0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    %18 = ADDu %69, %71
    %74 = ANDi killed %68, 255
    %75 = LW %37, 48, <0x32ade80> = !{!"unison-memory-partition", i32 4} :: (load 4 from %ir.72, align 8, !tbaa !26)
    %76 = ADDiu killed %73, target-flags(<unknown>) @image_simple_expand
    %14 = ADDu %69, killed %72
    %15 = LBu %14, 0, <0x33082d0> = !{!"unison-memory-partition", i32 5} :: (load 1 from %ir.65, !tbaa !68)
    %77 = ADDu killed %61, %2
    %78 = ADDiu killed %77, 2047
    %10 = SRL killed %78, 12
    %79 = ADDiu %10, -1
    %80 = SRA killed %79, 3
    %16 = ADDu %69, %80
    %17 = LBu %16, 0, <0x3301380> = !{!"unison-memory-partition", i32 6} :: (load 1 from %ir.68, !tbaa !68)
    %81 = ADDiu %80, 1
    %12 = SUBu killed %81, %71
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %a0 = COPY %18
    %a1 = COPY %11
    %a2 = COPY %12
    %a3 = COPY %38
    %t0 = COPY %39
    %t1 = COPY %40
    %t2 = COPY %2
    %t3 = COPY %75
    %t4 = COPY %74
    %t9 = COPY %76
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %t0, implicit %t1, implicit %t2, implicit %t3, implicit %t4, implicit-def %sp
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %19 = ANDi %4, 7
    BEQ %19, %zero, %bb.10, implicit-def dead %at
    B %bb.9, implicit-def dead %at
  
  bb.9 (%ir-block.82, freq 9):
    successors: %bb.10(100)
  
    %82 = ORi %zero, 65280
    %83 = SRLV killed %82, %19
    %84 = AND %15, %83
    %85 = NOR %83, %zero
    %86 = LBu %14, 0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.65, !tbaa !68)
    %87 = AND killed %86, killed %85
    %88 = ADDu killed %87, killed %84
    SB killed %88, %14, 0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.65, !tbaa !68)
  
  bb.10 (%ir-block.91, freq 15):
    successors: %bb.12(37), %bb.11(62)
  
    %20 = ANDi %10, 7
    BEQ %20, %zero, %bb.12, implicit-def dead %at
    B %bb.11, implicit-def dead %at
  
  bb.11 (%ir-block.94, freq 9):
    successors: %bb.12(100)
  
    %89 = ORi %zero, 65280
    %90 = SRLV killed %89, %20
    %91 = NOR %90, %zero
    %92 = AND %17, killed %91
    %93 = LBu %16, 0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.68, !tbaa !68)
    %94 = AND killed %93, %90
    %95 = ADDu killed %94, killed %92
    SB killed %95, %16, 0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.68, !tbaa !68)
  
  bb.12 (%ir-block.103, freq 15):
    successors: %bb.20..loopexit(50), %bb.13..lr.ph20.preheader(50)
  
    %97 = SLTi %6, 2
    %96 = ADDiu %zero, 1
    BNE killed %97, %zero, %bb.20..loopexit, implicit-def dead %at
    B %bb.13..lr.ph20.preheader, implicit-def dead %at
  
  bb.13..lr.ph20.preheader (freq 7):
    successors: %bb.15..lr.ph20(100)
  
    %13 = SUBu %10, %4
    %99 = SRA %1, 31
    %100 = AND killed %99, %13
    %21 = SUBu %4, killed %100
    %98 = ADDiu %zero, 1
    B %bb.15..lr.ph20, implicit-def dead %at
  
  bb.14 (%ir-block.107, freq 125):
    successors: %bb.15..lr.ph20(96), %bb.20..loopexit(3)
  
    %24 = ADDiu %22, 1
    %106 = SLT %24, %6
    BEQ killed %106, %zero, %bb.20..loopexit, implicit-def dead %at
    B %bb.15..lr.ph20, implicit-def dead %at
  
  bb.15..lr.ph20 (freq 130):
    successors: %bb.20..loopexit(3), %bb.14(96)
  
    %22 = PHI %98, %bb.13..lr.ph20.preheader, %24, %bb.14
    %101 = ADDu %5, %22
    ADJCALLSTACKDOWN 48, implicit-def dead %sp, implicit %sp
    %103 = COPY %sp
    SW %98, %103, 40, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %98, %103, 32, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %13, %103, 28, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW killed %101, %103, 24, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %21, %103, 20, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %103, 36, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %103, 16, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %a0 = COPY %41
    %a1 = COPY %18
    %a2 = COPY %11
    %a3 = COPY %12
    %t9 = COPY %0
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 48, 0, implicit-def dead %sp, implicit %sp
    %104 = COPY %v0
    %23 = COPY %104
    BLTZ %104, %bb.20..loopexit, implicit-def dead %at
    B %bb.14, implicit-def dead %at
  
  bb.16 (%ir-block.113, freq 1197):
    successors: %bb.17(100)
  
    %26 = LW %37, 104, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.116, align 8, !tbaa !29)
    %55 = LW %37, 48, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.119, align 8, !tbaa !26)
    %25 = LW %37, 100, <0x32f1280> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.114, !tbaa !30)
    %56 = LW %45, target-flags(<unknown>) @image_simple_expand, <0x32368d0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %27 = ANDi %4, 31
    %57 = ADDiu killed %56, target-flags(<unknown>) @image_simple_expand
    %58 = ADDiu %zero, 0
    %a0 = COPY %7
    %a1 = COPY %27
    %a2 = COPY %25
    %a3 = COPY %38
    %t0 = COPY %39
    %t1 = COPY %40
    %t2 = COPY %2
    %t3 = COPY %55
    %t4 = COPY %58
    %t9 = COPY %57
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %t0, implicit %t1, implicit %t2, implicit %t3, implicit %t4, implicit-def %sp
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
  
  bb.17 (%ir-block.121, freq 1925):
    successors: %bb.22(62), %bb.20..loopexit(37)
  
    %28 = PHI %27, %bb.16, %107, %bb.2
    %29 = PHI %25, %bb.16, %8, %bb.2
    %30 = PHI %26, %bb.16, %40, %bb.2
    %31 = PHI %7, %bb.16, %38, %bb.2
    %110 = ADDiu %zero, 1
    BLEZ %6, %bb.20..loopexit, implicit-def %at
  
  bb.22 (freq 1203):
    successors: %bb.19..lr.ph(100)
  
    %111 = SRA %1, 31
    %112 = AND %111, %30
    %32 = SUBu %4, %112
    %109 = ADDiu %zero, 0
    %113 = LW %45, target-flags(<unknown>) @copy_portrait, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %115 = ADDiu %113, target-flags(<unknown>) @copy_portrait
    %116 = ADDiu %zero, 1
    B %bb.19..lr.ph, implicit-def %at
  
  bb.18 (%ir-block.125, freq 18952):
    successors: %bb.19..lr.ph(96), %bb.20..loopexit(3)
  
    %35 = ADDiu %33, 1
    %119 = SLT %35, %6
    %118 = ADDiu %zero, 1
    BEQ killed %119, %zero, %bb.20..loopexit, implicit-def dead %at
    B %bb.19..lr.ph, implicit-def dead %at
  
  bb.19..lr.ph (freq 19563):
    successors: %bb.20..loopexit(3), %bb.18(96)
  
    %33 = PHI %109, %bb.22, %35, %bb.18
    %114 = ADDu %5, %33
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %a0 = COPY %37
    %a1 = COPY %31
    %a2 = COPY %28
    %a3 = COPY %29
    %t0 = COPY %32
    %t1 = COPY %114
    %t2 = COPY %30
    %t3 = COPY %116
    %t4 = COPY %41
    %t9 = COPY %115
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %t0, implicit %t1, implicit %t2, implicit %t3, implicit %t4, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %117 = COPY %v0
    %34 = COPY %117
    BGEZ %117, %bb.18, implicit-def dead %at
    B %bb.20..loopexit, implicit-def dead %at
  
  bb.20..loopexit (freq 3106):
    liveouts: %v0
  
    %36 = PHI %42, %bb.0, %96, %bb.12, %23, %bb.15..lr.ph20, %42, %bb.14, %110, %bb.17, %34, %bb.19..lr.ph, %118, %bb.18
    %v0 = COPY %36
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/ghostscript/ghostscript.gximage1.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.gx_image_strategies_s = type { i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)*, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)* }
  %struct.gx_device_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s }
  %struct.gs_memory_s = type { %struct.gs_memory_procs_s }
  %struct.gs_memory_procs_s = type { i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i32, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i32, %struct.gs_memory_struct_type_s*, i8*)*, i8* (%struct.gs_memory_s*, i8*, i32, i8*)*, i32 (%struct.gs_memory_s*, i8*)*, %struct.gs_memory_struct_type_s* (%struct.gs_memory_s*, i8*)*, void (%struct.gs_memory_s*, i8*, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i8*, i32, i32, i8*)*, void (%struct.gs_memory_s*, i8*, i32, i8*)*, void (%struct.gs_memory_s*, %struct.gs_gc_root_s*, %struct.gs_ptr_procs_s*, i8**, i8*)*, void (%struct.gs_memory_s*, %struct.gs_gc_root_s*, i8*)*, void (%struct.gs_memory_s*, %struct.gs_memory_status_s*)*, void (%struct.gs_memory_s*, i32)* }
  %struct.gs_gc_root_s = type { %struct.gs_gc_root_s*, %struct.gs_ptr_procs_s*, i8** }
  %struct.gs_ptr_procs_s = type { void (i8*, %struct.gc_state_s*)*, i32 (i8*, %struct.gc_state_s*)*, i8* (i8*, %struct.gc_state_s*)* }
  %struct.gc_state_s = type opaque
  %struct.gs_memory_status_s = type { i32, i32 }
  %struct.gs_memory_struct_type_s = type { i32, i8*, %struct.struct_shared_procs_s*, void (i8*, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)*, void (i8*)* }
  %struct.struct_shared_procs_s = type opaque
  %struct.gx_device_color_info_s = type { i32, i32, i16, i16, i16, i16 }
  %struct.gx_page_device_procs_s = type { i32 (%struct.gx_device_s*, %struct.gs_state_s*)*, i32 (%struct.gx_device_s*, %struct.gs_state_s*)*, i32 (%struct.gx_device_s*, i32, %struct.gs_state_s*)* }
  %struct.gs_state_s = type opaque
  %struct.gx_device_procs_s = type { i32 (%struct.gx_device_s*)*, void (%struct.gx_device_s*, %struct.gs_matrix_s*)*, i32 (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i32, i32)*, i32 (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16)*, i32 (%struct.gx_device_s*, i32, i16*)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, %struct.gx_tile_bitmap_s*, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i8*, i8**)*, i32 (%struct.gx_device_s*, %struct.gs_param_list_s*)*, i32 (%struct.gx_device_s*, %struct.gs_param_list_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16, i16)*, %struct.gx_xfont_procs_s* (%struct.gx_device_s*)*, %struct.gx_device_s* (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i16, i16, i16, i16)*, %struct.gx_device_s* (%struct.gx_device_s*)*, i32 (%struct.gx_device_s*, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i32, i32*)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32*, %struct.gx_tile_bitmap_s*, i32*, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gx_path_s*, %struct.gx_fill_params_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gx_path_s*, %struct.gx_stroke_params_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32, i32, %struct.gx_clip_path_s*)*, i32 (%struct.gx_device_s*, %struct.gs_fixed_edge_s*, %struct.gs_fixed_edge_s*, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, i32, i32, i32, i32, %struct.gx_device_color_s*, i32)*, i32 (%struct.gx_device_s*, %struct.gs_imager_state_s*, %struct.gs_image_s*, i32, %struct.gs_int_rect_s*, %struct.gx_device_color_s*, %struct.gx_clip_path_s*, %struct.gs_memory_s*, i8**)*, i32 (%struct.gx_device_s*, i8*, i8**, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32)*, i32 (%struct.gx_device_s*, %struct.gx_strip_bitmap_s*, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32*, %struct.gx_strip_bitmap_s*, i32*, i32, i32, i32, i32, i32, i32, i32)*, void (%struct.gx_device_s*, %struct.gs_fixed_rect_s*)* }
  %struct.gs_matrix_s = type { float, float, float, float, float, float }
  %struct.gx_tile_bitmap_s = type { i8*, i32, %struct.gs_int_point_s, i32, i16, i16 }
  %struct.gs_int_point_s = type { i32, i32 }
  %struct.gs_param_list_s = type opaque
  %struct.gx_xfont_procs_s = type opaque
  %struct.gs_imager_state_s = type { %struct.gs_memory_s*, %struct.gx_line_params_s, %struct.gs_matrix_fixed_s, i32, i16, i32, float, %struct.gs_fixed_point_s, i32, i32, %struct.gs_halftone_s*, [2 x %struct.gs_int_point_s], %struct.gx_device_halftone_s*, %struct.gx_ht_cache_s*, %struct.gs_cie_render_s*, %struct.gx_transfer_map_s*, %struct.gx_transfer_map_s*, %union.gx_transfer_s, %union.gx_transfer_s, %struct.gx_cie_joint_caches_s*, %struct.gx_color_map_procs_s*, %struct.gx_pattern_cache_s* }
  %struct.gx_line_params_s = type { float, i32, i32, float, float, float, float, %struct.gx_dash_params_s }
  %struct.gx_dash_params_s = type { float*, i32, float, i32, float, i32, i32, float }
  %struct.gs_matrix_fixed_s = type { float, float, float, float, float, float, i32, i32, i32 }
  %struct.gs_fixed_point_s = type { i32, i32 }
  %struct.gs_halftone_s = type { i32, %struct.rc_header_s, %union.anon }
  %struct.rc_header_s = type { i32, %struct.gs_memory_s*, void (%struct.gs_memory_s*, i8*, i8*)* }
  %union.anon = type { %struct.gs_colorscreen_halftone_s }
  %struct.gs_colorscreen_halftone_s = type { %union._css }
  %union._css = type { [4 x %struct.gs_screen_halftone_s] }
  %struct.gs_screen_halftone_s = type { float, float, float (double, double)*, float, float }
  %struct.gx_device_halftone_s = type { %struct.gx_ht_order_s, %struct.rc_header_s, i32, %struct.gx_ht_order_component_s*, i32, [4 x i32], i32, i32 }
  %struct.gx_ht_order_s = type { %struct.gx_ht_cell_params_s, i16, i16, i16, i16, i16, i16, i32, i32, i32, i32*, %struct.gx_ht_bit_s*, %struct.gx_ht_cache_s*, %struct.gx_transfer_map_s* }
  %struct.gx_ht_cell_params_s = type { i16, i16, i16, i16, i16, i16, i32, i16, i16, i32, i32, i32 }
  %struct.gx_ht_bit_s = type { i32, i32 }
  %struct.gx_ht_order_component_s = type { %struct.gx_ht_order_s, i32 }
  %struct.gx_ht_cache_s = type { i8*, i32, %struct.gx_ht_tile_s*, i32, %struct.gx_ht_order_s, i32, i32, i32 }
  %struct.gx_ht_tile_s = type { %struct.gx_strip_bitmap_s, i32, i32 }
  %struct.gx_strip_bitmap_s = type { i8*, i32, %struct.gs_int_point_s, i32, i16, i16, i16, i16 }
  %struct.gs_cie_render_s = type opaque
  %struct.gx_transfer_map_s = type { %struct.rc_header_s, {}*, i32, [256 x i16] }
  %union.gx_transfer_s = type { [4 x %struct.gx_transfer_map_s*] }
  %struct.gx_cie_joint_caches_s = type opaque
  %struct.gx_color_map_procs_s = type { void (i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, void (i16, i16, i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, void (i16, i16, i16, i16, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)* }
  %struct.gx_pattern_cache_s = type opaque
  %struct.gx_path_s = type { %struct.gs_memory_s*, %struct.gs_fixed_rect_s, %struct.segment_s*, %struct.subpath_s*, %struct.subpath_s*, i32, i32, %struct.gs_fixed_point_s, %struct.gs_point_s, %struct.gs_point_s, i8, i8, i8, i8 }
  %struct.gs_fixed_rect_s = type { %struct.gs_fixed_point_s, %struct.gs_fixed_point_s }
  %struct.segment_s = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s }
  %struct.subpath_s = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s, %struct.segment_s*, i32, %struct.line_close_segment, i8 }
  %struct.line_close_segment = type { %struct.segment_s*, %struct.segment_s*, i16, i16, %struct.gs_fixed_point_s, %struct.subpath_s* }
  %struct.gs_point_s = type { double, double }
  %struct.gx_fill_params_s = type opaque
  %struct.gx_device_color_s = type { %struct.gx_device_color_procs_s*, %union._c, %struct.gs_int_point_s, %struct._mask }
  %struct.gx_device_color_procs_s = type { i32 (%struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)*, i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)* }
  %struct.gx_rop_source_s = type { i8*, i32, i32, i32, [2 x i32], i32 }
  %union._c = type { %struct._col }
  %struct._col = type { %struct.gx_device_halftone_s*, [4 x i8], [4 x i32], i16 }
  %struct._mask = type { %struct.gs_client_color_s, i32, %struct.gx_color_tile_s* }
  %struct.gs_client_color_s = type { %struct.gs_paint_color_s, %struct.gs_pattern_instance_s* }
  %struct.gs_paint_color_s = type { [4 x float] }
  %struct.gs_pattern_instance_s = type opaque
  %struct.gx_color_tile_s = type opaque
  %struct.gx_clip_path_s = type opaque
  %struct.gx_stroke_params_s = type opaque
  %struct.gs_fixed_edge_s = type { %struct.gs_fixed_point_s, %struct.gs_fixed_point_s }
  %struct.gs_image_s = type { i32, i32, %struct.gs_matrix_s, i32, %struct.gs_color_space_s*, [8 x float], i32, i32, i32, i32 }
  %struct.gs_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.1 }
  %struct.gs_color_space_type_s = type { i32, i32, i32, void (%struct.gs_client_color_s*, %struct.gs_color_space_s*)*, %struct.gs_color_space_s* (%struct.gs_color_space_s*, %struct.gs_imager_state_s*)*, i32 (%struct.gs_client_color_s*, %struct.gs_color_space_s*, i16*, %struct.gs_imager_state_s*)*, i32 (i16*, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gs_client_color_s*, %struct.gs_color_space_s*, %struct.gx_device_color_s*, %struct.gs_imager_state_s*, %struct.gx_device_s*, i32)*, i32 (%struct.gs_color_space_s*, %struct.gs_state_s*)*, void (%struct.gs_color_space_s*, %struct.gs_memory_s*, i32)*, void (%struct.gs_client_color_s*, %struct.gs_color_space_s*, %struct.gs_memory_s*, i32)*, %struct.gs_ptr_procs_s* (i8*, i32, i32, i8**)*, void (i8*, i32, %struct.gc_state_s*)* }
  %union.anon.1 = type { %struct.gs_pattern_params_s }
  %struct.gs_pattern_params_s = type { i32, %struct.gs_paint_color_space_s }
  %struct.gs_paint_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.4 }
  %union.anon.4 = type { %struct.gs_indexed_params_s }
  %struct.gs_indexed_params_s = type { %struct.gs_base_color_space_s, i32, %union.anon.3, i32 }
  %struct.gs_base_color_space_s = type { %struct.gs_color_space_type_s*, %union.anon.2 }
  %union.anon.2 = type { %struct.gs_cie_defg_s* }
  %struct.gs_cie_defg_s = type opaque
  %union.anon.3 = type { %struct.gs_const_string_s }
  %struct.gs_const_string_s = type { i8*, i32 }
  %struct.gs_int_rect_s = type { %struct.gs_int_point_s, %struct.gs_int_point_s }
  %struct.gx_image_enum_s = type { i8, i8, i8, i8, i8, i8, i8, i8, %struct.gs_matrix_s, %struct.r_, %struct.gs_fixed_point_s, %struct.gs_fixed_point_s, i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)*, {}*, %struct.gs_imager_state_s*, %struct.gs_color_space_s*, %struct.gs_memory_s*, %struct.gx_device_s*, i8*, i32, i8*, i32, i32, i32, i8, i8, i8, i8, %struct.gs_fixed_rect_s, %struct.gs_fixed_rect_s, i32, i32, i32, i32, %struct.gx_device_clip_s*, %struct.gx_device_rop_texture_s*, %struct.stream_IScale_state_s*, i32, %struct.gs_fixed_point_s, %struct.gs_fixed_point_s, %struct.dd_, i32, i32, %struct.gs_int_point_s, i32, i32, i32, i32, [4 x %struct.sample_map_s], [256 x %struct.gx_image_clue_s] }
  %struct.r_ = type { i32, i32, i32, i32 }
  %union.sample_lookup_s = type { [16 x i32], [192 x i8] }
  %struct.gx_device_clip_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s, %struct.gx_device_s*, %struct.gx_clip_list_s, %struct.gx_clip_rect_s*, %struct.gs_int_point_s }
  %struct.gx_clip_list_s = type { %struct.gx_clip_rect_s, %struct.gx_clip_rect_s*, %struct.gx_clip_rect_s*, i32, i32 }
  %struct.gx_clip_rect_s = type { %struct.gx_clip_rect_s*, %struct.gx_clip_rect_s*, i32, i32, i32, i32, i8 }
  %struct.gx_device_rop_texture_s = type opaque
  %struct.stream_IScale_state_s = type { %struct.stream_template_s*, %struct.gs_memory_s*, i32 (%struct.stream_state_s*, i8*)*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, double, double, i8*, i8*, i8*, %struct.CLIST*, %struct.CONTRIB*, i32, i32, i32, i32, i32, i32, %struct.CLIST, i32, [8 x %struct.CONTRIB] }
  %struct.stream_template_s = type { %struct.gs_memory_struct_type_s*, i32 (%struct.stream_state_s*)*, i32 (%struct.stream_state_s*, %struct.stream_cursor_read_s*, %struct.stream_cursor_write_s*, i32)*, i32, i32, void (%struct.stream_state_s*)*, void (%struct.stream_state_s*)*, i32 (%struct.stream_state_s*)* }
  %struct.stream_state_s = type { %struct.stream_template_s*, %struct.gs_memory_s*, i32 (%struct.stream_state_s*, i8*)* }
  %struct.stream_cursor_read_s = type { i8*, i8*, i8* }
  %struct.stream_cursor_write_s = type { i8*, i8*, i8* }
  %struct.CONTRIB = type { float }
  %struct.CLIST = type { i32, i32, i32 }
  %struct.dd_ = type { %struct.gx_dda_fixed_point_s, %struct.gx_dda_fixed_point_s }
  %struct.gx_dda_fixed_point_s = type { %struct.gx_dda_fixed_s, %struct.gx_dda_fixed_s }
  %struct.gx_dda_fixed_s = type { %struct._a, %struct._e }
  %struct._a = type { i32, i32 }
  %struct._e = type { i32, i32, i32 }
  %struct.sample_map_s = type { %union.sample_lookup_s, [16 x float], double, i32 }
  %struct.gx_image_clue_s = type { %struct.gx_device_color_s, i32 }
  %struct.gx_device_memory_s = type { i32, %struct.gx_device_procs_s*, i8*, %struct.gs_memory_s*, %struct.gs_memory_struct_type_s*, i32, i32, %struct.gx_device_color_info_s, i32, i32, [2 x float], [4 x float], i32, [2 x float], [2 x float], [2 x float], [4 x float], i32, i32, i32, %struct.gx_page_device_procs_s, %struct.gx_device_procs_s, %struct.gx_device_s*, %struct.gs_matrix_s, i32, i32, i8*, i8**, %struct.gs_memory_s*, %struct.gs_const_string_s, %struct._c24, %struct.gs_log2_scale_point_s, i32, i32, i32, i32, i32, i32 }
  %struct._c24 = type { i32, i32, i32, i32 }
  %struct.gs_log2_scale_point_s = type { i32, i32 }
  
  @image_strategies = external global %struct.gx_image_strategies_s, align 4
  @.str = private unnamed_addr constant [11 x i8] c"image line\00", align 1
  @mem_mono_device = external global %struct.gx_device_memory_s, align 4
  @gx_dc_procs_pure = external global %struct.gx_device_color_procs_s, align 4
  @byte_reverse_bits = external global [256 x i8], align 1
  @byte_bit_run_length_0 = external global [256 x i8], align 1
  @image_simple_expand.lmasks = internal unnamed_addr constant [9 x i8] c"\FF\7F?\1F\0F\07\03\01\00", align 1
  @image_simple_expand.rmasks = internal unnamed_addr constant [9 x i8] c"\00\80\C0\E0\F0\F8\FC\FE\FF", align 1
  
  ; Function Attrs: norecurse nounwind
  define void @gs_gximage1_init(%struct.gs_memory_s* nocapture readnone %mem) #0 {
    store i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)* @image_strategy_simple, i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* (%struct.gx_image_enum_s*)** getelementptr inbounds (%struct.gx_image_strategies_s, %struct.gx_image_strategies_s* @image_strategies, i32 0, i32 1), align 4, !tbaa !1
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* @image_strategy_simple(%struct.gx_image_enum_s* %penum) #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 0, i32 0, i32 0
    %2 = load i32, i32* %1, align 4, !tbaa !6
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 1, i32 0, i32 0
    %4 = load i32, i32* %3, align 4, !tbaa !21
    %5 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 24
    %6 = load i8, i8* %5, align 8, !tbaa !22
    %7 = icmp eq i8 %6, 0
    br i1 %7, label %8, label %114
  
  ; <label>:8                                       ; preds = %0
    %9 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 3
    %10 = load i8, i8* %9, align 1, !tbaa !23
    %11 = icmp eq i8 %10, 1
    br i1 %11, label %12, label %114
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %14 = load i8, i8* %13, align 8, !tbaa !24
    %15 = icmp eq i8 %14, 1
    br i1 %15, label %16, label %114
  
  ; <label>:16                                      ; preds = %12
    %17 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 23
    %18 = load i32, i32* %17, align 4, !tbaa !25
    switch i32 %18, label %114 [
      i32 0, label %19
      i32 1, label %56
    ]
  
  ; <label>:19                                      ; preds = %16
    %20 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %21 = load i32, i32* %20, align 8, !tbaa !26
    %22 = add i32 %2, 2047
    %23 = add i32 %22, %21
    %24 = ashr i32 %23, 12
    %25 = ashr i32 %22, 12
    %26 = sub nsw i32 %24, %25
    %27 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 9, i32 2
    %28 = load i32, i32* %27, align 8, !tbaa !27
    %29 = icmp eq i32 %26, %28
    br i1 %29, label %.thread16, label %30
  
  ; <label>:30                                      ; preds = %19
    %31 = icmp slt i32 %26, 0
    %32 = sub nsw i32 0, %26
    %33 = select i1 %31, i32 %32, i32 %26
    %34 = add nsw i32 %33, 31
    %35 = ashr i32 %34, 5
    %36 = shl nsw i32 %35, 2
    %37 = add nsw i32 %36, 4
    %38 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 31
    %39 = load i32, i32* %38, align 8, !tbaa !28
    %40 = icmp eq i32 %39, 0
    br i1 %40, label %41, label %114
  
  ; <label>:41                                      ; preds = %30
    %42 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    store i32 %33, i32* %42, align 8, !tbaa !29
    %43 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    store i32 %37, i32* %43, align 4, !tbaa !30
    %44 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 16
    %45 = load %struct.gs_memory_s*, %struct.gs_memory_s** %44, align 8, !tbaa !31
    %46 = bitcast %struct.gs_memory_s* %45 to i8* (%struct.gs_memory_s*, i32, i8*)**
    %47 = load i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)** %46, align 4, !tbaa !32
    %48 = tail call i8* %47(%struct.gs_memory_s* %45, i32 signext %37, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i32 0, i32 0)) #4
    %49 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    store i8* %48, i8** %49, align 8, !tbaa !35
    %50 = icmp eq i8* %48, null
    br i1 %50, label %51, label %.thread16
  
  ; <label>:51                                      ; preds = %41
    %52 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %53 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 17
    %54 = load %struct.gx_device_s*, %struct.gx_device_s** %53, align 4, !tbaa !36
    %55 = tail call i32 @gx_default_end_image(%struct.gx_device_s* %54, i8* nonnull %52, i32 signext 0) #4
    br label %114
  
  ; <label>:56                                      ; preds = %16
    %57 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 1
    %58 = load i32, i32* %57, align 4, !tbaa !37
    %59 = add i32 %4, 2048
    %60 = add i32 %59, %58
    %61 = ashr i32 %60, 12
    %62 = ashr i32 %59, 12
    %63 = sub nsw i32 %61, %62
    %64 = icmp slt i32 %63, 0
    %65 = sub nsw i32 0, %63
    %66 = select i1 %64, i32 %65, i32 %63
    %67 = add nsw i32 %66, 31
    %68 = and i32 %67, -32
    %69 = shl nsw i32 %66, 2
    %70 = add nsw i32 %69, 28
    %71 = and i32 %70, -32
    %72 = add i32 %71, %68
    %73 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 9, i32 2
    %74 = load i32, i32* %73, align 8, !tbaa !27
    %75 = icmp eq i32 %66, %74
    br i1 %75, label %80, label %76
  
  ; <label>:76                                      ; preds = %56
    %77 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 31
    %78 = load i32, i32* %77, align 8, !tbaa !28
    %79 = icmp eq i32 %78, 0
    br i1 %79, label %80, label %114
  
  ; <label>:80                                      ; preds = %76, %56
    %81 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    store i32 %66, i32* %81, align 8, !tbaa !29
    %82 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    store i32 %72, i32* %82, align 4, !tbaa !30
    %83 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 16
    %84 = load %struct.gs_memory_s*, %struct.gs_memory_s** %83, align 8, !tbaa !31
    %85 = bitcast %struct.gs_memory_s* %84 to i8* (%struct.gs_memory_s*, i32, i8*)**
    %86 = load i8* (%struct.gs_memory_s*, i32, i8*)*, i8* (%struct.gs_memory_s*, i32, i8*)** %85, align 4, !tbaa !32
    %87 = tail call i8* %86(%struct.gs_memory_s* %84, i32 signext %72, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i32 0, i32 0)) #4
    %88 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    store i8* %87, i8** %88, align 8, !tbaa !35
    %89 = icmp eq i8* %87, null
    br i1 %89, label %.critedge, label %.critedge13
  
  .critedge:                                        ; preds = %80
    %90 = bitcast %struct.gx_image_enum_s* %penum to i8*
    %91 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 17
    %92 = load %struct.gx_device_s*, %struct.gx_device_s** %91, align 4, !tbaa !36
    %93 = tail call i32 @gx_default_end_image(%struct.gx_device_s* %92, i8* nonnull %90, i32 signext 0) #4
    br label %114
  
  .critedge13:                                      ; preds = %80
    %94 = add nsw i32 %2, 2048
    %95 = ashr i32 %94, 12
    %96 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    store i32 %95, i32* %96, align 4, !tbaa !38
    %97 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 42
    store i32 %95, i32* %97, align 8, !tbaa !39
    %98 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 1
    %99 = load float, float* %98, align 4, !tbaa !40
    %100 = fpext float %99 to double
    %101 = fadd double %100, 0x3F20000000000000
    %102 = fmul double %101, 4.096000e+03
    %103 = fptosi double %102 to i32
    %104 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 33
    store i32 %103, i32* %104, align 8, !tbaa !41
    br label %.thread16
  
  .thread16:                                        ; preds = %.critedge13, %41, %19
    %rproc.2 = phi i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* [ @image_render_landscape, %.critedge13 ], [ @image_render_simple, %41 ], [ @image_render_simple, %19 ]
    %105 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 0
    %106 = load float, float* %105, align 8, !tbaa !42
    %107 = fpext float %106 to double
    %108 = fadd double %107, 0x3F20000000000000
    %109 = fmul double %108, 4.096000e+03
    %110 = fptosi double %109 to i32
    %111 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 32
    store i32 %110, i32* %111, align 4, !tbaa !43
    %112 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 12
    store i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)* @sample_unpack_copy, i8* (i8*, i32*, i8*, i32, i32, %union.sample_lookup_s*, i32)** %112, align 8, !tbaa !44
    %113 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 1
    store i8 8, i8* %113, align 1, !tbaa !45
    br label %114
  
  ; <label>:114                                     ; preds = %.thread16, %.critedge, %76, %51, %30, %16, %12, %8, %0
    %.4 = phi i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* [ %rproc.2, %.thread16 ], [ null, %12 ], [ null, %8 ], [ null, %0 ], [ null, %.critedge ], [ null, %76 ], [ null, %16 ], [ null, %51 ], [ null, %30 ]
    ret i32 (%struct.gx_image_enum_s*, i8*, i32, i32, i32, %struct.gx_device_s*)* %.4
  }
  
  declare i32 @gx_default_end_image(%struct.gx_device_s*, i8*, i32 signext) #2
  
  ; Function Attrs: nounwind
  define internal i32 @image_render_simple(%struct.gx_image_enum_s* %penum, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) #1 {
    %1 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 0, i32 21, i32 9
    %2 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** %1, align 4, !tbaa !46
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 32
    %4 = load i32, i32* %3, align 4, !tbaa !43
    %5 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 0, i32 0, i32 0
    %6 = load i32, i32* %5, align 4, !tbaa !6
    %7 = add nsw i32 %6, 2047
    %8 = ashr i32 %7, 12
    %9 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 44
    %10 = load i32, i32* %9, align 4, !tbaa !52
    %11 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 45
    %12 = load i32, i32* %11, align 8, !tbaa !53
    %13 = icmp eq i32 %h, 0
    br i1 %13, label %.loopexit, label %14
  
  ; <label>:14                                      ; preds = %0
    %15 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %16 = load i8*, i8** %15, align 8, !tbaa !35
    %17 = icmp eq i8* %16, null
    br i1 %17, label %18, label %21
  
  ; <label>:18                                      ; preds = %14
    %19 = add i32 %w, 7
    %20 = lshr i32 %19, 3
    br label %121
  
  ; <label>:21                                      ; preds = %14
    %22 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** getelementptr inbounds (%struct.gx_device_memory_s, %struct.gx_device_memory_s* @mem_mono_device, i32 0, i32 21, i32 9), align 4, !tbaa !54
    %23 = icmp eq i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)* %2, %22
    %24 = icmp sgt i32 %4, 0
    %or.cond = and i1 %24, %23
    br i1 %or.cond, label %25, label %113
  
  ; <label>:25                                      ; preds = %21
    %26 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0, i32 0
    %27 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %26, align 8, !tbaa !59
    %28 = icmp eq %struct.gx_device_color_procs_s* %27, @gx_dc_procs_pure
    br i1 %28, label %29, label %113
  
  ; <label>:29                                      ; preds = %25
    %30 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0, i32 0
    %31 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %30, align 8, !tbaa !59
    %32 = icmp eq %struct.gx_device_color_procs_s* %31, @gx_dc_procs_pure
    br i1 %32, label %33, label %113
  
  ; <label>:33                                      ; preds = %29
    %34 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0, i32 1
    %35 = bitcast %union._c* %34 to i32*
    %36 = load i32, i32* %35, align 4, !tbaa !64
    %37 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0, i32 1
    %38 = bitcast %union._c* %37 to i32*
    %39 = load i32, i32* %38, align 4, !tbaa !64
    %40 = xor i32 %39, %36
    %41 = icmp eq i32 %40, 1
    br i1 %41, label %42, label %113
  
  ; <label>:42                                      ; preds = %33
    %43 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 25
    %44 = load i8, i8* %43, align 1, !tbaa !65
    %45 = icmp eq i8 %44, 0
    br i1 %45, label %46, label %113
  
  ; <label>:46                                      ; preds = %42
    %47 = mul i32 %4, %w
    %48 = add i32 %47, 2047
    %49 = add i32 %48, %6
    %50 = lshr i32 %49, 12
    %51 = add nsw i32 %50, -1
    %52 = ashr i32 %7, 15
    %53 = ashr i32 %51, 3
    %54 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 1, i32 7, i32 4
    %55 = bitcast i16* %54 to i8***
    %56 = load i8**, i8*** %55, align 4, !tbaa !66
    %57 = getelementptr inbounds i8*, i8** %56, i32 %10
    %58 = load i8*, i8** %57, align 4, !tbaa !67
    %59 = and i32 %8, 31
    %60 = sub nsw i32 %8, %59
    %61 = add nsw i32 %53, 1
    %62 = ashr i32 %60, 3
    %63 = sub nsw i32 %61, %62
    %64 = sub nsw i32 %50, %8
    %65 = getelementptr inbounds i8, i8* %58, i32 %52
    %66 = load i8, i8* %65, align 1, !tbaa !68
    %67 = zext i8 %66 to i32
    %68 = getelementptr inbounds i8, i8* %58, i32 %53
    %69 = load i8, i8* %68, align 1, !tbaa !68
    %70 = zext i8 %69 to i32
    %71 = getelementptr inbounds i8, i8* %58, i32 %62
    %72 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %73 = load i32, i32* %72, align 8, !tbaa !26
    %74 = icmp eq i32 %36, 0
    %75 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 48, i32 0, i32 0, i32 0, i32 0
    %76 = load i32, i32* %75, align 8, !tbaa !69
    %77 = icmp eq i32 %76, 0
    %78 = xor i1 %74, %77
    %79 = sext i1 %78 to i8
    tail call fastcc void @image_simple_expand(i8* %71, i32 signext %59, i32 signext %63, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %6, i32 signext %73, i8 zeroext %79)
    %80 = and i32 %8, 7
    %81 = icmp eq i32 %80, 0
    br i1 %81, label %91, label %82
  
  ; <label>:82                                      ; preds = %46
    %83 = lshr i32 65280, %80
    %84 = and i32 %67, %83
    %85 = load i8, i8* %65, align 1, !tbaa !68
    %86 = zext i8 %85 to i32
    %87 = xor i32 %83, 255
    %88 = and i32 %86, %87
    %89 = add nuw nsw i32 %88, %84
    %90 = trunc i32 %89 to i8
    store i8 %90, i8* %65, align 1, !tbaa !68
    br label %91
  
  ; <label>:91                                      ; preds = %82, %46
    %92 = and i32 %50, 7
    %93 = icmp eq i32 %92, 0
    br i1 %93, label %103, label %94
  
  ; <label>:94                                      ; preds = %91
    %95 = lshr i32 65280, %92
    %96 = load i8, i8* %68, align 1, !tbaa !68
    %97 = zext i8 %96 to i32
    %98 = and i32 %97, %95
    %99 = xor i32 %95, 255
    %100 = and i32 %70, %99
    %101 = add nuw nsw i32 %98, %100
    %102 = trunc i32 %101 to i8
    store i8 %102, i8* %68, align 1, !tbaa !68
    br label %103
  
  ; <label>:103                                     ; preds = %94, %91
    %104 = icmp slt i32 %12, 2
    br i1 %104, label %.loopexit, label %.lr.ph20.preheader
  
  .lr.ph20.preheader:                               ; preds = %103
    %105 = icmp slt i32 %4, 0
    %106 = select i1 %105, i32 %64, i32 0
    %. = sub nsw i32 %8, %106
    br label %.lr.ph20
  
  ; <label>:107                                     ; preds = %.lr.ph20
    %108 = icmp slt i32 %112, %12
    br i1 %108, label %.lr.ph20, label %.loopexit
  
  .lr.ph20:                                         ; preds = %107, %.lr.ph20.preheader
    %dy.018 = phi i32 [ %112, %107 ], [ 1, %.lr.ph20.preheader ]
    %109 = add i32 %10, %dy.018
    %110 = tail call i32 %2(%struct.gx_device_s* %dev, i8* %71, i32 signext %59, i32 signext %63, i32 signext 0, i32 signext %., i32 signext %109, i32 signext %64, i32 signext 1, i32 signext 0, i32 signext 1) #4
    %111 = icmp slt i32 %110, 0
    %112 = add nuw nsw i32 %dy.018, 1
    br i1 %111, label %.loopexit, label %107
  
  ; <label>:113                                     ; preds = %42, %33, %29, %25, %21
    %114 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 21
    %115 = load i32, i32* %114, align 4, !tbaa !30
    %116 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %117 = load i32, i32* %116, align 8, !tbaa !29
    %118 = and i32 %8, 31
    %119 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 10, i32 0
    %120 = load i32, i32* %119, align 8, !tbaa !26
    tail call fastcc void @image_simple_expand(i8* nonnull %16, i32 signext %118, i32 signext %115, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %6, i32 signext %120, i8 zeroext 0)
    br label %121
  
  ; <label>:121                                     ; preds = %113, %18
    %line_x.0 = phi i32 [ 0, %18 ], [ %118, %113 ]
    %line_size.0 = phi i32 [ %20, %18 ], [ %115, %113 ]
    %line_width.0 = phi i32 [ %w, %18 ], [ %117, %113 ]
    %line.0 = phi i8* [ %buffer, %18 ], [ %16, %113 ]
    %122 = icmp slt i32 %4, 0
    %123 = select i1 %122, i32 %line_width.0, i32 0
    %.9 = sub i32 %8, %123
    %124 = icmp sgt i32 %12, 0
    br i1 %124, label %.lr.ph, label %.loopexit
  
  ; <label>:125                                     ; preds = %.lr.ph
    %126 = icmp slt i32 %130, %12
    br i1 %126, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %121, %125
    %dy.114 = phi i32 [ %130, %125 ], [ 0, %121 ]
    %127 = add i32 %10, %dy.114
    %128 = tail call fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %line.0, i32 signext %line_x.0, i32 signext %line_size.0, i32 signext %.9, i32 signext %127, i32 signext %line_width.0, i32 signext 1, %struct.gx_device_s* %dev)
    %129 = icmp slt i32 %128, 0
    %130 = add nuw nsw i32 %dy.114, 1
    br i1 %129, label %.loopexit, label %125
  
  .loopexit:                                        ; preds = %107, %.lr.ph20, %125, %.lr.ph, %121, %103, %0
    %.5 = phi i32 [ 0, %0 ], [ 1, %103 ], [ 1, %121 ], [ 1, %125 ], [ %128, %.lr.ph ], [ 0, %107 ], [ %110, %.lr.ph20 ]
    ret i32 %.5
  }
  
  ; Function Attrs: nounwind
  define internal i32 @image_render_landscape(%struct.gx_image_enum_s* %penum, i8* readonly %buffer, i32 signext %data_x, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %2 = load i8*, i8** %1, align 8, !tbaa !35
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %4 = load i32, i32* %3, align 8, !tbaa !29
    %5 = add i32 %4, 31
    %6 = lshr i32 %5, 5
    %7 = shl nuw nsw i32 %6, 2
    %8 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 46
    %9 = load i32, i32* %8, align 4, !tbaa !70
    %10 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 47
    %11 = load i32, i32* %10, align 8, !tbaa !71
    %12 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 33
    %13 = load i32, i32* %12, align 8, !tbaa !41
    %.lobit = lshr i32 %13, 31
    %14 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 8, i32 2
    %15 = load float, float* %14, align 8, !tbaa !72
    %16 = fcmp olt float %15, 0.000000e+00
    %17 = sub nsw i32 0, %11
    %xinc.0 = select i1 %16, i32 -1, i32 1
    %iw.0 = select i1 %16, i32 %17, i32 %11
    %18 = select i1 %16, i32 %11, i32 0
    %ix.0 = add nsw i32 %18, %9
    %19 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 42
    %20 = load i32, i32* %19, align 8, !tbaa !39
    %21 = icmp eq i32 %ix.0, %20
    br i1 %21, label %33, label %22
  
  ; <label>:22                                      ; preds = %0
    %23 = fcmp olt float %15, 0.000000e+00
    %24 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    %25 = load i32, i32* %24, align 4, !tbaa !38
    br i1 %23, label %28, label %26
  
  ; <label>:26                                      ; preds = %22
    %27 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %25, i32 signext %20, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %30
  
  ; <label>:28                                      ; preds = %22
    %29 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %20, i32 signext %25, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %30
  
  ; <label>:30                                      ; preds = %28, %26
    %31 = phi i32 [ %27, %26 ], [ %29, %28 ]
    %32 = icmp slt i32 %31, 0
    br i1 %32, label %.loopexit, label %.critedge
  
  .critedge:                                        ; preds = %30
    %sunkaddr = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr1 = add i32 %sunkaddr, 276
    %sunkaddr2 = inttoptr i32 %sunkaddr1 to i32*
    store i32 %ix.0, i32* %sunkaddr2, align 4, !tbaa !38
    br label %33
  
  ; <label>:33                                      ; preds = %.critedge, %0
    %34 = icmp eq i32 %h, 0
    br i1 %34, label %65, label %.preheader
  
  .preheader:                                       ; preds = %33
    %35 = icmp eq i32 %iw.0, 0
    br i1 %35, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader
    %36 = fcmp olt float %15, 0.000000e+00
    %37 = sext i1 %36 to i32
    %38 = sub i32 0, %iw.0
    br label %39
  
  ; <label>:39                                      ; preds = %63, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %63 ], [ %38, %.lr.ph ]
    %ix.116 = phi i32 [ %ix.0, %.lr.ph ], [ %ix.3, %63 ]
    %orig_row.014 = phi i8* [ null, %.lr.ph ], [ %orig_row.4, %63 ]
    %.ix.1 = add nsw i32 %ix.116, %37
    %40 = and i32 %.ix.1, 7
    %41 = mul nuw i32 %40, %7
    %42 = getelementptr inbounds i8, i8* %2, i32 %41
    %43 = icmp eq i8* %orig_row.014, null
    br i1 %43, label %44, label %47
  
  ; <label>:44                                      ; preds = %39
    %sunkaddr3 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr4 = add i32 %sunkaddr3, 256
    %sunkaddr5 = inttoptr i32 %sunkaddr4 to i32*
    %45 = load i32, i32* %sunkaddr5, align 4, !tbaa !21
    %sunkaddr6 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr7 = add i32 %sunkaddr6, 52
    %sunkaddr8 = inttoptr i32 %sunkaddr7 to i32*
    %46 = load i32, i32* %sunkaddr8, align 4, !tbaa !37
    tail call fastcc void @image_simple_expand(i8* %42, i32 signext 0, i32 signext %7, i8* %buffer, i32 signext %data_x, i32 signext %w, i32 signext %45, i32 signext %46, i8 zeroext 0)
    br label %48
  
  ; <label>:47                                      ; preds = %39
    tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %42, i8* nonnull %orig_row.014, i32 %7, i32 1, i1 false)
    br label %48
  
  ; <label>:48                                      ; preds = %47, %44
    %orig_row.1 = phi i8* [ %42, %44 ], [ %orig_row.014, %47 ]
    %49 = fcmp olt float %15, 0.000000e+00
    br i1 %49, label %57, label %50
  
  ; <label>:50                                      ; preds = %48
    %51 = add nsw i32 %.ix.1, 1
    %52 = icmp eq i32 %40, 7
    br i1 %52, label %53, label %63
  
  ; <label>:53                                      ; preds = %50
    %sunkaddr9 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr10 = add i32 %sunkaddr9, 276
    %sunkaddr11 = inttoptr i32 %sunkaddr10 to i32*
    %54 = load i32, i32* %sunkaddr11, align 4, !tbaa !38
    %55 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %54, i32 signext %51, i32 signext %.lobit, %struct.gx_device_s* %dev)
    %56 = icmp slt i32 %55, 0
    br i1 %56, label %.loopexit, label %.thread
  
  .thread:                                          ; preds = %53
    %sunkaddr12 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr13 = add i32 %sunkaddr12, 276
    %sunkaddr14 = inttoptr i32 %sunkaddr13 to i32*
    store i32 %51, i32* %sunkaddr14, align 4, !tbaa !38
    br label %63
  
  ; <label>:57                                      ; preds = %48
    %58 = icmp eq i32 %40, 0
    br i1 %58, label %59, label %63
  
  ; <label>:59                                      ; preds = %57
    %sunkaddr15 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr16 = add i32 %sunkaddr15, 276
    %sunkaddr17 = inttoptr i32 %sunkaddr16 to i32*
    %60 = load i32, i32* %sunkaddr17, align 4, !tbaa !38
    %61 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %.ix.1, i32 signext %60, i32 signext %.lobit, %struct.gx_device_s* %dev)
    %62 = icmp slt i32 %61, 0
    br i1 %62, label %.loopexit, label %.thread10
  
  .thread10:                                        ; preds = %59
    %sunkaddr18 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr19 = add i32 %sunkaddr18, 276
    %sunkaddr20 = inttoptr i32 %sunkaddr19 to i32*
    store i32 %.ix.1, i32* %sunkaddr20, align 4, !tbaa !38
    br label %63
  
  ; <label>:63                                      ; preds = %.thread10, %57, %.thread, %50
    %orig_row.4 = phi i8* [ %orig_row.1, %50 ], [ %orig_row.1, %57 ], [ null, %.thread ], [ null, %.thread10 ]
    %ix.3 = phi i32 [ %51, %50 ], [ %.ix.1, %57 ], [ %51, %.thread ], [ %.ix.1, %.thread10 ]
    %lsr.iv.next = add i32 %lsr.iv, %xinc.0
    %64 = icmp eq i32 %lsr.iv.next, 0
    br i1 %64, label %._crit_edge, label %39
  
  ._crit_edge:                                      ; preds = %63, %.preheader
    %ix.1.lcssa = phi i32 [ %ix.0, %.preheader ], [ %ix.3, %63 ]
    %sunkaddr21 = ptrtoint %struct.gx_image_enum_s* %penum to i32
    %sunkaddr22 = add i32 %sunkaddr21, 280
    %sunkaddr23 = inttoptr i32 %sunkaddr22 to i32*
    store i32 %ix.1.lcssa, i32* %sunkaddr23, align 8, !tbaa !39
    br label %.loopexit
  
  ; <label>:65                                      ; preds = %33
    %66 = fcmp olt float %15, 0.000000e+00
    %67 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 41
    %68 = load i32, i32* %67, align 4, !tbaa !38
    br i1 %66, label %71, label %69
  
  ; <label>:69                                      ; preds = %65
    %70 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %68, i32 signext %ix.0, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %.loopexit
  
  ; <label>:71                                      ; preds = %65
    %72 = tail call fastcc i32 @copy_landscape(%struct.gx_image_enum_s* nonnull %penum, i32 signext %ix.0, i32 signext %68, i32 signext %.lobit, %struct.gx_device_s* %dev)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %53, %59, %71, %69, %._crit_edge, %30
    %.6 = phi i32 [ 0, %._crit_edge ], [ %31, %30 ], [ %70, %69 ], [ %72, %71 ], [ %61, %59 ], [ %55, %53 ]
    ret i32 %.6
  }
  
  declare i8* @sample_unpack_copy(i8*, i32*, i8*, i32 signext, i32 signext, %union.sample_lookup_s*, i32 signext) #2
  
  ; Function Attrs: norecurse nounwind
  define internal fastcc void @image_simple_expand(i8* nocapture %line, i32 signext %line_x, i32 signext %raster, i8* readonly %buffer, i32 signext %data_x, i32 signext %w, i32 signext %xcur, i32 signext %x_extent, i8 zeroext %zero) unnamed_addr #0 {
    %1 = and i32 %data_x, 7
    %2 = lshr i32 128, %1
    %3 = lshr i32 255, %1
    %4 = add i32 %1, %w
    %5 = ashr i32 %data_x, 3
    %6 = getelementptr inbounds i8, i8* %buffer, i32 %5
    %7 = lshr i32 %4, 3
    %8 = getelementptr inbounds i8, i8* %6, i32 %7
    %9 = zext i8 %zero to i32
    %10 = xor i32 %9, 255
    %11 = icmp eq i32 %w, 0
    br i1 %11, label %.thread, label %12
  
  ; <label>:12                                      ; preds = %0
    %fold = add i32 %w, %data_x
    %13 = and i32 %fold, 7
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %15, label %17
  
  ; <label>:15                                      ; preds = %12
    %16 = getelementptr inbounds i8, i8* %8, i32 -1
    br label %21
  
  ; <label>:17                                      ; preds = %12
    %18 = xor i32 %13, 7
    %19 = shl i32 2, %18
    %20 = trunc i32 %19 to i8
    br label %21
  
  ; <label>:21                                      ; preds = %17, %15
    %stop.0 = phi i8* [ %16, %15 ], [ %8, %17 ]
    %stopbit.0 = phi i8 [ 1, %15 ], [ %20, %17 ]
    %22 = zext i8 %stopbit.0 to i32
    %23 = sub nsw i32 0, %22
    %24 = shl nsw i32 %23, 1
    %25 = load i8, i8* %stop.0, align 1, !tbaa !68
    %26 = icmp eq i8* %stop.0, %6
    %27 = select i1 %26, i32 %3, i32 -1
    %. = and i32 %24, %27
    %28 = zext i8 %25 to i32
    %29 = and i8 %25, %stopbit.0
    %30 = icmp eq i8 %29, 0
    br i1 %30, label %64, label %31
  
  ; <label>:31                                      ; preds = %21
    %32 = xor i32 %28, 254
    %33 = and i32 %32, %.
    %34 = icmp eq i32 %33, 0
    br i1 %34, label %.preheader16, label %35
  
  ; <label>:35                                      ; preds = %31
    %36 = add nuw nsw i32 %22, 255
    %37 = or i32 %28, %36
    %38 = trunc i32 %37 to i8
    br label %62
  
  .preheader16:                                     ; preds = %31, %40
    %stop.1 = phi i8* [ %41, %40 ], [ %stop.0, %31 ]
    %39 = icmp ugt i8* %stop.1, %6
    br i1 %39, label %40, label %.critedge
  
  ; <label>:40                                      ; preds = %.preheader16
    %41 = getelementptr inbounds i8, i8* %stop.1, i32 -1
    %scevgep11 = getelementptr i8, i8* %stop.1, i32 -1
    %42 = load i8, i8* %scevgep11, align 1, !tbaa !68
    %43 = icmp eq i8 %42, -1
    br i1 %43, label %.preheader16, label %.critedge
  
  .critedge:                                        ; preds = %.preheader16, %40
    %44 = icmp eq i8* %stop.1, %6
    br i1 %44, label %54, label %45
  
  ; <label>:45                                      ; preds = %.critedge
    %46 = getelementptr inbounds i8, i8* %6, i32 1
    %47 = icmp eq i8* %stop.1, %46
    br i1 %47, label %48, label %59
  
  ; <label>:48                                      ; preds = %45
    %49 = load i8, i8* %6, align 1, !tbaa !68
    %50 = zext i8 %49 to i32
    %51 = xor i32 %50, -1
    %52 = and i32 %3, %51
    %53 = icmp eq i32 %52, 0
    br i1 %53, label %54, label %59
  
  ; <label>:54                                      ; preds = %48, %.critedge
    %55 = trunc i32 %10 to i8
    %56 = ashr i32 %line_x, 3
    %57 = getelementptr inbounds i8, i8* %line, i32 %56
    %58 = sub i32 %raster, %56
    tail call void @llvm.memset.p0i8.i32(i8* %57, i8 %55, i32 %58, i32 1, i1 false)
    br label %.thread
  
  ; <label>:59                                      ; preds = %48, %45
    %60 = getelementptr inbounds i8, i8* %stop.1, i32 -1
    %61 = load i8, i8* %60, align 1, !tbaa !68
    br label %62
  
  ; <label>:62                                      ; preds = %59, %35
    %stop.2 = phi i8* [ %stop.0, %35 ], [ %60, %59 ]
    %last.0 = phi i8 [ %38, %35 ], [ %61, %59 ]
    %63 = zext i8 %last.0 to i32
    br label %94
  
  ; <label>:64                                      ; preds = %21
    %stopmask.0 = trunc i32 %. to i8
    %65 = and i8 %stopmask.0, %25
    %66 = icmp eq i8 %65, 0
    br i1 %66, label %.preheader15, label %67
  
  ; <label>:67                                      ; preds = %64
    %68 = and i32 %28, %23
    %69 = trunc i32 %68 to i8
    br label %91
  
  .preheader15:                                     ; preds = %64, %71
    %stop.3 = phi i8* [ %72, %71 ], [ %stop.0, %64 ]
    %70 = icmp ugt i8* %stop.3, %6
    br i1 %70, label %71, label %.critedge3
  
  ; <label>:71                                      ; preds = %.preheader15
    %72 = getelementptr inbounds i8, i8* %stop.3, i32 -1
    %scevgep10 = getelementptr i8, i8* %stop.3, i32 -1
    %73 = load i8, i8* %scevgep10, align 1, !tbaa !68
    %74 = icmp eq i8 %73, 0
    br i1 %74, label %.preheader15, label %.critedge3
  
  .critedge3:                                       ; preds = %.preheader15, %71
    %75 = icmp eq i8* %stop.3, %6
    br i1 %75, label %84, label %76
  
  ; <label>:76                                      ; preds = %.critedge3
    %77 = getelementptr inbounds i8, i8* %6, i32 1
    %78 = icmp eq i8* %stop.3, %77
    br i1 %78, label %79, label %88
  
  ; <label>:79                                      ; preds = %76
    %80 = load i8, i8* %6, align 1, !tbaa !68
    %81 = zext i8 %80 to i32
    %82 = and i32 %81, %3
    %83 = icmp eq i32 %82, 0
    br i1 %83, label %84, label %88
  
  ; <label>:84                                      ; preds = %79, %.critedge3
    %85 = ashr i32 %line_x, 3
    %86 = getelementptr inbounds i8, i8* %line, i32 %85
    %87 = sub i32 %raster, %85
    tail call void @llvm.memset.p0i8.i32(i8* %86, i8 %zero, i32 %87, i32 1, i1 false)
    br label %.thread
  
  ; <label>:88                                      ; preds = %79, %76
    %89 = getelementptr inbounds i8, i8* %stop.3, i32 -1
    %90 = load i8, i8* %89, align 1, !tbaa !68
    br label %91
  
  ; <label>:91                                      ; preds = %88, %67
    %stop.4 = phi i8* [ %stop.0, %67 ], [ %89, %88 ]
    %last.1 = phi i8 [ %69, %67 ], [ %90, %88 ]
    %92 = zext i8 %last.1 to i32
    %93 = xor i32 %92, 255
    br label %94
  
  ; <label>:94                                      ; preds = %91, %62
    %.pn87 = phi i32 [ %63, %62 ], [ %93, %91 ]
    %stop.5 = phi i8* [ %stop.2, %62 ], [ %stop.4, %91 ]
    %.sink8.in = getelementptr inbounds [256 x i8], [256 x i8]* @byte_reverse_bits, i32 0, i32 %.pn87
    %.sink8 = load i8, i8* %.sink8.in, align 1, !tbaa !68
    %95 = zext i8 %.sink8 to i32
    %.sink.in = getelementptr inbounds [256 x i8], [256 x i8]* @byte_bit_run_length_0, i32 0, i32 %95
    %.sink = load i8, i8* %.sink.in, align 1, !tbaa !68
    %96 = zext i8 %.sink to i32
    %stopx.0 = add nsw i32 %96, -1
    %97 = icmp eq i8 %.sink, 0
    %98 = getelementptr inbounds i8, i8* %stop.5, i32 1
    %.stop.5 = select i1 %97, i8* %98, i8* %stop.5
    %stopx.0.op = shl i32 1, %stopx.0
    %99 = trunc i32 %stopx.0.op to i8
    %100 = select i1 %97, i8 -128, i8 %99
    %101 = ashr i32 %line_x, 3
    %102 = getelementptr inbounds i8, i8* %line, i32 %101
    %103 = sub i32 %raster, %101
    tail call void @llvm.memset.p0i8.i32(i8* %102, i8 %zero, i32 %103, i32 1, i1 false)
    %104 = icmp sgt i32 %x_extent, -1
    %105 = add i32 %xcur, 2047
    br i1 %104, label %120, label %106
  
  ; <label>:106                                     ; preds = %94
    %107 = add i32 %105, %x_extent
    %108 = and i32 %107, 4095
    %109 = sub nsw i32 %108, %x_extent
    %110 = shl i32 %line_x, 12
    %111 = add nsw i32 %109, %110
    %112 = sub nsw i32 0, %x_extent
    %113 = udiv i32 %112, %w
    %114 = sub i32 0, %113
    %115 = urem i32 %112, %w
    %116 = icmp eq i32 %115, 0
    br i1 %116, label %126, label %117
  
  ; <label>:117                                     ; preds = %106
    %118 = xor i32 %113, -1
    %119 = sub i32 %w, %115
    br label %126
  
  ; <label>:120                                     ; preds = %94
    %121 = and i32 %105, 4095
    %122 = shl i32 %line_x, 12
    %123 = or i32 %121, %122
    %124 = udiv i32 %x_extent, %w
    %125 = urem i32 %x_extent, %w
    br label %126
  
  ; <label>:126                                     ; preds = %120, %117, %106
    %127 = phi i32 [ %111, %117 ], [ %111, %106 ], [ %123, %120 ]
    %xl.sroa.82.0 = phi i32 [ %118, %117 ], [ %114, %106 ], [ %124, %120 ]
    %xl.sroa.98.0 = phi i32 [ %119, %117 ], [ 0, %106 ], [ %125, %120 ]
    %128 = trunc i32 %2 to i8
    %129 = sub i32 %w, %xl.sroa.98.0
    %130 = icmp ult i32 %xl.sroa.98.0, %129
    %131 = shl i32 %xl.sroa.98.0, 1
    %132 = sub i32 %xl.sroa.98.0, %129
    %133 = add nsw i32 %xl.sroa.82.0, 1
    %dxx4.sroa.16.0 = select i1 %130, i32 %131, i32 %132
    %134 = select i1 %130, i32 %xl.sroa.82.0, i32 %133
    %135 = add nsw i32 %134, %xl.sroa.82.0
    %136 = icmp ult i32 %dxx4.sroa.16.0, %129
    %137 = shl i32 %dxx4.sroa.16.0, 1
    %138 = sub i32 %dxx4.sroa.16.0, %129
    %dxx4.sroa.16.1 = select i1 %136, i32 %137, i32 %138
    %139 = zext i1 %136 to i32
    %factor = shl i32 %135, 1
    %140 = or i32 %139, %factor
    %141 = xor i32 %140, 1
    %142 = icmp ult i32 %dxx4.sroa.16.1, %129
    %143 = shl i32 %dxx4.sroa.16.1, 1
    %144 = sub i32 %dxx4.sroa.16.1, %129
    %145 = add nsw i32 %141, 1
    %dxx8.sroa.16.0 = select i1 %142, i32 %143, i32 %144
    %146 = select i1 %142, i32 %141, i32 %145
    %147 = add nsw i32 %146, %141
    %148 = icmp ult i32 %dxx8.sroa.16.0, %129
    %149 = shl i32 %dxx8.sroa.16.0, 1
    %150 = sub i32 %dxx8.sroa.16.0, %129
    %151 = add nsw i32 %147, 1
    %dxx16.sroa.8.0 = select i1 %148, i32 %149, i32 %150
    %152 = select i1 %148, i32 %147, i32 %151
    %153 = add nsw i32 %152, %147
    %154 = icmp ult i32 %dxx16.sroa.8.0, %129
    %155 = sub i32 0, %129
    %dxx24.sroa.8.0.p = select i1 %154, i32 %dxx8.sroa.16.0, i32 %155
    %dxx24.sroa.8.0 = add i32 %dxx24.sroa.8.0.p, %dxx16.sroa.8.0
    %156 = select i1 %154, i32 %147, i32 %151
    %157 = add nsw i32 %153, %156
    %158 = icmp ult i32 %dxx24.sroa.8.0, %129
    %dxx32.sroa.7.0.p = select i1 %158, i32 %dxx8.sroa.16.0, i32 %155
    %dxx32.sroa.7.0 = add i32 %dxx32.sroa.7.0.p, %dxx24.sroa.8.0
    %159 = select i1 %158, i32 %147, i32 %151
    %160 = add nsw i32 %157, %159
    %161 = load i8, i8* %6, align 1, !tbaa !68
    %162 = add nsw i32 %127, %x_extent
    %163 = sub i32 0, %xl.sroa.98.0
    %164 = sub i32 0, %dxx4.sroa.16.1
    %165 = sub i32 0, %dxx8.sroa.16.0
    %166 = sub i32 0, %dxx32.sroa.7.0
    %167 = sub i32 0, %dxx24.sroa.8.0
    %168 = sub i32 0, %dxx16.sroa.8.0
    %scevgep = getelementptr i8, i8* %line, i32 2
    %scevgep128 = getelementptr i8, i8* %line, i32 1
    br label %.critedge5
  
  .critedge5:                                       ; preds = %334, %126
    %psrc.0 = phi i8* [ %6, %126 ], [ %psrc.6, %334 ]
    %xl.sroa.0.0 = phi i32 [ %127, %126 ], [ %xl.sroa.0.11, %334 ]
    %xl.sroa.27.0 = phi i32 [ %w, %126 ], [ %xl.sroa.27.22, %334 ]
    %data.0 = phi i8 [ %161, %126 ], [ %data.4, %334 ]
    %sbit.0 = phi i8 [ %128, %126 ], [ %sbit.8, %334 ]
    %169 = zext i8 %data.0 to i32
    %170 = xor i32 %169, 255
    %171 = zext i8 %sbit.0 to i32
    %172 = and i32 %171, %170
    %173 = icmp eq i32 %172, 0
    br i1 %173, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.critedge5, %.lr.ph
    %sbit.149 = phi i8 [ %177, %.lr.ph ], [ %sbit.0, %.critedge5 ]
    %xl.sroa.27.148 = phi i32 [ %xl.sroa.27.2, %.lr.ph ], [ %xl.sroa.27.0, %.critedge5 ]
    %xl.sroa.0.147 = phi i32 [ %176, %.lr.ph ], [ %xl.sroa.0.0, %.critedge5 ]
    %174 = icmp ult i32 %xl.sroa.27.148, %xl.sroa.98.0
    %xl.sroa.27.2.p = select i1 %174, i32 %129, i32 %163
    %xl.sroa.27.2 = add i32 %xl.sroa.27.2.p, %xl.sroa.27.148
    %175 = select i1 %174, i32 %133, i32 %xl.sroa.82.0
    %176 = add nsw i32 %175, %xl.sroa.0.147
    %177 = lshr i8 %sbit.149, 1
    %178 = zext i8 %177 to i32
    %179 = and i32 %178, %170
    %180 = icmp eq i32 %179, 0
    br i1 %180, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.critedge5
    %sbit.1.lcssa = phi i8 [ %sbit.0, %.critedge5 ], [ %177, %.lr.ph ]
    %xl.sroa.27.1.lcssa = phi i32 [ %xl.sroa.27.0, %.critedge5 ], [ %xl.sroa.27.2, %.lr.ph ]
    %xl.sroa.0.1.lcssa = phi i32 [ %xl.sroa.0.0, %.critedge5 ], [ %176, %.lr.ph ]
    %181 = icmp eq i8 %sbit.1.lcssa, 0
    br i1 %181, label %.preheader13, label %.loopexit12
  
  .preheader13:                                     ; preds = %._crit_edge
    %182 = getelementptr inbounds i8, i8* %psrc.0, i32 1
    %183 = load i8, i8* %182, align 1, !tbaa !68
    %184 = icmp eq i8 %183, 0
    br i1 %184, label %.lr.ph55.preheader, label %.loopexit14
  
  .lr.ph55.preheader:                               ; preds = %.preheader13
    %scevgep1 = getelementptr i8, i8* %psrc.0, i32 2
    br label %.lr.ph55
  
  .lr.ph55:                                         ; preds = %207, %.lr.ph55.preheader
    %lsr.iv = phi i8* [ %scevgep2, %207 ], [ %scevgep1, %.lr.ph55.preheader ]
    %xl.sroa.27.354 = phi i32 [ %xl.sroa.27.7, %207 ], [ %xl.sroa.27.1.lcssa, %.lr.ph55.preheader ]
    %xl.sroa.0.253 = phi i32 [ %211, %207 ], [ %xl.sroa.0.1.lcssa, %.lr.ph55.preheader ]
    %185 = load i8, i8* %lsr.iv, align 1, !tbaa !68
    %186 = icmp eq i8 %185, 0
    br i1 %186, label %191, label %187
  
  ; <label>:187                                     ; preds = %.lr.ph55
    %188 = icmp ult i32 %xl.sroa.27.354, %dxx8.sroa.16.0
    %xl.sroa.27.4.p = select i1 %188, i32 %129, i32 %165
    %xl.sroa.27.4 = add i32 %xl.sroa.27.4.p, %xl.sroa.27.354
    %189 = select i1 %188, i32 %151, i32 %147
    %190 = add nsw i32 %189, %xl.sroa.0.253
    br label %.loopexit14
  
  ; <label>:191                                     ; preds = %.lr.ph55
    %scevgep8 = getelementptr i8, i8* %lsr.iv, i32 1
    %192 = load i8, i8* %scevgep8, align 1, !tbaa !68
    %193 = icmp eq i8 %192, 0
    %scevgep7 = getelementptr i8, i8* %lsr.iv, i32 1
    br i1 %193, label %199, label %194
  
  ; <label>:194                                     ; preds = %191
    %195 = icmp ult i32 %xl.sroa.27.354, %dxx16.sroa.8.0
    %xl.sroa.27.5.p = select i1 %195, i32 %129, i32 %168
    %xl.sroa.27.5 = add i32 %xl.sroa.27.5.p, %xl.sroa.27.354
    %196 = zext i1 %195 to i32
    %197 = add i32 %xl.sroa.0.253, %153
    %198 = add i32 %197, %196
    br label %.loopexit14
  
  ; <label>:199                                     ; preds = %191
    %scevgep6 = getelementptr i8, i8* %lsr.iv, i32 2
    %200 = load i8, i8* %scevgep6, align 1, !tbaa !68
    %201 = icmp eq i8 %200, 0
    %scevgep5 = getelementptr i8, i8* %lsr.iv, i32 2
    br i1 %201, label %207, label %202
  
  ; <label>:202                                     ; preds = %199
    %203 = icmp ult i32 %xl.sroa.27.354, %dxx24.sroa.8.0
    %xl.sroa.27.6.p = select i1 %203, i32 %129, i32 %167
    %xl.sroa.27.6 = add i32 %xl.sroa.27.6.p, %xl.sroa.27.354
    %204 = zext i1 %203 to i32
    %205 = add i32 %xl.sroa.0.253, %157
    %206 = add i32 %205, %204
    br label %.loopexit14
  
  ; <label>:207                                     ; preds = %199
    %208 = icmp ult i32 %xl.sroa.27.354, %dxx32.sroa.7.0
    %xl.sroa.27.7.p = select i1 %208, i32 %129, i32 %166
    %xl.sroa.27.7 = add i32 %xl.sroa.27.7.p, %xl.sroa.27.354
    %209 = zext i1 %208 to i32
    %210 = add i32 %160, %xl.sroa.0.253
    %211 = add i32 %210, %209
    %scevgep4 = getelementptr i8, i8* %lsr.iv, i32 3
    %212 = load i8, i8* %scevgep4, align 1, !tbaa !68
    %213 = icmp eq i8 %212, 0
    %scevgep2 = getelementptr i8, i8* %lsr.iv, i32 4
    %scevgep3 = getelementptr i8, i8* %scevgep2, i32 -1
    br i1 %213, label %.lr.ph55, label %.loopexit14
  
  .loopexit14:                                      ; preds = %207, %202, %194, %187, %.preheader13
    %psrc.2 = phi i8* [ %lsr.iv, %187 ], [ %scevgep7, %194 ], [ %scevgep5, %202 ], [ %182, %.preheader13 ], [ %scevgep3, %207 ]
    %xl.sroa.0.3 = phi i32 [ %190, %187 ], [ %198, %194 ], [ %206, %202 ], [ %xl.sroa.0.1.lcssa, %.preheader13 ], [ %211, %207 ]
    %xl.sroa.27.8 = phi i32 [ %xl.sroa.27.4, %187 ], [ %xl.sroa.27.5, %194 ], [ %xl.sroa.27.6, %202 ], [ %xl.sroa.27.1.lcssa, %.preheader13 ], [ %xl.sroa.27.7, %207 ]
    %data.1 = phi i8 [ %185, %187 ], [ %192, %194 ], [ %200, %202 ], [ %183, %.preheader13 ], [ %212, %207 ]
    %214 = zext i8 %data.1 to i32
    %215 = icmp ugt i8 %data.1, 15
    br i1 %215, label %220, label %216
  
  ; <label>:216                                     ; preds = %.loopexit14
    %217 = icmp ult i32 %xl.sroa.27.8, %dxx4.sroa.16.1
    %xl.sroa.27.9.p = select i1 %217, i32 %129, i32 %164
    %xl.sroa.27.9 = add i32 %xl.sroa.27.9.p, %xl.sroa.27.8
    %218 = select i1 %217, i32 %145, i32 %141
    %219 = add nsw i32 %218, %xl.sroa.0.3
    br label %220
  
  ; <label>:220                                     ; preds = %216, %.loopexit14
    %xl.sroa.0.4 = phi i32 [ %219, %216 ], [ %xl.sroa.0.3, %.loopexit14 ]
    %xl.sroa.27.10 = phi i32 [ %xl.sroa.27.9, %216 ], [ %xl.sroa.27.8, %.loopexit14 ]
    %sbit.2 = phi i8 [ 8, %216 ], [ -128, %.loopexit14 ]
    %221 = xor i32 %214, 255
    %222 = zext i8 %sbit.2 to i32
    %223 = and i32 %222, %221
    %224 = icmp eq i32 %223, 0
    br i1 %224, label %.loopexit12, label %.lr.ph64
  
  .lr.ph64:                                         ; preds = %220, %.lr.ph64
    %sbit.362 = phi i8 [ %228, %.lr.ph64 ], [ %sbit.2, %220 ]
    %xl.sroa.27.1161 = phi i32 [ %xl.sroa.27.12, %.lr.ph64 ], [ %xl.sroa.27.10, %220 ]
    %xl.sroa.0.560 = phi i32 [ %227, %.lr.ph64 ], [ %xl.sroa.0.4, %220 ]
    %225 = icmp ult i32 %xl.sroa.27.1161, %xl.sroa.98.0
    %xl.sroa.27.12.p = select i1 %225, i32 %129, i32 %163
    %xl.sroa.27.12 = add i32 %xl.sroa.27.12.p, %xl.sroa.27.1161
    %226 = select i1 %225, i32 %133, i32 %xl.sroa.82.0
    %227 = add nsw i32 %226, %xl.sroa.0.560
    %228 = lshr i8 %sbit.362, 1
    %229 = zext i8 %228 to i32
    %230 = and i32 %229, %221
    %231 = icmp eq i32 %230, 0
    br i1 %231, label %.loopexit12, label %.lr.ph64
  
  .loopexit12:                                      ; preds = %.lr.ph64, %220, %._crit_edge
    %psrc.3 = phi i8* [ %psrc.0, %._crit_edge ], [ %psrc.2, %220 ], [ %psrc.2, %.lr.ph64 ]
    %xl.sroa.0.6 = phi i32 [ %xl.sroa.0.1.lcssa, %._crit_edge ], [ %xl.sroa.0.4, %220 ], [ %227, %.lr.ph64 ]
    %xl.sroa.27.13 = phi i32 [ %xl.sroa.27.1.lcssa, %._crit_edge ], [ %xl.sroa.27.10, %220 ], [ %xl.sroa.27.12, %.lr.ph64 ]
    %data.2.in = phi i32 [ %170, %._crit_edge ], [ %221, %220 ], [ %221, %.lr.ph64 ]
    %sbit.4 = phi i8 [ %sbit.1.lcssa, %._crit_edge ], [ %sbit.2, %220 ], [ %228, %.lr.ph64 ]
    %232 = ashr i32 %xl.sroa.0.6, 12
    %233 = icmp uge i8* %psrc.3, %.stop.5
    %234 = icmp eq i8 %sbit.4, %100
    %or.cond = and i1 %233, %234
    br i1 %or.cond, label %235, label %236
  
  ; <label>:235                                     ; preds = %.loopexit12
    %data.2 = trunc i32 %data.2.in to i8
    br label %.loopexit10
  
  ; <label>:236                                     ; preds = %.loopexit12
    %237 = xor i32 %data.2.in, 255
    br label %238
  
  ; <label>:238                                     ; preds = %238, %236
    %xl.sroa.0.7 = phi i32 [ %xl.sroa.0.6, %236 ], [ %241, %238 ]
    %xl.sroa.27.14 = phi i32 [ %xl.sroa.27.13, %236 ], [ %xl.sroa.27.15, %238 ]
    %sbit.5 = phi i8 [ %sbit.4, %236 ], [ %242, %238 ]
    %239 = icmp ult i32 %xl.sroa.27.14, %xl.sroa.98.0
    %xl.sroa.27.15.p = select i1 %239, i32 %129, i32 %163
    %xl.sroa.27.15 = add i32 %xl.sroa.27.15.p, %xl.sroa.27.14
    %240 = select i1 %239, i32 %133, i32 %xl.sroa.82.0
    %241 = add nsw i32 %240, %xl.sroa.0.7
    %242 = lshr i8 %sbit.5, 1
    %243 = zext i8 %242 to i32
    %244 = and i32 %243, %237
    %245 = icmp eq i32 %244, 0
    br i1 %245, label %246, label %238
  
  ; <label>:246                                     ; preds = %238
    %247 = trunc i32 %237 to i8
    %248 = icmp eq i8 %242, 0
    br i1 %248, label %.preheader11, label %.loopexit10
  
  .preheader11:                                     ; preds = %246
    %249 = getelementptr inbounds i8, i8* %psrc.3, i32 1
    %250 = load i8, i8* %249, align 1, !tbaa !68
    %251 = icmp eq i8 %250, -1
    br i1 %251, label %.lr.ph70, label %._crit_edge71
  
  .lr.ph70:                                         ; preds = %.preheader11, %.lr.ph70
    %252 = phi i8* [ %256, %.lr.ph70 ], [ %249, %.preheader11 ]
    %xl.sroa.27.1669 = phi i32 [ %xl.sroa.27.17, %.lr.ph70 ], [ %xl.sroa.27.15, %.preheader11 ]
    %xl.sroa.0.868 = phi i32 [ %255, %.lr.ph70 ], [ %241, %.preheader11 ]
    %253 = icmp ult i32 %xl.sroa.27.1669, %dxx8.sroa.16.0
    %xl.sroa.27.17.p = select i1 %253, i32 %129, i32 %165
    %xl.sroa.27.17 = add i32 %xl.sroa.27.17.p, %xl.sroa.27.1669
    %254 = select i1 %253, i32 %151, i32 %147
    %255 = add nsw i32 %254, %xl.sroa.0.868
    %256 = getelementptr inbounds i8, i8* %252, i32 1
    %scevgep9 = getelementptr i8, i8* %252, i32 1
    %257 = load i8, i8* %scevgep9, align 1, !tbaa !68
    %258 = icmp eq i8 %257, -1
    br i1 %258, label %.lr.ph70, label %._crit_edge71
  
  ._crit_edge71:                                    ; preds = %.lr.ph70, %.preheader11
    %.lcssa45 = phi i8 [ %250, %.preheader11 ], [ %257, %.lr.ph70 ]
    %.lcssa44 = phi i8* [ %249, %.preheader11 ], [ %256, %.lr.ph70 ]
    %xl.sroa.27.16.lcssa = phi i32 [ %xl.sroa.27.15, %.preheader11 ], [ %xl.sroa.27.17, %.lr.ph70 ]
    %xl.sroa.0.8.lcssa = phi i32 [ %241, %.preheader11 ], [ %255, %.lr.ph70 ]
    %259 = icmp ult i8 %.lcssa45, -16
    br i1 %259, label %.preheader9, label %260
  
  ; <label>:260                                     ; preds = %._crit_edge71
    %261 = icmp ult i32 %xl.sroa.27.16.lcssa, %dxx4.sroa.16.1
    %xl.sroa.27.18.p = select i1 %261, i32 %129, i32 %164
    %xl.sroa.27.18 = add i32 %xl.sroa.27.18.p, %xl.sroa.27.16.lcssa
    %262 = select i1 %261, i32 %145, i32 %141
    %263 = add nsw i32 %262, %xl.sroa.0.8.lcssa
    br label %.preheader9
  
  .preheader9:                                      ; preds = %260, %._crit_edge71
    %xl.sroa.0.9.ph = phi i32 [ %xl.sroa.0.8.lcssa, %._crit_edge71 ], [ %263, %260 ]
    %xl.sroa.27.19.ph = phi i32 [ %xl.sroa.27.16.lcssa, %._crit_edge71 ], [ %xl.sroa.27.18, %260 ]
    %sbit.6.ph = phi i8 [ -128, %._crit_edge71 ], [ 8, %260 ]
    %264 = and i8 %sbit.6.ph, %.lcssa45
    %265 = icmp eq i8 %264, 0
    br i1 %265, label %.loopexit10, label %.lr.ph79
  
  .lr.ph79:                                         ; preds = %.preheader9, %.lr.ph79
    %sbit.678 = phi i8 [ %269, %.lr.ph79 ], [ %sbit.6.ph, %.preheader9 ]
    %xl.sroa.27.1977 = phi i32 [ %xl.sroa.27.20, %.lr.ph79 ], [ %xl.sroa.27.19.ph, %.preheader9 ]
    %xl.sroa.0.976 = phi i32 [ %268, %.lr.ph79 ], [ %xl.sroa.0.9.ph, %.preheader9 ]
    %266 = icmp ult i32 %xl.sroa.27.1977, %xl.sroa.98.0
    %xl.sroa.27.20.p = select i1 %266, i32 %129, i32 %163
    %xl.sroa.27.20 = add i32 %xl.sroa.27.20.p, %xl.sroa.27.1977
    %267 = select i1 %266, i32 %133, i32 %xl.sroa.82.0
    %268 = add nsw i32 %267, %xl.sroa.0.976
    %269 = lshr i8 %sbit.678, 1
    %270 = and i8 %269, %.lcssa45
    %271 = icmp eq i8 %270, 0
    br i1 %271, label %.loopexit10, label %.lr.ph79
  
  .loopexit10:                                      ; preds = %.lr.ph79, %.preheader9, %246, %235
    %psrc.6 = phi i8* [ %psrc.3, %235 ], [ %psrc.3, %246 ], [ %.lcssa44, %.preheader9 ], [ %.lcssa44, %.lr.ph79 ]
    %xl.sroa.0.11 = phi i32 [ %xl.sroa.0.6, %235 ], [ %241, %246 ], [ %xl.sroa.0.9.ph, %.preheader9 ], [ %268, %.lr.ph79 ]
    %xl.sroa.27.22 = phi i32 [ %xl.sroa.27.13, %235 ], [ %xl.sroa.27.15, %246 ], [ %xl.sroa.27.19.ph, %.preheader9 ], [ %xl.sroa.27.20, %.lr.ph79 ]
    %data.4 = phi i8 [ %data.2, %235 ], [ %247, %246 ], [ %.lcssa45, %.preheader9 ], [ %.lcssa45, %.lr.ph79 ]
    %.pn.in = phi i32 [ %162, %235 ], [ %241, %246 ], [ %xl.sroa.0.9.ph, %.preheader9 ], [ %268, %.lr.ph79 ]
    %sbit.8 = phi i8 [ %100, %235 ], [ %242, %246 ], [ %sbit.6.ph, %.preheader9 ], [ %269, %.lr.ph79 ]
    %.pn = ashr i32 %.pn.in, 12
    %n.0 = sub nsw i32 %.pn, %232
    %272 = icmp slt i32 %n.0, 0
    %273 = sub nsw i32 0, %n.0
    %.pn. = select i1 %272, i32 %.pn, i32 %232
    %.n.0 = select i1 %272, i32 %273, i32 %n.0
    %274 = ashr i32 %.pn., 3
    %275 = getelementptr inbounds i8, i8* %line, i32 %274
    %276 = and i32 %.pn., 7
    %277 = add nsw i32 %276, %.n.0
    %278 = icmp slt i32 %277, 9
    br i1 %278, label %279, label %291
  
  ; <label>:279                                     ; preds = %.loopexit10
    %280 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %276
    %281 = load i8, i8* %280, align 1, !tbaa !68
    %282 = zext i8 %281 to i32
    %283 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %277
    %284 = load i8, i8* %283, align 1, !tbaa !68
    %285 = zext i8 %284 to i32
    %286 = sub nsw i32 %282, %285
    %287 = load i8, i8* %275, align 1, !tbaa !68
    %288 = zext i8 %287 to i32
    %289 = xor i32 %288, %286
    %290 = trunc i32 %289 to i8
    store i8 %290, i8* %275, align 1, !tbaa !68
    br label %334
  
  ; <label>:291                                     ; preds = %.loopexit10
    %292 = add nsw i32 %277, -8
    %293 = icmp slt i32 %292, 9
    %294 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.lmasks, i32 0, i32 %276
    %295 = load i8, i8* %294, align 1, !tbaa !68
    br i1 %293, label %296, label %304
  
  ; <label>:296                                     ; preds = %291
    %297 = load i8, i8* %275, align 1, !tbaa !68
    %298 = xor i8 %297, %295
    store i8 %298, i8* %275, align 1, !tbaa !68
    %299 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.rmasks, i32 0, i32 %292
    %300 = load i8, i8* %299, align 1, !tbaa !68
    %301 = getelementptr inbounds i8, i8* %275, i32 1
    %302 = load i8, i8* %301, align 1, !tbaa !68
    %303 = xor i8 %302, %300
    store i8 %303, i8* %301, align 1, !tbaa !68
    br label %334
  
  ; <label>:304                                     ; preds = %291
    %305 = getelementptr inbounds i8, i8* %275, i32 1
    %306 = load i8, i8* %275, align 1, !tbaa !68
    %307 = xor i8 %306, %295
    store i8 %307, i8* %275, align 1, !tbaa !68
    %308 = icmp sgt i32 %292, 55
    br i1 %308, label %322, label %.preheader
  
  .preheader:                                       ; preds = %304
    %309 = add nsw i32 %277, -16
    %310 = icmp sgt i32 %309, -1
    br i1 %310, label %.lr.ph84.preheader, label %.loopexit
  
  .lr.ph84.preheader:                               ; preds = %.preheader
    %311 = trunc i32 %10 to i8
    %312 = add nsw i32 %232, -1
    %313 = sub nsw i32 %312, %.pn
    %314 = icmp sgt i32 %313, -1
    %smax = select i1 %314, i32 %313, i32 -1
    %315 = sub nsw i32 %312, %smax
    %316 = and i32 %315, 7
    %317 = add nsw i32 %.n.0, -16
    %318 = add nsw i32 %317, %316
    %319 = lshr i32 %318, 3
    %320 = add nsw i32 %274, %319
    %scevgep129 = getelementptr i8, i8* %scevgep128, i32 %274
    %321 = add nuw nsw i32 %319, 1
    call void @llvm.memset.p0i8.i32(i8* %scevgep129, i8 %311, i32 %321, i32 1, i1 false)
    br label %.lr.ph84
  
  ; <label>:322                                     ; preds = %304
    %323 = trunc i32 %10 to i8
    %324 = ashr i32 %292, 3
    tail call void @llvm.memset.p0i8.i32(i8* %305, i8 %323, i32 %324, i32 1, i1 false)
    %325 = getelementptr inbounds i8, i8* %305, i32 %324
    br label %.loopexit
  
  .lr.ph84:                                         ; preds = %.lr.ph84, %.lr.ph84.preheader
    %326 = phi i32 [ %327, %.lr.ph84 ], [ %309, %.lr.ph84.preheader ]
    %327 = add nsw i32 %326, -8
    %328 = icmp sgt i32 %327, -1
    br i1 %328, label %.lr.ph84, label %.loopexit.loopexit
  
  .loopexit.loopexit:                               ; preds = %.lr.ph84
    %scevgep127 = getelementptr i8, i8* %scevgep, i32 %320
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.loopexit.loopexit, %322, %.preheader
    %n.3 = phi i32 [ %292, %322 ], [ %309, %.preheader ], [ %327, %.loopexit.loopexit ]
    %bp.1 = phi i8* [ %325, %322 ], [ %305, %.preheader ], [ %scevgep127, %.loopexit.loopexit ]
    %329 = and i32 %n.3, 7
    %330 = getelementptr inbounds [9 x i8], [9 x i8]* @image_simple_expand.rmasks, i32 0, i32 %329
    %331 = load i8, i8* %330, align 1, !tbaa !68
    %332 = load i8, i8* %bp.1, align 1, !tbaa !68
    %333 = xor i8 %332, %331
    store i8 %333, i8* %bp.1, align 1, !tbaa !68
    br label %334
  
  ; <label>:334                                     ; preds = %.loopexit, %296, %279
    %335 = icmp uge i8* %psrc.6, %.stop.5
    %336 = icmp eq i8 %sbit.8, %100
    %or.cond4 = and i1 %335, %336
    br i1 %or.cond4, label %.thread, label %.critedge5
  
  .thread:                                          ; preds = %334, %84, %54, %0
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %data, i32 signext %dx, i32 signext %raster, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev) unnamed_addr #1 {
    %1 = ptrtoint i8* %data to i32
    %2 = and i32 %1, 3
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 48, i32 0, i32 0, i32 0, i32 0
    %4 = load i32, i32* %3, align 8, !tbaa !69
    %5 = icmp eq i32 %4, 0
    %6 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 255, i32 0
    %7 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 49, i32 0, i32 0
    %pdc0.0 = select i1 %5, %struct.gx_device_color_s* %7, %struct.gx_device_color_s* %6
    %pdc1.0 = select i1 %5, %struct.gx_device_color_s* %6, %struct.gx_device_color_s* %7
    %8 = sub nsw i32 0, %2
    %9 = getelementptr inbounds i8, i8* %data, i32 %8
    %10 = shl nuw nsw i32 %2, 3
    %11 = add i32 %10, %dx
    %12 = bitcast %struct.gx_device_color_s* %pdc0.0 to %struct.gx_device_color_procs_s**
    %13 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %12, align 4, !tbaa !59
    %14 = icmp eq %struct.gx_device_color_procs_s* %13, @gx_dc_procs_pure
    %15 = bitcast %struct.gx_device_color_s* %pdc1.0 to %struct.gx_device_color_procs_s**
    %16 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %15, align 4, !tbaa !59
    br i1 %14, label %17, label %35
  
  ; <label>:17                                      ; preds = %0
    %18 = icmp eq %struct.gx_device_color_procs_s* %16, @gx_dc_procs_pure
    br i1 %18, label %19, label %42
  
  ; <label>:19                                      ; preds = %17
    %20 = icmp eq i32 %h, 1
    %21 = and i32 %raster, 3
    %22 = icmp eq i32 %21, 0
    %or.cond = or i1 %22, %20
    br i1 %or.cond, label %23, label %26
  
  ; <label>:23                                      ; preds = %19
    %24 = getelementptr inbounds %struct.gx_device_s, %struct.gx_device_s* %dev, i32 0, i32 21, i32 9
    %25 = load i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)*, i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)** %24, align 4, !tbaa !46
    br label %26
  
  ; <label>:26                                      ; preds = %23, %19
    %27 = phi i32 (%struct.gx_device_s*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32)* [ %25, %23 ], [ @gx_copy_mono_unaligned, %19 ]
    %28 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc0.0, i32 0, i32 1
    %29 = bitcast %union._c* %28 to i32*
    %30 = load i32, i32* %29, align 4, !tbaa !64
    %31 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc1.0, i32 0, i32 1
    %32 = bitcast %union._c* %31 to i32*
    %33 = load i32, i32* %32, align 4, !tbaa !64
    %34 = tail call i32 %27(%struct.gx_device_s* %dev, i8* %9, i32 signext %11, i32 signext %raster, i32 signext 0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, i32 signext %30, i32 signext %33) #4
    br label %56
  
  ; <label>:35                                      ; preds = %0
    %36 = icmp eq %struct.gx_device_color_procs_s* %16, @gx_dc_procs_pure
    br i1 %36, label %37, label %.thread3
  
  ; <label>:37                                      ; preds = %35
    %38 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc1.0, i32 0, i32 1
    %39 = bitcast %union._c* %38 to i32*
    %40 = load i32, i32* %39, align 4, !tbaa !64
    %41 = icmp eq i32 %40, -1
    br i1 %41, label %50, label %.thread3
  
  ; <label>:42                                      ; preds = %17
    %43 = getelementptr inbounds %struct.gx_device_color_s, %struct.gx_device_color_s* %pdc0.0, i32 0, i32 1
    %44 = bitcast %union._c* %43 to i32*
    %45 = load i32, i32* %44, align 4, !tbaa !64
    %46 = icmp eq i32 %45, -1
    br i1 %46, label %50, label %.thread3
  
  .thread3:                                         ; preds = %42, %37, %35
    %47 = getelementptr inbounds %struct.gx_device_color_procs_s, %struct.gx_device_color_procs_s* %13, i32 0, i32 1
    %48 = load i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)*, i32 (%struct.gx_device_color_s*, i32, i32, i32, i32, %struct.gx_device_s*, i32, %struct.gx_rop_source_s*)** %47, align 4, !tbaa !73
    %49 = tail call i32 %48(%struct.gx_device_color_s* nonnull %pdc0.0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev, i32 signext 252, %struct.gx_rop_source_s* null) #4
    %not. = icmp sgt i32 %49, -1
    br i1 %not., label %50, label %56
  
  ; <label>:50                                      ; preds = %.thread3, %42, %37
    %pdc.0 = phi %struct.gx_device_color_s* [ %pdc0.0, %37 ], [ %pdc1.0, %.thread3 ], [ %pdc1.0, %42 ]
    %invert.0 = phi i32 [ 1, %37 ], [ 0, %.thread3 ], [ 0, %42 ]
    %51 = bitcast %struct.gx_device_color_s* %pdc.0 to %struct.gx_device_color_procs_s**
    %52 = load %struct.gx_device_color_procs_s*, %struct.gx_device_color_procs_s** %51, align 4, !tbaa !59
    %53 = getelementptr inbounds %struct.gx_device_color_procs_s, %struct.gx_device_color_procs_s* %52, i32 0, i32 2
    %54 = load i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)*, i32 (%struct.gx_device_color_s*, i8*, i32, i32, i32, i32, i32, i32, i32, %struct.gx_device_s*, i32, i32)** %53, align 4, !tbaa !75
    %55 = tail call i32 %54(%struct.gx_device_color_s* %pdc.0, i8* %9, i32 signext %11, i32 signext %raster, i32 signext 0, i32 signext %x, i32 signext %y, i32 signext %w, i32 signext %h, %struct.gx_device_s* %dev, i32 signext 252, i32 signext %invert.0) #4
    br label %56
  
  ; <label>:56                                      ; preds = %50, %.thread3, %26
    %.2 = phi i32 [ %34, %26 ], [ %55, %50 ], [ %49, %.thread3 ]
    ret i32 %.2
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #3
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture readonly, i32, i32, i1) #3
  
  declare i32 @gx_copy_mono_unaligned(%struct.gx_device_s*, i8*, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext, i32 signext) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @copy_landscape(%struct.gx_image_enum_s* %penum, i32 signext %x0, i32 signext %x1, i32 signext %y_neg, %struct.gx_device_s* %dev) unnamed_addr #1 {
    %1 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 20
    %2 = load i8*, i8** %1, align 8, !tbaa !35
    %3 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 22
    %4 = load i32, i32* %3, align 8, !tbaa !29
    %5 = add i32 %4, 31
    %6 = lshr i32 %5, 5
    %7 = shl nuw nsw i32 %6, 2
    %8 = shl nuw i32 %6, 5
    %9 = getelementptr inbounds i8, i8* %2, i32 %8
    %10 = sub nsw i32 %x1, %x0
    %11 = getelementptr inbounds %struct.gx_image_enum_s, %struct.gx_image_enum_s* %penum, i32 0, i32 40, i32 1, i32 1, i32 0, i32 0
    %12 = load i32, i32* %11, align 4, !tbaa !21
    %13 = add nsw i32 %12, 2047
    %14 = ashr i32 %13, 12
    %15 = icmp eq i32 %x1, %x0
    %16 = icmp eq i32 %4, 0
    %or.cond = or i1 %15, %16
    br i1 %or.cond, label %34, label %17
  
  ; <label>:17                                      ; preds = %0
    %18 = add i32 %4, -1
    %19 = lshr i32 %18, 3
    %20 = add i32 %19, 1
    %21 = shl i32 %19, 5
    %22 = add i32 %4, 31
    %23 = lshr i32 %22, 5
    %24 = shl i32 %23, 5
    %25 = add i32 %21, %24
    %scevgep = getelementptr i8, i8* %2, i32 %25
    br label %26
  
  ; <label>:26                                      ; preds = %26, %17
    %lsr.iv1 = phi i8* [ %scevgep2, %26 ], [ %scevgep, %17 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %26 ], [ %20, %17 ]
    %scevgep3 = getelementptr i8, i8* %2, i32 %lsr.iv
    %scevgep4 = getelementptr i8, i8* %scevgep3, i32 -1
    tail call void @memflip8x8(i8* %scevgep4, i32 signext %7, i8* %lsr.iv1, i32 signext 4) #4
    %lsr.iv.next = add nsw i32 %lsr.iv, -1
    %scevgep2 = getelementptr i8, i8* %lsr.iv1, i32 -32
    %27 = icmp sgt i32 %lsr.iv.next, 0
    br i1 %27, label %26, label %.loopexit
  
  .loopexit:                                        ; preds = %26
    %28 = icmp slt i32 %10, 0
    %29 = sub nsw i32 0, %10
    %x1.x0 = select i1 %28, i32 %x1, i32 %x0
    %. = select i1 %28, i32 %29, i32 %10
    %30 = icmp eq i32 %y_neg, 0
    %31 = select i1 %30, i32 0, i32 %4
    %y.0 = sub i32 %14, %31
    %32 = and i32 %x1.x0, 7
    %33 = tail call fastcc i32 @copy_portrait(%struct.gx_image_enum_s* %penum, i8* %9, i32 signext %32, i32 signext 4, i32 signext %x1.x0, i32 signext %y.0, i32 signext %., i32 signext %4, %struct.gx_device_s* %dev)
    br label %34
  
  ; <label>:34                                      ; preds = %.loopexit, %0
    %.0 = phi i32 [ %33, %.loopexit ], [ 0, %0 ]
    ret i32 %.0
  }
  
  declare void @memflip8x8(i8*, i32 signext, i8*, i32 signext) #2
  
  attributes #0 = { norecurse nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #4 = { nounwind }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !3, i64 4}
  !2 = !{!"gx_image_strategies_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16}
  !3 = !{!"any pointer", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !13, i64 236}
  !7 = !{!"gx_image_enum_s", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3, !4, i64 4, !4, i64 5, !4, i64 6, !4, i64 7, !8, i64 8, !10, i64 32, !12, i64 48, !12, i64 56, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76, !3, i64 80, !3, i64 84, !3, i64 88, !11, i64 92, !3, i64 96, !11, i64 100, !11, i64 104, !4, i64 108, !4, i64 112, !4, i64 113, !4, i64 114, !4, i64 115, !14, i64 116, !14, i64 132, !11, i64 148, !13, i64 152, !13, i64 156, !13, i64 160, !3, i64 164, !3, i64 168, !3, i64 172, !11, i64 176, !12, i64 180, !12, i64 188, !15, i64 196, !11, i64 276, !11, i64 280, !20, i64 284, !11, i64 292, !11, i64 296, !11, i64 300, !11, i64 304, !4, i64 312, !4, i64 1656}
  !8 = !{!"gs_matrix_s", !9, i64 0, !9, i64 4, !9, i64 8, !9, i64 12, !9, i64 16, !9, i64 20}
  !9 = !{!"float", !4, i64 0}
  !10 = !{!"r_", !11, i64 0, !11, i64 4, !11, i64 8, !11, i64 12}
  !11 = !{!"int", !4, i64 0}
  !12 = !{!"gs_fixed_point_s", !13, i64 0, !13, i64 4}
  !13 = !{!"long", !4, i64 0}
  !14 = !{!"gs_fixed_rect_s", !12, i64 0, !12, i64 8}
  !15 = !{!"dd_", !16, i64 0, !16, i64 40}
  !16 = !{!"gx_dda_fixed_point_s", !17, i64 0, !17, i64 20}
  !17 = !{!"gx_dda_fixed_s", !18, i64 0, !19, i64 8}
  !18 = !{!"_a", !13, i64 0, !11, i64 4}
  !19 = !{!"_e", !13, i64 0, !11, i64 4, !11, i64 8}
  !20 = !{!"gs_int_point_s", !11, i64 0, !11, i64 4}
  !21 = !{!7, !13, i64 256}
  !22 = !{!7, !4, i64 112}
  !23 = !{!7, !4, i64 3}
  !24 = !{!7, !4, i64 0}
  !25 = !{!7, !4, i64 108}
  !26 = !{!7, !13, i64 48}
  !27 = !{!7, !11, i64 40}
  !28 = !{!7, !13, i64 152}
  !29 = !{!7, !11, i64 104}
  !30 = !{!7, !11, i64 100}
  !31 = !{!7, !3, i64 80}
  !32 = !{!33, !3, i64 0}
  !33 = !{!"gs_memory_s", !34, i64 0}
  !34 = !{!"gs_memory_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !3, i64 24, !3, i64 28, !3, i64 32, !3, i64 36, !3, i64 40, !3, i64 44, !3, i64 48, !3, i64 52, !3, i64 56, !3, i64 60, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76}
  !35 = !{!7, !3, i64 96}
  !36 = !{!7, !3, i64 84}
  !37 = !{!7, !13, i64 52}
  !38 = !{!7, !11, i64 276}
  !39 = !{!7, !11, i64 280}
  !40 = !{!7, !9, i64 12}
  !41 = !{!7, !13, i64 160}
  !42 = !{!7, !9, i64 8}
  !43 = !{!7, !13, i64 156}
  !44 = !{!7, !3, i64 64}
  !45 = !{!7, !4, i64 1}
  !46 = !{!47, !3, i64 180}
  !47 = !{!"gx_device_s", !11, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !11, i64 20, !11, i64 24, !48, i64 28, !11, i64 44, !11, i64 48, !4, i64 52, !4, i64 60, !11, i64 76, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !13, i64 120, !13, i64 124, !11, i64 128, !50, i64 132, !51, i64 144}
  !48 = !{!"gx_device_color_info_s", !11, i64 0, !11, i64 4, !49, i64 8, !49, i64 10, !49, i64 12, !49, i64 14}
  !49 = !{!"short", !4, i64 0}
  !50 = !{!"gx_page_device_procs_s", !3, i64 0, !3, i64 4, !3, i64 8}
  !51 = !{!"gx_device_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !3, i64 24, !3, i64 28, !3, i64 32, !3, i64 36, !3, i64 40, !3, i64 44, !3, i64 48, !3, i64 52, !3, i64 56, !3, i64 60, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76, !3, i64 80, !3, i64 84, !3, i64 88, !3, i64 92, !3, i64 96, !3, i64 100, !3, i64 104, !3, i64 108, !3, i64 112, !3, i64 116, !3, i64 120, !3, i64 124, !3, i64 128, !3, i64 132, !3, i64 136, !3, i64 140, !3, i64 144}
  !52 = !{!7, !11, i64 292}
  !53 = !{!7, !11, i64 296}
  !54 = !{!55, !3, i64 180}
  !55 = !{!"gx_device_memory_s", !11, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !11, i64 20, !11, i64 24, !48, i64 28, !11, i64 44, !11, i64 48, !4, i64 52, !4, i64 60, !11, i64 76, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !13, i64 120, !13, i64 124, !11, i64 128, !50, i64 132, !51, i64 144, !3, i64 292, !8, i64 296, !11, i64 320, !11, i64 324, !3, i64 328, !3, i64 332, !3, i64 336, !56, i64 340, !57, i64 348, !58, i64 364, !11, i64 372, !11, i64 376, !11, i64 380, !11, i64 384, !11, i64 388, !13, i64 392}
  !56 = !{!"gs_const_string_s", !3, i64 0, !11, i64 4}
  !57 = !{!"_c24", !13, i64 0, !11, i64 4, !11, i64 8, !11, i64 12}
  !58 = !{!"gs_log2_scale_point_s", !11, i64 0, !11, i64 4}
  !59 = !{!60, !3, i64 0}
  !60 = !{!"gx_device_color_s", !3, i64 0, !4, i64 4, !20, i64 32, !61, i64 40}
  !61 = !{!"_mask", !62, i64 0, !13, i64 20, !3, i64 24}
  !62 = !{!"gs_client_color_s", !63, i64 0, !3, i64 16}
  !63 = !{!"gs_paint_color_s", !4, i64 0}
  !64 = !{!13, !13, i64 0}
  !65 = !{!7, !4, i64 113}
  !66 = !{!55, !3, i64 332}
  !67 = !{!3, !3, i64 0}
  !68 = !{!4, !4, i64 0}
  !69 = !{!11, !11, i64 0}
  !70 = !{!7, !11, i64 300}
  !71 = !{!7, !11, i64 304}
  !72 = !{!7, !9, i64 16}
  !73 = !{!74, !3, i64 4}
  !74 = !{!"gx_device_color_procs_s", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16}
  !75 = !{!74, !3, i64 8}

...
---
name:            image_render_landscape
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: fgr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: fgr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: fgr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: fgr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: fgr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: gpr32 }
  - { id: 75, class: gpr32 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: gpr32 }
  - { id: 78, class: gpr32 }
  - { id: 79, class: gpr32 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: gpr32 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: fgr32 }
  - { id: 84, class: gpr32 }
  - { id: 85, class: gpr32 }
  - { id: 86, class: gpr32 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: gpr32 }
  - { id: 89, class: gpr32 }
  - { id: 90, class: gpr32 }
  - { id: 91, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%32' }
  - { reg: '%a1', virtual-reg: '%33' }
  - { reg: '%a2', virtual-reg: '%34' }
  - { reg: '%a3', virtual-reg: '%35' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 20, size: 4, alignment: 4, isImmutable: true, isAliased: false }
  - { id: 1, offset: 16, size: 4, alignment: 8, isImmutable: true, isAliased: false }
body:             |
  bb.0 (%ir-block.0, freq 52):
    successors: %bb.6(50), %bb.1(50)
    liveins: %a0, %a1, %a2, %a3, %t9, %v0
  
    %53 = ADDu %v0, %t9
    %35 = COPY %a3
    %34 = COPY %a2
    %33 = COPY %a1
    %32 = COPY %a0
    %37 = LW %fixed-stack.0, 0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack)
    %3 = LWC1 %32, 16, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.14, align 8, !tbaa !72)
    %38 = LW %32, 304, <0x32f1280> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.10, align 8, !tbaa !71)
    %39 = MTC1 %zero
    FCMP_S32 %3, %39, 4, implicit-def %fcc0
    %41 = MOVF_I %zero, %fcc0, %38
    %42 = SUBu %zero, %38
    %43 = LW %32, 104, <0x32368d0> = !{!"unison-memory-partition", i32 3} :: (load 4 from %ir.3, align 8, !tbaa !29)
    %5 = MOVT_I killed %42, %fcc0, %38
    %7 = LW %32, 280, <0x32ade80> = !{!"unison-memory-partition", i32 4} :: (load 4 from %ir.19, align 8, !tbaa !39)
    %48 = LW %32, 300, <0x33082d0> = !{!"unison-memory-partition", i32 5} :: (load 4 from %ir.8, !tbaa !70)
    %49 = ADDiu %zero, 1
    %50 = ADDiu %zero, -1
    FCMP_S32 %3, %39, 4, implicit-def %fcc0
    %4 = MOVT_I killed %50, %fcc0, %49
    %6 = ADDu killed %41, killed %48
    %0 = LW %32, 96, <0x3301380> = !{!"unison-memory-partition", i32 6} :: (load 4 from %ir.1, align 8, !tbaa !35)
    %51 = LW %32, 160, <0x3294080> = !{!"unison-memory-partition", i32 7} :: (load 4 from %ir.12, align 8, !tbaa !41)
    %2 = SRL killed %51, 31
    BEQ %6, %7, %bb.6, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.22, freq 26):
    successors: %bb.3(50), %bb.2(50)
  
    %8 = LW %32, 276, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.24, !tbaa !38)
    FCMP_S32 %3, %39, 4, implicit-def %fcc0
    BC1T %fcc0, %bb.3, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.26, freq 13):
    successors: %bb.4(100)
  
    %54 = LW %53, target-flags(<unknown>) @copy_landscape, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %55 = ADDiu killed %54, target-flags(<unknown>) @copy_landscape
    %a0 = COPY %32
    %a1 = COPY %8
    %a2 = COPY %7
    %a3 = COPY %2
    %t0 = COPY %37
    %t9 = COPY %55
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %t0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %56 = COPY %v0
    %9 = COPY %56
    B %bb.4, implicit-def dead %at
  
  bb.3 (%ir-block.28, freq 13):
    successors: %bb.4(100)
  
    %57 = LW %53, target-flags(<unknown>) @copy_landscape, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %58 = ADDiu killed %57, target-flags(<unknown>) @copy_landscape
    %a0 = COPY %32
    %a1 = COPY %7
    %a2 = COPY %8
    %a3 = COPY %2
    %t0 = COPY %37
    %t9 = COPY %58
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %t0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %59 = COPY %v0
    %10 = COPY %59
  
  bb.4 (%ir-block.30, freq 26):
    successors: %bb.24..loopexit(37), %bb.5..critedge(62)
  
    %11 = PHI %9, %bb.2, %10, %bb.3
    BLTZ %11, %bb.24..loopexit, implicit-def dead %at
    B %bb.5..critedge, implicit-def dead %at
  
  bb.5..critedge (freq 16):
    successors: %bb.6(100)
  
    SW %6, %32, 276, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.sunkaddr2, !tbaa !38)
  
  bb.6 (%ir-block.33, freq 42):
    successors: %bb.21(37), %bb.7..preheader(62)
  
    %36 = LW %fixed-stack.1, 0, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    BEQ %36, %zero, %bb.21, implicit-def dead %at
    B %bb.7..preheader, implicit-def dead %at
  
  bb.7..preheader (freq 26):
    successors: %bb.20.._crit_edge(37), %bb.8..lr.ph(62)
  
    BEQ %5, %zero, %bb.20.._crit_edge, implicit-def dead %at
    B %bb.8..lr.ph, implicit-def dead %at
  
  bb.8..lr.ph (freq 16):
    successors: %bb.9(100)
  
    %44 = LUi 8191
    %45 = ORi %44, 65532
    %46 = ADDiu %43, 31
    %47 = SRL %46, 3
    %1 = AND %47, %45
    %62 = ADDiu %zero, -1
    %60 = ADDiu %zero, 0
    FCMP_S32 %3, %39, 4, implicit-def %fcc0
    %12 = MOVF_I %zero, %fcc0, %62
    %13 = SUBu %zero, %5
    %67 = LW %53, target-flags(<unknown>) @image_simple_expand, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %68 = ADDiu %67, target-flags(<unknown>) @image_simple_expand
    %78 = LW %53, target-flags(<unknown>) @copy_landscape, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %79 = ADDiu %78, target-flags(<unknown>) @copy_landscape
    %71 = ADDiu %zero, 7
  
  bb.9 (%ir-block.39, freq 374):
    successors: %bb.10(37), %bb.11(62)
  
    %14 = PHI %13, %bb.8..lr.ph, %26, %bb.19
    %15 = PHI %6, %bb.8..lr.ph, %25, %bb.19
    %16 = PHI %60, %bb.8..lr.ph, %24, %bb.19
    %17 = ADDu %15, %12
    %18 = ANDi %17, 7
    %63 = MUL %18, %1, implicit-def dead %hi0, implicit-def dead %lo0
    %19 = ADDu %0, killed %63
    BNE %16, %zero, %bb.11, implicit-def dead %at
    B %bb.10, implicit-def dead %at
  
  bb.10 (%ir-block.44, freq 140):
    successors: %bb.12(100)
  
    %65 = LW %32, 52, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.sunkaddr8, !tbaa !37)
    %66 = LW %32, 256, <0x32f12f0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.sunkaddr5, !tbaa !21)
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %a0 = COPY %19
    %a1 = COPY %60
    %a2 = COPY %1
    %a3 = COPY %33
    %t0 = COPY %34
    %t1 = COPY %35
    %t2 = COPY %66
    %t3 = COPY %65
    %t4 = COPY %60
    %t9 = COPY %68
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %t0, implicit %t1, implicit %t2, implicit %t3, implicit %t4, implicit-def %sp
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    B %bb.12, implicit-def dead %at
  
  bb.11 (%ir-block.47, freq 234):
    successors: %bb.12(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %64 = LW %53, target-flags(<unknown>) $memcpy, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry $memcpy)
    %a0 = COPY %19
    %a1 = COPY %16
    %a2 = COPY %1
    %gp = COPY %53
    %t9 = COPY %64
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.12 (%ir-block.48, freq 374):
    successors: %bb.16(50), %bb.13(50)
  
    %20 = PHI %16, %bb.11, %19, %bb.10
    FCMP_S32 %3, %39, 4, implicit-def %fcc0
    BC1T %fcc0, %bb.16, implicit-def dead %at
    B %bb.13, implicit-def dead %at
  
  bb.13 (%ir-block.50, freq 187):
    successors: %bb.14(50), %bb.19(50)
  
    %21 = ADDiu %17, 1
    BNE %18, %71, %bb.19, implicit-def dead %at
    B %bb.14, implicit-def dead %at
  
  bb.14 (%ir-block.53, freq 93):
    successors: %bb.24..loopexit(3), %bb.15..thread(96)
  
    %72 = LW %32, 276, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.sunkaddr11, !tbaa !38)
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %74 = ADDiu %78, target-flags(<unknown>) @copy_landscape
    %a0 = COPY %32
    %a1 = COPY %72
    %a2 = COPY %21
    %a3 = COPY %2
    %t0 = COPY %37
    %t9 = COPY %74
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %t0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %75 = COPY %v0
    %22 = COPY %75
    BLTZ %75, %bb.24..loopexit, implicit-def dead %at
    B %bb.15..thread, implicit-def dead %at
  
  bb.15..thread (freq 90):
    successors: %bb.19(100)
  
    SW %21, %32, 276, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.sunkaddr14, !tbaa !38)
    %76 = ADDiu %zero, 0
    B %bb.19, implicit-def dead %at
  
  bb.16 (%ir-block.57, freq 187):
    successors: %bb.17(37), %bb.19(62)
  
    BNE %18, %zero, %bb.19, implicit-def dead %at
    B %bb.17, implicit-def dead %at
  
  bb.17 (%ir-block.59, freq 70):
    successors: %bb.24..loopexit(3), %bb.18..thread10(96)
  
    %77 = LW %32, 276, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.sunkaddr17, !tbaa !38)
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %a0 = COPY %32
    %a1 = COPY %17
    %a2 = COPY %77
    %a3 = COPY %2
    %t0 = COPY %37
    %t9 = COPY %79
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %t0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %80 = COPY %v0
    %23 = COPY %80
    BLTZ %80, %bb.24..loopexit, implicit-def dead %at
    B %bb.18..thread10, implicit-def dead %at
  
  bb.18..thread10 (freq 68):
    successors: %bb.19(100)
  
    SW %17, %32, 276, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.sunkaddr20, !tbaa !38)
    %81 = ADDiu %zero, 0
  
  bb.19 (%ir-block.63, freq 369):
    successors: %bb.20.._crit_edge(3), %bb.9(96)
  
    %24 = PHI %20, %bb.13, %76, %bb.15..thread, %20, %bb.16, %81, %bb.18..thread10
    %25 = PHI %21, %bb.13, %21, %bb.15..thread, %17, %bb.16, %17, %bb.18..thread10
    %26 = ADDu %14, %4
    BNE %26, %zero, %bb.9, implicit-def dead %at
    B %bb.20.._crit_edge, implicit-def dead %at
  
  bb.20.._crit_edge (freq 21):
    successors: %bb.24..loopexit(100)
  
    %27 = PHI %6, %bb.7..preheader, %25, %bb.19
    SW %27, %32, 280, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.sunkaddr23, align 8, !tbaa !39)
    %82 = ADDiu %zero, 0
    B %bb.24..loopexit, implicit-def dead %at
  
  bb.21 (%ir-block.65, freq 15):
    successors: %bb.23(50), %bb.22(50)
  
    %28 = LW %32, 276, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.67, !tbaa !38)
    FCMP_S32 %3, %39, 4, implicit-def %fcc0
    BC1T %fcc0, %bb.23, implicit-def dead %at
    B %bb.22, implicit-def dead %at
  
  bb.22 (%ir-block.69, freq 8):
    successors: %bb.24..loopexit(100)
  
    %84 = LW %53, target-flags(<unknown>) @copy_landscape, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %85 = ADDiu killed %84, target-flags(<unknown>) @copy_landscape
    %a0 = COPY %32
    %a1 = COPY %28
    %a2 = COPY %6
    %a3 = COPY %2
    %t0 = COPY %37
    %t9 = COPY %85
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %t0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %86 = COPY %v0
    %29 = COPY %86
    B %bb.24..loopexit, implicit-def dead %at
  
  bb.23 (%ir-block.71, freq 8):
    successors: %bb.24..loopexit(100)
  
    %87 = LW %53, target-flags(<unknown>) @copy_landscape, <0x3212bb0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %88 = ADDiu killed %87, target-flags(<unknown>) @copy_landscape
    %a0 = COPY %32
    %a1 = COPY %6
    %a2 = COPY %28
    %a3 = COPY %2
    %t0 = COPY %37
    %t9 = COPY %88
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %t0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %89 = COPY %v0
    %30 = COPY %89
  
  bb.24..loopexit (freq 52):
    liveouts: %v0
  
    %31 = PHI %11, %bb.4, %22, %bb.14, %23, %bb.17, %82, %bb.20.._crit_edge, %29, %bb.22, %30, %bb.23
    %v0 = COPY %31
    RetRA implicit %v0

...
