--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/mesa/mesa.shapes.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.model = type { i32, %struct.model*, i32, double* }
  %struct.GLUquadricObj = type opaque
  
  @auxWireIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @lists = internal unnamed_addr global [25 x %struct.model*] zeroinitializer, align 4
  @drawbox.n = internal global [6 x [3 x double]] [[3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @drawbox.faces = internal unnamed_addr constant [6 x [4 x i32]] [[4 x i32] [i32 0, i32 1, i32 2, i32 3], [4 x i32] [i32 3, i32 2, i32 6, i32 7], [4 x i32] [i32 7, i32 6, i32 5, i32 4], [4 x i32] [i32 4, i32 5, i32 1, i32 0], [4 x i32] [i32 5, i32 6, i32 2, i32 1], [4 x i32] [i32 7, i32 4, i32 0, i32 3]], align 4
  @iindex = internal unnamed_addr constant [20 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 1], [3 x i32] [i32 0, i32 9, i32 4], [3 x i32] [i32 9, i32 5, i32 4], [3 x i32] [i32 4, i32 5, i32 8], [3 x i32] [i32 4, i32 8, i32 1], [3 x i32] [i32 8, i32 10, i32 1], [3 x i32] [i32 8, i32 3, i32 10], [3 x i32] [i32 5, i32 3, i32 8], [3 x i32] [i32 5, i32 2, i32 3], [3 x i32] [i32 2, i32 7, i32 3], [3 x i32] [i32 7, i32 10, i32 3], [3 x i32] [i32 7, i32 6, i32 10], [3 x i32] [i32 7, i32 11, i32 6], [3 x i32] [i32 11, i32 0, i32 6], [3 x i32] [i32 0, i32 1, i32 6], [3 x i32] [i32 6, i32 1, i32 10], [3 x i32] [i32 9, i32 0, i32 11], [3 x i32] [i32 9, i32 11, i32 2], [3 x i32] [i32 9, i32 2, i32 5], [3 x i32] [i32 7, i32 2, i32 11]], align 4
  @idata = internal global [12 x [3 x double]] [[3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00]], align 8
  @ondex = internal unnamed_addr constant [8 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 2], [3 x i32] [i32 1, i32 2, i32 4], [3 x i32] [i32 0, i32 3, i32 4], [3 x i32] [i32 1, i32 4, i32 3], [3 x i32] [i32 0, i32 2, i32 5], [3 x i32] [i32 1, i32 5, i32 2], [3 x i32] [i32 0, i32 5, i32 3], [3 x i32] [i32 1, i32 3, i32 5]], align 4
  @odata = internal global [6 x [3 x double]] [[3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @tndex = internal unnamed_addr constant [4 x [3 x i32]] [[3 x i32] [i32 0, i32 1, i32 3], [3 x i32] [i32 2, i32 1, i32 0], [3 x i32] [i32 3, i32 2, i32 0], [3 x i32] [i32 1, i32 2, i32 3]], align 4
  @tdata = internal global [4 x [3 x double]] [[3 x double] [double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA], [3 x double] [double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA]], align 8
  @dodecahedron.inited = internal unnamed_addr global i1 false
  @dodec = internal global [20 x [3 x double]] zeroinitializer, align 8
  
  ; Function Attrs: nounwind
  define void @auxWireSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast ([25 x %struct.model*]* @lists to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast ([25 x %struct.model*]* @lists to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100011) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare noalias i8* @malloc(i32 signext) #0
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @findList(i32 signext %lindex, double* nocapture readonly %paramArray, i32 signext %size) #2 {
    %1 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %endList.02 = load %struct.model*, %struct.model** %1, align 4, !tbaa !5
    %2 = icmp eq %struct.model* %endList.02, null
    br i1 %2, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0
    br label %3
  
  ; <label>:3                                       ; preds = %18, %.lr.ph
    %endList.03 = phi %struct.model* [ %endList.02, %.lr.ph ], [ %endList.0, %18 ]
    %4 = icmp sgt i32 %size, 0
    br i1 %4, label %.lr.ph.i.preheader, label %compareParams.exit.thread
  
  .lr.ph.i.preheader:                               ; preds = %3
    %5 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 3
    %6 = load double*, double** %5, align 4, !tbaa !7
    br label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %matches.05.i = phi i32 [ %matches.1.i, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %.03.i = phi double* [ %7, %.lr.ph.i ], [ %6, %.lr.ph.i.preheader ]
    %.012.i = phi double* [ %9, %.lr.ph.i ], [ %paramArray, %.lr.ph.i.preheader ]
    %7 = getelementptr inbounds double, double* %.03.i, i32 1
    %8 = load double, double* %.03.i, align 8, !tbaa !1
    %9 = getelementptr inbounds double, double* %.012.i, i32 1
    %10 = load double, double* %.012.i, align 8, !tbaa !1
    %11 = fcmp une double %8, %10
    %matches.1.i = select i1 %11, i32 0, i32 %matches.05.i
    %12 = icmp slt i32 %lsr.iv, %size
    %13 = icmp ne i32 %matches.1.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %14, label %.lr.ph.i, label %compareParams.exit
  
  compareParams.exit:                               ; preds = %.lr.ph.i
    %15 = icmp eq i32 %matches.1.i, 0
    br i1 %15, label %18, label %compareParams.exit.thread
  
  compareParams.exit.thread:                        ; preds = %compareParams.exit, %3
    %16 = bitcast %struct.model* %endList.03 to i32*
    %17 = load i32, i32* %16, align 4, !tbaa !10
    br label %.loopexit
  
  ; <label>:18                                      ; preds = %compareParams.exit
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 1
    %endList.0 = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0, null
    br i1 %20, label %.loopexit, label %3
  
  .loopexit:                                        ; preds = %18, %compareParams.exit.thread, %0
    %.0 = phi i32 [ %17, %compareParams.exit.thread ], [ 0, %0 ], [ 0, %18 ]
    ret i32 %.0
  }
  
  declare void @glNewList(i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @makeModelPtr(i32 signext %lindex, double* %sizeArray, i32 signext %count) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = tail call i32 @glGenLists(i32 signext 1) #4
    %3 = bitcast i8* %1 to i32*
    store i32 %2, i32* %3, align 4, !tbaa !10
    %4 = getelementptr inbounds i8, i8* %1, i32 8
    %5 = bitcast i8* %4 to i32*
    store i32 %count, i32* %5, align 4, !tbaa !11
    %6 = getelementptr inbounds i8, i8* %1, i32 12
    %7 = bitcast i8* %6 to double**
    store double* %sizeArray, double** %7, align 4, !tbaa !7
    %8 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %9 = bitcast %struct.model** %8 to i32*
    %10 = load i32, i32* %9, align 4, !tbaa !5
    %11 = getelementptr inbounds i8, i8* %1, i32 4
    %12 = bitcast i8* %11 to i32*
    store i32 %10, i32* %12, align 4, !tbaa !12
    %13 = bitcast %struct.model** %8 to i8**
    store i8* %1, i8** %13, align 4, !tbaa !5
    ret i32 %2
  }
  
  declare %struct.GLUquadricObj* @gluNewQuadric() #3
  
  declare void @gluQuadricDrawStyle(%struct.GLUquadricObj*, i32 signext) #3
  
  declare void @gluSphere(%struct.GLUquadricObj*, double, i32 signext, i32 signext) #3
  
  declare void @glEndList() #3
  
  declare void @glCallList(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  define void @auxSolidSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %23, i32 signext 100000) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  declare void @gluQuadricNormals(%struct.GLUquadricObj*, i32 signext) #3
  
  ; Function Attrs: nounwind
  define void @auxWireCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 2)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawbox(double %x0, double %x1, double %y0, double %y1, double %z0, double %z1, i32 signext %type) unnamed_addr #0 {
    %v = alloca [8 x [3 x double]], align 8
    %1 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.start(i64 192, i8* %1) #4
    %2 = fcmp ogt double %x0, %x1
    %.05 = select i1 %2, double %x0, double %x1
    %.0 = select i1 %2, double %x1, double %x0
    %3 = fcmp ogt double %y0, %y1
    %.04 = select i1 %3, double %y1, double %y0
    %.03 = select i1 %3, double %y0, double %y1
    %4 = fcmp ogt double %z0, %z1
    %.02 = select i1 %4, double %z1, double %z0
    %.01 = select i1 %4, double %z0, double %z1
    %5 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 0
    store double %.0, double* %5, align 8, !tbaa !1
    %6 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 0
    store double %.0, double* %6, align 8, !tbaa !1
    %7 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 0
    store double %.0, double* %7, align 8, !tbaa !1
    %8 = bitcast [8 x [3 x double]]* %v to double*
    store double %.0, double* %8, align 8, !tbaa !1
    %9 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 0
    store double %.05, double* %9, align 8, !tbaa !1
    %10 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 0
    store double %.05, double* %10, align 8, !tbaa !1
    %11 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 0
    store double %.05, double* %11, align 8, !tbaa !1
    %12 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 0
    store double %.05, double* %12, align 8, !tbaa !1
    %13 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 1
    store double %.04, double* %13, align 8, !tbaa !1
    %14 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 1
    store double %.04, double* %14, align 8, !tbaa !1
    %15 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 1
    store double %.04, double* %15, align 8, !tbaa !1
    %16 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 1
    store double %.04, double* %16, align 8, !tbaa !1
    %17 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 1
    store double %.03, double* %17, align 8, !tbaa !1
    %18 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 1
    store double %.03, double* %18, align 8, !tbaa !1
    %19 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 1
    store double %.03, double* %19, align 8, !tbaa !1
    %20 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 1
    store double %.03, double* %20, align 8, !tbaa !1
    %21 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 2
    store double %.02, double* %21, align 8, !tbaa !1
    %22 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 2
    store double %.02, double* %22, align 8, !tbaa !1
    %23 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 2
    store double %.02, double* %23, align 8, !tbaa !1
    %24 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 2
    store double %.02, double* %24, align 8, !tbaa !1
    %25 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 2
    store double %.01, double* %25, align 8, !tbaa !1
    %26 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 2
    store double %.01, double* %26, align 8, !tbaa !1
    %27 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 2
    store double %.01, double* %27, align 8, !tbaa !1
    %28 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 2
    store double %.01, double* %28, align 8, !tbaa !1
    br label %29
  
  ; <label>:29                                      ; preds = %29, %0
    %lsr.iv1 = phi [6 x [4 x i32]]* [ %38, %29 ], [ bitcast (i32* getelementptr inbounds ([6 x [4 x i32]], [6 x [4 x i32]]* @drawbox.faces, i32 0, i32 0, i32 2) to [6 x [4 x i32]]*), %0 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %29 ], [ 0, %0 ]
    %lsr.iv12 = bitcast [6 x [4 x i32]]* %lsr.iv1 to i32*
    call void @glBegin(i32 signext %type) #4
    %uglygep11 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep1112 = bitcast i8* %uglygep11 to double*
    call void @glNormal3dv(double* %uglygep1112) #4
    %scevgep5 = getelementptr i32, i32* %lsr.iv12, i32 -2
    %30 = load i32, i32* %scevgep5, align 4, !tbaa !13
    %31 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %30, i32 0
    call void @glVertex3dv(double* %31) #4
    %uglygep9 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep910 = bitcast i8* %uglygep9 to double*
    call void @glNormal3dv(double* %uglygep910) #4
    %scevgep4 = getelementptr i32, i32* %lsr.iv12, i32 -1
    %32 = load i32, i32* %scevgep4, align 4, !tbaa !13
    %33 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %32, i32 0
    call void @glVertex3dv(double* %33) #4
    %uglygep7 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep78 = bitcast i8* %uglygep7 to double*
    call void @glNormal3dv(double* %uglygep78) #4
    %34 = load i32, i32* %lsr.iv12, align 4, !tbaa !13
    %35 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %34, i32 0
    call void @glVertex3dv(double* %35) #4
    %uglygep = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep6 = bitcast i8* %uglygep to double*
    call void @glNormal3dv(double* %uglygep6) #4
    %scevgep3 = getelementptr i32, i32* %lsr.iv12, i32 1
    %36 = load i32, i32* %scevgep3, align 4, !tbaa !13
    %37 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %36, i32 0
    call void @glVertex3dv(double* %37) #4
    call void @glEnd() #4
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 24
    %scevgep = getelementptr [6 x [4 x i32]], [6 x [4 x i32]]* %lsr.iv1, i32 0, i32 1, i32 0
    %38 = bitcast i32* %scevgep to [6 x [4 x i32]]*
    %exitcond = icmp eq i32 %lsr.iv.next, 144
    br i1 %exitcond, label %39, label %29
  
  ; <label>:39                                      ; preds = %29
    %40 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.end(i64 192, i8* %40) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 7)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 2)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 7)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 5, i32 signext 10, i32 signext 2)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @doughnut(double %r, double %R, i32 signext %nsides, i32 signext %rings, i32 signext %type) unnamed_addr #0 {
    %p0 = alloca [3 x double], align 8
    %p1 = alloca [3 x double], align 8
    %p2 = alloca [3 x double], align 8
    %p3 = alloca [3 x double], align 8
    %n0 = alloca [3 x double], align 8
    %n1 = alloca [3 x double], align 8
    %n2 = alloca [3 x double], align 8
    %n3 = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %p1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %p2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %p3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %n1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %n2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = bitcast [3 x double]* %n3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %8) #4
    %9 = icmp sgt i32 %rings, 0
    br i1 %9, label %.lr.ph3, label %._crit_edge
  
  .lr.ph3:                                          ; preds = %0
    %10 = sitofp i32 %rings to double
    %11 = sitofp i32 %nsides to double
    br label %12
  
  .loopexit:                                        ; preds = %.lr.ph, %12
    %exitcond4 = icmp eq i32 %17, %rings
    br i1 %exitcond4, label %._crit_edge, label %12
  
  ; <label>:12                                      ; preds = %.loopexit, %.lr.ph3
    %IV.S.1 = phi double [ 0.000000e+00, %.lr.ph3 ], [ %IV.S.next.2, %.loopexit ]
    %i.02 = phi i32 [ 0, %.lr.ph3 ], [ %17, %.loopexit ]
    %13 = icmp sgt i32 %nsides, 0
    %14 = fmul double %IV.S.1, 2.000000e+00
    %15 = fmul double %14, 0x400921FB54442C46
    %16 = fdiv double %15, %10
    %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
    %17 = add nuw nsw i32 %i.02, 1
    %18 = sitofp i32 %17 to double
    %19 = fmul double %18, 2.000000e+00
    %20 = fmul double %19, 0x400921FB54442C46
    %21 = fdiv double %20, %10
    br i1 %13, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %12, %.lr.ph
    %IV.S. = phi double [ %IV.S.next., %.lr.ph ], [ 0.000000e+00, %12 ]
    %j.01 = phi i32 [ %33, %.lr.ph ], [ 0, %12 ]
    %22 = bitcast [3 x double]* %n3 to double*
    %23 = bitcast [3 x double]* %n2 to double*
    %24 = bitcast [3 x double]* %n1 to double*
    %25 = bitcast [3 x double]* %n0 to double*
    %26 = bitcast [3 x double]* %p3 to double*
    %27 = bitcast [3 x double]* %p2 to double*
    %28 = bitcast [3 x double]* %p1 to double*
    %29 = bitcast [3 x double]* %p0 to double*
    %30 = fmul double %IV.S., 2.000000e+00
    %31 = fmul double %30, 0x400921FB54442C46
    %32 = fdiv double %31, %11
    %IV.S.next. = fadd double %IV.S., 1.000000e+00
    %33 = add nuw nsw i32 %j.01, 1
    %34 = sitofp i32 %33 to double
    %35 = fmul double %34, 2.000000e+00
    %36 = fmul double %35, 0x400921FB54442C46
    %37 = fdiv double %36, %11
    %38 = call double @cos(double %16) #4
    %39 = call double @cos(double %32) #4
    %40 = fmul double %39, %r
    %41 = fadd double %40, %R
    %42 = fmul double %38, %41
    store double %42, double* %29, align 8, !tbaa !1
    %43 = call double @sin(double %16) #4
    %44 = call double @cos(double %32) #4
    %45 = fmul double %44, %r
    %46 = fadd double %45, %R
    %47 = fmul double %43, %46
    %48 = fsub double -0.000000e+00, %47
    %sunkaddr = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    store double %48, double* %sunkaddr4, align 8, !tbaa !1
    %49 = call double @sin(double %32) #4
    %50 = fmul double %49, %r
    %sunkaddr5 = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr6 = add i32 %sunkaddr5, 16
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %50, double* %sunkaddr7, align 8, !tbaa !1
    %51 = call double @cos(double %21) #4
    %52 = call double @cos(double %32) #4
    %53 = fmul double %52, %r
    %54 = fadd double %53, %R
    %55 = fmul double %51, %54
    store double %55, double* %28, align 8, !tbaa !1
    %56 = call double @sin(double %21) #4
    %57 = call double @cos(double %32) #4
    %58 = fmul double %57, %r
    %59 = fadd double %58, %R
    %60 = fmul double %56, %59
    %61 = fsub double -0.000000e+00, %60
    %sunkaddr8 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %61, double* %sunkaddr10, align 8, !tbaa !1
    %62 = call double @sin(double %32) #4
    %63 = fmul double %62, %r
    %sunkaddr11 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr12 = add i32 %sunkaddr11, 16
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %63, double* %sunkaddr13, align 8, !tbaa !1
    %64 = call double @cos(double %21) #4
    %65 = call double @cos(double %37) #4
    %66 = fmul double %65, %r
    %67 = fadd double %66, %R
    %68 = fmul double %64, %67
    store double %68, double* %27, align 8, !tbaa !1
    %69 = call double @sin(double %21) #4
    %70 = call double @cos(double %37) #4
    %71 = fmul double %70, %r
    %72 = fadd double %71, %R
    %73 = fmul double %69, %72
    %74 = fsub double -0.000000e+00, %73
    %sunkaddr14 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 8
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    store double %74, double* %sunkaddr16, align 8, !tbaa !1
    %75 = call double @sin(double %37) #4
    %76 = fmul double %75, %r
    %sunkaddr17 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %76, double* %sunkaddr19, align 8, !tbaa !1
    %77 = call double @cos(double %16) #4
    %78 = call double @cos(double %37) #4
    %79 = fmul double %78, %r
    %80 = fadd double %79, %R
    %81 = fmul double %77, %80
    store double %81, double* %26, align 8, !tbaa !1
    %82 = call double @sin(double %16) #4
    %83 = call double @cos(double %37) #4
    %84 = fmul double %83, %r
    %85 = fadd double %84, %R
    %86 = fmul double %82, %85
    %87 = fsub double -0.000000e+00, %86
    %sunkaddr20 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr21 = add i32 %sunkaddr20, 8
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %87, double* %sunkaddr22, align 8, !tbaa !1
    %88 = call double @sin(double %37) #4
    %89 = fmul double %88, %r
    %sunkaddr23 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %89, double* %sunkaddr25, align 8, !tbaa !1
    %90 = call double @cos(double %16) #4
    %91 = call double @cos(double %32) #4
    %92 = fmul double %90, %91
    store double %92, double* %25, align 8, !tbaa !1
    %93 = call double @sin(double %16) #4
    %94 = call double @cos(double %32) #4
    %95 = fmul double %93, %94
    %96 = fsub double -0.000000e+00, %95
    %sunkaddr26 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr27 = add i32 %sunkaddr26, 8
    %sunkaddr28 = inttoptr i32 %sunkaddr27 to double*
    store double %96, double* %sunkaddr28, align 8, !tbaa !1
    %97 = call double @sin(double %32) #4
    %sunkaddr29 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr30 = add i32 %sunkaddr29, 16
    %sunkaddr31 = inttoptr i32 %sunkaddr30 to double*
    store double %97, double* %sunkaddr31, align 8, !tbaa !1
    %98 = call double @cos(double %21) #4
    %99 = call double @cos(double %32) #4
    %100 = fmul double %98, %99
    store double %100, double* %24, align 8, !tbaa !1
    %101 = call double @sin(double %21) #4
    %102 = call double @cos(double %32) #4
    %103 = fmul double %101, %102
    %104 = fsub double -0.000000e+00, %103
    %sunkaddr32 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr33 = add i32 %sunkaddr32, 8
    %sunkaddr34 = inttoptr i32 %sunkaddr33 to double*
    store double %104, double* %sunkaddr34, align 8, !tbaa !1
    %105 = call double @sin(double %32) #4
    %sunkaddr35 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr36 = add i32 %sunkaddr35, 16
    %sunkaddr37 = inttoptr i32 %sunkaddr36 to double*
    store double %105, double* %sunkaddr37, align 8, !tbaa !1
    %106 = call double @cos(double %21) #4
    %107 = call double @cos(double %37) #4
    %108 = fmul double %106, %107
    store double %108, double* %23, align 8, !tbaa !1
    %109 = call double @sin(double %21) #4
    %110 = call double @cos(double %37) #4
    %111 = fmul double %109, %110
    %112 = fsub double -0.000000e+00, %111
    %sunkaddr38 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr39 = add i32 %sunkaddr38, 8
    %sunkaddr40 = inttoptr i32 %sunkaddr39 to double*
    store double %112, double* %sunkaddr40, align 8, !tbaa !1
    %113 = call double @sin(double %37) #4
    %sunkaddr41 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr42 = add i32 %sunkaddr41, 16
    %sunkaddr43 = inttoptr i32 %sunkaddr42 to double*
    store double %113, double* %sunkaddr43, align 8, !tbaa !1
    %114 = call double @cos(double %16) #4
    %115 = call double @cos(double %37) #4
    %116 = fmul double %114, %115
    store double %116, double* %22, align 8, !tbaa !1
    %117 = call double @sin(double %16) #4
    %118 = call double @cos(double %37) #4
    %119 = fmul double %117, %118
    %120 = fsub double -0.000000e+00, %119
    %sunkaddr44 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr45 = add i32 %sunkaddr44, 8
    %sunkaddr46 = inttoptr i32 %sunkaddr45 to double*
    store double %120, double* %sunkaddr46, align 8, !tbaa !1
    %121 = call double @sin(double %37) #4
    %sunkaddr47 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr48 = add i32 %sunkaddr47, 16
    %sunkaddr49 = inttoptr i32 %sunkaddr48 to double*
    store double %121, double* %sunkaddr49, align 8, !tbaa !1
    call void @m_xformpt(double* %29, double* %29, double* %25, double* %25) #4
    call void @m_xformpt(double* %28, double* %28, double* %24, double* %24) #4
    call void @m_xformpt(double* %27, double* %27, double* %23, double* %23) #4
    call void @m_xformpt(double* %26, double* %26, double* %22, double* %22) #4
    call void @glBegin(i32 signext %type) #4
    call void @glNormal3dv(double* %22) #4
    call void @glVertex3dv(double* %26) #4
    call void @glNormal3dv(double* %23) #4
    call void @glVertex3dv(double* %27) #4
    call void @glNormal3dv(double* %24) #4
    call void @glVertex3dv(double* %28) #4
    call void @glNormal3dv(double* %25) #4
    call void @glVertex3dv(double* %29) #4
    call void @glEnd() #4
    %exitcond = icmp eq i32 %nsides, %33
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.loopexit, %0
    %122 = bitcast [3 x double]* %n3 to i8*
    %123 = bitcast [3 x double]* %n2 to i8*
    %124 = bitcast [3 x double]* %n1 to i8*
    %125 = bitcast [3 x double]* %n0 to i8*
    %126 = bitcast [3 x double]* %p3 to i8*
    %127 = bitcast [3 x double]* %p2 to i8*
    %128 = bitcast [3 x double]* %p1 to i8*
    %129 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.end(i64 24, i8* %122) #4
    call void @llvm.lifetime.end(i64 24, i8* %123) #4
    call void @llvm.lifetime.end(i64 24, i8* %124) #4
    call void @llvm.lifetime.end(i64 24, i8* %125) #4
    call void @llvm.lifetime.end(i64 24, i8* %126) #4
    call void @llvm.lifetime.end(i64 24, i8* %127) #4
    call void @llvm.lifetime.end(i64 24, i8* %128) #4
    call void @llvm.lifetime.end(i64 24, i8* %129) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 8, i32 signext 15, i32 signext 7)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  declare void @glPushMatrix() #3
  
  declare void @glRotatef(float, float, float, float) #3
  
  declare void @glTranslatef(float, float, float) #3
  
  declare void @gluCylinder(%struct.GLUquadricObj*, double, double, double, i32 signext, i32 signext) #3
  
  declare void @glPopMatrix() #3
  
  ; Function Attrs: nounwind
  define void @auxSolidCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @icosahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 8, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 9, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 10, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 11, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 12, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 13, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 14, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 15, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 16, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 17, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 18, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 19, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireOctahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @octahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidOctahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireDodecahedron.center, i32 0, i32 0), double %23, i32 signext 2)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @dodecahedron(double* nocapture readonly %center, double %sc, i32 signext %type) unnamed_addr #0 {
    %.b = load i1, i1* @dodecahedron.inited, align 1
    br i1 %.b, label %2, label %1
  
  ; <label>:1                                       ; preds = %0
    store i1 true, i1* @dodecahedron.inited, align 1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 2), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 2), align 8, !tbaa !1
    br label %2
  
  ; <label>:2                                       ; preds = %1, %0
    tail call void @m_pushmatrix() #4
    %3 = load double, double* %center, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %center, i32 1
    %5 = load double, double* %4, align 8, !tbaa !1
    %6 = getelementptr inbounds double, double* %center, i32 2
    %7 = load double, double* %6, align 8, !tbaa !1
    tail call void @m_translate(double %3, double %5, double %7) #4
    tail call void @m_scale(double %sc, double %sc, double %sc) #4
    tail call fastcc void @pentagon(i32 signext 0, i32 signext 1, i32 signext 9, i32 signext 16, i32 signext 5, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 0, i32 signext 3, i32 signext 18, i32 signext 7, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 7, i32 signext 11, i32 signext 10, i32 signext 9, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 11, i32 signext 7, i32 signext 18, i32 signext 19, i32 signext 6, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 8, i32 signext 17, i32 signext 16, i32 signext 9, i32 signext 10, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 14, i32 signext 15, i32 signext 6, i32 signext 19, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 13, i32 signext 12, i32 signext 4, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 19, i32 signext 18, i32 signext 3, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 3, i32 signext 0, i32 signext 5, i32 signext 12, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 6, i32 signext 15, i32 signext 8, i32 signext 10, i32 signext 11, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 17, i32 signext 8, i32 signext 15, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 12, i32 signext 5, i32 signext 16, i32 signext 17, i32 signext %type)
    tail call void @m_popmatrix() #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidDodecahedron.center, i32 0, i32 0), double %23, i32 signext 6)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @compareParams(double* nocapture readonly %oneArray, double* nocapture readonly %twoArray, i32 signext %size) #2 {
    %1 = icmp sgt i32 %size, 0
    br i1 %1, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ 1, %0 ]
    %matches.05 = phi i32 [ %matches.1, %.lr.ph ], [ 1, %0 ]
    %.03 = phi double* [ %2, %.lr.ph ], [ %oneArray, %0 ]
    %.012 = phi double* [ %4, %.lr.ph ], [ %twoArray, %0 ]
    %2 = getelementptr inbounds double, double* %.03, i32 1
    %3 = load double, double* %.03, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %.012, i32 1
    %5 = load double, double* %.012, align 8, !tbaa !1
    %6 = fcmp une double %3, %5
    %matches.1 = select i1 %6, i32 0, i32 %matches.05
    %7 = icmp slt i32 %lsr.iv, %size
    %8 = icmp ne i32 %matches.1, 0
    %9 = and i1 %7, %8
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    %matches.0.lcssa = phi i32 [ 1, %0 ], [ %matches.1, %.lr.ph ]
    ret i32 %matches.0.lcssa
  }
  
  declare i32 @glGenLists(i32 signext) #3
  
  declare void @glBegin(i32 signext) #3
  
  declare void @glNormal3dv(double*) #3
  
  declare void @glVertex3dv(double*) #3
  
  declare void @glEnd() #3
  
  ; Function Attrs: nounwind
  declare double @cos(double) #0
  
  ; Function Attrs: nounwind
  declare double @sin(double) #0
  
  declare void @m_xformpt(double*, double*, double*, double*) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawtriangle(i32 signext %i, i32 signext %geomType, double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    %p1.i.i = alloca [3 x double], align 8
    %p2.i.i = alloca [3 x double], align 8
    %p3.i.i = alloca [3 x double], align 8
    %q0.i.i = alloca [3 x double], align 8
    %q1.i.i = alloca [3 x double], align 8
    %n11.i.i = alloca [3 x double], align 8
    switch i32 %geomType, label %31 [
      i32 0, label %1
      i32 1, label %11
      i32 2, label %21
    ]
  
  ; <label>:1                                       ; preds = %0
    %2 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 0
    %3 = load i32, i32* %2, align 4, !tbaa !13
    %4 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %3, i32 0
    %5 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 1
    %6 = load i32, i32* %5, align 4, !tbaa !13
    %7 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %6, i32 0
    %8 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 2
    %9 = load i32, i32* %8, align 4, !tbaa !13
    %10 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %9, i32 0
    br label %31
  
  ; <label>:11                                      ; preds = %0
    %12 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 0
    %13 = load i32, i32* %12, align 4, !tbaa !13
    %14 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %13, i32 0
    %15 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 1
    %16 = load i32, i32* %15, align 4, !tbaa !13
    %17 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %16, i32 0
    %18 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 2
    %19 = load i32, i32* %18, align 4, !tbaa !13
    %20 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %19, i32 0
    br label %31
  
  ; <label>:21                                      ; preds = %0
    %22 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 0
    %23 = load i32, i32* %22, align 4, !tbaa !13
    %24 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %23, i32 0
    %25 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 1
    %26 = load i32, i32* %25, align 4, !tbaa !13
    %27 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %26, i32 0
    %28 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 2
    %29 = load i32, i32* %28, align 4, !tbaa !13
    %30 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %29, i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %21, %11, %1, %0
    %x0.0 = phi double* [ undef, %0 ], [ %24, %21 ], [ %14, %11 ], [ %4, %1 ]
    %x1.0 = phi double* [ undef, %0 ], [ %27, %21 ], [ %17, %11 ], [ %7, %1 ]
    %x2.0 = phi double* [ undef, %0 ], [ %30, %21 ], [ %20, %11 ], [ %10, %1 ]
    %32 = load double, double* %x0.0, align 8, !tbaa !1
    %33 = fmul double %32, 0.000000e+00
    %34 = load double, double* %x1.0, align 8, !tbaa !1
    %35 = fmul double %34, 0.000000e+00
    %36 = fadd double %33, %35
    %37 = load double, double* %x2.0, align 8, !tbaa !1
    %38 = fadd double %37, %36
    %39 = fadd double %32, %35
    %40 = fmul double %37, 0.000000e+00
    %41 = fadd double %39, %40
    %42 = fadd double %33, %34
    %43 = fadd double %42, %40
    %44 = getelementptr inbounds double, double* %x0.0, i32 1
    %45 = load double, double* %44, align 8, !tbaa !1
    %46 = fmul double %45, 0.000000e+00
    %47 = getelementptr inbounds double, double* %x1.0, i32 1
    %48 = load double, double* %47, align 8, !tbaa !1
    %49 = fmul double %48, 0.000000e+00
    %50 = fadd double %46, %49
    %51 = getelementptr inbounds double, double* %x2.0, i32 1
    %52 = load double, double* %51, align 8, !tbaa !1
    %53 = fadd double %52, %50
    %54 = fadd double %45, %49
    %55 = fmul double %52, 0.000000e+00
    %56 = fadd double %54, %55
    %57 = fadd double %46, %48
    %58 = fadd double %57, %55
    %59 = getelementptr inbounds double, double* %x0.0, i32 2
    %60 = load double, double* %59, align 8, !tbaa !1
    %61 = fmul double %60, 0.000000e+00
    %62 = getelementptr inbounds double, double* %x1.0, i32 2
    %63 = load double, double* %62, align 8, !tbaa !1
    %64 = fmul double %63, 0.000000e+00
    %65 = fadd double %61, %64
    %66 = getelementptr inbounds double, double* %x2.0, i32 2
    %67 = load double, double* %66, align 8, !tbaa !1
    %68 = fadd double %67, %65
    %69 = fadd double %60, %64
    %70 = fmul double %67, 0.000000e+00
    %71 = fadd double %69, %70
    %72 = fadd double %61, %63
    %73 = fadd double %72, %70
    %74 = fmul double %38, %38
    %75 = fmul double %53, %53
    %76 = fadd double %74, %75
    %77 = fmul double %68, %68
    %78 = fadd double %76, %77
    %79 = tail call double @sqrt(double %78) #5
    %80 = fcmp oeq double %79, %79
    br i1 %80, label %.split, label %call.sqrt
  
  call.sqrt:                                        ; preds = %31
    %81 = tail call double @sqrt(double %78) #4
    br label %.split
  
  .split:                                           ; preds = %31, %call.sqrt
    %82 = phi double [ %79, %31 ], [ %81, %call.sqrt ]
    %83 = fdiv double %38, %82
    %84 = fdiv double %53, %82
    %85 = fdiv double %68, %82
    %86 = fmul double %41, %41
    %87 = fmul double %56, %56
    %88 = fadd double %86, %87
    %89 = fmul double %71, %71
    %90 = fadd double %88, %89
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %.split.split, label %call.sqrt1
  
  call.sqrt1:                                       ; preds = %.split
    %93 = tail call double @sqrt(double %90) #4
    br label %.split.split
  
  .split.split:                                     ; preds = %.split, %call.sqrt1
    %94 = phi double [ %91, %.split ], [ %93, %call.sqrt1 ]
    %95 = fdiv double %41, %94
    %96 = fdiv double %56, %94
    %97 = fdiv double %71, %94
    %98 = fmul double %43, %43
    %99 = fmul double %58, %58
    %100 = fadd double %98, %99
    %101 = fmul double %73, %73
    %102 = fadd double %100, %101
    %103 = tail call double @sqrt(double %102) #5
    %104 = fcmp oeq double %103, %103
    br i1 %104, label %.split.split.split, label %call.sqrt2
  
  call.sqrt2:                                       ; preds = %.split.split
    %105 = tail call double @sqrt(double %102) #4
    br label %.split.split.split
  
  .split.split.split:                               ; preds = %.split.split, %call.sqrt2
    %106 = phi double [ %103, %.split.split ], [ %105, %call.sqrt2 ]
    %107 = bitcast [3 x double]* %n11.i.i to double*
    %108 = bitcast [3 x double]* %q1.i.i to double*
    %109 = bitcast [3 x double]* %q0.i.i to double*
    %110 = bitcast [3 x double]* %p3.i.i to double*
    %111 = bitcast [3 x double]* %p2.i.i to double*
    %112 = bitcast [3 x double]* %p1.i.i to double*
    %113 = bitcast [3 x double]* %n11.i.i to i8*
    %114 = bitcast [3 x double]* %q1.i.i to i8*
    %115 = bitcast [3 x double]* %q0.i.i to i8*
    %116 = bitcast [3 x double]* %p3.i.i to i8*
    %117 = bitcast [3 x double]* %p2.i.i to i8*
    %118 = bitcast [3 x double]* %p1.i.i to i8*
    %119 = fdiv double %43, %106
    %120 = fdiv double %58, %106
    %121 = fdiv double %73, %106
    call void @llvm.lifetime.start(i64 24, i8* %118) #4
    call void @llvm.lifetime.start(i64 24, i8* %117) #4
    call void @llvm.lifetime.start(i64 24, i8* %116) #4
    call void @llvm.lifetime.start(i64 24, i8* %115) #4
    call void @llvm.lifetime.start(i64 24, i8* %114) #4
    call void @llvm.lifetime.start(i64 24, i8* %113) #4
    %122 = fmul double %95, %radius
    %123 = load double, double* %p0, align 8, !tbaa !1
    %124 = fadd double %122, %123
    store double %124, double* %112, align 8, !tbaa !1
    %125 = fmul double %83, %radius
    %126 = fadd double %125, %123
    store double %126, double* %111, align 8, !tbaa !1
    %127 = fmul double %119, %radius
    %128 = fadd double %127, %123
    store double %128, double* %110, align 8, !tbaa !1
    %129 = fmul double %96, %radius
    %sunkaddr = ptrtoint double* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    %130 = load double, double* %sunkaddr4, align 8, !tbaa !1
    %131 = fadd double %129, %130
    %sunkaddr5 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr6 = add i32 %sunkaddr5, 8
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %131, double* %sunkaddr7, align 8, !tbaa !1
    %132 = fmul double %84, %radius
    %133 = fadd double %132, %130
    %sunkaddr8 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %133, double* %sunkaddr10, align 8, !tbaa !1
    %134 = fmul double %120, %radius
    %135 = fadd double %134, %130
    %sunkaddr11 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr12 = add i32 %sunkaddr11, 8
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %135, double* %sunkaddr13, align 8, !tbaa !1
    %136 = fmul double %97, %radius
    %sunkaddr14 = ptrtoint double* %p0 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 16
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    %137 = load double, double* %sunkaddr16, align 8, !tbaa !1
    %138 = fadd double %136, %137
    %sunkaddr17 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %138, double* %sunkaddr19, align 8, !tbaa !1
    %139 = fmul double %85, %radius
    %140 = fadd double %139, %137
    %sunkaddr20 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr21 = add i32 %sunkaddr20, 16
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %140, double* %sunkaddr22, align 8, !tbaa !1
    %141 = fmul double %121, %radius
    %142 = fadd double %141, %137
    %sunkaddr23 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %142, double* %sunkaddr25, align 8, !tbaa !1
    call void @diff3(double* %112, double* %111, double* %109) #4
    call void @diff3(double* %111, double* %110, double* %108) #4
    call void @crossprod(double* %109, double* %108, double* %108) #4
    call void @normalize(double* %108) #4
    call void @m_xformpt(double* %112, double* %112, double* %108, double* %107) #4
    call void @m_xformptonly(double* %111, double* %111) #4
    call void @m_xformptonly(double* %110, double* %110) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %107) #4
    call void @glVertex3dv(double* %112) #4
    call void @glVertex3dv(double* %111) #4
    call void @glVertex3dv(double* %110) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %113) #4
    call void @llvm.lifetime.end(i64 24, i8* %114) #4
    call void @llvm.lifetime.end(i64 24, i8* %115) #4
    call void @llvm.lifetime.end(i64 24, i8* %116) #4
    call void @llvm.lifetime.end(i64 24, i8* %117) #4
    call void @llvm.lifetime.end(i64 24, i8* %118) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  declare void @diff3(double*, double*, double*) #3
  
  declare void @crossprod(double*, double*, double*) #3
  
  declare void @normalize(double*) #3
  
  declare void @m_xformptonly(double*, double*) #3
  
  declare void @m_pushmatrix() #3
  
  declare void @m_translate(double, double, double) #3
  
  declare void @m_scale(double, double, double) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @pentagon(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %shadeType) unnamed_addr #0 {
    %n0 = alloca [3 x double], align 8
    %d1 = alloca [3 x double], align 8
    %d2 = alloca [3 x double], align 8
    %d3 = alloca [3 x double], align 8
    %d4 = alloca [3 x double], align 8
    %d5 = alloca [3 x double], align 8
    %nout = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %d1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %d2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %d3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %d4 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %d5 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %nout to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %a, i32 0
    %9 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %b, i32 0
    %10 = bitcast [3 x double]* %d1 to double*
    call void @diff3(double* %8, double* %9, double* %10) #4
    %11 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %c, i32 0
    %12 = bitcast [3 x double]* %d2 to double*
    call void @diff3(double* %9, double* %11, double* %12) #4
    %13 = bitcast [3 x double]* %n0 to double*
    call void @crossprod(double* %10, double* %12, double* %13) #4
    call void @normalize(double* %13) #4
    %14 = bitcast [3 x double]* %nout to double*
    call void @m_xformpt(double* %8, double* %10, double* %13, double* %14) #4
    call void @m_xformptonly(double* %9, double* %12) #4
    %15 = bitcast [3 x double]* %d3 to double*
    call void @m_xformptonly(double* %11, double* %15) #4
    %16 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %d, i32 0
    %17 = bitcast [3 x double]* %d4 to double*
    call void @m_xformptonly(double* %16, double* %17) #4
    %18 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %e, i32 0
    %19 = bitcast [3 x double]* %d5 to double*
    call void @m_xformptonly(double* %18, double* %19) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %14) #4
    call void @glVertex3dv(double* %10) #4
    call void @glVertex3dv(double* %12) #4
    call void @glVertex3dv(double* %15) #4
    call void @glVertex3dv(double* %17) #4
    call void @glVertex3dv(double* %19) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %7) #4
    call void @llvm.lifetime.end(i64 24, i8* %6) #4
    call void @llvm.lifetime.end(i64 24, i8* %5) #4
    call void @llvm.lifetime.end(i64 24, i8* %4) #4
    call void @llvm.lifetime.end(i64 24, i8* %3) #4
    call void @llvm.lifetime.end(i64 24, i8* %2) #4
    call void @llvm.lifetime.end(i64 24, i8* %1) #4
    ret void
  }
  
  declare void @m_popmatrix() #3
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { norecurse nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { nounwind }
  attributes #5 = { nounwind readnone }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !2, i64 0}
  !2 = !{!"double", !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"any pointer", !3, i64 0}
  !7 = !{!8, !6, i64 12}
  !8 = !{!"model", !9, i64 0, !6, i64 4, !9, i64 8, !6, i64 12}
  !9 = !{!"int", !3, i64 0}
  !10 = !{!8, !9, i64 0}
  !11 = !{!8, !9, i64 8}
  !12 = !{!8, !6, i64 4}
  !13 = !{!9, !9, i64 0}

...
---
name:            auxWireSphere
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: afgr64 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: afgr64 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
liveins:         
  - { reg: '%d6', virtual-reg: '%5' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 40):
    successors: %bb.4.findList.exit.thread(37), %bb.7(62)
    liveins: %d6, %t9, %v0
  
    %6 = ADDu %v0, %t9
    %5 = COPY %d6
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %7 = LW %6, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %8 = ADDiu %zero, 8
    %a0 = COPY %8
    %gp = COPY %6
    %t9 = COPY %7
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %9 = COPY %v0
    SDC1 %5, %9, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.2, !tbaa !1)
    %10 = LW %6, target-flags(<unknown>) @lists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %1 = LW %10, target-flags(<unknown>) @lists, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from `%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0)`, !tbaa !5)
    %0 = COPY %9
    BEQ %1, %zero, %bb.4.findList.exit.thread, implicit-def %at
  
  bb.7 (freq 25):
    successors: %bb.1.compareParams.exit.i(100)
  
  
  bb.1.compareParams.exit.i (freq 409):
    successors: %bb.2(96), %bb.3.findList.exit(3)
  
    %2 = PHI %1, %bb.7, %3, %bb.2
    %11 = LW %2, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.4, !tbaa !7)
    %12 = LDC1 killed %11, 0, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 8 from %ir.5, !tbaa !1)
    FCMP_D32 killed %12, %5, 2, implicit-def %fcc0
    BC1T %fcc0, %bb.3.findList.exit, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.7, freq 396):
    successors: %bb.4.findList.exit.thread(3), %bb.1.compareParams.exit.i(96)
  
    %3 = LW %2, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.8, !tbaa !5)
    BEQ %3, %zero, %bb.4.findList.exit.thread, implicit-def dead %at
    B %bb.1.compareParams.exit.i, implicit-def dead %at
  
  bb.3.findList.exit (freq 12):
    successors: %bb.4.findList.exit.thread(37), %bb.5(62)
  
    %4 = LW %2, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.10, !tbaa !10)
    BNE %4, %zero, %bb.5, implicit-def dead %at
    B %bb.4.findList.exit.thread, implicit-def dead %at
  
  bb.4.findList.exit.thread (freq 32):
    successors: %bb.6(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %15 = LW %6, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %16 = ADDiu %zero, 16
    %a0 = COPY %16
    %t9 = COPY %15
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %17 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %18 = LW %6, target-flags(<unknown>) @glGenLists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glGenLists)
    %19 = ADDiu %zero, 1
    %a0 = COPY %19
    %gp = COPY %6
    %t9 = COPY %18
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %20 = COPY %v0
    %22 = ADDiu %zero, 4865
    SW %20, %17, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.15, !tbaa !10)
    SW %19, %17, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.17, !tbaa !11)
    SW %0, %17, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.19, !tbaa !7)
    %23 = LW %10, target-flags(<unknown>) @lists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast ([25 x %struct.model*]* @lists to i32*)`, !tbaa !5)
    SW killed %23, %17, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.22, !tbaa !12)
    SW %17, %10, target-flags(<unknown>) @lists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast ([25 x %struct.model*]* @lists to i8**)`, !tbaa !5)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %24 = LW %6, target-flags(<unknown>) @glNewList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glNewList)
    %a0 = COPY %20
    %a1 = COPY %22
    %gp = COPY %6
    %t9 = COPY %24
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %25 = LW %6, target-flags(<unknown>) @gluNewQuadric, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @gluNewQuadric)
    %gp = COPY %6
    %t9 = COPY %25
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %26 = COPY %v0
    %27 = LUi 1
    %28 = ORi killed %27, 34475
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %29 = LW %6, target-flags(<unknown>) @gluQuadricDrawStyle, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @gluQuadricDrawStyle)
    %a0 = COPY %26
    %a1 = COPY %28
    %gp = COPY %6
    %t9 = COPY %29
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %30 = ExtractElementF64 %5, 1
    %31 = ExtractElementF64 %5, 0
    ADJCALLSTACKDOWN 24, implicit-def dead %sp, implicit %sp
    %32 = COPY %sp
    SW %16, %32, 20, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %16, %32, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %33 = LW %6, target-flags(<unknown>) @gluSphere, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @gluSphere)
    %a0 = COPY %26
    %a2 = COPY %30
    %a3 = COPY %31
    %gp = COPY %6
    %t9 = COPY %33
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 24, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %34 = LW %6, target-flags(<unknown>) @glEndList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glEndList)
    %gp = COPY %6
    %t9 = COPY %34
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.6, implicit-def dead %at
  
  bb.5 (%ir-block.24, freq 7):
    successors: %bb.6(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %13 = LW %6, target-flags(<unknown>) @glCallList, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @glCallList)
    %a0 = COPY %4
    %gp = COPY %6
    %t9 = COPY %13
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %14 = LW %6, target-flags(<unknown>) @free, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @free)
    %a0 = COPY %0
    %gp = COPY %6
    %t9 = COPY %14
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.6 (%ir-block.25, freq 40):
    liveouts:
  
    RetRA

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/mesa/mesa.shapes.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.model = type { i32, %struct.model*, i32, double* }
  %struct.GLUquadricObj = type opaque
  
  @auxWireIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @lists = internal unnamed_addr global [25 x %struct.model*] zeroinitializer, align 4
  @drawbox.n = internal global [6 x [3 x double]] [[3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @drawbox.faces = internal unnamed_addr constant [6 x [4 x i32]] [[4 x i32] [i32 0, i32 1, i32 2, i32 3], [4 x i32] [i32 3, i32 2, i32 6, i32 7], [4 x i32] [i32 7, i32 6, i32 5, i32 4], [4 x i32] [i32 4, i32 5, i32 1, i32 0], [4 x i32] [i32 5, i32 6, i32 2, i32 1], [4 x i32] [i32 7, i32 4, i32 0, i32 3]], align 4
  @iindex = internal unnamed_addr constant [20 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 1], [3 x i32] [i32 0, i32 9, i32 4], [3 x i32] [i32 9, i32 5, i32 4], [3 x i32] [i32 4, i32 5, i32 8], [3 x i32] [i32 4, i32 8, i32 1], [3 x i32] [i32 8, i32 10, i32 1], [3 x i32] [i32 8, i32 3, i32 10], [3 x i32] [i32 5, i32 3, i32 8], [3 x i32] [i32 5, i32 2, i32 3], [3 x i32] [i32 2, i32 7, i32 3], [3 x i32] [i32 7, i32 10, i32 3], [3 x i32] [i32 7, i32 6, i32 10], [3 x i32] [i32 7, i32 11, i32 6], [3 x i32] [i32 11, i32 0, i32 6], [3 x i32] [i32 0, i32 1, i32 6], [3 x i32] [i32 6, i32 1, i32 10], [3 x i32] [i32 9, i32 0, i32 11], [3 x i32] [i32 9, i32 11, i32 2], [3 x i32] [i32 9, i32 2, i32 5], [3 x i32] [i32 7, i32 2, i32 11]], align 4
  @idata = internal global [12 x [3 x double]] [[3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00]], align 8
  @ondex = internal unnamed_addr constant [8 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 2], [3 x i32] [i32 1, i32 2, i32 4], [3 x i32] [i32 0, i32 3, i32 4], [3 x i32] [i32 1, i32 4, i32 3], [3 x i32] [i32 0, i32 2, i32 5], [3 x i32] [i32 1, i32 5, i32 2], [3 x i32] [i32 0, i32 5, i32 3], [3 x i32] [i32 1, i32 3, i32 5]], align 4
  @odata = internal global [6 x [3 x double]] [[3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @tndex = internal unnamed_addr constant [4 x [3 x i32]] [[3 x i32] [i32 0, i32 1, i32 3], [3 x i32] [i32 2, i32 1, i32 0], [3 x i32] [i32 3, i32 2, i32 0], [3 x i32] [i32 1, i32 2, i32 3]], align 4
  @tdata = internal global [4 x [3 x double]] [[3 x double] [double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA], [3 x double] [double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA]], align 8
  @dodecahedron.inited = internal unnamed_addr global i1 false
  @dodec = internal global [20 x [3 x double]] zeroinitializer, align 8
  
  ; Function Attrs: nounwind
  define void @auxWireSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast ([25 x %struct.model*]* @lists to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast ([25 x %struct.model*]* @lists to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100011) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare noalias i8* @malloc(i32 signext) #0
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @findList(i32 signext %lindex, double* nocapture readonly %paramArray, i32 signext %size) #2 {
    %1 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %endList.02 = load %struct.model*, %struct.model** %1, align 4, !tbaa !5
    %2 = icmp eq %struct.model* %endList.02, null
    br i1 %2, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0
    br label %3
  
  ; <label>:3                                       ; preds = %18, %.lr.ph
    %endList.03 = phi %struct.model* [ %endList.02, %.lr.ph ], [ %endList.0, %18 ]
    %4 = icmp sgt i32 %size, 0
    br i1 %4, label %.lr.ph.i.preheader, label %compareParams.exit.thread
  
  .lr.ph.i.preheader:                               ; preds = %3
    %5 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 3
    %6 = load double*, double** %5, align 4, !tbaa !7
    br label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %matches.05.i = phi i32 [ %matches.1.i, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %.03.i = phi double* [ %7, %.lr.ph.i ], [ %6, %.lr.ph.i.preheader ]
    %.012.i = phi double* [ %9, %.lr.ph.i ], [ %paramArray, %.lr.ph.i.preheader ]
    %7 = getelementptr inbounds double, double* %.03.i, i32 1
    %8 = load double, double* %.03.i, align 8, !tbaa !1
    %9 = getelementptr inbounds double, double* %.012.i, i32 1
    %10 = load double, double* %.012.i, align 8, !tbaa !1
    %11 = fcmp une double %8, %10
    %matches.1.i = select i1 %11, i32 0, i32 %matches.05.i
    %12 = icmp slt i32 %lsr.iv, %size
    %13 = icmp ne i32 %matches.1.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %14, label %.lr.ph.i, label %compareParams.exit
  
  compareParams.exit:                               ; preds = %.lr.ph.i
    %15 = icmp eq i32 %matches.1.i, 0
    br i1 %15, label %18, label %compareParams.exit.thread
  
  compareParams.exit.thread:                        ; preds = %compareParams.exit, %3
    %16 = bitcast %struct.model* %endList.03 to i32*
    %17 = load i32, i32* %16, align 4, !tbaa !10
    br label %.loopexit
  
  ; <label>:18                                      ; preds = %compareParams.exit
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 1
    %endList.0 = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0, null
    br i1 %20, label %.loopexit, label %3
  
  .loopexit:                                        ; preds = %18, %compareParams.exit.thread, %0
    %.0 = phi i32 [ %17, %compareParams.exit.thread ], [ 0, %0 ], [ 0, %18 ]
    ret i32 %.0
  }
  
  declare void @glNewList(i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @makeModelPtr(i32 signext %lindex, double* %sizeArray, i32 signext %count) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = tail call i32 @glGenLists(i32 signext 1) #4
    %3 = bitcast i8* %1 to i32*
    store i32 %2, i32* %3, align 4, !tbaa !10
    %4 = getelementptr inbounds i8, i8* %1, i32 8
    %5 = bitcast i8* %4 to i32*
    store i32 %count, i32* %5, align 4, !tbaa !11
    %6 = getelementptr inbounds i8, i8* %1, i32 12
    %7 = bitcast i8* %6 to double**
    store double* %sizeArray, double** %7, align 4, !tbaa !7
    %8 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %9 = bitcast %struct.model** %8 to i32*
    %10 = load i32, i32* %9, align 4, !tbaa !5
    %11 = getelementptr inbounds i8, i8* %1, i32 4
    %12 = bitcast i8* %11 to i32*
    store i32 %10, i32* %12, align 4, !tbaa !12
    %13 = bitcast %struct.model** %8 to i8**
    store i8* %1, i8** %13, align 4, !tbaa !5
    ret i32 %2
  }
  
  declare %struct.GLUquadricObj* @gluNewQuadric() #3
  
  declare void @gluQuadricDrawStyle(%struct.GLUquadricObj*, i32 signext) #3
  
  declare void @gluSphere(%struct.GLUquadricObj*, double, i32 signext, i32 signext) #3
  
  declare void @glEndList() #3
  
  declare void @glCallList(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  define void @auxSolidSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %23, i32 signext 100000) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  declare void @gluQuadricNormals(%struct.GLUquadricObj*, i32 signext) #3
  
  ; Function Attrs: nounwind
  define void @auxWireCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 2)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawbox(double %x0, double %x1, double %y0, double %y1, double %z0, double %z1, i32 signext %type) unnamed_addr #0 {
    %v = alloca [8 x [3 x double]], align 8
    %1 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.start(i64 192, i8* %1) #4
    %2 = fcmp ogt double %x0, %x1
    %.05 = select i1 %2, double %x0, double %x1
    %.0 = select i1 %2, double %x1, double %x0
    %3 = fcmp ogt double %y0, %y1
    %.04 = select i1 %3, double %y1, double %y0
    %.03 = select i1 %3, double %y0, double %y1
    %4 = fcmp ogt double %z0, %z1
    %.02 = select i1 %4, double %z1, double %z0
    %.01 = select i1 %4, double %z0, double %z1
    %5 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 0
    store double %.0, double* %5, align 8, !tbaa !1
    %6 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 0
    store double %.0, double* %6, align 8, !tbaa !1
    %7 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 0
    store double %.0, double* %7, align 8, !tbaa !1
    %8 = bitcast [8 x [3 x double]]* %v to double*
    store double %.0, double* %8, align 8, !tbaa !1
    %9 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 0
    store double %.05, double* %9, align 8, !tbaa !1
    %10 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 0
    store double %.05, double* %10, align 8, !tbaa !1
    %11 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 0
    store double %.05, double* %11, align 8, !tbaa !1
    %12 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 0
    store double %.05, double* %12, align 8, !tbaa !1
    %13 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 1
    store double %.04, double* %13, align 8, !tbaa !1
    %14 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 1
    store double %.04, double* %14, align 8, !tbaa !1
    %15 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 1
    store double %.04, double* %15, align 8, !tbaa !1
    %16 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 1
    store double %.04, double* %16, align 8, !tbaa !1
    %17 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 1
    store double %.03, double* %17, align 8, !tbaa !1
    %18 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 1
    store double %.03, double* %18, align 8, !tbaa !1
    %19 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 1
    store double %.03, double* %19, align 8, !tbaa !1
    %20 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 1
    store double %.03, double* %20, align 8, !tbaa !1
    %21 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 2
    store double %.02, double* %21, align 8, !tbaa !1
    %22 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 2
    store double %.02, double* %22, align 8, !tbaa !1
    %23 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 2
    store double %.02, double* %23, align 8, !tbaa !1
    %24 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 2
    store double %.02, double* %24, align 8, !tbaa !1
    %25 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 2
    store double %.01, double* %25, align 8, !tbaa !1
    %26 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 2
    store double %.01, double* %26, align 8, !tbaa !1
    %27 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 2
    store double %.01, double* %27, align 8, !tbaa !1
    %28 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 2
    store double %.01, double* %28, align 8, !tbaa !1
    br label %29
  
  ; <label>:29                                      ; preds = %29, %0
    %lsr.iv1 = phi [6 x [4 x i32]]* [ %38, %29 ], [ bitcast (i32* getelementptr inbounds ([6 x [4 x i32]], [6 x [4 x i32]]* @drawbox.faces, i32 0, i32 0, i32 2) to [6 x [4 x i32]]*), %0 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %29 ], [ 0, %0 ]
    %lsr.iv12 = bitcast [6 x [4 x i32]]* %lsr.iv1 to i32*
    call void @glBegin(i32 signext %type) #4
    %uglygep11 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep1112 = bitcast i8* %uglygep11 to double*
    call void @glNormal3dv(double* %uglygep1112) #4
    %scevgep5 = getelementptr i32, i32* %lsr.iv12, i32 -2
    %30 = load i32, i32* %scevgep5, align 4, !tbaa !13
    %31 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %30, i32 0
    call void @glVertex3dv(double* %31) #4
    %uglygep9 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep910 = bitcast i8* %uglygep9 to double*
    call void @glNormal3dv(double* %uglygep910) #4
    %scevgep4 = getelementptr i32, i32* %lsr.iv12, i32 -1
    %32 = load i32, i32* %scevgep4, align 4, !tbaa !13
    %33 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %32, i32 0
    call void @glVertex3dv(double* %33) #4
    %uglygep7 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep78 = bitcast i8* %uglygep7 to double*
    call void @glNormal3dv(double* %uglygep78) #4
    %34 = load i32, i32* %lsr.iv12, align 4, !tbaa !13
    %35 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %34, i32 0
    call void @glVertex3dv(double* %35) #4
    %uglygep = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep6 = bitcast i8* %uglygep to double*
    call void @glNormal3dv(double* %uglygep6) #4
    %scevgep3 = getelementptr i32, i32* %lsr.iv12, i32 1
    %36 = load i32, i32* %scevgep3, align 4, !tbaa !13
    %37 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %36, i32 0
    call void @glVertex3dv(double* %37) #4
    call void @glEnd() #4
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 24
    %scevgep = getelementptr [6 x [4 x i32]], [6 x [4 x i32]]* %lsr.iv1, i32 0, i32 1, i32 0
    %38 = bitcast i32* %scevgep to [6 x [4 x i32]]*
    %exitcond = icmp eq i32 %lsr.iv.next, 144
    br i1 %exitcond, label %39, label %29
  
  ; <label>:39                                      ; preds = %29
    %40 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.end(i64 192, i8* %40) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 7)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 2)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 7)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 5, i32 signext 10, i32 signext 2)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @doughnut(double %r, double %R, i32 signext %nsides, i32 signext %rings, i32 signext %type) unnamed_addr #0 {
    %p0 = alloca [3 x double], align 8
    %p1 = alloca [3 x double], align 8
    %p2 = alloca [3 x double], align 8
    %p3 = alloca [3 x double], align 8
    %n0 = alloca [3 x double], align 8
    %n1 = alloca [3 x double], align 8
    %n2 = alloca [3 x double], align 8
    %n3 = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %p1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %p2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %p3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %n1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %n2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = bitcast [3 x double]* %n3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %8) #4
    %9 = icmp sgt i32 %rings, 0
    br i1 %9, label %.lr.ph3, label %._crit_edge
  
  .lr.ph3:                                          ; preds = %0
    %10 = sitofp i32 %rings to double
    %11 = sitofp i32 %nsides to double
    br label %12
  
  .loopexit:                                        ; preds = %.lr.ph, %12
    %exitcond4 = icmp eq i32 %17, %rings
    br i1 %exitcond4, label %._crit_edge, label %12
  
  ; <label>:12                                      ; preds = %.loopexit, %.lr.ph3
    %IV.S.1 = phi double [ 0.000000e+00, %.lr.ph3 ], [ %IV.S.next.2, %.loopexit ]
    %i.02 = phi i32 [ 0, %.lr.ph3 ], [ %17, %.loopexit ]
    %13 = icmp sgt i32 %nsides, 0
    %14 = fmul double %IV.S.1, 2.000000e+00
    %15 = fmul double %14, 0x400921FB54442C46
    %16 = fdiv double %15, %10
    %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
    %17 = add nuw nsw i32 %i.02, 1
    %18 = sitofp i32 %17 to double
    %19 = fmul double %18, 2.000000e+00
    %20 = fmul double %19, 0x400921FB54442C46
    %21 = fdiv double %20, %10
    br i1 %13, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %12, %.lr.ph
    %IV.S. = phi double [ %IV.S.next., %.lr.ph ], [ 0.000000e+00, %12 ]
    %j.01 = phi i32 [ %33, %.lr.ph ], [ 0, %12 ]
    %22 = bitcast [3 x double]* %n3 to double*
    %23 = bitcast [3 x double]* %n2 to double*
    %24 = bitcast [3 x double]* %n1 to double*
    %25 = bitcast [3 x double]* %n0 to double*
    %26 = bitcast [3 x double]* %p3 to double*
    %27 = bitcast [3 x double]* %p2 to double*
    %28 = bitcast [3 x double]* %p1 to double*
    %29 = bitcast [3 x double]* %p0 to double*
    %30 = fmul double %IV.S., 2.000000e+00
    %31 = fmul double %30, 0x400921FB54442C46
    %32 = fdiv double %31, %11
    %IV.S.next. = fadd double %IV.S., 1.000000e+00
    %33 = add nuw nsw i32 %j.01, 1
    %34 = sitofp i32 %33 to double
    %35 = fmul double %34, 2.000000e+00
    %36 = fmul double %35, 0x400921FB54442C46
    %37 = fdiv double %36, %11
    %38 = call double @cos(double %16) #4
    %39 = call double @cos(double %32) #4
    %40 = fmul double %39, %r
    %41 = fadd double %40, %R
    %42 = fmul double %38, %41
    store double %42, double* %29, align 8, !tbaa !1
    %43 = call double @sin(double %16) #4
    %44 = call double @cos(double %32) #4
    %45 = fmul double %44, %r
    %46 = fadd double %45, %R
    %47 = fmul double %43, %46
    %48 = fsub double -0.000000e+00, %47
    %sunkaddr = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    store double %48, double* %sunkaddr4, align 8, !tbaa !1
    %49 = call double @sin(double %32) #4
    %50 = fmul double %49, %r
    %sunkaddr5 = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr6 = add i32 %sunkaddr5, 16
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %50, double* %sunkaddr7, align 8, !tbaa !1
    %51 = call double @cos(double %21) #4
    %52 = call double @cos(double %32) #4
    %53 = fmul double %52, %r
    %54 = fadd double %53, %R
    %55 = fmul double %51, %54
    store double %55, double* %28, align 8, !tbaa !1
    %56 = call double @sin(double %21) #4
    %57 = call double @cos(double %32) #4
    %58 = fmul double %57, %r
    %59 = fadd double %58, %R
    %60 = fmul double %56, %59
    %61 = fsub double -0.000000e+00, %60
    %sunkaddr8 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %61, double* %sunkaddr10, align 8, !tbaa !1
    %62 = call double @sin(double %32) #4
    %63 = fmul double %62, %r
    %sunkaddr11 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr12 = add i32 %sunkaddr11, 16
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %63, double* %sunkaddr13, align 8, !tbaa !1
    %64 = call double @cos(double %21) #4
    %65 = call double @cos(double %37) #4
    %66 = fmul double %65, %r
    %67 = fadd double %66, %R
    %68 = fmul double %64, %67
    store double %68, double* %27, align 8, !tbaa !1
    %69 = call double @sin(double %21) #4
    %70 = call double @cos(double %37) #4
    %71 = fmul double %70, %r
    %72 = fadd double %71, %R
    %73 = fmul double %69, %72
    %74 = fsub double -0.000000e+00, %73
    %sunkaddr14 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 8
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    store double %74, double* %sunkaddr16, align 8, !tbaa !1
    %75 = call double @sin(double %37) #4
    %76 = fmul double %75, %r
    %sunkaddr17 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %76, double* %sunkaddr19, align 8, !tbaa !1
    %77 = call double @cos(double %16) #4
    %78 = call double @cos(double %37) #4
    %79 = fmul double %78, %r
    %80 = fadd double %79, %R
    %81 = fmul double %77, %80
    store double %81, double* %26, align 8, !tbaa !1
    %82 = call double @sin(double %16) #4
    %83 = call double @cos(double %37) #4
    %84 = fmul double %83, %r
    %85 = fadd double %84, %R
    %86 = fmul double %82, %85
    %87 = fsub double -0.000000e+00, %86
    %sunkaddr20 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr21 = add i32 %sunkaddr20, 8
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %87, double* %sunkaddr22, align 8, !tbaa !1
    %88 = call double @sin(double %37) #4
    %89 = fmul double %88, %r
    %sunkaddr23 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %89, double* %sunkaddr25, align 8, !tbaa !1
    %90 = call double @cos(double %16) #4
    %91 = call double @cos(double %32) #4
    %92 = fmul double %90, %91
    store double %92, double* %25, align 8, !tbaa !1
    %93 = call double @sin(double %16) #4
    %94 = call double @cos(double %32) #4
    %95 = fmul double %93, %94
    %96 = fsub double -0.000000e+00, %95
    %sunkaddr26 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr27 = add i32 %sunkaddr26, 8
    %sunkaddr28 = inttoptr i32 %sunkaddr27 to double*
    store double %96, double* %sunkaddr28, align 8, !tbaa !1
    %97 = call double @sin(double %32) #4
    %sunkaddr29 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr30 = add i32 %sunkaddr29, 16
    %sunkaddr31 = inttoptr i32 %sunkaddr30 to double*
    store double %97, double* %sunkaddr31, align 8, !tbaa !1
    %98 = call double @cos(double %21) #4
    %99 = call double @cos(double %32) #4
    %100 = fmul double %98, %99
    store double %100, double* %24, align 8, !tbaa !1
    %101 = call double @sin(double %21) #4
    %102 = call double @cos(double %32) #4
    %103 = fmul double %101, %102
    %104 = fsub double -0.000000e+00, %103
    %sunkaddr32 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr33 = add i32 %sunkaddr32, 8
    %sunkaddr34 = inttoptr i32 %sunkaddr33 to double*
    store double %104, double* %sunkaddr34, align 8, !tbaa !1
    %105 = call double @sin(double %32) #4
    %sunkaddr35 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr36 = add i32 %sunkaddr35, 16
    %sunkaddr37 = inttoptr i32 %sunkaddr36 to double*
    store double %105, double* %sunkaddr37, align 8, !tbaa !1
    %106 = call double @cos(double %21) #4
    %107 = call double @cos(double %37) #4
    %108 = fmul double %106, %107
    store double %108, double* %23, align 8, !tbaa !1
    %109 = call double @sin(double %21) #4
    %110 = call double @cos(double %37) #4
    %111 = fmul double %109, %110
    %112 = fsub double -0.000000e+00, %111
    %sunkaddr38 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr39 = add i32 %sunkaddr38, 8
    %sunkaddr40 = inttoptr i32 %sunkaddr39 to double*
    store double %112, double* %sunkaddr40, align 8, !tbaa !1
    %113 = call double @sin(double %37) #4
    %sunkaddr41 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr42 = add i32 %sunkaddr41, 16
    %sunkaddr43 = inttoptr i32 %sunkaddr42 to double*
    store double %113, double* %sunkaddr43, align 8, !tbaa !1
    %114 = call double @cos(double %16) #4
    %115 = call double @cos(double %37) #4
    %116 = fmul double %114, %115
    store double %116, double* %22, align 8, !tbaa !1
    %117 = call double @sin(double %16) #4
    %118 = call double @cos(double %37) #4
    %119 = fmul double %117, %118
    %120 = fsub double -0.000000e+00, %119
    %sunkaddr44 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr45 = add i32 %sunkaddr44, 8
    %sunkaddr46 = inttoptr i32 %sunkaddr45 to double*
    store double %120, double* %sunkaddr46, align 8, !tbaa !1
    %121 = call double @sin(double %37) #4
    %sunkaddr47 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr48 = add i32 %sunkaddr47, 16
    %sunkaddr49 = inttoptr i32 %sunkaddr48 to double*
    store double %121, double* %sunkaddr49, align 8, !tbaa !1
    call void @m_xformpt(double* %29, double* %29, double* %25, double* %25) #4
    call void @m_xformpt(double* %28, double* %28, double* %24, double* %24) #4
    call void @m_xformpt(double* %27, double* %27, double* %23, double* %23) #4
    call void @m_xformpt(double* %26, double* %26, double* %22, double* %22) #4
    call void @glBegin(i32 signext %type) #4
    call void @glNormal3dv(double* %22) #4
    call void @glVertex3dv(double* %26) #4
    call void @glNormal3dv(double* %23) #4
    call void @glVertex3dv(double* %27) #4
    call void @glNormal3dv(double* %24) #4
    call void @glVertex3dv(double* %28) #4
    call void @glNormal3dv(double* %25) #4
    call void @glVertex3dv(double* %29) #4
    call void @glEnd() #4
    %exitcond = icmp eq i32 %nsides, %33
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.loopexit, %0
    %122 = bitcast [3 x double]* %n3 to i8*
    %123 = bitcast [3 x double]* %n2 to i8*
    %124 = bitcast [3 x double]* %n1 to i8*
    %125 = bitcast [3 x double]* %n0 to i8*
    %126 = bitcast [3 x double]* %p3 to i8*
    %127 = bitcast [3 x double]* %p2 to i8*
    %128 = bitcast [3 x double]* %p1 to i8*
    %129 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.end(i64 24, i8* %122) #4
    call void @llvm.lifetime.end(i64 24, i8* %123) #4
    call void @llvm.lifetime.end(i64 24, i8* %124) #4
    call void @llvm.lifetime.end(i64 24, i8* %125) #4
    call void @llvm.lifetime.end(i64 24, i8* %126) #4
    call void @llvm.lifetime.end(i64 24, i8* %127) #4
    call void @llvm.lifetime.end(i64 24, i8* %128) #4
    call void @llvm.lifetime.end(i64 24, i8* %129) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 8, i32 signext 15, i32 signext 7)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  declare void @glPushMatrix() #3
  
  declare void @glRotatef(float, float, float, float) #3
  
  declare void @glTranslatef(float, float, float) #3
  
  declare void @gluCylinder(%struct.GLUquadricObj*, double, double, double, i32 signext, i32 signext) #3
  
  declare void @glPopMatrix() #3
  
  ; Function Attrs: nounwind
  define void @auxSolidCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @icosahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 8, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 9, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 10, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 11, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 12, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 13, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 14, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 15, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 16, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 17, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 18, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 19, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireOctahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @octahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidOctahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireDodecahedron.center, i32 0, i32 0), double %23, i32 signext 2)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @dodecahedron(double* nocapture readonly %center, double %sc, i32 signext %type) unnamed_addr #0 {
    %.b = load i1, i1* @dodecahedron.inited, align 1
    br i1 %.b, label %2, label %1
  
  ; <label>:1                                       ; preds = %0
    store i1 true, i1* @dodecahedron.inited, align 1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 2), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 2), align 8, !tbaa !1
    br label %2
  
  ; <label>:2                                       ; preds = %1, %0
    tail call void @m_pushmatrix() #4
    %3 = load double, double* %center, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %center, i32 1
    %5 = load double, double* %4, align 8, !tbaa !1
    %6 = getelementptr inbounds double, double* %center, i32 2
    %7 = load double, double* %6, align 8, !tbaa !1
    tail call void @m_translate(double %3, double %5, double %7) #4
    tail call void @m_scale(double %sc, double %sc, double %sc) #4
    tail call fastcc void @pentagon(i32 signext 0, i32 signext 1, i32 signext 9, i32 signext 16, i32 signext 5, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 0, i32 signext 3, i32 signext 18, i32 signext 7, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 7, i32 signext 11, i32 signext 10, i32 signext 9, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 11, i32 signext 7, i32 signext 18, i32 signext 19, i32 signext 6, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 8, i32 signext 17, i32 signext 16, i32 signext 9, i32 signext 10, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 14, i32 signext 15, i32 signext 6, i32 signext 19, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 13, i32 signext 12, i32 signext 4, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 19, i32 signext 18, i32 signext 3, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 3, i32 signext 0, i32 signext 5, i32 signext 12, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 6, i32 signext 15, i32 signext 8, i32 signext 10, i32 signext 11, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 17, i32 signext 8, i32 signext 15, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 12, i32 signext 5, i32 signext 16, i32 signext 17, i32 signext %type)
    tail call void @m_popmatrix() #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidDodecahedron.center, i32 0, i32 0), double %23, i32 signext 6)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @compareParams(double* nocapture readonly %oneArray, double* nocapture readonly %twoArray, i32 signext %size) #2 {
    %1 = icmp sgt i32 %size, 0
    br i1 %1, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ 1, %0 ]
    %matches.05 = phi i32 [ %matches.1, %.lr.ph ], [ 1, %0 ]
    %.03 = phi double* [ %2, %.lr.ph ], [ %oneArray, %0 ]
    %.012 = phi double* [ %4, %.lr.ph ], [ %twoArray, %0 ]
    %2 = getelementptr inbounds double, double* %.03, i32 1
    %3 = load double, double* %.03, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %.012, i32 1
    %5 = load double, double* %.012, align 8, !tbaa !1
    %6 = fcmp une double %3, %5
    %matches.1 = select i1 %6, i32 0, i32 %matches.05
    %7 = icmp slt i32 %lsr.iv, %size
    %8 = icmp ne i32 %matches.1, 0
    %9 = and i1 %7, %8
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    %matches.0.lcssa = phi i32 [ 1, %0 ], [ %matches.1, %.lr.ph ]
    ret i32 %matches.0.lcssa
  }
  
  declare i32 @glGenLists(i32 signext) #3
  
  declare void @glBegin(i32 signext) #3
  
  declare void @glNormal3dv(double*) #3
  
  declare void @glVertex3dv(double*) #3
  
  declare void @glEnd() #3
  
  ; Function Attrs: nounwind
  declare double @cos(double) #0
  
  ; Function Attrs: nounwind
  declare double @sin(double) #0
  
  declare void @m_xformpt(double*, double*, double*, double*) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawtriangle(i32 signext %i, i32 signext %geomType, double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    %p1.i.i = alloca [3 x double], align 8
    %p2.i.i = alloca [3 x double], align 8
    %p3.i.i = alloca [3 x double], align 8
    %q0.i.i = alloca [3 x double], align 8
    %q1.i.i = alloca [3 x double], align 8
    %n11.i.i = alloca [3 x double], align 8
    switch i32 %geomType, label %31 [
      i32 0, label %1
      i32 1, label %11
      i32 2, label %21
    ]
  
  ; <label>:1                                       ; preds = %0
    %2 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 0
    %3 = load i32, i32* %2, align 4, !tbaa !13
    %4 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %3, i32 0
    %5 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 1
    %6 = load i32, i32* %5, align 4, !tbaa !13
    %7 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %6, i32 0
    %8 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 2
    %9 = load i32, i32* %8, align 4, !tbaa !13
    %10 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %9, i32 0
    br label %31
  
  ; <label>:11                                      ; preds = %0
    %12 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 0
    %13 = load i32, i32* %12, align 4, !tbaa !13
    %14 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %13, i32 0
    %15 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 1
    %16 = load i32, i32* %15, align 4, !tbaa !13
    %17 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %16, i32 0
    %18 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 2
    %19 = load i32, i32* %18, align 4, !tbaa !13
    %20 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %19, i32 0
    br label %31
  
  ; <label>:21                                      ; preds = %0
    %22 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 0
    %23 = load i32, i32* %22, align 4, !tbaa !13
    %24 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %23, i32 0
    %25 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 1
    %26 = load i32, i32* %25, align 4, !tbaa !13
    %27 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %26, i32 0
    %28 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 2
    %29 = load i32, i32* %28, align 4, !tbaa !13
    %30 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %29, i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %21, %11, %1, %0
    %x0.0 = phi double* [ undef, %0 ], [ %24, %21 ], [ %14, %11 ], [ %4, %1 ]
    %x1.0 = phi double* [ undef, %0 ], [ %27, %21 ], [ %17, %11 ], [ %7, %1 ]
    %x2.0 = phi double* [ undef, %0 ], [ %30, %21 ], [ %20, %11 ], [ %10, %1 ]
    %32 = load double, double* %x0.0, align 8, !tbaa !1
    %33 = fmul double %32, 0.000000e+00
    %34 = load double, double* %x1.0, align 8, !tbaa !1
    %35 = fmul double %34, 0.000000e+00
    %36 = fadd double %33, %35
    %37 = load double, double* %x2.0, align 8, !tbaa !1
    %38 = fadd double %37, %36
    %39 = fadd double %32, %35
    %40 = fmul double %37, 0.000000e+00
    %41 = fadd double %39, %40
    %42 = fadd double %33, %34
    %43 = fadd double %42, %40
    %44 = getelementptr inbounds double, double* %x0.0, i32 1
    %45 = load double, double* %44, align 8, !tbaa !1
    %46 = fmul double %45, 0.000000e+00
    %47 = getelementptr inbounds double, double* %x1.0, i32 1
    %48 = load double, double* %47, align 8, !tbaa !1
    %49 = fmul double %48, 0.000000e+00
    %50 = fadd double %46, %49
    %51 = getelementptr inbounds double, double* %x2.0, i32 1
    %52 = load double, double* %51, align 8, !tbaa !1
    %53 = fadd double %52, %50
    %54 = fadd double %45, %49
    %55 = fmul double %52, 0.000000e+00
    %56 = fadd double %54, %55
    %57 = fadd double %46, %48
    %58 = fadd double %57, %55
    %59 = getelementptr inbounds double, double* %x0.0, i32 2
    %60 = load double, double* %59, align 8, !tbaa !1
    %61 = fmul double %60, 0.000000e+00
    %62 = getelementptr inbounds double, double* %x1.0, i32 2
    %63 = load double, double* %62, align 8, !tbaa !1
    %64 = fmul double %63, 0.000000e+00
    %65 = fadd double %61, %64
    %66 = getelementptr inbounds double, double* %x2.0, i32 2
    %67 = load double, double* %66, align 8, !tbaa !1
    %68 = fadd double %67, %65
    %69 = fadd double %60, %64
    %70 = fmul double %67, 0.000000e+00
    %71 = fadd double %69, %70
    %72 = fadd double %61, %63
    %73 = fadd double %72, %70
    %74 = fmul double %38, %38
    %75 = fmul double %53, %53
    %76 = fadd double %74, %75
    %77 = fmul double %68, %68
    %78 = fadd double %76, %77
    %79 = tail call double @sqrt(double %78) #5
    %80 = fcmp oeq double %79, %79
    br i1 %80, label %.split, label %call.sqrt
  
  call.sqrt:                                        ; preds = %31
    %81 = tail call double @sqrt(double %78) #4
    br label %.split
  
  .split:                                           ; preds = %31, %call.sqrt
    %82 = phi double [ %79, %31 ], [ %81, %call.sqrt ]
    %83 = fdiv double %38, %82
    %84 = fdiv double %53, %82
    %85 = fdiv double %68, %82
    %86 = fmul double %41, %41
    %87 = fmul double %56, %56
    %88 = fadd double %86, %87
    %89 = fmul double %71, %71
    %90 = fadd double %88, %89
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %.split.split, label %call.sqrt1
  
  call.sqrt1:                                       ; preds = %.split
    %93 = tail call double @sqrt(double %90) #4
    br label %.split.split
  
  .split.split:                                     ; preds = %.split, %call.sqrt1
    %94 = phi double [ %91, %.split ], [ %93, %call.sqrt1 ]
    %95 = fdiv double %41, %94
    %96 = fdiv double %56, %94
    %97 = fdiv double %71, %94
    %98 = fmul double %43, %43
    %99 = fmul double %58, %58
    %100 = fadd double %98, %99
    %101 = fmul double %73, %73
    %102 = fadd double %100, %101
    %103 = tail call double @sqrt(double %102) #5
    %104 = fcmp oeq double %103, %103
    br i1 %104, label %.split.split.split, label %call.sqrt2
  
  call.sqrt2:                                       ; preds = %.split.split
    %105 = tail call double @sqrt(double %102) #4
    br label %.split.split.split
  
  .split.split.split:                               ; preds = %.split.split, %call.sqrt2
    %106 = phi double [ %103, %.split.split ], [ %105, %call.sqrt2 ]
    %107 = bitcast [3 x double]* %n11.i.i to double*
    %108 = bitcast [3 x double]* %q1.i.i to double*
    %109 = bitcast [3 x double]* %q0.i.i to double*
    %110 = bitcast [3 x double]* %p3.i.i to double*
    %111 = bitcast [3 x double]* %p2.i.i to double*
    %112 = bitcast [3 x double]* %p1.i.i to double*
    %113 = bitcast [3 x double]* %n11.i.i to i8*
    %114 = bitcast [3 x double]* %q1.i.i to i8*
    %115 = bitcast [3 x double]* %q0.i.i to i8*
    %116 = bitcast [3 x double]* %p3.i.i to i8*
    %117 = bitcast [3 x double]* %p2.i.i to i8*
    %118 = bitcast [3 x double]* %p1.i.i to i8*
    %119 = fdiv double %43, %106
    %120 = fdiv double %58, %106
    %121 = fdiv double %73, %106
    call void @llvm.lifetime.start(i64 24, i8* %118) #4
    call void @llvm.lifetime.start(i64 24, i8* %117) #4
    call void @llvm.lifetime.start(i64 24, i8* %116) #4
    call void @llvm.lifetime.start(i64 24, i8* %115) #4
    call void @llvm.lifetime.start(i64 24, i8* %114) #4
    call void @llvm.lifetime.start(i64 24, i8* %113) #4
    %122 = fmul double %95, %radius
    %123 = load double, double* %p0, align 8, !tbaa !1
    %124 = fadd double %122, %123
    store double %124, double* %112, align 8, !tbaa !1
    %125 = fmul double %83, %radius
    %126 = fadd double %125, %123
    store double %126, double* %111, align 8, !tbaa !1
    %127 = fmul double %119, %radius
    %128 = fadd double %127, %123
    store double %128, double* %110, align 8, !tbaa !1
    %129 = fmul double %96, %radius
    %sunkaddr = ptrtoint double* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    %130 = load double, double* %sunkaddr4, align 8, !tbaa !1
    %131 = fadd double %129, %130
    %sunkaddr5 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr6 = add i32 %sunkaddr5, 8
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %131, double* %sunkaddr7, align 8, !tbaa !1
    %132 = fmul double %84, %radius
    %133 = fadd double %132, %130
    %sunkaddr8 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %133, double* %sunkaddr10, align 8, !tbaa !1
    %134 = fmul double %120, %radius
    %135 = fadd double %134, %130
    %sunkaddr11 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr12 = add i32 %sunkaddr11, 8
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %135, double* %sunkaddr13, align 8, !tbaa !1
    %136 = fmul double %97, %radius
    %sunkaddr14 = ptrtoint double* %p0 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 16
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    %137 = load double, double* %sunkaddr16, align 8, !tbaa !1
    %138 = fadd double %136, %137
    %sunkaddr17 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %138, double* %sunkaddr19, align 8, !tbaa !1
    %139 = fmul double %85, %radius
    %140 = fadd double %139, %137
    %sunkaddr20 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr21 = add i32 %sunkaddr20, 16
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %140, double* %sunkaddr22, align 8, !tbaa !1
    %141 = fmul double %121, %radius
    %142 = fadd double %141, %137
    %sunkaddr23 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %142, double* %sunkaddr25, align 8, !tbaa !1
    call void @diff3(double* %112, double* %111, double* %109) #4
    call void @diff3(double* %111, double* %110, double* %108) #4
    call void @crossprod(double* %109, double* %108, double* %108) #4
    call void @normalize(double* %108) #4
    call void @m_xformpt(double* %112, double* %112, double* %108, double* %107) #4
    call void @m_xformptonly(double* %111, double* %111) #4
    call void @m_xformptonly(double* %110, double* %110) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %107) #4
    call void @glVertex3dv(double* %112) #4
    call void @glVertex3dv(double* %111) #4
    call void @glVertex3dv(double* %110) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %113) #4
    call void @llvm.lifetime.end(i64 24, i8* %114) #4
    call void @llvm.lifetime.end(i64 24, i8* %115) #4
    call void @llvm.lifetime.end(i64 24, i8* %116) #4
    call void @llvm.lifetime.end(i64 24, i8* %117) #4
    call void @llvm.lifetime.end(i64 24, i8* %118) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  declare void @diff3(double*, double*, double*) #3
  
  declare void @crossprod(double*, double*, double*) #3
  
  declare void @normalize(double*) #3
  
  declare void @m_xformptonly(double*, double*) #3
  
  declare void @m_pushmatrix() #3
  
  declare void @m_translate(double, double, double) #3
  
  declare void @m_scale(double, double, double) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @pentagon(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %shadeType) unnamed_addr #0 {
    %n0 = alloca [3 x double], align 8
    %d1 = alloca [3 x double], align 8
    %d2 = alloca [3 x double], align 8
    %d3 = alloca [3 x double], align 8
    %d4 = alloca [3 x double], align 8
    %d5 = alloca [3 x double], align 8
    %nout = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %d1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %d2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %d3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %d4 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %d5 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %nout to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %a, i32 0
    %9 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %b, i32 0
    %10 = bitcast [3 x double]* %d1 to double*
    call void @diff3(double* %8, double* %9, double* %10) #4
    %11 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %c, i32 0
    %12 = bitcast [3 x double]* %d2 to double*
    call void @diff3(double* %9, double* %11, double* %12) #4
    %13 = bitcast [3 x double]* %n0 to double*
    call void @crossprod(double* %10, double* %12, double* %13) #4
    call void @normalize(double* %13) #4
    %14 = bitcast [3 x double]* %nout to double*
    call void @m_xformpt(double* %8, double* %10, double* %13, double* %14) #4
    call void @m_xformptonly(double* %9, double* %12) #4
    %15 = bitcast [3 x double]* %d3 to double*
    call void @m_xformptonly(double* %11, double* %15) #4
    %16 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %d, i32 0
    %17 = bitcast [3 x double]* %d4 to double*
    call void @m_xformptonly(double* %16, double* %17) #4
    %18 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %e, i32 0
    %19 = bitcast [3 x double]* %d5 to double*
    call void @m_xformptonly(double* %18, double* %19) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %14) #4
    call void @glVertex3dv(double* %10) #4
    call void @glVertex3dv(double* %12) #4
    call void @glVertex3dv(double* %15) #4
    call void @glVertex3dv(double* %17) #4
    call void @glVertex3dv(double* %19) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %7) #4
    call void @llvm.lifetime.end(i64 24, i8* %6) #4
    call void @llvm.lifetime.end(i64 24, i8* %5) #4
    call void @llvm.lifetime.end(i64 24, i8* %4) #4
    call void @llvm.lifetime.end(i64 24, i8* %3) #4
    call void @llvm.lifetime.end(i64 24, i8* %2) #4
    call void @llvm.lifetime.end(i64 24, i8* %1) #4
    ret void
  }
  
  declare void @m_popmatrix() #3
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { norecurse nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { nounwind }
  attributes #5 = { nounwind readnone }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !2, i64 0}
  !2 = !{!"double", !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"any pointer", !3, i64 0}
  !7 = !{!8, !6, i64 12}
  !8 = !{!"model", !9, i64 0, !6, i64 4, !9, i64 8, !6, i64 12}
  !9 = !{!"int", !3, i64 0}
  !10 = !{!8, !9, i64 0}
  !11 = !{!8, !9, i64 8}
  !12 = !{!8, !6, i64 4}
  !13 = !{!9, !9, i64 0}

...
---
name:            findList
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: afgr64 }
  - { id: 25, class: afgr64 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%14' }
  - { reg: '%a1', virtual-reg: '%15' }
  - { reg: '%a2', virtual-reg: '%16' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 18):
    successors: %bb.8..loopexit(37), %bb.1..lr.ph(62)
    liveins: %a0, %a1, %a2, %t9, %v0
  
    %18 = ADDu %v0, %t9
    %16 = COPY %a2
    %15 = COPY %a1
    %14 = COPY %a0
    %19 = SLL %14, 2
    %20 = LW %18, target-flags(<unknown>) @lists, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %21 = ADDiu killed %20, target-flags(<unknown>) @lists
    %22 = ADDu killed %21, killed %19
    %0 = LW killed %22, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.1, !tbaa !5)
    %17 = ADDiu %zero, 0
    BEQ %0, %zero, %bb.8..loopexit, implicit-def dead %at
    B %bb.1..lr.ph, implicit-def dead %at
  
  bb.1..lr.ph (freq 11):
    successors: %bb.2(100)
  
  
  bb.2 (%ir-block.3, freq 130):
    successors: %bb.3..lr.ph.i.preheader(96), %bb.6.compareParams.exit.thread(3)
  
    %1 = PHI %0, %bb.1..lr.ph, %12, %bb.7
    BLEZ %16, %bb.6.compareParams.exit.thread, implicit-def dead %at
    B %bb.3..lr.ph.i.preheader, implicit-def dead %at
  
  bb.3..lr.ph.i.preheader (freq 125):
    successors: %bb.4..lr.ph.i(100)
  
    %2 = LW %1, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.5, !tbaa !7)
    %23 = ADDiu %zero, 1
  
  bb.4..lr.ph.i (freq 4030):
    successors: %bb.9..lr.ph.i(98), %bb.5.compareParams.exit(1)
  
    %3 = PHI %23, %bb.3..lr.ph.i.preheader, %10, %bb.9..lr.ph.i
    %4 = PHI %23, %bb.3..lr.ph.i.preheader, %9, %bb.9..lr.ph.i
    %5 = PHI %2, %bb.3..lr.ph.i.preheader, %7, %bb.9..lr.ph.i
    %6 = PHI %15, %bb.3..lr.ph.i.preheader, %8, %bb.9..lr.ph.i
    %24 = LDC1 %6, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from %ir..012.i, !tbaa !1)
    %25 = LDC1 %5, 0, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 8 from %ir..03.i, !tbaa !1)
    FCMP_D32 killed %25, killed %24, 18, implicit-def %fcc0
    %9 = MOVF_I killed %zero, %fcc0, %4
    %27 = SLT %3, %16
    BEQ killed %27, %zero, %bb.5.compareParams.exit, implicit-def dead %at
    B %bb.9..lr.ph.i, implicit-def dead %at
  
  bb.9..lr.ph.i (freq 3968):
    successors: %bb.4..lr.ph.i(98), %bb.5.compareParams.exit(1)
  
    %10 = ADDiu %3, 1
    %8 = ADDiu %6, 8
    %7 = ADDiu %5, 8
    BNE %9, %zero, %bb.4..lr.ph.i, implicit-def dead %at
    B %bb.5.compareParams.exit, implicit-def dead %at
  
  bb.5.compareParams.exit (freq 125):
    successors: %bb.7(96), %bb.6.compareParams.exit.thread(3)
  
    BEQ %9, %zero, %bb.7, implicit-def dead %at
    B %bb.6.compareParams.exit.thread, implicit-def dead %at
  
  bb.6.compareParams.exit.thread (freq 8):
    successors: %bb.8..loopexit(100)
  
    %11 = LW %1, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.16, !tbaa !10)
    B %bb.8..loopexit, implicit-def dead %at
  
  bb.7 (%ir-block.18, freq 122):
    successors: %bb.8..loopexit(3), %bb.2(96)
  
    %12 = LW %1, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.19, !tbaa !5)
    BNE %12, %zero, %bb.2, implicit-def dead %at
    B %bb.8..loopexit, implicit-def dead %at
  
  bb.8..loopexit (freq 18):
    liveouts: %v0
  
    %13 = PHI %17, %bb.0, %11, %bb.6.compareParams.exit.thread, %17, %bb.7
    %v0 = COPY %13
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/mesa/mesa.shapes.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.model = type { i32, %struct.model*, i32, double* }
  %struct.GLUquadricObj = type opaque
  
  @auxWireIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @lists = internal unnamed_addr global [25 x %struct.model*] zeroinitializer, align 4
  @drawbox.n = internal global [6 x [3 x double]] [[3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @drawbox.faces = internal unnamed_addr constant [6 x [4 x i32]] [[4 x i32] [i32 0, i32 1, i32 2, i32 3], [4 x i32] [i32 3, i32 2, i32 6, i32 7], [4 x i32] [i32 7, i32 6, i32 5, i32 4], [4 x i32] [i32 4, i32 5, i32 1, i32 0], [4 x i32] [i32 5, i32 6, i32 2, i32 1], [4 x i32] [i32 7, i32 4, i32 0, i32 3]], align 4
  @iindex = internal unnamed_addr constant [20 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 1], [3 x i32] [i32 0, i32 9, i32 4], [3 x i32] [i32 9, i32 5, i32 4], [3 x i32] [i32 4, i32 5, i32 8], [3 x i32] [i32 4, i32 8, i32 1], [3 x i32] [i32 8, i32 10, i32 1], [3 x i32] [i32 8, i32 3, i32 10], [3 x i32] [i32 5, i32 3, i32 8], [3 x i32] [i32 5, i32 2, i32 3], [3 x i32] [i32 2, i32 7, i32 3], [3 x i32] [i32 7, i32 10, i32 3], [3 x i32] [i32 7, i32 6, i32 10], [3 x i32] [i32 7, i32 11, i32 6], [3 x i32] [i32 11, i32 0, i32 6], [3 x i32] [i32 0, i32 1, i32 6], [3 x i32] [i32 6, i32 1, i32 10], [3 x i32] [i32 9, i32 0, i32 11], [3 x i32] [i32 9, i32 11, i32 2], [3 x i32] [i32 9, i32 2, i32 5], [3 x i32] [i32 7, i32 2, i32 11]], align 4
  @idata = internal global [12 x [3 x double]] [[3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00]], align 8
  @ondex = internal unnamed_addr constant [8 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 2], [3 x i32] [i32 1, i32 2, i32 4], [3 x i32] [i32 0, i32 3, i32 4], [3 x i32] [i32 1, i32 4, i32 3], [3 x i32] [i32 0, i32 2, i32 5], [3 x i32] [i32 1, i32 5, i32 2], [3 x i32] [i32 0, i32 5, i32 3], [3 x i32] [i32 1, i32 3, i32 5]], align 4
  @odata = internal global [6 x [3 x double]] [[3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @tndex = internal unnamed_addr constant [4 x [3 x i32]] [[3 x i32] [i32 0, i32 1, i32 3], [3 x i32] [i32 2, i32 1, i32 0], [3 x i32] [i32 3, i32 2, i32 0], [3 x i32] [i32 1, i32 2, i32 3]], align 4
  @tdata = internal global [4 x [3 x double]] [[3 x double] [double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA], [3 x double] [double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA]], align 8
  @dodecahedron.inited = internal unnamed_addr global i1 false
  @dodec = internal global [20 x [3 x double]] zeroinitializer, align 8
  
  ; Function Attrs: nounwind
  define void @auxWireSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast ([25 x %struct.model*]* @lists to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast ([25 x %struct.model*]* @lists to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100011) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare noalias i8* @malloc(i32 signext) #0
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @findList(i32 signext %lindex, double* nocapture readonly %paramArray, i32 signext %size) #2 {
    %1 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %endList.02 = load %struct.model*, %struct.model** %1, align 4, !tbaa !5
    %2 = icmp eq %struct.model* %endList.02, null
    br i1 %2, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0
    br label %3
  
  ; <label>:3                                       ; preds = %18, %.lr.ph
    %endList.03 = phi %struct.model* [ %endList.02, %.lr.ph ], [ %endList.0, %18 ]
    %4 = icmp sgt i32 %size, 0
    br i1 %4, label %.lr.ph.i.preheader, label %compareParams.exit.thread
  
  .lr.ph.i.preheader:                               ; preds = %3
    %5 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 3
    %6 = load double*, double** %5, align 4, !tbaa !7
    br label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %matches.05.i = phi i32 [ %matches.1.i, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %.03.i = phi double* [ %7, %.lr.ph.i ], [ %6, %.lr.ph.i.preheader ]
    %.012.i = phi double* [ %9, %.lr.ph.i ], [ %paramArray, %.lr.ph.i.preheader ]
    %7 = getelementptr inbounds double, double* %.03.i, i32 1
    %8 = load double, double* %.03.i, align 8, !tbaa !1
    %9 = getelementptr inbounds double, double* %.012.i, i32 1
    %10 = load double, double* %.012.i, align 8, !tbaa !1
    %11 = fcmp une double %8, %10
    %matches.1.i = select i1 %11, i32 0, i32 %matches.05.i
    %12 = icmp slt i32 %lsr.iv, %size
    %13 = icmp ne i32 %matches.1.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %14, label %.lr.ph.i, label %compareParams.exit
  
  compareParams.exit:                               ; preds = %.lr.ph.i
    %15 = icmp eq i32 %matches.1.i, 0
    br i1 %15, label %18, label %compareParams.exit.thread
  
  compareParams.exit.thread:                        ; preds = %compareParams.exit, %3
    %16 = bitcast %struct.model* %endList.03 to i32*
    %17 = load i32, i32* %16, align 4, !tbaa !10
    br label %.loopexit
  
  ; <label>:18                                      ; preds = %compareParams.exit
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 1
    %endList.0 = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0, null
    br i1 %20, label %.loopexit, label %3
  
  .loopexit:                                        ; preds = %18, %compareParams.exit.thread, %0
    %.0 = phi i32 [ %17, %compareParams.exit.thread ], [ 0, %0 ], [ 0, %18 ]
    ret i32 %.0
  }
  
  declare void @glNewList(i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @makeModelPtr(i32 signext %lindex, double* %sizeArray, i32 signext %count) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = tail call i32 @glGenLists(i32 signext 1) #4
    %3 = bitcast i8* %1 to i32*
    store i32 %2, i32* %3, align 4, !tbaa !10
    %4 = getelementptr inbounds i8, i8* %1, i32 8
    %5 = bitcast i8* %4 to i32*
    store i32 %count, i32* %5, align 4, !tbaa !11
    %6 = getelementptr inbounds i8, i8* %1, i32 12
    %7 = bitcast i8* %6 to double**
    store double* %sizeArray, double** %7, align 4, !tbaa !7
    %8 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %9 = bitcast %struct.model** %8 to i32*
    %10 = load i32, i32* %9, align 4, !tbaa !5
    %11 = getelementptr inbounds i8, i8* %1, i32 4
    %12 = bitcast i8* %11 to i32*
    store i32 %10, i32* %12, align 4, !tbaa !12
    %13 = bitcast %struct.model** %8 to i8**
    store i8* %1, i8** %13, align 4, !tbaa !5
    ret i32 %2
  }
  
  declare %struct.GLUquadricObj* @gluNewQuadric() #3
  
  declare void @gluQuadricDrawStyle(%struct.GLUquadricObj*, i32 signext) #3
  
  declare void @gluSphere(%struct.GLUquadricObj*, double, i32 signext, i32 signext) #3
  
  declare void @glEndList() #3
  
  declare void @glCallList(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  define void @auxSolidSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %23, i32 signext 100000) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  declare void @gluQuadricNormals(%struct.GLUquadricObj*, i32 signext) #3
  
  ; Function Attrs: nounwind
  define void @auxWireCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 2)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawbox(double %x0, double %x1, double %y0, double %y1, double %z0, double %z1, i32 signext %type) unnamed_addr #0 {
    %v = alloca [8 x [3 x double]], align 8
    %1 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.start(i64 192, i8* %1) #4
    %2 = fcmp ogt double %x0, %x1
    %.05 = select i1 %2, double %x0, double %x1
    %.0 = select i1 %2, double %x1, double %x0
    %3 = fcmp ogt double %y0, %y1
    %.04 = select i1 %3, double %y1, double %y0
    %.03 = select i1 %3, double %y0, double %y1
    %4 = fcmp ogt double %z0, %z1
    %.02 = select i1 %4, double %z1, double %z0
    %.01 = select i1 %4, double %z0, double %z1
    %5 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 0
    store double %.0, double* %5, align 8, !tbaa !1
    %6 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 0
    store double %.0, double* %6, align 8, !tbaa !1
    %7 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 0
    store double %.0, double* %7, align 8, !tbaa !1
    %8 = bitcast [8 x [3 x double]]* %v to double*
    store double %.0, double* %8, align 8, !tbaa !1
    %9 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 0
    store double %.05, double* %9, align 8, !tbaa !1
    %10 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 0
    store double %.05, double* %10, align 8, !tbaa !1
    %11 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 0
    store double %.05, double* %11, align 8, !tbaa !1
    %12 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 0
    store double %.05, double* %12, align 8, !tbaa !1
    %13 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 1
    store double %.04, double* %13, align 8, !tbaa !1
    %14 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 1
    store double %.04, double* %14, align 8, !tbaa !1
    %15 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 1
    store double %.04, double* %15, align 8, !tbaa !1
    %16 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 1
    store double %.04, double* %16, align 8, !tbaa !1
    %17 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 1
    store double %.03, double* %17, align 8, !tbaa !1
    %18 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 1
    store double %.03, double* %18, align 8, !tbaa !1
    %19 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 1
    store double %.03, double* %19, align 8, !tbaa !1
    %20 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 1
    store double %.03, double* %20, align 8, !tbaa !1
    %21 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 2
    store double %.02, double* %21, align 8, !tbaa !1
    %22 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 2
    store double %.02, double* %22, align 8, !tbaa !1
    %23 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 2
    store double %.02, double* %23, align 8, !tbaa !1
    %24 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 2
    store double %.02, double* %24, align 8, !tbaa !1
    %25 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 2
    store double %.01, double* %25, align 8, !tbaa !1
    %26 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 2
    store double %.01, double* %26, align 8, !tbaa !1
    %27 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 2
    store double %.01, double* %27, align 8, !tbaa !1
    %28 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 2
    store double %.01, double* %28, align 8, !tbaa !1
    br label %29
  
  ; <label>:29                                      ; preds = %29, %0
    %lsr.iv1 = phi [6 x [4 x i32]]* [ %38, %29 ], [ bitcast (i32* getelementptr inbounds ([6 x [4 x i32]], [6 x [4 x i32]]* @drawbox.faces, i32 0, i32 0, i32 2) to [6 x [4 x i32]]*), %0 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %29 ], [ 0, %0 ]
    %lsr.iv12 = bitcast [6 x [4 x i32]]* %lsr.iv1 to i32*
    call void @glBegin(i32 signext %type) #4
    %uglygep11 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep1112 = bitcast i8* %uglygep11 to double*
    call void @glNormal3dv(double* %uglygep1112) #4
    %scevgep5 = getelementptr i32, i32* %lsr.iv12, i32 -2
    %30 = load i32, i32* %scevgep5, align 4, !tbaa !13
    %31 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %30, i32 0
    call void @glVertex3dv(double* %31) #4
    %uglygep9 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep910 = bitcast i8* %uglygep9 to double*
    call void @glNormal3dv(double* %uglygep910) #4
    %scevgep4 = getelementptr i32, i32* %lsr.iv12, i32 -1
    %32 = load i32, i32* %scevgep4, align 4, !tbaa !13
    %33 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %32, i32 0
    call void @glVertex3dv(double* %33) #4
    %uglygep7 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep78 = bitcast i8* %uglygep7 to double*
    call void @glNormal3dv(double* %uglygep78) #4
    %34 = load i32, i32* %lsr.iv12, align 4, !tbaa !13
    %35 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %34, i32 0
    call void @glVertex3dv(double* %35) #4
    %uglygep = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep6 = bitcast i8* %uglygep to double*
    call void @glNormal3dv(double* %uglygep6) #4
    %scevgep3 = getelementptr i32, i32* %lsr.iv12, i32 1
    %36 = load i32, i32* %scevgep3, align 4, !tbaa !13
    %37 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %36, i32 0
    call void @glVertex3dv(double* %37) #4
    call void @glEnd() #4
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 24
    %scevgep = getelementptr [6 x [4 x i32]], [6 x [4 x i32]]* %lsr.iv1, i32 0, i32 1, i32 0
    %38 = bitcast i32* %scevgep to [6 x [4 x i32]]*
    %exitcond = icmp eq i32 %lsr.iv.next, 144
    br i1 %exitcond, label %39, label %29
  
  ; <label>:39                                      ; preds = %29
    %40 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.end(i64 192, i8* %40) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 7)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 2)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 7)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 5, i32 signext 10, i32 signext 2)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @doughnut(double %r, double %R, i32 signext %nsides, i32 signext %rings, i32 signext %type) unnamed_addr #0 {
    %p0 = alloca [3 x double], align 8
    %p1 = alloca [3 x double], align 8
    %p2 = alloca [3 x double], align 8
    %p3 = alloca [3 x double], align 8
    %n0 = alloca [3 x double], align 8
    %n1 = alloca [3 x double], align 8
    %n2 = alloca [3 x double], align 8
    %n3 = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %p1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %p2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %p3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %n1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %n2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = bitcast [3 x double]* %n3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %8) #4
    %9 = icmp sgt i32 %rings, 0
    br i1 %9, label %.lr.ph3, label %._crit_edge
  
  .lr.ph3:                                          ; preds = %0
    %10 = sitofp i32 %rings to double
    %11 = sitofp i32 %nsides to double
    br label %12
  
  .loopexit:                                        ; preds = %.lr.ph, %12
    %exitcond4 = icmp eq i32 %17, %rings
    br i1 %exitcond4, label %._crit_edge, label %12
  
  ; <label>:12                                      ; preds = %.loopexit, %.lr.ph3
    %IV.S.1 = phi double [ 0.000000e+00, %.lr.ph3 ], [ %IV.S.next.2, %.loopexit ]
    %i.02 = phi i32 [ 0, %.lr.ph3 ], [ %17, %.loopexit ]
    %13 = icmp sgt i32 %nsides, 0
    %14 = fmul double %IV.S.1, 2.000000e+00
    %15 = fmul double %14, 0x400921FB54442C46
    %16 = fdiv double %15, %10
    %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
    %17 = add nuw nsw i32 %i.02, 1
    %18 = sitofp i32 %17 to double
    %19 = fmul double %18, 2.000000e+00
    %20 = fmul double %19, 0x400921FB54442C46
    %21 = fdiv double %20, %10
    br i1 %13, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %12, %.lr.ph
    %IV.S. = phi double [ %IV.S.next., %.lr.ph ], [ 0.000000e+00, %12 ]
    %j.01 = phi i32 [ %33, %.lr.ph ], [ 0, %12 ]
    %22 = bitcast [3 x double]* %n3 to double*
    %23 = bitcast [3 x double]* %n2 to double*
    %24 = bitcast [3 x double]* %n1 to double*
    %25 = bitcast [3 x double]* %n0 to double*
    %26 = bitcast [3 x double]* %p3 to double*
    %27 = bitcast [3 x double]* %p2 to double*
    %28 = bitcast [3 x double]* %p1 to double*
    %29 = bitcast [3 x double]* %p0 to double*
    %30 = fmul double %IV.S., 2.000000e+00
    %31 = fmul double %30, 0x400921FB54442C46
    %32 = fdiv double %31, %11
    %IV.S.next. = fadd double %IV.S., 1.000000e+00
    %33 = add nuw nsw i32 %j.01, 1
    %34 = sitofp i32 %33 to double
    %35 = fmul double %34, 2.000000e+00
    %36 = fmul double %35, 0x400921FB54442C46
    %37 = fdiv double %36, %11
    %38 = call double @cos(double %16) #4
    %39 = call double @cos(double %32) #4
    %40 = fmul double %39, %r
    %41 = fadd double %40, %R
    %42 = fmul double %38, %41
    store double %42, double* %29, align 8, !tbaa !1
    %43 = call double @sin(double %16) #4
    %44 = call double @cos(double %32) #4
    %45 = fmul double %44, %r
    %46 = fadd double %45, %R
    %47 = fmul double %43, %46
    %48 = fsub double -0.000000e+00, %47
    %sunkaddr = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    store double %48, double* %sunkaddr4, align 8, !tbaa !1
    %49 = call double @sin(double %32) #4
    %50 = fmul double %49, %r
    %sunkaddr5 = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr6 = add i32 %sunkaddr5, 16
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %50, double* %sunkaddr7, align 8, !tbaa !1
    %51 = call double @cos(double %21) #4
    %52 = call double @cos(double %32) #4
    %53 = fmul double %52, %r
    %54 = fadd double %53, %R
    %55 = fmul double %51, %54
    store double %55, double* %28, align 8, !tbaa !1
    %56 = call double @sin(double %21) #4
    %57 = call double @cos(double %32) #4
    %58 = fmul double %57, %r
    %59 = fadd double %58, %R
    %60 = fmul double %56, %59
    %61 = fsub double -0.000000e+00, %60
    %sunkaddr8 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %61, double* %sunkaddr10, align 8, !tbaa !1
    %62 = call double @sin(double %32) #4
    %63 = fmul double %62, %r
    %sunkaddr11 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr12 = add i32 %sunkaddr11, 16
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %63, double* %sunkaddr13, align 8, !tbaa !1
    %64 = call double @cos(double %21) #4
    %65 = call double @cos(double %37) #4
    %66 = fmul double %65, %r
    %67 = fadd double %66, %R
    %68 = fmul double %64, %67
    store double %68, double* %27, align 8, !tbaa !1
    %69 = call double @sin(double %21) #4
    %70 = call double @cos(double %37) #4
    %71 = fmul double %70, %r
    %72 = fadd double %71, %R
    %73 = fmul double %69, %72
    %74 = fsub double -0.000000e+00, %73
    %sunkaddr14 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 8
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    store double %74, double* %sunkaddr16, align 8, !tbaa !1
    %75 = call double @sin(double %37) #4
    %76 = fmul double %75, %r
    %sunkaddr17 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %76, double* %sunkaddr19, align 8, !tbaa !1
    %77 = call double @cos(double %16) #4
    %78 = call double @cos(double %37) #4
    %79 = fmul double %78, %r
    %80 = fadd double %79, %R
    %81 = fmul double %77, %80
    store double %81, double* %26, align 8, !tbaa !1
    %82 = call double @sin(double %16) #4
    %83 = call double @cos(double %37) #4
    %84 = fmul double %83, %r
    %85 = fadd double %84, %R
    %86 = fmul double %82, %85
    %87 = fsub double -0.000000e+00, %86
    %sunkaddr20 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr21 = add i32 %sunkaddr20, 8
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %87, double* %sunkaddr22, align 8, !tbaa !1
    %88 = call double @sin(double %37) #4
    %89 = fmul double %88, %r
    %sunkaddr23 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %89, double* %sunkaddr25, align 8, !tbaa !1
    %90 = call double @cos(double %16) #4
    %91 = call double @cos(double %32) #4
    %92 = fmul double %90, %91
    store double %92, double* %25, align 8, !tbaa !1
    %93 = call double @sin(double %16) #4
    %94 = call double @cos(double %32) #4
    %95 = fmul double %93, %94
    %96 = fsub double -0.000000e+00, %95
    %sunkaddr26 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr27 = add i32 %sunkaddr26, 8
    %sunkaddr28 = inttoptr i32 %sunkaddr27 to double*
    store double %96, double* %sunkaddr28, align 8, !tbaa !1
    %97 = call double @sin(double %32) #4
    %sunkaddr29 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr30 = add i32 %sunkaddr29, 16
    %sunkaddr31 = inttoptr i32 %sunkaddr30 to double*
    store double %97, double* %sunkaddr31, align 8, !tbaa !1
    %98 = call double @cos(double %21) #4
    %99 = call double @cos(double %32) #4
    %100 = fmul double %98, %99
    store double %100, double* %24, align 8, !tbaa !1
    %101 = call double @sin(double %21) #4
    %102 = call double @cos(double %32) #4
    %103 = fmul double %101, %102
    %104 = fsub double -0.000000e+00, %103
    %sunkaddr32 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr33 = add i32 %sunkaddr32, 8
    %sunkaddr34 = inttoptr i32 %sunkaddr33 to double*
    store double %104, double* %sunkaddr34, align 8, !tbaa !1
    %105 = call double @sin(double %32) #4
    %sunkaddr35 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr36 = add i32 %sunkaddr35, 16
    %sunkaddr37 = inttoptr i32 %sunkaddr36 to double*
    store double %105, double* %sunkaddr37, align 8, !tbaa !1
    %106 = call double @cos(double %21) #4
    %107 = call double @cos(double %37) #4
    %108 = fmul double %106, %107
    store double %108, double* %23, align 8, !tbaa !1
    %109 = call double @sin(double %21) #4
    %110 = call double @cos(double %37) #4
    %111 = fmul double %109, %110
    %112 = fsub double -0.000000e+00, %111
    %sunkaddr38 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr39 = add i32 %sunkaddr38, 8
    %sunkaddr40 = inttoptr i32 %sunkaddr39 to double*
    store double %112, double* %sunkaddr40, align 8, !tbaa !1
    %113 = call double @sin(double %37) #4
    %sunkaddr41 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr42 = add i32 %sunkaddr41, 16
    %sunkaddr43 = inttoptr i32 %sunkaddr42 to double*
    store double %113, double* %sunkaddr43, align 8, !tbaa !1
    %114 = call double @cos(double %16) #4
    %115 = call double @cos(double %37) #4
    %116 = fmul double %114, %115
    store double %116, double* %22, align 8, !tbaa !1
    %117 = call double @sin(double %16) #4
    %118 = call double @cos(double %37) #4
    %119 = fmul double %117, %118
    %120 = fsub double -0.000000e+00, %119
    %sunkaddr44 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr45 = add i32 %sunkaddr44, 8
    %sunkaddr46 = inttoptr i32 %sunkaddr45 to double*
    store double %120, double* %sunkaddr46, align 8, !tbaa !1
    %121 = call double @sin(double %37) #4
    %sunkaddr47 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr48 = add i32 %sunkaddr47, 16
    %sunkaddr49 = inttoptr i32 %sunkaddr48 to double*
    store double %121, double* %sunkaddr49, align 8, !tbaa !1
    call void @m_xformpt(double* %29, double* %29, double* %25, double* %25) #4
    call void @m_xformpt(double* %28, double* %28, double* %24, double* %24) #4
    call void @m_xformpt(double* %27, double* %27, double* %23, double* %23) #4
    call void @m_xformpt(double* %26, double* %26, double* %22, double* %22) #4
    call void @glBegin(i32 signext %type) #4
    call void @glNormal3dv(double* %22) #4
    call void @glVertex3dv(double* %26) #4
    call void @glNormal3dv(double* %23) #4
    call void @glVertex3dv(double* %27) #4
    call void @glNormal3dv(double* %24) #4
    call void @glVertex3dv(double* %28) #4
    call void @glNormal3dv(double* %25) #4
    call void @glVertex3dv(double* %29) #4
    call void @glEnd() #4
    %exitcond = icmp eq i32 %nsides, %33
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.loopexit, %0
    %122 = bitcast [3 x double]* %n3 to i8*
    %123 = bitcast [3 x double]* %n2 to i8*
    %124 = bitcast [3 x double]* %n1 to i8*
    %125 = bitcast [3 x double]* %n0 to i8*
    %126 = bitcast [3 x double]* %p3 to i8*
    %127 = bitcast [3 x double]* %p2 to i8*
    %128 = bitcast [3 x double]* %p1 to i8*
    %129 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.end(i64 24, i8* %122) #4
    call void @llvm.lifetime.end(i64 24, i8* %123) #4
    call void @llvm.lifetime.end(i64 24, i8* %124) #4
    call void @llvm.lifetime.end(i64 24, i8* %125) #4
    call void @llvm.lifetime.end(i64 24, i8* %126) #4
    call void @llvm.lifetime.end(i64 24, i8* %127) #4
    call void @llvm.lifetime.end(i64 24, i8* %128) #4
    call void @llvm.lifetime.end(i64 24, i8* %129) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 8, i32 signext 15, i32 signext 7)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  declare void @glPushMatrix() #3
  
  declare void @glRotatef(float, float, float, float) #3
  
  declare void @glTranslatef(float, float, float) #3
  
  declare void @gluCylinder(%struct.GLUquadricObj*, double, double, double, i32 signext, i32 signext) #3
  
  declare void @glPopMatrix() #3
  
  ; Function Attrs: nounwind
  define void @auxSolidCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @icosahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 8, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 9, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 10, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 11, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 12, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 13, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 14, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 15, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 16, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 17, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 18, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 19, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireOctahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @octahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidOctahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireDodecahedron.center, i32 0, i32 0), double %23, i32 signext 2)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @dodecahedron(double* nocapture readonly %center, double %sc, i32 signext %type) unnamed_addr #0 {
    %.b = load i1, i1* @dodecahedron.inited, align 1
    br i1 %.b, label %2, label %1
  
  ; <label>:1                                       ; preds = %0
    store i1 true, i1* @dodecahedron.inited, align 1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 2), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 2), align 8, !tbaa !1
    br label %2
  
  ; <label>:2                                       ; preds = %1, %0
    tail call void @m_pushmatrix() #4
    %3 = load double, double* %center, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %center, i32 1
    %5 = load double, double* %4, align 8, !tbaa !1
    %6 = getelementptr inbounds double, double* %center, i32 2
    %7 = load double, double* %6, align 8, !tbaa !1
    tail call void @m_translate(double %3, double %5, double %7) #4
    tail call void @m_scale(double %sc, double %sc, double %sc) #4
    tail call fastcc void @pentagon(i32 signext 0, i32 signext 1, i32 signext 9, i32 signext 16, i32 signext 5, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 0, i32 signext 3, i32 signext 18, i32 signext 7, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 7, i32 signext 11, i32 signext 10, i32 signext 9, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 11, i32 signext 7, i32 signext 18, i32 signext 19, i32 signext 6, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 8, i32 signext 17, i32 signext 16, i32 signext 9, i32 signext 10, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 14, i32 signext 15, i32 signext 6, i32 signext 19, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 13, i32 signext 12, i32 signext 4, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 19, i32 signext 18, i32 signext 3, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 3, i32 signext 0, i32 signext 5, i32 signext 12, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 6, i32 signext 15, i32 signext 8, i32 signext 10, i32 signext 11, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 17, i32 signext 8, i32 signext 15, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 12, i32 signext 5, i32 signext 16, i32 signext 17, i32 signext %type)
    tail call void @m_popmatrix() #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidDodecahedron.center, i32 0, i32 0), double %23, i32 signext 6)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @compareParams(double* nocapture readonly %oneArray, double* nocapture readonly %twoArray, i32 signext %size) #2 {
    %1 = icmp sgt i32 %size, 0
    br i1 %1, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ 1, %0 ]
    %matches.05 = phi i32 [ %matches.1, %.lr.ph ], [ 1, %0 ]
    %.03 = phi double* [ %2, %.lr.ph ], [ %oneArray, %0 ]
    %.012 = phi double* [ %4, %.lr.ph ], [ %twoArray, %0 ]
    %2 = getelementptr inbounds double, double* %.03, i32 1
    %3 = load double, double* %.03, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %.012, i32 1
    %5 = load double, double* %.012, align 8, !tbaa !1
    %6 = fcmp une double %3, %5
    %matches.1 = select i1 %6, i32 0, i32 %matches.05
    %7 = icmp slt i32 %lsr.iv, %size
    %8 = icmp ne i32 %matches.1, 0
    %9 = and i1 %7, %8
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    %matches.0.lcssa = phi i32 [ 1, %0 ], [ %matches.1, %.lr.ph ]
    ret i32 %matches.0.lcssa
  }
  
  declare i32 @glGenLists(i32 signext) #3
  
  declare void @glBegin(i32 signext) #3
  
  declare void @glNormal3dv(double*) #3
  
  declare void @glVertex3dv(double*) #3
  
  declare void @glEnd() #3
  
  ; Function Attrs: nounwind
  declare double @cos(double) #0
  
  ; Function Attrs: nounwind
  declare double @sin(double) #0
  
  declare void @m_xformpt(double*, double*, double*, double*) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawtriangle(i32 signext %i, i32 signext %geomType, double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    %p1.i.i = alloca [3 x double], align 8
    %p2.i.i = alloca [3 x double], align 8
    %p3.i.i = alloca [3 x double], align 8
    %q0.i.i = alloca [3 x double], align 8
    %q1.i.i = alloca [3 x double], align 8
    %n11.i.i = alloca [3 x double], align 8
    switch i32 %geomType, label %31 [
      i32 0, label %1
      i32 1, label %11
      i32 2, label %21
    ]
  
  ; <label>:1                                       ; preds = %0
    %2 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 0
    %3 = load i32, i32* %2, align 4, !tbaa !13
    %4 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %3, i32 0
    %5 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 1
    %6 = load i32, i32* %5, align 4, !tbaa !13
    %7 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %6, i32 0
    %8 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 2
    %9 = load i32, i32* %8, align 4, !tbaa !13
    %10 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %9, i32 0
    br label %31
  
  ; <label>:11                                      ; preds = %0
    %12 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 0
    %13 = load i32, i32* %12, align 4, !tbaa !13
    %14 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %13, i32 0
    %15 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 1
    %16 = load i32, i32* %15, align 4, !tbaa !13
    %17 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %16, i32 0
    %18 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 2
    %19 = load i32, i32* %18, align 4, !tbaa !13
    %20 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %19, i32 0
    br label %31
  
  ; <label>:21                                      ; preds = %0
    %22 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 0
    %23 = load i32, i32* %22, align 4, !tbaa !13
    %24 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %23, i32 0
    %25 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 1
    %26 = load i32, i32* %25, align 4, !tbaa !13
    %27 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %26, i32 0
    %28 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 2
    %29 = load i32, i32* %28, align 4, !tbaa !13
    %30 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %29, i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %21, %11, %1, %0
    %x0.0 = phi double* [ undef, %0 ], [ %24, %21 ], [ %14, %11 ], [ %4, %1 ]
    %x1.0 = phi double* [ undef, %0 ], [ %27, %21 ], [ %17, %11 ], [ %7, %1 ]
    %x2.0 = phi double* [ undef, %0 ], [ %30, %21 ], [ %20, %11 ], [ %10, %1 ]
    %32 = load double, double* %x0.0, align 8, !tbaa !1
    %33 = fmul double %32, 0.000000e+00
    %34 = load double, double* %x1.0, align 8, !tbaa !1
    %35 = fmul double %34, 0.000000e+00
    %36 = fadd double %33, %35
    %37 = load double, double* %x2.0, align 8, !tbaa !1
    %38 = fadd double %37, %36
    %39 = fadd double %32, %35
    %40 = fmul double %37, 0.000000e+00
    %41 = fadd double %39, %40
    %42 = fadd double %33, %34
    %43 = fadd double %42, %40
    %44 = getelementptr inbounds double, double* %x0.0, i32 1
    %45 = load double, double* %44, align 8, !tbaa !1
    %46 = fmul double %45, 0.000000e+00
    %47 = getelementptr inbounds double, double* %x1.0, i32 1
    %48 = load double, double* %47, align 8, !tbaa !1
    %49 = fmul double %48, 0.000000e+00
    %50 = fadd double %46, %49
    %51 = getelementptr inbounds double, double* %x2.0, i32 1
    %52 = load double, double* %51, align 8, !tbaa !1
    %53 = fadd double %52, %50
    %54 = fadd double %45, %49
    %55 = fmul double %52, 0.000000e+00
    %56 = fadd double %54, %55
    %57 = fadd double %46, %48
    %58 = fadd double %57, %55
    %59 = getelementptr inbounds double, double* %x0.0, i32 2
    %60 = load double, double* %59, align 8, !tbaa !1
    %61 = fmul double %60, 0.000000e+00
    %62 = getelementptr inbounds double, double* %x1.0, i32 2
    %63 = load double, double* %62, align 8, !tbaa !1
    %64 = fmul double %63, 0.000000e+00
    %65 = fadd double %61, %64
    %66 = getelementptr inbounds double, double* %x2.0, i32 2
    %67 = load double, double* %66, align 8, !tbaa !1
    %68 = fadd double %67, %65
    %69 = fadd double %60, %64
    %70 = fmul double %67, 0.000000e+00
    %71 = fadd double %69, %70
    %72 = fadd double %61, %63
    %73 = fadd double %72, %70
    %74 = fmul double %38, %38
    %75 = fmul double %53, %53
    %76 = fadd double %74, %75
    %77 = fmul double %68, %68
    %78 = fadd double %76, %77
    %79 = tail call double @sqrt(double %78) #5
    %80 = fcmp oeq double %79, %79
    br i1 %80, label %.split, label %call.sqrt
  
  call.sqrt:                                        ; preds = %31
    %81 = tail call double @sqrt(double %78) #4
    br label %.split
  
  .split:                                           ; preds = %31, %call.sqrt
    %82 = phi double [ %79, %31 ], [ %81, %call.sqrt ]
    %83 = fdiv double %38, %82
    %84 = fdiv double %53, %82
    %85 = fdiv double %68, %82
    %86 = fmul double %41, %41
    %87 = fmul double %56, %56
    %88 = fadd double %86, %87
    %89 = fmul double %71, %71
    %90 = fadd double %88, %89
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %.split.split, label %call.sqrt1
  
  call.sqrt1:                                       ; preds = %.split
    %93 = tail call double @sqrt(double %90) #4
    br label %.split.split
  
  .split.split:                                     ; preds = %.split, %call.sqrt1
    %94 = phi double [ %91, %.split ], [ %93, %call.sqrt1 ]
    %95 = fdiv double %41, %94
    %96 = fdiv double %56, %94
    %97 = fdiv double %71, %94
    %98 = fmul double %43, %43
    %99 = fmul double %58, %58
    %100 = fadd double %98, %99
    %101 = fmul double %73, %73
    %102 = fadd double %100, %101
    %103 = tail call double @sqrt(double %102) #5
    %104 = fcmp oeq double %103, %103
    br i1 %104, label %.split.split.split, label %call.sqrt2
  
  call.sqrt2:                                       ; preds = %.split.split
    %105 = tail call double @sqrt(double %102) #4
    br label %.split.split.split
  
  .split.split.split:                               ; preds = %.split.split, %call.sqrt2
    %106 = phi double [ %103, %.split.split ], [ %105, %call.sqrt2 ]
    %107 = bitcast [3 x double]* %n11.i.i to double*
    %108 = bitcast [3 x double]* %q1.i.i to double*
    %109 = bitcast [3 x double]* %q0.i.i to double*
    %110 = bitcast [3 x double]* %p3.i.i to double*
    %111 = bitcast [3 x double]* %p2.i.i to double*
    %112 = bitcast [3 x double]* %p1.i.i to double*
    %113 = bitcast [3 x double]* %n11.i.i to i8*
    %114 = bitcast [3 x double]* %q1.i.i to i8*
    %115 = bitcast [3 x double]* %q0.i.i to i8*
    %116 = bitcast [3 x double]* %p3.i.i to i8*
    %117 = bitcast [3 x double]* %p2.i.i to i8*
    %118 = bitcast [3 x double]* %p1.i.i to i8*
    %119 = fdiv double %43, %106
    %120 = fdiv double %58, %106
    %121 = fdiv double %73, %106
    call void @llvm.lifetime.start(i64 24, i8* %118) #4
    call void @llvm.lifetime.start(i64 24, i8* %117) #4
    call void @llvm.lifetime.start(i64 24, i8* %116) #4
    call void @llvm.lifetime.start(i64 24, i8* %115) #4
    call void @llvm.lifetime.start(i64 24, i8* %114) #4
    call void @llvm.lifetime.start(i64 24, i8* %113) #4
    %122 = fmul double %95, %radius
    %123 = load double, double* %p0, align 8, !tbaa !1
    %124 = fadd double %122, %123
    store double %124, double* %112, align 8, !tbaa !1
    %125 = fmul double %83, %radius
    %126 = fadd double %125, %123
    store double %126, double* %111, align 8, !tbaa !1
    %127 = fmul double %119, %radius
    %128 = fadd double %127, %123
    store double %128, double* %110, align 8, !tbaa !1
    %129 = fmul double %96, %radius
    %sunkaddr = ptrtoint double* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    %130 = load double, double* %sunkaddr4, align 8, !tbaa !1
    %131 = fadd double %129, %130
    %sunkaddr5 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr6 = add i32 %sunkaddr5, 8
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %131, double* %sunkaddr7, align 8, !tbaa !1
    %132 = fmul double %84, %radius
    %133 = fadd double %132, %130
    %sunkaddr8 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %133, double* %sunkaddr10, align 8, !tbaa !1
    %134 = fmul double %120, %radius
    %135 = fadd double %134, %130
    %sunkaddr11 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr12 = add i32 %sunkaddr11, 8
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %135, double* %sunkaddr13, align 8, !tbaa !1
    %136 = fmul double %97, %radius
    %sunkaddr14 = ptrtoint double* %p0 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 16
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    %137 = load double, double* %sunkaddr16, align 8, !tbaa !1
    %138 = fadd double %136, %137
    %sunkaddr17 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %138, double* %sunkaddr19, align 8, !tbaa !1
    %139 = fmul double %85, %radius
    %140 = fadd double %139, %137
    %sunkaddr20 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr21 = add i32 %sunkaddr20, 16
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %140, double* %sunkaddr22, align 8, !tbaa !1
    %141 = fmul double %121, %radius
    %142 = fadd double %141, %137
    %sunkaddr23 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %142, double* %sunkaddr25, align 8, !tbaa !1
    call void @diff3(double* %112, double* %111, double* %109) #4
    call void @diff3(double* %111, double* %110, double* %108) #4
    call void @crossprod(double* %109, double* %108, double* %108) #4
    call void @normalize(double* %108) #4
    call void @m_xformpt(double* %112, double* %112, double* %108, double* %107) #4
    call void @m_xformptonly(double* %111, double* %111) #4
    call void @m_xformptonly(double* %110, double* %110) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %107) #4
    call void @glVertex3dv(double* %112) #4
    call void @glVertex3dv(double* %111) #4
    call void @glVertex3dv(double* %110) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %113) #4
    call void @llvm.lifetime.end(i64 24, i8* %114) #4
    call void @llvm.lifetime.end(i64 24, i8* %115) #4
    call void @llvm.lifetime.end(i64 24, i8* %116) #4
    call void @llvm.lifetime.end(i64 24, i8* %117) #4
    call void @llvm.lifetime.end(i64 24, i8* %118) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  declare void @diff3(double*, double*, double*) #3
  
  declare void @crossprod(double*, double*, double*) #3
  
  declare void @normalize(double*) #3
  
  declare void @m_xformptonly(double*, double*) #3
  
  declare void @m_pushmatrix() #3
  
  declare void @m_translate(double, double, double) #3
  
  declare void @m_scale(double, double, double) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @pentagon(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %shadeType) unnamed_addr #0 {
    %n0 = alloca [3 x double], align 8
    %d1 = alloca [3 x double], align 8
    %d2 = alloca [3 x double], align 8
    %d3 = alloca [3 x double], align 8
    %d4 = alloca [3 x double], align 8
    %d5 = alloca [3 x double], align 8
    %nout = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %d1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %d2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %d3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %d4 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %d5 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %nout to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %a, i32 0
    %9 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %b, i32 0
    %10 = bitcast [3 x double]* %d1 to double*
    call void @diff3(double* %8, double* %9, double* %10) #4
    %11 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %c, i32 0
    %12 = bitcast [3 x double]* %d2 to double*
    call void @diff3(double* %9, double* %11, double* %12) #4
    %13 = bitcast [3 x double]* %n0 to double*
    call void @crossprod(double* %10, double* %12, double* %13) #4
    call void @normalize(double* %13) #4
    %14 = bitcast [3 x double]* %nout to double*
    call void @m_xformpt(double* %8, double* %10, double* %13, double* %14) #4
    call void @m_xformptonly(double* %9, double* %12) #4
    %15 = bitcast [3 x double]* %d3 to double*
    call void @m_xformptonly(double* %11, double* %15) #4
    %16 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %d, i32 0
    %17 = bitcast [3 x double]* %d4 to double*
    call void @m_xformptonly(double* %16, double* %17) #4
    %18 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %e, i32 0
    %19 = bitcast [3 x double]* %d5 to double*
    call void @m_xformptonly(double* %18, double* %19) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %14) #4
    call void @glVertex3dv(double* %10) #4
    call void @glVertex3dv(double* %12) #4
    call void @glVertex3dv(double* %15) #4
    call void @glVertex3dv(double* %17) #4
    call void @glVertex3dv(double* %19) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %7) #4
    call void @llvm.lifetime.end(i64 24, i8* %6) #4
    call void @llvm.lifetime.end(i64 24, i8* %5) #4
    call void @llvm.lifetime.end(i64 24, i8* %4) #4
    call void @llvm.lifetime.end(i64 24, i8* %3) #4
    call void @llvm.lifetime.end(i64 24, i8* %2) #4
    call void @llvm.lifetime.end(i64 24, i8* %1) #4
    ret void
  }
  
  declare void @m_popmatrix() #3
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { norecurse nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { nounwind }
  attributes #5 = { nounwind readnone }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !2, i64 0}
  !2 = !{!"double", !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"any pointer", !3, i64 0}
  !7 = !{!8, !6, i64 12}
  !8 = !{!"model", !9, i64 0, !6, i64 4, !9, i64 8, !6, i64 12}
  !9 = !{!"int", !3, i64 0}
  !10 = !{!8, !9, i64 0}
  !11 = !{!8, !9, i64 8}
  !12 = !{!8, !6, i64 4}
  !13 = !{!9, !9, i64 0}

...
---
name:            makeModelPtr
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%0' }
  - { reg: '%a1', virtual-reg: '%1' }
  - { reg: '%a2', virtual-reg: '%2' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 8):
    liveins: %a0, %a1, %a2, %t9, %v0
    liveouts: %v0
  
    %3 = ADDu %v0, %t9
    %2 = COPY %a2
    %1 = COPY %a1
    %0 = COPY %a0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %4 = LW %3, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %5 = ADDiu %zero, 16
    %a0 = COPY %5
    %gp = COPY %3
    %t9 = COPY %4
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %6 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %7 = LW %3, target-flags(<unknown>) @glGenLists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glGenLists)
    %8 = ADDiu %zero, 1
    %a0 = COPY %8
    %gp = COPY %3
    %t9 = COPY %7
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %9 = COPY %v0
    %10 = SLL %0, 2
    %11 = LW %3, target-flags(<unknown>) @lists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %12 = ADDiu killed %11, target-flags(<unknown>) @lists
    %13 = ADDu killed %12, killed %10
    SW %9, %6, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.3, !tbaa !10)
    SW %2, %6, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.5, !tbaa !11)
    SW %1, %6, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.7, !tbaa !7)
    %14 = LW %13, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.9, !tbaa !5)
    SW killed %14, %6, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.12, !tbaa !12)
    SW %6, %13, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.13, !tbaa !5)
    %v0 = COPY %9
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/mesa/mesa.shapes.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.model = type { i32, %struct.model*, i32, double* }
  %struct.GLUquadricObj = type opaque
  
  @auxWireIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @lists = internal unnamed_addr global [25 x %struct.model*] zeroinitializer, align 4
  @drawbox.n = internal global [6 x [3 x double]] [[3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @drawbox.faces = internal unnamed_addr constant [6 x [4 x i32]] [[4 x i32] [i32 0, i32 1, i32 2, i32 3], [4 x i32] [i32 3, i32 2, i32 6, i32 7], [4 x i32] [i32 7, i32 6, i32 5, i32 4], [4 x i32] [i32 4, i32 5, i32 1, i32 0], [4 x i32] [i32 5, i32 6, i32 2, i32 1], [4 x i32] [i32 7, i32 4, i32 0, i32 3]], align 4
  @iindex = internal unnamed_addr constant [20 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 1], [3 x i32] [i32 0, i32 9, i32 4], [3 x i32] [i32 9, i32 5, i32 4], [3 x i32] [i32 4, i32 5, i32 8], [3 x i32] [i32 4, i32 8, i32 1], [3 x i32] [i32 8, i32 10, i32 1], [3 x i32] [i32 8, i32 3, i32 10], [3 x i32] [i32 5, i32 3, i32 8], [3 x i32] [i32 5, i32 2, i32 3], [3 x i32] [i32 2, i32 7, i32 3], [3 x i32] [i32 7, i32 10, i32 3], [3 x i32] [i32 7, i32 6, i32 10], [3 x i32] [i32 7, i32 11, i32 6], [3 x i32] [i32 11, i32 0, i32 6], [3 x i32] [i32 0, i32 1, i32 6], [3 x i32] [i32 6, i32 1, i32 10], [3 x i32] [i32 9, i32 0, i32 11], [3 x i32] [i32 9, i32 11, i32 2], [3 x i32] [i32 9, i32 2, i32 5], [3 x i32] [i32 7, i32 2, i32 11]], align 4
  @idata = internal global [12 x [3 x double]] [[3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00]], align 8
  @ondex = internal unnamed_addr constant [8 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 2], [3 x i32] [i32 1, i32 2, i32 4], [3 x i32] [i32 0, i32 3, i32 4], [3 x i32] [i32 1, i32 4, i32 3], [3 x i32] [i32 0, i32 2, i32 5], [3 x i32] [i32 1, i32 5, i32 2], [3 x i32] [i32 0, i32 5, i32 3], [3 x i32] [i32 1, i32 3, i32 5]], align 4
  @odata = internal global [6 x [3 x double]] [[3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @tndex = internal unnamed_addr constant [4 x [3 x i32]] [[3 x i32] [i32 0, i32 1, i32 3], [3 x i32] [i32 2, i32 1, i32 0], [3 x i32] [i32 3, i32 2, i32 0], [3 x i32] [i32 1, i32 2, i32 3]], align 4
  @tdata = internal global [4 x [3 x double]] [[3 x double] [double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA], [3 x double] [double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA]], align 8
  @dodecahedron.inited = internal unnamed_addr global i1 false
  @dodec = internal global [20 x [3 x double]] zeroinitializer, align 8
  
  ; Function Attrs: nounwind
  define void @auxWireSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast ([25 x %struct.model*]* @lists to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast ([25 x %struct.model*]* @lists to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100011) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare noalias i8* @malloc(i32 signext) #0
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @findList(i32 signext %lindex, double* nocapture readonly %paramArray, i32 signext %size) #2 {
    %1 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %endList.02 = load %struct.model*, %struct.model** %1, align 4, !tbaa !5
    %2 = icmp eq %struct.model* %endList.02, null
    br i1 %2, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0
    br label %3
  
  ; <label>:3                                       ; preds = %18, %.lr.ph
    %endList.03 = phi %struct.model* [ %endList.02, %.lr.ph ], [ %endList.0, %18 ]
    %4 = icmp sgt i32 %size, 0
    br i1 %4, label %.lr.ph.i.preheader, label %compareParams.exit.thread
  
  .lr.ph.i.preheader:                               ; preds = %3
    %5 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 3
    %6 = load double*, double** %5, align 4, !tbaa !7
    br label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %matches.05.i = phi i32 [ %matches.1.i, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %.03.i = phi double* [ %7, %.lr.ph.i ], [ %6, %.lr.ph.i.preheader ]
    %.012.i = phi double* [ %9, %.lr.ph.i ], [ %paramArray, %.lr.ph.i.preheader ]
    %7 = getelementptr inbounds double, double* %.03.i, i32 1
    %8 = load double, double* %.03.i, align 8, !tbaa !1
    %9 = getelementptr inbounds double, double* %.012.i, i32 1
    %10 = load double, double* %.012.i, align 8, !tbaa !1
    %11 = fcmp une double %8, %10
    %matches.1.i = select i1 %11, i32 0, i32 %matches.05.i
    %12 = icmp slt i32 %lsr.iv, %size
    %13 = icmp ne i32 %matches.1.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %14, label %.lr.ph.i, label %compareParams.exit
  
  compareParams.exit:                               ; preds = %.lr.ph.i
    %15 = icmp eq i32 %matches.1.i, 0
    br i1 %15, label %18, label %compareParams.exit.thread
  
  compareParams.exit.thread:                        ; preds = %compareParams.exit, %3
    %16 = bitcast %struct.model* %endList.03 to i32*
    %17 = load i32, i32* %16, align 4, !tbaa !10
    br label %.loopexit
  
  ; <label>:18                                      ; preds = %compareParams.exit
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 1
    %endList.0 = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0, null
    br i1 %20, label %.loopexit, label %3
  
  .loopexit:                                        ; preds = %18, %compareParams.exit.thread, %0
    %.0 = phi i32 [ %17, %compareParams.exit.thread ], [ 0, %0 ], [ 0, %18 ]
    ret i32 %.0
  }
  
  declare void @glNewList(i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @makeModelPtr(i32 signext %lindex, double* %sizeArray, i32 signext %count) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = tail call i32 @glGenLists(i32 signext 1) #4
    %3 = bitcast i8* %1 to i32*
    store i32 %2, i32* %3, align 4, !tbaa !10
    %4 = getelementptr inbounds i8, i8* %1, i32 8
    %5 = bitcast i8* %4 to i32*
    store i32 %count, i32* %5, align 4, !tbaa !11
    %6 = getelementptr inbounds i8, i8* %1, i32 12
    %7 = bitcast i8* %6 to double**
    store double* %sizeArray, double** %7, align 4, !tbaa !7
    %8 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %9 = bitcast %struct.model** %8 to i32*
    %10 = load i32, i32* %9, align 4, !tbaa !5
    %11 = getelementptr inbounds i8, i8* %1, i32 4
    %12 = bitcast i8* %11 to i32*
    store i32 %10, i32* %12, align 4, !tbaa !12
    %13 = bitcast %struct.model** %8 to i8**
    store i8* %1, i8** %13, align 4, !tbaa !5
    ret i32 %2
  }
  
  declare %struct.GLUquadricObj* @gluNewQuadric() #3
  
  declare void @gluQuadricDrawStyle(%struct.GLUquadricObj*, i32 signext) #3
  
  declare void @gluSphere(%struct.GLUquadricObj*, double, i32 signext, i32 signext) #3
  
  declare void @glEndList() #3
  
  declare void @glCallList(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  define void @auxSolidSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %23, i32 signext 100000) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  declare void @gluQuadricNormals(%struct.GLUquadricObj*, i32 signext) #3
  
  ; Function Attrs: nounwind
  define void @auxWireCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 2)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawbox(double %x0, double %x1, double %y0, double %y1, double %z0, double %z1, i32 signext %type) unnamed_addr #0 {
    %v = alloca [8 x [3 x double]], align 8
    %1 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.start(i64 192, i8* %1) #4
    %2 = fcmp ogt double %x0, %x1
    %.05 = select i1 %2, double %x0, double %x1
    %.0 = select i1 %2, double %x1, double %x0
    %3 = fcmp ogt double %y0, %y1
    %.04 = select i1 %3, double %y1, double %y0
    %.03 = select i1 %3, double %y0, double %y1
    %4 = fcmp ogt double %z0, %z1
    %.02 = select i1 %4, double %z1, double %z0
    %.01 = select i1 %4, double %z0, double %z1
    %5 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 0
    store double %.0, double* %5, align 8, !tbaa !1
    %6 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 0
    store double %.0, double* %6, align 8, !tbaa !1
    %7 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 0
    store double %.0, double* %7, align 8, !tbaa !1
    %8 = bitcast [8 x [3 x double]]* %v to double*
    store double %.0, double* %8, align 8, !tbaa !1
    %9 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 0
    store double %.05, double* %9, align 8, !tbaa !1
    %10 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 0
    store double %.05, double* %10, align 8, !tbaa !1
    %11 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 0
    store double %.05, double* %11, align 8, !tbaa !1
    %12 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 0
    store double %.05, double* %12, align 8, !tbaa !1
    %13 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 1
    store double %.04, double* %13, align 8, !tbaa !1
    %14 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 1
    store double %.04, double* %14, align 8, !tbaa !1
    %15 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 1
    store double %.04, double* %15, align 8, !tbaa !1
    %16 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 1
    store double %.04, double* %16, align 8, !tbaa !1
    %17 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 1
    store double %.03, double* %17, align 8, !tbaa !1
    %18 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 1
    store double %.03, double* %18, align 8, !tbaa !1
    %19 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 1
    store double %.03, double* %19, align 8, !tbaa !1
    %20 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 1
    store double %.03, double* %20, align 8, !tbaa !1
    %21 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 2
    store double %.02, double* %21, align 8, !tbaa !1
    %22 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 2
    store double %.02, double* %22, align 8, !tbaa !1
    %23 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 2
    store double %.02, double* %23, align 8, !tbaa !1
    %24 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 2
    store double %.02, double* %24, align 8, !tbaa !1
    %25 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 2
    store double %.01, double* %25, align 8, !tbaa !1
    %26 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 2
    store double %.01, double* %26, align 8, !tbaa !1
    %27 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 2
    store double %.01, double* %27, align 8, !tbaa !1
    %28 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 2
    store double %.01, double* %28, align 8, !tbaa !1
    br label %29
  
  ; <label>:29                                      ; preds = %29, %0
    %lsr.iv1 = phi [6 x [4 x i32]]* [ %38, %29 ], [ bitcast (i32* getelementptr inbounds ([6 x [4 x i32]], [6 x [4 x i32]]* @drawbox.faces, i32 0, i32 0, i32 2) to [6 x [4 x i32]]*), %0 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %29 ], [ 0, %0 ]
    %lsr.iv12 = bitcast [6 x [4 x i32]]* %lsr.iv1 to i32*
    call void @glBegin(i32 signext %type) #4
    %uglygep11 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep1112 = bitcast i8* %uglygep11 to double*
    call void @glNormal3dv(double* %uglygep1112) #4
    %scevgep5 = getelementptr i32, i32* %lsr.iv12, i32 -2
    %30 = load i32, i32* %scevgep5, align 4, !tbaa !13
    %31 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %30, i32 0
    call void @glVertex3dv(double* %31) #4
    %uglygep9 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep910 = bitcast i8* %uglygep9 to double*
    call void @glNormal3dv(double* %uglygep910) #4
    %scevgep4 = getelementptr i32, i32* %lsr.iv12, i32 -1
    %32 = load i32, i32* %scevgep4, align 4, !tbaa !13
    %33 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %32, i32 0
    call void @glVertex3dv(double* %33) #4
    %uglygep7 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep78 = bitcast i8* %uglygep7 to double*
    call void @glNormal3dv(double* %uglygep78) #4
    %34 = load i32, i32* %lsr.iv12, align 4, !tbaa !13
    %35 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %34, i32 0
    call void @glVertex3dv(double* %35) #4
    %uglygep = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep6 = bitcast i8* %uglygep to double*
    call void @glNormal3dv(double* %uglygep6) #4
    %scevgep3 = getelementptr i32, i32* %lsr.iv12, i32 1
    %36 = load i32, i32* %scevgep3, align 4, !tbaa !13
    %37 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %36, i32 0
    call void @glVertex3dv(double* %37) #4
    call void @glEnd() #4
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 24
    %scevgep = getelementptr [6 x [4 x i32]], [6 x [4 x i32]]* %lsr.iv1, i32 0, i32 1, i32 0
    %38 = bitcast i32* %scevgep to [6 x [4 x i32]]*
    %exitcond = icmp eq i32 %lsr.iv.next, 144
    br i1 %exitcond, label %39, label %29
  
  ; <label>:39                                      ; preds = %29
    %40 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.end(i64 192, i8* %40) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 7)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 2)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 7)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 5, i32 signext 10, i32 signext 2)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @doughnut(double %r, double %R, i32 signext %nsides, i32 signext %rings, i32 signext %type) unnamed_addr #0 {
    %p0 = alloca [3 x double], align 8
    %p1 = alloca [3 x double], align 8
    %p2 = alloca [3 x double], align 8
    %p3 = alloca [3 x double], align 8
    %n0 = alloca [3 x double], align 8
    %n1 = alloca [3 x double], align 8
    %n2 = alloca [3 x double], align 8
    %n3 = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %p1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %p2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %p3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %n1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %n2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = bitcast [3 x double]* %n3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %8) #4
    %9 = icmp sgt i32 %rings, 0
    br i1 %9, label %.lr.ph3, label %._crit_edge
  
  .lr.ph3:                                          ; preds = %0
    %10 = sitofp i32 %rings to double
    %11 = sitofp i32 %nsides to double
    br label %12
  
  .loopexit:                                        ; preds = %.lr.ph, %12
    %exitcond4 = icmp eq i32 %17, %rings
    br i1 %exitcond4, label %._crit_edge, label %12
  
  ; <label>:12                                      ; preds = %.loopexit, %.lr.ph3
    %IV.S.1 = phi double [ 0.000000e+00, %.lr.ph3 ], [ %IV.S.next.2, %.loopexit ]
    %i.02 = phi i32 [ 0, %.lr.ph3 ], [ %17, %.loopexit ]
    %13 = icmp sgt i32 %nsides, 0
    %14 = fmul double %IV.S.1, 2.000000e+00
    %15 = fmul double %14, 0x400921FB54442C46
    %16 = fdiv double %15, %10
    %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
    %17 = add nuw nsw i32 %i.02, 1
    %18 = sitofp i32 %17 to double
    %19 = fmul double %18, 2.000000e+00
    %20 = fmul double %19, 0x400921FB54442C46
    %21 = fdiv double %20, %10
    br i1 %13, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %12, %.lr.ph
    %IV.S. = phi double [ %IV.S.next., %.lr.ph ], [ 0.000000e+00, %12 ]
    %j.01 = phi i32 [ %33, %.lr.ph ], [ 0, %12 ]
    %22 = bitcast [3 x double]* %n3 to double*
    %23 = bitcast [3 x double]* %n2 to double*
    %24 = bitcast [3 x double]* %n1 to double*
    %25 = bitcast [3 x double]* %n0 to double*
    %26 = bitcast [3 x double]* %p3 to double*
    %27 = bitcast [3 x double]* %p2 to double*
    %28 = bitcast [3 x double]* %p1 to double*
    %29 = bitcast [3 x double]* %p0 to double*
    %30 = fmul double %IV.S., 2.000000e+00
    %31 = fmul double %30, 0x400921FB54442C46
    %32 = fdiv double %31, %11
    %IV.S.next. = fadd double %IV.S., 1.000000e+00
    %33 = add nuw nsw i32 %j.01, 1
    %34 = sitofp i32 %33 to double
    %35 = fmul double %34, 2.000000e+00
    %36 = fmul double %35, 0x400921FB54442C46
    %37 = fdiv double %36, %11
    %38 = call double @cos(double %16) #4
    %39 = call double @cos(double %32) #4
    %40 = fmul double %39, %r
    %41 = fadd double %40, %R
    %42 = fmul double %38, %41
    store double %42, double* %29, align 8, !tbaa !1
    %43 = call double @sin(double %16) #4
    %44 = call double @cos(double %32) #4
    %45 = fmul double %44, %r
    %46 = fadd double %45, %R
    %47 = fmul double %43, %46
    %48 = fsub double -0.000000e+00, %47
    %sunkaddr = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    store double %48, double* %sunkaddr4, align 8, !tbaa !1
    %49 = call double @sin(double %32) #4
    %50 = fmul double %49, %r
    %sunkaddr5 = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr6 = add i32 %sunkaddr5, 16
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %50, double* %sunkaddr7, align 8, !tbaa !1
    %51 = call double @cos(double %21) #4
    %52 = call double @cos(double %32) #4
    %53 = fmul double %52, %r
    %54 = fadd double %53, %R
    %55 = fmul double %51, %54
    store double %55, double* %28, align 8, !tbaa !1
    %56 = call double @sin(double %21) #4
    %57 = call double @cos(double %32) #4
    %58 = fmul double %57, %r
    %59 = fadd double %58, %R
    %60 = fmul double %56, %59
    %61 = fsub double -0.000000e+00, %60
    %sunkaddr8 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %61, double* %sunkaddr10, align 8, !tbaa !1
    %62 = call double @sin(double %32) #4
    %63 = fmul double %62, %r
    %sunkaddr11 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr12 = add i32 %sunkaddr11, 16
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %63, double* %sunkaddr13, align 8, !tbaa !1
    %64 = call double @cos(double %21) #4
    %65 = call double @cos(double %37) #4
    %66 = fmul double %65, %r
    %67 = fadd double %66, %R
    %68 = fmul double %64, %67
    store double %68, double* %27, align 8, !tbaa !1
    %69 = call double @sin(double %21) #4
    %70 = call double @cos(double %37) #4
    %71 = fmul double %70, %r
    %72 = fadd double %71, %R
    %73 = fmul double %69, %72
    %74 = fsub double -0.000000e+00, %73
    %sunkaddr14 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 8
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    store double %74, double* %sunkaddr16, align 8, !tbaa !1
    %75 = call double @sin(double %37) #4
    %76 = fmul double %75, %r
    %sunkaddr17 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %76, double* %sunkaddr19, align 8, !tbaa !1
    %77 = call double @cos(double %16) #4
    %78 = call double @cos(double %37) #4
    %79 = fmul double %78, %r
    %80 = fadd double %79, %R
    %81 = fmul double %77, %80
    store double %81, double* %26, align 8, !tbaa !1
    %82 = call double @sin(double %16) #4
    %83 = call double @cos(double %37) #4
    %84 = fmul double %83, %r
    %85 = fadd double %84, %R
    %86 = fmul double %82, %85
    %87 = fsub double -0.000000e+00, %86
    %sunkaddr20 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr21 = add i32 %sunkaddr20, 8
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %87, double* %sunkaddr22, align 8, !tbaa !1
    %88 = call double @sin(double %37) #4
    %89 = fmul double %88, %r
    %sunkaddr23 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %89, double* %sunkaddr25, align 8, !tbaa !1
    %90 = call double @cos(double %16) #4
    %91 = call double @cos(double %32) #4
    %92 = fmul double %90, %91
    store double %92, double* %25, align 8, !tbaa !1
    %93 = call double @sin(double %16) #4
    %94 = call double @cos(double %32) #4
    %95 = fmul double %93, %94
    %96 = fsub double -0.000000e+00, %95
    %sunkaddr26 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr27 = add i32 %sunkaddr26, 8
    %sunkaddr28 = inttoptr i32 %sunkaddr27 to double*
    store double %96, double* %sunkaddr28, align 8, !tbaa !1
    %97 = call double @sin(double %32) #4
    %sunkaddr29 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr30 = add i32 %sunkaddr29, 16
    %sunkaddr31 = inttoptr i32 %sunkaddr30 to double*
    store double %97, double* %sunkaddr31, align 8, !tbaa !1
    %98 = call double @cos(double %21) #4
    %99 = call double @cos(double %32) #4
    %100 = fmul double %98, %99
    store double %100, double* %24, align 8, !tbaa !1
    %101 = call double @sin(double %21) #4
    %102 = call double @cos(double %32) #4
    %103 = fmul double %101, %102
    %104 = fsub double -0.000000e+00, %103
    %sunkaddr32 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr33 = add i32 %sunkaddr32, 8
    %sunkaddr34 = inttoptr i32 %sunkaddr33 to double*
    store double %104, double* %sunkaddr34, align 8, !tbaa !1
    %105 = call double @sin(double %32) #4
    %sunkaddr35 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr36 = add i32 %sunkaddr35, 16
    %sunkaddr37 = inttoptr i32 %sunkaddr36 to double*
    store double %105, double* %sunkaddr37, align 8, !tbaa !1
    %106 = call double @cos(double %21) #4
    %107 = call double @cos(double %37) #4
    %108 = fmul double %106, %107
    store double %108, double* %23, align 8, !tbaa !1
    %109 = call double @sin(double %21) #4
    %110 = call double @cos(double %37) #4
    %111 = fmul double %109, %110
    %112 = fsub double -0.000000e+00, %111
    %sunkaddr38 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr39 = add i32 %sunkaddr38, 8
    %sunkaddr40 = inttoptr i32 %sunkaddr39 to double*
    store double %112, double* %sunkaddr40, align 8, !tbaa !1
    %113 = call double @sin(double %37) #4
    %sunkaddr41 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr42 = add i32 %sunkaddr41, 16
    %sunkaddr43 = inttoptr i32 %sunkaddr42 to double*
    store double %113, double* %sunkaddr43, align 8, !tbaa !1
    %114 = call double @cos(double %16) #4
    %115 = call double @cos(double %37) #4
    %116 = fmul double %114, %115
    store double %116, double* %22, align 8, !tbaa !1
    %117 = call double @sin(double %16) #4
    %118 = call double @cos(double %37) #4
    %119 = fmul double %117, %118
    %120 = fsub double -0.000000e+00, %119
    %sunkaddr44 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr45 = add i32 %sunkaddr44, 8
    %sunkaddr46 = inttoptr i32 %sunkaddr45 to double*
    store double %120, double* %sunkaddr46, align 8, !tbaa !1
    %121 = call double @sin(double %37) #4
    %sunkaddr47 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr48 = add i32 %sunkaddr47, 16
    %sunkaddr49 = inttoptr i32 %sunkaddr48 to double*
    store double %121, double* %sunkaddr49, align 8, !tbaa !1
    call void @m_xformpt(double* %29, double* %29, double* %25, double* %25) #4
    call void @m_xformpt(double* %28, double* %28, double* %24, double* %24) #4
    call void @m_xformpt(double* %27, double* %27, double* %23, double* %23) #4
    call void @m_xformpt(double* %26, double* %26, double* %22, double* %22) #4
    call void @glBegin(i32 signext %type) #4
    call void @glNormal3dv(double* %22) #4
    call void @glVertex3dv(double* %26) #4
    call void @glNormal3dv(double* %23) #4
    call void @glVertex3dv(double* %27) #4
    call void @glNormal3dv(double* %24) #4
    call void @glVertex3dv(double* %28) #4
    call void @glNormal3dv(double* %25) #4
    call void @glVertex3dv(double* %29) #4
    call void @glEnd() #4
    %exitcond = icmp eq i32 %nsides, %33
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.loopexit, %0
    %122 = bitcast [3 x double]* %n3 to i8*
    %123 = bitcast [3 x double]* %n2 to i8*
    %124 = bitcast [3 x double]* %n1 to i8*
    %125 = bitcast [3 x double]* %n0 to i8*
    %126 = bitcast [3 x double]* %p3 to i8*
    %127 = bitcast [3 x double]* %p2 to i8*
    %128 = bitcast [3 x double]* %p1 to i8*
    %129 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.end(i64 24, i8* %122) #4
    call void @llvm.lifetime.end(i64 24, i8* %123) #4
    call void @llvm.lifetime.end(i64 24, i8* %124) #4
    call void @llvm.lifetime.end(i64 24, i8* %125) #4
    call void @llvm.lifetime.end(i64 24, i8* %126) #4
    call void @llvm.lifetime.end(i64 24, i8* %127) #4
    call void @llvm.lifetime.end(i64 24, i8* %128) #4
    call void @llvm.lifetime.end(i64 24, i8* %129) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 8, i32 signext 15, i32 signext 7)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  declare void @glPushMatrix() #3
  
  declare void @glRotatef(float, float, float, float) #3
  
  declare void @glTranslatef(float, float, float) #3
  
  declare void @gluCylinder(%struct.GLUquadricObj*, double, double, double, i32 signext, i32 signext) #3
  
  declare void @glPopMatrix() #3
  
  ; Function Attrs: nounwind
  define void @auxSolidCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @icosahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 8, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 9, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 10, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 11, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 12, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 13, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 14, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 15, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 16, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 17, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 18, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 19, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireOctahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @octahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidOctahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireDodecahedron.center, i32 0, i32 0), double %23, i32 signext 2)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @dodecahedron(double* nocapture readonly %center, double %sc, i32 signext %type) unnamed_addr #0 {
    %.b = load i1, i1* @dodecahedron.inited, align 1
    br i1 %.b, label %2, label %1
  
  ; <label>:1                                       ; preds = %0
    store i1 true, i1* @dodecahedron.inited, align 1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 2), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 2), align 8, !tbaa !1
    br label %2
  
  ; <label>:2                                       ; preds = %1, %0
    tail call void @m_pushmatrix() #4
    %3 = load double, double* %center, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %center, i32 1
    %5 = load double, double* %4, align 8, !tbaa !1
    %6 = getelementptr inbounds double, double* %center, i32 2
    %7 = load double, double* %6, align 8, !tbaa !1
    tail call void @m_translate(double %3, double %5, double %7) #4
    tail call void @m_scale(double %sc, double %sc, double %sc) #4
    tail call fastcc void @pentagon(i32 signext 0, i32 signext 1, i32 signext 9, i32 signext 16, i32 signext 5, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 0, i32 signext 3, i32 signext 18, i32 signext 7, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 7, i32 signext 11, i32 signext 10, i32 signext 9, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 11, i32 signext 7, i32 signext 18, i32 signext 19, i32 signext 6, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 8, i32 signext 17, i32 signext 16, i32 signext 9, i32 signext 10, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 14, i32 signext 15, i32 signext 6, i32 signext 19, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 13, i32 signext 12, i32 signext 4, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 19, i32 signext 18, i32 signext 3, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 3, i32 signext 0, i32 signext 5, i32 signext 12, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 6, i32 signext 15, i32 signext 8, i32 signext 10, i32 signext 11, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 17, i32 signext 8, i32 signext 15, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 12, i32 signext 5, i32 signext 16, i32 signext 17, i32 signext %type)
    tail call void @m_popmatrix() #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidDodecahedron.center, i32 0, i32 0), double %23, i32 signext 6)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @compareParams(double* nocapture readonly %oneArray, double* nocapture readonly %twoArray, i32 signext %size) #2 {
    %1 = icmp sgt i32 %size, 0
    br i1 %1, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ 1, %0 ]
    %matches.05 = phi i32 [ %matches.1, %.lr.ph ], [ 1, %0 ]
    %.03 = phi double* [ %2, %.lr.ph ], [ %oneArray, %0 ]
    %.012 = phi double* [ %4, %.lr.ph ], [ %twoArray, %0 ]
    %2 = getelementptr inbounds double, double* %.03, i32 1
    %3 = load double, double* %.03, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %.012, i32 1
    %5 = load double, double* %.012, align 8, !tbaa !1
    %6 = fcmp une double %3, %5
    %matches.1 = select i1 %6, i32 0, i32 %matches.05
    %7 = icmp slt i32 %lsr.iv, %size
    %8 = icmp ne i32 %matches.1, 0
    %9 = and i1 %7, %8
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    %matches.0.lcssa = phi i32 [ 1, %0 ], [ %matches.1, %.lr.ph ]
    ret i32 %matches.0.lcssa
  }
  
  declare i32 @glGenLists(i32 signext) #3
  
  declare void @glBegin(i32 signext) #3
  
  declare void @glNormal3dv(double*) #3
  
  declare void @glVertex3dv(double*) #3
  
  declare void @glEnd() #3
  
  ; Function Attrs: nounwind
  declare double @cos(double) #0
  
  ; Function Attrs: nounwind
  declare double @sin(double) #0
  
  declare void @m_xformpt(double*, double*, double*, double*) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawtriangle(i32 signext %i, i32 signext %geomType, double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    %p1.i.i = alloca [3 x double], align 8
    %p2.i.i = alloca [3 x double], align 8
    %p3.i.i = alloca [3 x double], align 8
    %q0.i.i = alloca [3 x double], align 8
    %q1.i.i = alloca [3 x double], align 8
    %n11.i.i = alloca [3 x double], align 8
    switch i32 %geomType, label %31 [
      i32 0, label %1
      i32 1, label %11
      i32 2, label %21
    ]
  
  ; <label>:1                                       ; preds = %0
    %2 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 0
    %3 = load i32, i32* %2, align 4, !tbaa !13
    %4 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %3, i32 0
    %5 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 1
    %6 = load i32, i32* %5, align 4, !tbaa !13
    %7 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %6, i32 0
    %8 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 2
    %9 = load i32, i32* %8, align 4, !tbaa !13
    %10 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %9, i32 0
    br label %31
  
  ; <label>:11                                      ; preds = %0
    %12 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 0
    %13 = load i32, i32* %12, align 4, !tbaa !13
    %14 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %13, i32 0
    %15 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 1
    %16 = load i32, i32* %15, align 4, !tbaa !13
    %17 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %16, i32 0
    %18 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 2
    %19 = load i32, i32* %18, align 4, !tbaa !13
    %20 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %19, i32 0
    br label %31
  
  ; <label>:21                                      ; preds = %0
    %22 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 0
    %23 = load i32, i32* %22, align 4, !tbaa !13
    %24 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %23, i32 0
    %25 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 1
    %26 = load i32, i32* %25, align 4, !tbaa !13
    %27 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %26, i32 0
    %28 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 2
    %29 = load i32, i32* %28, align 4, !tbaa !13
    %30 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %29, i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %21, %11, %1, %0
    %x0.0 = phi double* [ undef, %0 ], [ %24, %21 ], [ %14, %11 ], [ %4, %1 ]
    %x1.0 = phi double* [ undef, %0 ], [ %27, %21 ], [ %17, %11 ], [ %7, %1 ]
    %x2.0 = phi double* [ undef, %0 ], [ %30, %21 ], [ %20, %11 ], [ %10, %1 ]
    %32 = load double, double* %x0.0, align 8, !tbaa !1
    %33 = fmul double %32, 0.000000e+00
    %34 = load double, double* %x1.0, align 8, !tbaa !1
    %35 = fmul double %34, 0.000000e+00
    %36 = fadd double %33, %35
    %37 = load double, double* %x2.0, align 8, !tbaa !1
    %38 = fadd double %37, %36
    %39 = fadd double %32, %35
    %40 = fmul double %37, 0.000000e+00
    %41 = fadd double %39, %40
    %42 = fadd double %33, %34
    %43 = fadd double %42, %40
    %44 = getelementptr inbounds double, double* %x0.0, i32 1
    %45 = load double, double* %44, align 8, !tbaa !1
    %46 = fmul double %45, 0.000000e+00
    %47 = getelementptr inbounds double, double* %x1.0, i32 1
    %48 = load double, double* %47, align 8, !tbaa !1
    %49 = fmul double %48, 0.000000e+00
    %50 = fadd double %46, %49
    %51 = getelementptr inbounds double, double* %x2.0, i32 1
    %52 = load double, double* %51, align 8, !tbaa !1
    %53 = fadd double %52, %50
    %54 = fadd double %45, %49
    %55 = fmul double %52, 0.000000e+00
    %56 = fadd double %54, %55
    %57 = fadd double %46, %48
    %58 = fadd double %57, %55
    %59 = getelementptr inbounds double, double* %x0.0, i32 2
    %60 = load double, double* %59, align 8, !tbaa !1
    %61 = fmul double %60, 0.000000e+00
    %62 = getelementptr inbounds double, double* %x1.0, i32 2
    %63 = load double, double* %62, align 8, !tbaa !1
    %64 = fmul double %63, 0.000000e+00
    %65 = fadd double %61, %64
    %66 = getelementptr inbounds double, double* %x2.0, i32 2
    %67 = load double, double* %66, align 8, !tbaa !1
    %68 = fadd double %67, %65
    %69 = fadd double %60, %64
    %70 = fmul double %67, 0.000000e+00
    %71 = fadd double %69, %70
    %72 = fadd double %61, %63
    %73 = fadd double %72, %70
    %74 = fmul double %38, %38
    %75 = fmul double %53, %53
    %76 = fadd double %74, %75
    %77 = fmul double %68, %68
    %78 = fadd double %76, %77
    %79 = tail call double @sqrt(double %78) #5
    %80 = fcmp oeq double %79, %79
    br i1 %80, label %.split, label %call.sqrt
  
  call.sqrt:                                        ; preds = %31
    %81 = tail call double @sqrt(double %78) #4
    br label %.split
  
  .split:                                           ; preds = %31, %call.sqrt
    %82 = phi double [ %79, %31 ], [ %81, %call.sqrt ]
    %83 = fdiv double %38, %82
    %84 = fdiv double %53, %82
    %85 = fdiv double %68, %82
    %86 = fmul double %41, %41
    %87 = fmul double %56, %56
    %88 = fadd double %86, %87
    %89 = fmul double %71, %71
    %90 = fadd double %88, %89
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %.split.split, label %call.sqrt1
  
  call.sqrt1:                                       ; preds = %.split
    %93 = tail call double @sqrt(double %90) #4
    br label %.split.split
  
  .split.split:                                     ; preds = %.split, %call.sqrt1
    %94 = phi double [ %91, %.split ], [ %93, %call.sqrt1 ]
    %95 = fdiv double %41, %94
    %96 = fdiv double %56, %94
    %97 = fdiv double %71, %94
    %98 = fmul double %43, %43
    %99 = fmul double %58, %58
    %100 = fadd double %98, %99
    %101 = fmul double %73, %73
    %102 = fadd double %100, %101
    %103 = tail call double @sqrt(double %102) #5
    %104 = fcmp oeq double %103, %103
    br i1 %104, label %.split.split.split, label %call.sqrt2
  
  call.sqrt2:                                       ; preds = %.split.split
    %105 = tail call double @sqrt(double %102) #4
    br label %.split.split.split
  
  .split.split.split:                               ; preds = %.split.split, %call.sqrt2
    %106 = phi double [ %103, %.split.split ], [ %105, %call.sqrt2 ]
    %107 = bitcast [3 x double]* %n11.i.i to double*
    %108 = bitcast [3 x double]* %q1.i.i to double*
    %109 = bitcast [3 x double]* %q0.i.i to double*
    %110 = bitcast [3 x double]* %p3.i.i to double*
    %111 = bitcast [3 x double]* %p2.i.i to double*
    %112 = bitcast [3 x double]* %p1.i.i to double*
    %113 = bitcast [3 x double]* %n11.i.i to i8*
    %114 = bitcast [3 x double]* %q1.i.i to i8*
    %115 = bitcast [3 x double]* %q0.i.i to i8*
    %116 = bitcast [3 x double]* %p3.i.i to i8*
    %117 = bitcast [3 x double]* %p2.i.i to i8*
    %118 = bitcast [3 x double]* %p1.i.i to i8*
    %119 = fdiv double %43, %106
    %120 = fdiv double %58, %106
    %121 = fdiv double %73, %106
    call void @llvm.lifetime.start(i64 24, i8* %118) #4
    call void @llvm.lifetime.start(i64 24, i8* %117) #4
    call void @llvm.lifetime.start(i64 24, i8* %116) #4
    call void @llvm.lifetime.start(i64 24, i8* %115) #4
    call void @llvm.lifetime.start(i64 24, i8* %114) #4
    call void @llvm.lifetime.start(i64 24, i8* %113) #4
    %122 = fmul double %95, %radius
    %123 = load double, double* %p0, align 8, !tbaa !1
    %124 = fadd double %122, %123
    store double %124, double* %112, align 8, !tbaa !1
    %125 = fmul double %83, %radius
    %126 = fadd double %125, %123
    store double %126, double* %111, align 8, !tbaa !1
    %127 = fmul double %119, %radius
    %128 = fadd double %127, %123
    store double %128, double* %110, align 8, !tbaa !1
    %129 = fmul double %96, %radius
    %sunkaddr = ptrtoint double* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    %130 = load double, double* %sunkaddr4, align 8, !tbaa !1
    %131 = fadd double %129, %130
    %sunkaddr5 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr6 = add i32 %sunkaddr5, 8
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %131, double* %sunkaddr7, align 8, !tbaa !1
    %132 = fmul double %84, %radius
    %133 = fadd double %132, %130
    %sunkaddr8 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %133, double* %sunkaddr10, align 8, !tbaa !1
    %134 = fmul double %120, %radius
    %135 = fadd double %134, %130
    %sunkaddr11 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr12 = add i32 %sunkaddr11, 8
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %135, double* %sunkaddr13, align 8, !tbaa !1
    %136 = fmul double %97, %radius
    %sunkaddr14 = ptrtoint double* %p0 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 16
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    %137 = load double, double* %sunkaddr16, align 8, !tbaa !1
    %138 = fadd double %136, %137
    %sunkaddr17 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %138, double* %sunkaddr19, align 8, !tbaa !1
    %139 = fmul double %85, %radius
    %140 = fadd double %139, %137
    %sunkaddr20 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr21 = add i32 %sunkaddr20, 16
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %140, double* %sunkaddr22, align 8, !tbaa !1
    %141 = fmul double %121, %radius
    %142 = fadd double %141, %137
    %sunkaddr23 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %142, double* %sunkaddr25, align 8, !tbaa !1
    call void @diff3(double* %112, double* %111, double* %109) #4
    call void @diff3(double* %111, double* %110, double* %108) #4
    call void @crossprod(double* %109, double* %108, double* %108) #4
    call void @normalize(double* %108) #4
    call void @m_xformpt(double* %112, double* %112, double* %108, double* %107) #4
    call void @m_xformptonly(double* %111, double* %111) #4
    call void @m_xformptonly(double* %110, double* %110) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %107) #4
    call void @glVertex3dv(double* %112) #4
    call void @glVertex3dv(double* %111) #4
    call void @glVertex3dv(double* %110) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %113) #4
    call void @llvm.lifetime.end(i64 24, i8* %114) #4
    call void @llvm.lifetime.end(i64 24, i8* %115) #4
    call void @llvm.lifetime.end(i64 24, i8* %116) #4
    call void @llvm.lifetime.end(i64 24, i8* %117) #4
    call void @llvm.lifetime.end(i64 24, i8* %118) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  declare void @diff3(double*, double*, double*) #3
  
  declare void @crossprod(double*, double*, double*) #3
  
  declare void @normalize(double*) #3
  
  declare void @m_xformptonly(double*, double*) #3
  
  declare void @m_pushmatrix() #3
  
  declare void @m_translate(double, double, double) #3
  
  declare void @m_scale(double, double, double) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @pentagon(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %shadeType) unnamed_addr #0 {
    %n0 = alloca [3 x double], align 8
    %d1 = alloca [3 x double], align 8
    %d2 = alloca [3 x double], align 8
    %d3 = alloca [3 x double], align 8
    %d4 = alloca [3 x double], align 8
    %d5 = alloca [3 x double], align 8
    %nout = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %d1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %d2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %d3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %d4 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %d5 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %nout to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %a, i32 0
    %9 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %b, i32 0
    %10 = bitcast [3 x double]* %d1 to double*
    call void @diff3(double* %8, double* %9, double* %10) #4
    %11 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %c, i32 0
    %12 = bitcast [3 x double]* %d2 to double*
    call void @diff3(double* %9, double* %11, double* %12) #4
    %13 = bitcast [3 x double]* %n0 to double*
    call void @crossprod(double* %10, double* %12, double* %13) #4
    call void @normalize(double* %13) #4
    %14 = bitcast [3 x double]* %nout to double*
    call void @m_xformpt(double* %8, double* %10, double* %13, double* %14) #4
    call void @m_xformptonly(double* %9, double* %12) #4
    %15 = bitcast [3 x double]* %d3 to double*
    call void @m_xformptonly(double* %11, double* %15) #4
    %16 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %d, i32 0
    %17 = bitcast [3 x double]* %d4 to double*
    call void @m_xformptonly(double* %16, double* %17) #4
    %18 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %e, i32 0
    %19 = bitcast [3 x double]* %d5 to double*
    call void @m_xformptonly(double* %18, double* %19) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %14) #4
    call void @glVertex3dv(double* %10) #4
    call void @glVertex3dv(double* %12) #4
    call void @glVertex3dv(double* %15) #4
    call void @glVertex3dv(double* %17) #4
    call void @glVertex3dv(double* %19) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %7) #4
    call void @llvm.lifetime.end(i64 24, i8* %6) #4
    call void @llvm.lifetime.end(i64 24, i8* %5) #4
    call void @llvm.lifetime.end(i64 24, i8* %4) #4
    call void @llvm.lifetime.end(i64 24, i8* %3) #4
    call void @llvm.lifetime.end(i64 24, i8* %2) #4
    call void @llvm.lifetime.end(i64 24, i8* %1) #4
    ret void
  }
  
  declare void @m_popmatrix() #3
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { norecurse nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { nounwind }
  attributes #5 = { nounwind readnone }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !2, i64 0}
  !2 = !{!"double", !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"any pointer", !3, i64 0}
  !7 = !{!8, !6, i64 12}
  !8 = !{!"model", !9, i64 0, !6, i64 4, !9, i64 8, !6, i64 12}
  !9 = !{!"int", !3, i64 0}
  !10 = !{!8, !9, i64 0}
  !11 = !{!8, !9, i64 8}
  !12 = !{!8, !6, i64 4}
  !13 = !{!9, !9, i64 0}

...
---
name:            auxSolidSphere
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: afgr64 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: afgr64 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
liveins:         
  - { reg: '%d6', virtual-reg: '%5' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 40):
    successors: %bb.4.findList.exit.thread(37), %bb.7(62)
    liveins: %d6, %t9, %v0
  
    %6 = ADDu %v0, %t9
    %5 = COPY %d6
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %7 = LW %6, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %8 = ADDiu %zero, 8
    %a0 = COPY %8
    %gp = COPY %6
    %t9 = COPY %7
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %9 = COPY %v0
    SDC1 %5, %9, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.2, !tbaa !1)
    %10 = LW %6, target-flags(<unknown>) @lists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %11 = ADDiu %10, target-flags(<unknown>) @lists
    %1 = LW %11, 40, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from `%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10)`, !tbaa !5)
    %0 = COPY %9
    BEQ %1, %zero, %bb.4.findList.exit.thread, implicit-def %at
  
  bb.7 (freq 25):
    successors: %bb.1.compareParams.exit.i(100)
  
  
  bb.1.compareParams.exit.i (freq 409):
    successors: %bb.2(96), %bb.3.findList.exit(3)
  
    %2 = PHI %1, %bb.7, %3, %bb.2
    %12 = LW %2, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.4, !tbaa !7)
    %13 = LDC1 killed %12, 0, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 8 from %ir.5, !tbaa !1)
    FCMP_D32 killed %13, %5, 2, implicit-def %fcc0
    BC1T %fcc0, %bb.3.findList.exit, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.7, freq 396):
    successors: %bb.4.findList.exit.thread(3), %bb.1.compareParams.exit.i(96)
  
    %3 = LW %2, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.8, !tbaa !5)
    BEQ %3, %zero, %bb.4.findList.exit.thread, implicit-def dead %at
    B %bb.1.compareParams.exit.i, implicit-def dead %at
  
  bb.3.findList.exit (freq 12):
    successors: %bb.4.findList.exit.thread(37), %bb.5(62)
  
    %4 = LW %2, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.10, !tbaa !10)
    BNE %4, %zero, %bb.5, implicit-def dead %at
    B %bb.4.findList.exit.thread, implicit-def dead %at
  
  bb.4.findList.exit.thread (freq 32):
    successors: %bb.6(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %16 = LW %6, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %17 = ADDiu %zero, 16
    %a0 = COPY %17
    %t9 = COPY %16
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %18 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %19 = LW %6, target-flags(<unknown>) @glGenLists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glGenLists)
    %20 = ADDiu %zero, 1
    %a0 = COPY %20
    %gp = COPY %6
    %t9 = COPY %19
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %21 = COPY %v0
    %24 = ADDiu %zero, 4865
    SW %21, %18, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.15, !tbaa !10)
    SW %20, %18, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.17, !tbaa !11)
    SW %0, %18, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.19, !tbaa !7)
    %25 = LW %11, 40, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*)`, !tbaa !5)
    SW killed %25, %18, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.22, !tbaa !12)
    SW %18, %11, 40, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**)`, !tbaa !5)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %26 = LW %6, target-flags(<unknown>) @glNewList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glNewList)
    %a0 = COPY %21
    %a1 = COPY %24
    %gp = COPY %6
    %t9 = COPY %26
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %27 = LW %6, target-flags(<unknown>) @gluNewQuadric, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @gluNewQuadric)
    %gp = COPY %6
    %t9 = COPY %27
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %28 = COPY %v0
    %29 = LUi 1
    %30 = ORi %29, 34476
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %31 = LW %6, target-flags(<unknown>) @gluQuadricDrawStyle, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @gluQuadricDrawStyle)
    %a0 = COPY %28
    %a1 = COPY %30
    %gp = COPY %6
    %t9 = COPY %31
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %32 = ORi %29, 34464
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %33 = LW %6, target-flags(<unknown>) @gluQuadricNormals, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @gluQuadricNormals)
    %a0 = COPY %28
    %a1 = COPY %32
    %gp = COPY %6
    %t9 = COPY %33
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %34 = ExtractElementF64 %5, 1
    %35 = ExtractElementF64 %5, 0
    ADJCALLSTACKDOWN 24, implicit-def dead %sp, implicit %sp
    %36 = COPY %sp
    SW %17, %36, 20, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %17, %36, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %37 = LW %6, target-flags(<unknown>) @gluSphere, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @gluSphere)
    %a0 = COPY %28
    %a2 = COPY %34
    %a3 = COPY %35
    %gp = COPY %6
    %t9 = COPY %37
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 24, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %38 = LW %6, target-flags(<unknown>) @glEndList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glEndList)
    %gp = COPY %6
    %t9 = COPY %38
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.6, implicit-def dead %at
  
  bb.5 (%ir-block.24, freq 7):
    successors: %bb.6(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %14 = LW %6, target-flags(<unknown>) @glCallList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glCallList)
    %a0 = COPY %4
    %gp = COPY %6
    %t9 = COPY %14
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %15 = LW %6, target-flags(<unknown>) @free, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @free)
    %a0 = COPY %0
    %gp = COPY %6
    %t9 = COPY %15
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.6 (%ir-block.25, freq 40):
    liveouts:
  
    RetRA

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/mesa/mesa.shapes.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.model = type { i32, %struct.model*, i32, double* }
  %struct.GLUquadricObj = type opaque
  
  @auxWireIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @lists = internal unnamed_addr global [25 x %struct.model*] zeroinitializer, align 4
  @drawbox.n = internal global [6 x [3 x double]] [[3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @drawbox.faces = internal unnamed_addr constant [6 x [4 x i32]] [[4 x i32] [i32 0, i32 1, i32 2, i32 3], [4 x i32] [i32 3, i32 2, i32 6, i32 7], [4 x i32] [i32 7, i32 6, i32 5, i32 4], [4 x i32] [i32 4, i32 5, i32 1, i32 0], [4 x i32] [i32 5, i32 6, i32 2, i32 1], [4 x i32] [i32 7, i32 4, i32 0, i32 3]], align 4
  @iindex = internal unnamed_addr constant [20 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 1], [3 x i32] [i32 0, i32 9, i32 4], [3 x i32] [i32 9, i32 5, i32 4], [3 x i32] [i32 4, i32 5, i32 8], [3 x i32] [i32 4, i32 8, i32 1], [3 x i32] [i32 8, i32 10, i32 1], [3 x i32] [i32 8, i32 3, i32 10], [3 x i32] [i32 5, i32 3, i32 8], [3 x i32] [i32 5, i32 2, i32 3], [3 x i32] [i32 2, i32 7, i32 3], [3 x i32] [i32 7, i32 10, i32 3], [3 x i32] [i32 7, i32 6, i32 10], [3 x i32] [i32 7, i32 11, i32 6], [3 x i32] [i32 11, i32 0, i32 6], [3 x i32] [i32 0, i32 1, i32 6], [3 x i32] [i32 6, i32 1, i32 10], [3 x i32] [i32 9, i32 0, i32 11], [3 x i32] [i32 9, i32 11, i32 2], [3 x i32] [i32 9, i32 2, i32 5], [3 x i32] [i32 7, i32 2, i32 11]], align 4
  @idata = internal global [12 x [3 x double]] [[3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00]], align 8
  @ondex = internal unnamed_addr constant [8 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 2], [3 x i32] [i32 1, i32 2, i32 4], [3 x i32] [i32 0, i32 3, i32 4], [3 x i32] [i32 1, i32 4, i32 3], [3 x i32] [i32 0, i32 2, i32 5], [3 x i32] [i32 1, i32 5, i32 2], [3 x i32] [i32 0, i32 5, i32 3], [3 x i32] [i32 1, i32 3, i32 5]], align 4
  @odata = internal global [6 x [3 x double]] [[3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @tndex = internal unnamed_addr constant [4 x [3 x i32]] [[3 x i32] [i32 0, i32 1, i32 3], [3 x i32] [i32 2, i32 1, i32 0], [3 x i32] [i32 3, i32 2, i32 0], [3 x i32] [i32 1, i32 2, i32 3]], align 4
  @tdata = internal global [4 x [3 x double]] [[3 x double] [double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA], [3 x double] [double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA]], align 8
  @dodecahedron.inited = internal unnamed_addr global i1 false
  @dodec = internal global [20 x [3 x double]] zeroinitializer, align 8
  
  ; Function Attrs: nounwind
  define void @auxWireSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast ([25 x %struct.model*]* @lists to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast ([25 x %struct.model*]* @lists to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100011) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare noalias i8* @malloc(i32 signext) #0
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @findList(i32 signext %lindex, double* nocapture readonly %paramArray, i32 signext %size) #2 {
    %1 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %endList.02 = load %struct.model*, %struct.model** %1, align 4, !tbaa !5
    %2 = icmp eq %struct.model* %endList.02, null
    br i1 %2, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0
    br label %3
  
  ; <label>:3                                       ; preds = %18, %.lr.ph
    %endList.03 = phi %struct.model* [ %endList.02, %.lr.ph ], [ %endList.0, %18 ]
    %4 = icmp sgt i32 %size, 0
    br i1 %4, label %.lr.ph.i.preheader, label %compareParams.exit.thread
  
  .lr.ph.i.preheader:                               ; preds = %3
    %5 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 3
    %6 = load double*, double** %5, align 4, !tbaa !7
    br label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %matches.05.i = phi i32 [ %matches.1.i, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %.03.i = phi double* [ %7, %.lr.ph.i ], [ %6, %.lr.ph.i.preheader ]
    %.012.i = phi double* [ %9, %.lr.ph.i ], [ %paramArray, %.lr.ph.i.preheader ]
    %7 = getelementptr inbounds double, double* %.03.i, i32 1
    %8 = load double, double* %.03.i, align 8, !tbaa !1
    %9 = getelementptr inbounds double, double* %.012.i, i32 1
    %10 = load double, double* %.012.i, align 8, !tbaa !1
    %11 = fcmp une double %8, %10
    %matches.1.i = select i1 %11, i32 0, i32 %matches.05.i
    %12 = icmp slt i32 %lsr.iv, %size
    %13 = icmp ne i32 %matches.1.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %14, label %.lr.ph.i, label %compareParams.exit
  
  compareParams.exit:                               ; preds = %.lr.ph.i
    %15 = icmp eq i32 %matches.1.i, 0
    br i1 %15, label %18, label %compareParams.exit.thread
  
  compareParams.exit.thread:                        ; preds = %compareParams.exit, %3
    %16 = bitcast %struct.model* %endList.03 to i32*
    %17 = load i32, i32* %16, align 4, !tbaa !10
    br label %.loopexit
  
  ; <label>:18                                      ; preds = %compareParams.exit
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 1
    %endList.0 = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0, null
    br i1 %20, label %.loopexit, label %3
  
  .loopexit:                                        ; preds = %18, %compareParams.exit.thread, %0
    %.0 = phi i32 [ %17, %compareParams.exit.thread ], [ 0, %0 ], [ 0, %18 ]
    ret i32 %.0
  }
  
  declare void @glNewList(i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @makeModelPtr(i32 signext %lindex, double* %sizeArray, i32 signext %count) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = tail call i32 @glGenLists(i32 signext 1) #4
    %3 = bitcast i8* %1 to i32*
    store i32 %2, i32* %3, align 4, !tbaa !10
    %4 = getelementptr inbounds i8, i8* %1, i32 8
    %5 = bitcast i8* %4 to i32*
    store i32 %count, i32* %5, align 4, !tbaa !11
    %6 = getelementptr inbounds i8, i8* %1, i32 12
    %7 = bitcast i8* %6 to double**
    store double* %sizeArray, double** %7, align 4, !tbaa !7
    %8 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %9 = bitcast %struct.model** %8 to i32*
    %10 = load i32, i32* %9, align 4, !tbaa !5
    %11 = getelementptr inbounds i8, i8* %1, i32 4
    %12 = bitcast i8* %11 to i32*
    store i32 %10, i32* %12, align 4, !tbaa !12
    %13 = bitcast %struct.model** %8 to i8**
    store i8* %1, i8** %13, align 4, !tbaa !5
    ret i32 %2
  }
  
  declare %struct.GLUquadricObj* @gluNewQuadric() #3
  
  declare void @gluQuadricDrawStyle(%struct.GLUquadricObj*, i32 signext) #3
  
  declare void @gluSphere(%struct.GLUquadricObj*, double, i32 signext, i32 signext) #3
  
  declare void @glEndList() #3
  
  declare void @glCallList(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  define void @auxSolidSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %23, i32 signext 100000) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  declare void @gluQuadricNormals(%struct.GLUquadricObj*, i32 signext) #3
  
  ; Function Attrs: nounwind
  define void @auxWireCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 2)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawbox(double %x0, double %x1, double %y0, double %y1, double %z0, double %z1, i32 signext %type) unnamed_addr #0 {
    %v = alloca [8 x [3 x double]], align 8
    %1 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.start(i64 192, i8* %1) #4
    %2 = fcmp ogt double %x0, %x1
    %.05 = select i1 %2, double %x0, double %x1
    %.0 = select i1 %2, double %x1, double %x0
    %3 = fcmp ogt double %y0, %y1
    %.04 = select i1 %3, double %y1, double %y0
    %.03 = select i1 %3, double %y0, double %y1
    %4 = fcmp ogt double %z0, %z1
    %.02 = select i1 %4, double %z1, double %z0
    %.01 = select i1 %4, double %z0, double %z1
    %5 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 0
    store double %.0, double* %5, align 8, !tbaa !1
    %6 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 0
    store double %.0, double* %6, align 8, !tbaa !1
    %7 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 0
    store double %.0, double* %7, align 8, !tbaa !1
    %8 = bitcast [8 x [3 x double]]* %v to double*
    store double %.0, double* %8, align 8, !tbaa !1
    %9 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 0
    store double %.05, double* %9, align 8, !tbaa !1
    %10 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 0
    store double %.05, double* %10, align 8, !tbaa !1
    %11 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 0
    store double %.05, double* %11, align 8, !tbaa !1
    %12 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 0
    store double %.05, double* %12, align 8, !tbaa !1
    %13 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 1
    store double %.04, double* %13, align 8, !tbaa !1
    %14 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 1
    store double %.04, double* %14, align 8, !tbaa !1
    %15 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 1
    store double %.04, double* %15, align 8, !tbaa !1
    %16 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 1
    store double %.04, double* %16, align 8, !tbaa !1
    %17 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 1
    store double %.03, double* %17, align 8, !tbaa !1
    %18 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 1
    store double %.03, double* %18, align 8, !tbaa !1
    %19 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 1
    store double %.03, double* %19, align 8, !tbaa !1
    %20 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 1
    store double %.03, double* %20, align 8, !tbaa !1
    %21 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 2
    store double %.02, double* %21, align 8, !tbaa !1
    %22 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 2
    store double %.02, double* %22, align 8, !tbaa !1
    %23 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 2
    store double %.02, double* %23, align 8, !tbaa !1
    %24 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 2
    store double %.02, double* %24, align 8, !tbaa !1
    %25 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 2
    store double %.01, double* %25, align 8, !tbaa !1
    %26 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 2
    store double %.01, double* %26, align 8, !tbaa !1
    %27 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 2
    store double %.01, double* %27, align 8, !tbaa !1
    %28 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 2
    store double %.01, double* %28, align 8, !tbaa !1
    br label %29
  
  ; <label>:29                                      ; preds = %29, %0
    %lsr.iv1 = phi [6 x [4 x i32]]* [ %38, %29 ], [ bitcast (i32* getelementptr inbounds ([6 x [4 x i32]], [6 x [4 x i32]]* @drawbox.faces, i32 0, i32 0, i32 2) to [6 x [4 x i32]]*), %0 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %29 ], [ 0, %0 ]
    %lsr.iv12 = bitcast [6 x [4 x i32]]* %lsr.iv1 to i32*
    call void @glBegin(i32 signext %type) #4
    %uglygep11 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep1112 = bitcast i8* %uglygep11 to double*
    call void @glNormal3dv(double* %uglygep1112) #4
    %scevgep5 = getelementptr i32, i32* %lsr.iv12, i32 -2
    %30 = load i32, i32* %scevgep5, align 4, !tbaa !13
    %31 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %30, i32 0
    call void @glVertex3dv(double* %31) #4
    %uglygep9 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep910 = bitcast i8* %uglygep9 to double*
    call void @glNormal3dv(double* %uglygep910) #4
    %scevgep4 = getelementptr i32, i32* %lsr.iv12, i32 -1
    %32 = load i32, i32* %scevgep4, align 4, !tbaa !13
    %33 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %32, i32 0
    call void @glVertex3dv(double* %33) #4
    %uglygep7 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep78 = bitcast i8* %uglygep7 to double*
    call void @glNormal3dv(double* %uglygep78) #4
    %34 = load i32, i32* %lsr.iv12, align 4, !tbaa !13
    %35 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %34, i32 0
    call void @glVertex3dv(double* %35) #4
    %uglygep = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep6 = bitcast i8* %uglygep to double*
    call void @glNormal3dv(double* %uglygep6) #4
    %scevgep3 = getelementptr i32, i32* %lsr.iv12, i32 1
    %36 = load i32, i32* %scevgep3, align 4, !tbaa !13
    %37 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %36, i32 0
    call void @glVertex3dv(double* %37) #4
    call void @glEnd() #4
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 24
    %scevgep = getelementptr [6 x [4 x i32]], [6 x [4 x i32]]* %lsr.iv1, i32 0, i32 1, i32 0
    %38 = bitcast i32* %scevgep to [6 x [4 x i32]]*
    %exitcond = icmp eq i32 %lsr.iv.next, 144
    br i1 %exitcond, label %39, label %29
  
  ; <label>:39                                      ; preds = %29
    %40 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.end(i64 192, i8* %40) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 7)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 2)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 7)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 5, i32 signext 10, i32 signext 2)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @doughnut(double %r, double %R, i32 signext %nsides, i32 signext %rings, i32 signext %type) unnamed_addr #0 {
    %p0 = alloca [3 x double], align 8
    %p1 = alloca [3 x double], align 8
    %p2 = alloca [3 x double], align 8
    %p3 = alloca [3 x double], align 8
    %n0 = alloca [3 x double], align 8
    %n1 = alloca [3 x double], align 8
    %n2 = alloca [3 x double], align 8
    %n3 = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %p1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %p2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %p3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %n1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %n2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = bitcast [3 x double]* %n3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %8) #4
    %9 = icmp sgt i32 %rings, 0
    br i1 %9, label %.lr.ph3, label %._crit_edge
  
  .lr.ph3:                                          ; preds = %0
    %10 = sitofp i32 %rings to double
    %11 = sitofp i32 %nsides to double
    br label %12
  
  .loopexit:                                        ; preds = %.lr.ph, %12
    %exitcond4 = icmp eq i32 %17, %rings
    br i1 %exitcond4, label %._crit_edge, label %12
  
  ; <label>:12                                      ; preds = %.loopexit, %.lr.ph3
    %IV.S.1 = phi double [ 0.000000e+00, %.lr.ph3 ], [ %IV.S.next.2, %.loopexit ]
    %i.02 = phi i32 [ 0, %.lr.ph3 ], [ %17, %.loopexit ]
    %13 = icmp sgt i32 %nsides, 0
    %14 = fmul double %IV.S.1, 2.000000e+00
    %15 = fmul double %14, 0x400921FB54442C46
    %16 = fdiv double %15, %10
    %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
    %17 = add nuw nsw i32 %i.02, 1
    %18 = sitofp i32 %17 to double
    %19 = fmul double %18, 2.000000e+00
    %20 = fmul double %19, 0x400921FB54442C46
    %21 = fdiv double %20, %10
    br i1 %13, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %12, %.lr.ph
    %IV.S. = phi double [ %IV.S.next., %.lr.ph ], [ 0.000000e+00, %12 ]
    %j.01 = phi i32 [ %33, %.lr.ph ], [ 0, %12 ]
    %22 = bitcast [3 x double]* %n3 to double*
    %23 = bitcast [3 x double]* %n2 to double*
    %24 = bitcast [3 x double]* %n1 to double*
    %25 = bitcast [3 x double]* %n0 to double*
    %26 = bitcast [3 x double]* %p3 to double*
    %27 = bitcast [3 x double]* %p2 to double*
    %28 = bitcast [3 x double]* %p1 to double*
    %29 = bitcast [3 x double]* %p0 to double*
    %30 = fmul double %IV.S., 2.000000e+00
    %31 = fmul double %30, 0x400921FB54442C46
    %32 = fdiv double %31, %11
    %IV.S.next. = fadd double %IV.S., 1.000000e+00
    %33 = add nuw nsw i32 %j.01, 1
    %34 = sitofp i32 %33 to double
    %35 = fmul double %34, 2.000000e+00
    %36 = fmul double %35, 0x400921FB54442C46
    %37 = fdiv double %36, %11
    %38 = call double @cos(double %16) #4
    %39 = call double @cos(double %32) #4
    %40 = fmul double %39, %r
    %41 = fadd double %40, %R
    %42 = fmul double %38, %41
    store double %42, double* %29, align 8, !tbaa !1
    %43 = call double @sin(double %16) #4
    %44 = call double @cos(double %32) #4
    %45 = fmul double %44, %r
    %46 = fadd double %45, %R
    %47 = fmul double %43, %46
    %48 = fsub double -0.000000e+00, %47
    %sunkaddr = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    store double %48, double* %sunkaddr4, align 8, !tbaa !1
    %49 = call double @sin(double %32) #4
    %50 = fmul double %49, %r
    %sunkaddr5 = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr6 = add i32 %sunkaddr5, 16
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %50, double* %sunkaddr7, align 8, !tbaa !1
    %51 = call double @cos(double %21) #4
    %52 = call double @cos(double %32) #4
    %53 = fmul double %52, %r
    %54 = fadd double %53, %R
    %55 = fmul double %51, %54
    store double %55, double* %28, align 8, !tbaa !1
    %56 = call double @sin(double %21) #4
    %57 = call double @cos(double %32) #4
    %58 = fmul double %57, %r
    %59 = fadd double %58, %R
    %60 = fmul double %56, %59
    %61 = fsub double -0.000000e+00, %60
    %sunkaddr8 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %61, double* %sunkaddr10, align 8, !tbaa !1
    %62 = call double @sin(double %32) #4
    %63 = fmul double %62, %r
    %sunkaddr11 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr12 = add i32 %sunkaddr11, 16
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %63, double* %sunkaddr13, align 8, !tbaa !1
    %64 = call double @cos(double %21) #4
    %65 = call double @cos(double %37) #4
    %66 = fmul double %65, %r
    %67 = fadd double %66, %R
    %68 = fmul double %64, %67
    store double %68, double* %27, align 8, !tbaa !1
    %69 = call double @sin(double %21) #4
    %70 = call double @cos(double %37) #4
    %71 = fmul double %70, %r
    %72 = fadd double %71, %R
    %73 = fmul double %69, %72
    %74 = fsub double -0.000000e+00, %73
    %sunkaddr14 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 8
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    store double %74, double* %sunkaddr16, align 8, !tbaa !1
    %75 = call double @sin(double %37) #4
    %76 = fmul double %75, %r
    %sunkaddr17 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %76, double* %sunkaddr19, align 8, !tbaa !1
    %77 = call double @cos(double %16) #4
    %78 = call double @cos(double %37) #4
    %79 = fmul double %78, %r
    %80 = fadd double %79, %R
    %81 = fmul double %77, %80
    store double %81, double* %26, align 8, !tbaa !1
    %82 = call double @sin(double %16) #4
    %83 = call double @cos(double %37) #4
    %84 = fmul double %83, %r
    %85 = fadd double %84, %R
    %86 = fmul double %82, %85
    %87 = fsub double -0.000000e+00, %86
    %sunkaddr20 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr21 = add i32 %sunkaddr20, 8
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %87, double* %sunkaddr22, align 8, !tbaa !1
    %88 = call double @sin(double %37) #4
    %89 = fmul double %88, %r
    %sunkaddr23 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %89, double* %sunkaddr25, align 8, !tbaa !1
    %90 = call double @cos(double %16) #4
    %91 = call double @cos(double %32) #4
    %92 = fmul double %90, %91
    store double %92, double* %25, align 8, !tbaa !1
    %93 = call double @sin(double %16) #4
    %94 = call double @cos(double %32) #4
    %95 = fmul double %93, %94
    %96 = fsub double -0.000000e+00, %95
    %sunkaddr26 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr27 = add i32 %sunkaddr26, 8
    %sunkaddr28 = inttoptr i32 %sunkaddr27 to double*
    store double %96, double* %sunkaddr28, align 8, !tbaa !1
    %97 = call double @sin(double %32) #4
    %sunkaddr29 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr30 = add i32 %sunkaddr29, 16
    %sunkaddr31 = inttoptr i32 %sunkaddr30 to double*
    store double %97, double* %sunkaddr31, align 8, !tbaa !1
    %98 = call double @cos(double %21) #4
    %99 = call double @cos(double %32) #4
    %100 = fmul double %98, %99
    store double %100, double* %24, align 8, !tbaa !1
    %101 = call double @sin(double %21) #4
    %102 = call double @cos(double %32) #4
    %103 = fmul double %101, %102
    %104 = fsub double -0.000000e+00, %103
    %sunkaddr32 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr33 = add i32 %sunkaddr32, 8
    %sunkaddr34 = inttoptr i32 %sunkaddr33 to double*
    store double %104, double* %sunkaddr34, align 8, !tbaa !1
    %105 = call double @sin(double %32) #4
    %sunkaddr35 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr36 = add i32 %sunkaddr35, 16
    %sunkaddr37 = inttoptr i32 %sunkaddr36 to double*
    store double %105, double* %sunkaddr37, align 8, !tbaa !1
    %106 = call double @cos(double %21) #4
    %107 = call double @cos(double %37) #4
    %108 = fmul double %106, %107
    store double %108, double* %23, align 8, !tbaa !1
    %109 = call double @sin(double %21) #4
    %110 = call double @cos(double %37) #4
    %111 = fmul double %109, %110
    %112 = fsub double -0.000000e+00, %111
    %sunkaddr38 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr39 = add i32 %sunkaddr38, 8
    %sunkaddr40 = inttoptr i32 %sunkaddr39 to double*
    store double %112, double* %sunkaddr40, align 8, !tbaa !1
    %113 = call double @sin(double %37) #4
    %sunkaddr41 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr42 = add i32 %sunkaddr41, 16
    %sunkaddr43 = inttoptr i32 %sunkaddr42 to double*
    store double %113, double* %sunkaddr43, align 8, !tbaa !1
    %114 = call double @cos(double %16) #4
    %115 = call double @cos(double %37) #4
    %116 = fmul double %114, %115
    store double %116, double* %22, align 8, !tbaa !1
    %117 = call double @sin(double %16) #4
    %118 = call double @cos(double %37) #4
    %119 = fmul double %117, %118
    %120 = fsub double -0.000000e+00, %119
    %sunkaddr44 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr45 = add i32 %sunkaddr44, 8
    %sunkaddr46 = inttoptr i32 %sunkaddr45 to double*
    store double %120, double* %sunkaddr46, align 8, !tbaa !1
    %121 = call double @sin(double %37) #4
    %sunkaddr47 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr48 = add i32 %sunkaddr47, 16
    %sunkaddr49 = inttoptr i32 %sunkaddr48 to double*
    store double %121, double* %sunkaddr49, align 8, !tbaa !1
    call void @m_xformpt(double* %29, double* %29, double* %25, double* %25) #4
    call void @m_xformpt(double* %28, double* %28, double* %24, double* %24) #4
    call void @m_xformpt(double* %27, double* %27, double* %23, double* %23) #4
    call void @m_xformpt(double* %26, double* %26, double* %22, double* %22) #4
    call void @glBegin(i32 signext %type) #4
    call void @glNormal3dv(double* %22) #4
    call void @glVertex3dv(double* %26) #4
    call void @glNormal3dv(double* %23) #4
    call void @glVertex3dv(double* %27) #4
    call void @glNormal3dv(double* %24) #4
    call void @glVertex3dv(double* %28) #4
    call void @glNormal3dv(double* %25) #4
    call void @glVertex3dv(double* %29) #4
    call void @glEnd() #4
    %exitcond = icmp eq i32 %nsides, %33
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.loopexit, %0
    %122 = bitcast [3 x double]* %n3 to i8*
    %123 = bitcast [3 x double]* %n2 to i8*
    %124 = bitcast [3 x double]* %n1 to i8*
    %125 = bitcast [3 x double]* %n0 to i8*
    %126 = bitcast [3 x double]* %p3 to i8*
    %127 = bitcast [3 x double]* %p2 to i8*
    %128 = bitcast [3 x double]* %p1 to i8*
    %129 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.end(i64 24, i8* %122) #4
    call void @llvm.lifetime.end(i64 24, i8* %123) #4
    call void @llvm.lifetime.end(i64 24, i8* %124) #4
    call void @llvm.lifetime.end(i64 24, i8* %125) #4
    call void @llvm.lifetime.end(i64 24, i8* %126) #4
    call void @llvm.lifetime.end(i64 24, i8* %127) #4
    call void @llvm.lifetime.end(i64 24, i8* %128) #4
    call void @llvm.lifetime.end(i64 24, i8* %129) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 8, i32 signext 15, i32 signext 7)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  declare void @glPushMatrix() #3
  
  declare void @glRotatef(float, float, float, float) #3
  
  declare void @glTranslatef(float, float, float) #3
  
  declare void @gluCylinder(%struct.GLUquadricObj*, double, double, double, i32 signext, i32 signext) #3
  
  declare void @glPopMatrix() #3
  
  ; Function Attrs: nounwind
  define void @auxSolidCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @icosahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 8, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 9, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 10, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 11, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 12, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 13, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 14, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 15, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 16, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 17, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 18, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 19, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireOctahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @octahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidOctahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireDodecahedron.center, i32 0, i32 0), double %23, i32 signext 2)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @dodecahedron(double* nocapture readonly %center, double %sc, i32 signext %type) unnamed_addr #0 {
    %.b = load i1, i1* @dodecahedron.inited, align 1
    br i1 %.b, label %2, label %1
  
  ; <label>:1                                       ; preds = %0
    store i1 true, i1* @dodecahedron.inited, align 1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 2), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 2), align 8, !tbaa !1
    br label %2
  
  ; <label>:2                                       ; preds = %1, %0
    tail call void @m_pushmatrix() #4
    %3 = load double, double* %center, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %center, i32 1
    %5 = load double, double* %4, align 8, !tbaa !1
    %6 = getelementptr inbounds double, double* %center, i32 2
    %7 = load double, double* %6, align 8, !tbaa !1
    tail call void @m_translate(double %3, double %5, double %7) #4
    tail call void @m_scale(double %sc, double %sc, double %sc) #4
    tail call fastcc void @pentagon(i32 signext 0, i32 signext 1, i32 signext 9, i32 signext 16, i32 signext 5, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 0, i32 signext 3, i32 signext 18, i32 signext 7, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 7, i32 signext 11, i32 signext 10, i32 signext 9, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 11, i32 signext 7, i32 signext 18, i32 signext 19, i32 signext 6, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 8, i32 signext 17, i32 signext 16, i32 signext 9, i32 signext 10, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 14, i32 signext 15, i32 signext 6, i32 signext 19, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 13, i32 signext 12, i32 signext 4, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 19, i32 signext 18, i32 signext 3, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 3, i32 signext 0, i32 signext 5, i32 signext 12, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 6, i32 signext 15, i32 signext 8, i32 signext 10, i32 signext 11, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 17, i32 signext 8, i32 signext 15, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 12, i32 signext 5, i32 signext 16, i32 signext 17, i32 signext %type)
    tail call void @m_popmatrix() #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidDodecahedron.center, i32 0, i32 0), double %23, i32 signext 6)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @compareParams(double* nocapture readonly %oneArray, double* nocapture readonly %twoArray, i32 signext %size) #2 {
    %1 = icmp sgt i32 %size, 0
    br i1 %1, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ 1, %0 ]
    %matches.05 = phi i32 [ %matches.1, %.lr.ph ], [ 1, %0 ]
    %.03 = phi double* [ %2, %.lr.ph ], [ %oneArray, %0 ]
    %.012 = phi double* [ %4, %.lr.ph ], [ %twoArray, %0 ]
    %2 = getelementptr inbounds double, double* %.03, i32 1
    %3 = load double, double* %.03, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %.012, i32 1
    %5 = load double, double* %.012, align 8, !tbaa !1
    %6 = fcmp une double %3, %5
    %matches.1 = select i1 %6, i32 0, i32 %matches.05
    %7 = icmp slt i32 %lsr.iv, %size
    %8 = icmp ne i32 %matches.1, 0
    %9 = and i1 %7, %8
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    %matches.0.lcssa = phi i32 [ 1, %0 ], [ %matches.1, %.lr.ph ]
    ret i32 %matches.0.lcssa
  }
  
  declare i32 @glGenLists(i32 signext) #3
  
  declare void @glBegin(i32 signext) #3
  
  declare void @glNormal3dv(double*) #3
  
  declare void @glVertex3dv(double*) #3
  
  declare void @glEnd() #3
  
  ; Function Attrs: nounwind
  declare double @cos(double) #0
  
  ; Function Attrs: nounwind
  declare double @sin(double) #0
  
  declare void @m_xformpt(double*, double*, double*, double*) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawtriangle(i32 signext %i, i32 signext %geomType, double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    %p1.i.i = alloca [3 x double], align 8
    %p2.i.i = alloca [3 x double], align 8
    %p3.i.i = alloca [3 x double], align 8
    %q0.i.i = alloca [3 x double], align 8
    %q1.i.i = alloca [3 x double], align 8
    %n11.i.i = alloca [3 x double], align 8
    switch i32 %geomType, label %31 [
      i32 0, label %1
      i32 1, label %11
      i32 2, label %21
    ]
  
  ; <label>:1                                       ; preds = %0
    %2 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 0
    %3 = load i32, i32* %2, align 4, !tbaa !13
    %4 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %3, i32 0
    %5 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 1
    %6 = load i32, i32* %5, align 4, !tbaa !13
    %7 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %6, i32 0
    %8 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 2
    %9 = load i32, i32* %8, align 4, !tbaa !13
    %10 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %9, i32 0
    br label %31
  
  ; <label>:11                                      ; preds = %0
    %12 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 0
    %13 = load i32, i32* %12, align 4, !tbaa !13
    %14 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %13, i32 0
    %15 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 1
    %16 = load i32, i32* %15, align 4, !tbaa !13
    %17 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %16, i32 0
    %18 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 2
    %19 = load i32, i32* %18, align 4, !tbaa !13
    %20 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %19, i32 0
    br label %31
  
  ; <label>:21                                      ; preds = %0
    %22 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 0
    %23 = load i32, i32* %22, align 4, !tbaa !13
    %24 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %23, i32 0
    %25 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 1
    %26 = load i32, i32* %25, align 4, !tbaa !13
    %27 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %26, i32 0
    %28 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 2
    %29 = load i32, i32* %28, align 4, !tbaa !13
    %30 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %29, i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %21, %11, %1, %0
    %x0.0 = phi double* [ undef, %0 ], [ %24, %21 ], [ %14, %11 ], [ %4, %1 ]
    %x1.0 = phi double* [ undef, %0 ], [ %27, %21 ], [ %17, %11 ], [ %7, %1 ]
    %x2.0 = phi double* [ undef, %0 ], [ %30, %21 ], [ %20, %11 ], [ %10, %1 ]
    %32 = load double, double* %x0.0, align 8, !tbaa !1
    %33 = fmul double %32, 0.000000e+00
    %34 = load double, double* %x1.0, align 8, !tbaa !1
    %35 = fmul double %34, 0.000000e+00
    %36 = fadd double %33, %35
    %37 = load double, double* %x2.0, align 8, !tbaa !1
    %38 = fadd double %37, %36
    %39 = fadd double %32, %35
    %40 = fmul double %37, 0.000000e+00
    %41 = fadd double %39, %40
    %42 = fadd double %33, %34
    %43 = fadd double %42, %40
    %44 = getelementptr inbounds double, double* %x0.0, i32 1
    %45 = load double, double* %44, align 8, !tbaa !1
    %46 = fmul double %45, 0.000000e+00
    %47 = getelementptr inbounds double, double* %x1.0, i32 1
    %48 = load double, double* %47, align 8, !tbaa !1
    %49 = fmul double %48, 0.000000e+00
    %50 = fadd double %46, %49
    %51 = getelementptr inbounds double, double* %x2.0, i32 1
    %52 = load double, double* %51, align 8, !tbaa !1
    %53 = fadd double %52, %50
    %54 = fadd double %45, %49
    %55 = fmul double %52, 0.000000e+00
    %56 = fadd double %54, %55
    %57 = fadd double %46, %48
    %58 = fadd double %57, %55
    %59 = getelementptr inbounds double, double* %x0.0, i32 2
    %60 = load double, double* %59, align 8, !tbaa !1
    %61 = fmul double %60, 0.000000e+00
    %62 = getelementptr inbounds double, double* %x1.0, i32 2
    %63 = load double, double* %62, align 8, !tbaa !1
    %64 = fmul double %63, 0.000000e+00
    %65 = fadd double %61, %64
    %66 = getelementptr inbounds double, double* %x2.0, i32 2
    %67 = load double, double* %66, align 8, !tbaa !1
    %68 = fadd double %67, %65
    %69 = fadd double %60, %64
    %70 = fmul double %67, 0.000000e+00
    %71 = fadd double %69, %70
    %72 = fadd double %61, %63
    %73 = fadd double %72, %70
    %74 = fmul double %38, %38
    %75 = fmul double %53, %53
    %76 = fadd double %74, %75
    %77 = fmul double %68, %68
    %78 = fadd double %76, %77
    %79 = tail call double @sqrt(double %78) #5
    %80 = fcmp oeq double %79, %79
    br i1 %80, label %.split, label %call.sqrt
  
  call.sqrt:                                        ; preds = %31
    %81 = tail call double @sqrt(double %78) #4
    br label %.split
  
  .split:                                           ; preds = %31, %call.sqrt
    %82 = phi double [ %79, %31 ], [ %81, %call.sqrt ]
    %83 = fdiv double %38, %82
    %84 = fdiv double %53, %82
    %85 = fdiv double %68, %82
    %86 = fmul double %41, %41
    %87 = fmul double %56, %56
    %88 = fadd double %86, %87
    %89 = fmul double %71, %71
    %90 = fadd double %88, %89
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %.split.split, label %call.sqrt1
  
  call.sqrt1:                                       ; preds = %.split
    %93 = tail call double @sqrt(double %90) #4
    br label %.split.split
  
  .split.split:                                     ; preds = %.split, %call.sqrt1
    %94 = phi double [ %91, %.split ], [ %93, %call.sqrt1 ]
    %95 = fdiv double %41, %94
    %96 = fdiv double %56, %94
    %97 = fdiv double %71, %94
    %98 = fmul double %43, %43
    %99 = fmul double %58, %58
    %100 = fadd double %98, %99
    %101 = fmul double %73, %73
    %102 = fadd double %100, %101
    %103 = tail call double @sqrt(double %102) #5
    %104 = fcmp oeq double %103, %103
    br i1 %104, label %.split.split.split, label %call.sqrt2
  
  call.sqrt2:                                       ; preds = %.split.split
    %105 = tail call double @sqrt(double %102) #4
    br label %.split.split.split
  
  .split.split.split:                               ; preds = %.split.split, %call.sqrt2
    %106 = phi double [ %103, %.split.split ], [ %105, %call.sqrt2 ]
    %107 = bitcast [3 x double]* %n11.i.i to double*
    %108 = bitcast [3 x double]* %q1.i.i to double*
    %109 = bitcast [3 x double]* %q0.i.i to double*
    %110 = bitcast [3 x double]* %p3.i.i to double*
    %111 = bitcast [3 x double]* %p2.i.i to double*
    %112 = bitcast [3 x double]* %p1.i.i to double*
    %113 = bitcast [3 x double]* %n11.i.i to i8*
    %114 = bitcast [3 x double]* %q1.i.i to i8*
    %115 = bitcast [3 x double]* %q0.i.i to i8*
    %116 = bitcast [3 x double]* %p3.i.i to i8*
    %117 = bitcast [3 x double]* %p2.i.i to i8*
    %118 = bitcast [3 x double]* %p1.i.i to i8*
    %119 = fdiv double %43, %106
    %120 = fdiv double %58, %106
    %121 = fdiv double %73, %106
    call void @llvm.lifetime.start(i64 24, i8* %118) #4
    call void @llvm.lifetime.start(i64 24, i8* %117) #4
    call void @llvm.lifetime.start(i64 24, i8* %116) #4
    call void @llvm.lifetime.start(i64 24, i8* %115) #4
    call void @llvm.lifetime.start(i64 24, i8* %114) #4
    call void @llvm.lifetime.start(i64 24, i8* %113) #4
    %122 = fmul double %95, %radius
    %123 = load double, double* %p0, align 8, !tbaa !1
    %124 = fadd double %122, %123
    store double %124, double* %112, align 8, !tbaa !1
    %125 = fmul double %83, %radius
    %126 = fadd double %125, %123
    store double %126, double* %111, align 8, !tbaa !1
    %127 = fmul double %119, %radius
    %128 = fadd double %127, %123
    store double %128, double* %110, align 8, !tbaa !1
    %129 = fmul double %96, %radius
    %sunkaddr = ptrtoint double* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    %130 = load double, double* %sunkaddr4, align 8, !tbaa !1
    %131 = fadd double %129, %130
    %sunkaddr5 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr6 = add i32 %sunkaddr5, 8
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %131, double* %sunkaddr7, align 8, !tbaa !1
    %132 = fmul double %84, %radius
    %133 = fadd double %132, %130
    %sunkaddr8 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %133, double* %sunkaddr10, align 8, !tbaa !1
    %134 = fmul double %120, %radius
    %135 = fadd double %134, %130
    %sunkaddr11 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr12 = add i32 %sunkaddr11, 8
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %135, double* %sunkaddr13, align 8, !tbaa !1
    %136 = fmul double %97, %radius
    %sunkaddr14 = ptrtoint double* %p0 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 16
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    %137 = load double, double* %sunkaddr16, align 8, !tbaa !1
    %138 = fadd double %136, %137
    %sunkaddr17 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %138, double* %sunkaddr19, align 8, !tbaa !1
    %139 = fmul double %85, %radius
    %140 = fadd double %139, %137
    %sunkaddr20 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr21 = add i32 %sunkaddr20, 16
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %140, double* %sunkaddr22, align 8, !tbaa !1
    %141 = fmul double %121, %radius
    %142 = fadd double %141, %137
    %sunkaddr23 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %142, double* %sunkaddr25, align 8, !tbaa !1
    call void @diff3(double* %112, double* %111, double* %109) #4
    call void @diff3(double* %111, double* %110, double* %108) #4
    call void @crossprod(double* %109, double* %108, double* %108) #4
    call void @normalize(double* %108) #4
    call void @m_xformpt(double* %112, double* %112, double* %108, double* %107) #4
    call void @m_xformptonly(double* %111, double* %111) #4
    call void @m_xformptonly(double* %110, double* %110) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %107) #4
    call void @glVertex3dv(double* %112) #4
    call void @glVertex3dv(double* %111) #4
    call void @glVertex3dv(double* %110) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %113) #4
    call void @llvm.lifetime.end(i64 24, i8* %114) #4
    call void @llvm.lifetime.end(i64 24, i8* %115) #4
    call void @llvm.lifetime.end(i64 24, i8* %116) #4
    call void @llvm.lifetime.end(i64 24, i8* %117) #4
    call void @llvm.lifetime.end(i64 24, i8* %118) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  declare void @diff3(double*, double*, double*) #3
  
  declare void @crossprod(double*, double*, double*) #3
  
  declare void @normalize(double*) #3
  
  declare void @m_xformptonly(double*, double*) #3
  
  declare void @m_pushmatrix() #3
  
  declare void @m_translate(double, double, double) #3
  
  declare void @m_scale(double, double, double) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @pentagon(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %shadeType) unnamed_addr #0 {
    %n0 = alloca [3 x double], align 8
    %d1 = alloca [3 x double], align 8
    %d2 = alloca [3 x double], align 8
    %d3 = alloca [3 x double], align 8
    %d4 = alloca [3 x double], align 8
    %d5 = alloca [3 x double], align 8
    %nout = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %d1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %d2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %d3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %d4 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %d5 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %nout to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %a, i32 0
    %9 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %b, i32 0
    %10 = bitcast [3 x double]* %d1 to double*
    call void @diff3(double* %8, double* %9, double* %10) #4
    %11 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %c, i32 0
    %12 = bitcast [3 x double]* %d2 to double*
    call void @diff3(double* %9, double* %11, double* %12) #4
    %13 = bitcast [3 x double]* %n0 to double*
    call void @crossprod(double* %10, double* %12, double* %13) #4
    call void @normalize(double* %13) #4
    %14 = bitcast [3 x double]* %nout to double*
    call void @m_xformpt(double* %8, double* %10, double* %13, double* %14) #4
    call void @m_xformptonly(double* %9, double* %12) #4
    %15 = bitcast [3 x double]* %d3 to double*
    call void @m_xformptonly(double* %11, double* %15) #4
    %16 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %d, i32 0
    %17 = bitcast [3 x double]* %d4 to double*
    call void @m_xformptonly(double* %16, double* %17) #4
    %18 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %e, i32 0
    %19 = bitcast [3 x double]* %d5 to double*
    call void @m_xformptonly(double* %18, double* %19) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %14) #4
    call void @glVertex3dv(double* %10) #4
    call void @glVertex3dv(double* %12) #4
    call void @glVertex3dv(double* %15) #4
    call void @glVertex3dv(double* %17) #4
    call void @glVertex3dv(double* %19) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %7) #4
    call void @llvm.lifetime.end(i64 24, i8* %6) #4
    call void @llvm.lifetime.end(i64 24, i8* %5) #4
    call void @llvm.lifetime.end(i64 24, i8* %4) #4
    call void @llvm.lifetime.end(i64 24, i8* %3) #4
    call void @llvm.lifetime.end(i64 24, i8* %2) #4
    call void @llvm.lifetime.end(i64 24, i8* %1) #4
    ret void
  }
  
  declare void @m_popmatrix() #3
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { norecurse nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { nounwind }
  attributes #5 = { nounwind readnone }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !2, i64 0}
  !2 = !{!"double", !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"any pointer", !3, i64 0}
  !7 = !{!8, !6, i64 12}
  !8 = !{!"model", !9, i64 0, !6, i64 4, !9, i64 8, !6, i64 12}
  !9 = !{!"int", !3, i64 0}
  !10 = !{!8, !9, i64 0}
  !11 = !{!8, !9, i64 8}
  !12 = !{!8, !6, i64 4}
  !13 = !{!9, !9, i64 0}

...
---
name:            auxWireCube
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: afgr64 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: afgr64 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: afgr64 }
  - { id: 29, class: afgr64 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: afgr64 }
  - { id: 32, class: afgr64 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
liveins:         
  - { reg: '%d6', virtual-reg: '%5' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
constants:       
  - id:              0
    value:           double -5.000000e-01
    alignment:       8
  - id:              1
    value:           double 5.000000e-01
    alignment:       8
body:             |
  bb.0 (%ir-block.0, freq 40):
    successors: %bb.4.findList.exit.thread(37), %bb.7(62)
    liveins: %d6, %t9, %v0
  
    %6 = ADDu %v0, %t9
    %5 = COPY %d6
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %7 = LW %6, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %8 = ADDiu %zero, 8
    %a0 = COPY %8
    %gp = COPY %6
    %t9 = COPY %7
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %9 = COPY %v0
    SDC1 %5, %9, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.2, !tbaa !1)
    %10 = LW %6, target-flags(<unknown>) @lists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %11 = ADDiu %10, target-flags(<unknown>) @lists
    %1 = LW %11, 4, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from `%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1)`, !tbaa !5)
    %0 = COPY %9
    BEQ %1, %zero, %bb.4.findList.exit.thread, implicit-def %at
  
  bb.7 (freq 25):
    successors: %bb.1.compareParams.exit.i(100)
  
  
  bb.1.compareParams.exit.i (freq 409):
    successors: %bb.2(96), %bb.3.findList.exit(3)
  
    %2 = PHI %1, %bb.7, %3, %bb.2
    %12 = LW %2, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.4, !tbaa !7)
    %13 = LDC1 killed %12, 0, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 8 from %ir.5, !tbaa !1)
    FCMP_D32 killed %13, %5, 2, implicit-def %fcc0
    BC1T %fcc0, %bb.3.findList.exit, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.7, freq 396):
    successors: %bb.4.findList.exit.thread(3), %bb.1.compareParams.exit.i(96)
  
    %3 = LW %2, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.8, !tbaa !5)
    BEQ %3, %zero, %bb.4.findList.exit.thread, implicit-def dead %at
    B %bb.1.compareParams.exit.i, implicit-def dead %at
  
  bb.3.findList.exit (freq 12):
    successors: %bb.4.findList.exit.thread(37), %bb.5(62)
  
    %4 = LW %2, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.10, !tbaa !10)
    BNE %4, %zero, %bb.5, implicit-def dead %at
    B %bb.4.findList.exit.thread, implicit-def dead %at
  
  bb.4.findList.exit.thread (freq 32):
    successors: %bb.6(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %16 = LW %6, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %17 = ADDiu %zero, 16
    %a0 = COPY %17
    %t9 = COPY %16
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %18 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %19 = LW %6, target-flags(<unknown>) @glGenLists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glGenLists)
    %20 = ADDiu %zero, 1
    %a0 = COPY %20
    %gp = COPY %6
    %t9 = COPY %19
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %21 = COPY %v0
    %24 = ADDiu %zero, 4865
    SW %21, %18, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.15, !tbaa !10)
    SW %20, %18, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.17, !tbaa !11)
    SW %0, %18, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.19, !tbaa !7)
    %25 = LW %11, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*)`, !tbaa !5)
    SW killed %25, %18, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.22, !tbaa !12)
    SW %18, %11, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**)`, !tbaa !5)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %26 = LW %6, target-flags(<unknown>) @glNewList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glNewList)
    %a0 = COPY %21
    %a1 = COPY %24
    %gp = COPY %6
    %t9 = COPY %26
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %27 = LW %6, target-flags(<unknown>) %const.0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %28 = LDC1 killed %27, target-flags(<unknown>) %const.0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %29 = FMUL_D32 %5, killed %28
    %30 = LW %6, target-flags(<unknown>) %const.1, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %31 = LDC1 killed %30, target-flags(<unknown>) %const.1, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %32 = FMUL_D32 %5, killed %31
    %33 = LW %6, target-flags(<unknown>) @drawbox, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %34 = ADDiu killed %33, target-flags(<unknown>) @drawbox
    %35 = ADDiu %zero, 2
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %d0 = COPY %29
    %d1 = COPY %32
    %d2 = COPY %29
    %d3 = COPY %32
    %d4 = COPY %29
    %d5 = COPY %32
    %a0 = COPY %35
    %t9 = COPY %34
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d0, implicit %d1, implicit %d2, implicit %d3, implicit %d4, implicit %d5, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %36 = LW %6, target-flags(<unknown>) @glEndList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glEndList)
    %gp = COPY %6
    %t9 = COPY %36
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.6, implicit-def dead %at
  
  bb.5 (%ir-block.25, freq 7):
    successors: %bb.6(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %14 = LW %6, target-flags(<unknown>) @glCallList, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @glCallList)
    %a0 = COPY %4
    %gp = COPY %6
    %t9 = COPY %14
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %15 = LW %6, target-flags(<unknown>) @free, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @free)
    %a0 = COPY %0
    %gp = COPY %6
    %t9 = COPY %15
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.6 (%ir-block.26, freq 40):
    liveouts:
  
    RetRA

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/mesa/mesa.shapes.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.model = type { i32, %struct.model*, i32, double* }
  %struct.GLUquadricObj = type opaque
  
  @auxWireIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @lists = internal unnamed_addr global [25 x %struct.model*] zeroinitializer, align 4
  @drawbox.n = internal global [6 x [3 x double]] [[3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @drawbox.faces = internal unnamed_addr constant [6 x [4 x i32]] [[4 x i32] [i32 0, i32 1, i32 2, i32 3], [4 x i32] [i32 3, i32 2, i32 6, i32 7], [4 x i32] [i32 7, i32 6, i32 5, i32 4], [4 x i32] [i32 4, i32 5, i32 1, i32 0], [4 x i32] [i32 5, i32 6, i32 2, i32 1], [4 x i32] [i32 7, i32 4, i32 0, i32 3]], align 4
  @iindex = internal unnamed_addr constant [20 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 1], [3 x i32] [i32 0, i32 9, i32 4], [3 x i32] [i32 9, i32 5, i32 4], [3 x i32] [i32 4, i32 5, i32 8], [3 x i32] [i32 4, i32 8, i32 1], [3 x i32] [i32 8, i32 10, i32 1], [3 x i32] [i32 8, i32 3, i32 10], [3 x i32] [i32 5, i32 3, i32 8], [3 x i32] [i32 5, i32 2, i32 3], [3 x i32] [i32 2, i32 7, i32 3], [3 x i32] [i32 7, i32 10, i32 3], [3 x i32] [i32 7, i32 6, i32 10], [3 x i32] [i32 7, i32 11, i32 6], [3 x i32] [i32 11, i32 0, i32 6], [3 x i32] [i32 0, i32 1, i32 6], [3 x i32] [i32 6, i32 1, i32 10], [3 x i32] [i32 9, i32 0, i32 11], [3 x i32] [i32 9, i32 11, i32 2], [3 x i32] [i32 9, i32 2, i32 5], [3 x i32] [i32 7, i32 2, i32 11]], align 4
  @idata = internal global [12 x [3 x double]] [[3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00]], align 8
  @ondex = internal unnamed_addr constant [8 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 2], [3 x i32] [i32 1, i32 2, i32 4], [3 x i32] [i32 0, i32 3, i32 4], [3 x i32] [i32 1, i32 4, i32 3], [3 x i32] [i32 0, i32 2, i32 5], [3 x i32] [i32 1, i32 5, i32 2], [3 x i32] [i32 0, i32 5, i32 3], [3 x i32] [i32 1, i32 3, i32 5]], align 4
  @odata = internal global [6 x [3 x double]] [[3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @tndex = internal unnamed_addr constant [4 x [3 x i32]] [[3 x i32] [i32 0, i32 1, i32 3], [3 x i32] [i32 2, i32 1, i32 0], [3 x i32] [i32 3, i32 2, i32 0], [3 x i32] [i32 1, i32 2, i32 3]], align 4
  @tdata = internal global [4 x [3 x double]] [[3 x double] [double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA], [3 x double] [double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA]], align 8
  @dodecahedron.inited = internal unnamed_addr global i1 false
  @dodec = internal global [20 x [3 x double]] zeroinitializer, align 8
  
  ; Function Attrs: nounwind
  define void @auxWireSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast ([25 x %struct.model*]* @lists to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast ([25 x %struct.model*]* @lists to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100011) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare noalias i8* @malloc(i32 signext) #0
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @findList(i32 signext %lindex, double* nocapture readonly %paramArray, i32 signext %size) #2 {
    %1 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %endList.02 = load %struct.model*, %struct.model** %1, align 4, !tbaa !5
    %2 = icmp eq %struct.model* %endList.02, null
    br i1 %2, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0
    br label %3
  
  ; <label>:3                                       ; preds = %18, %.lr.ph
    %endList.03 = phi %struct.model* [ %endList.02, %.lr.ph ], [ %endList.0, %18 ]
    %4 = icmp sgt i32 %size, 0
    br i1 %4, label %.lr.ph.i.preheader, label %compareParams.exit.thread
  
  .lr.ph.i.preheader:                               ; preds = %3
    %5 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 3
    %6 = load double*, double** %5, align 4, !tbaa !7
    br label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %matches.05.i = phi i32 [ %matches.1.i, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %.03.i = phi double* [ %7, %.lr.ph.i ], [ %6, %.lr.ph.i.preheader ]
    %.012.i = phi double* [ %9, %.lr.ph.i ], [ %paramArray, %.lr.ph.i.preheader ]
    %7 = getelementptr inbounds double, double* %.03.i, i32 1
    %8 = load double, double* %.03.i, align 8, !tbaa !1
    %9 = getelementptr inbounds double, double* %.012.i, i32 1
    %10 = load double, double* %.012.i, align 8, !tbaa !1
    %11 = fcmp une double %8, %10
    %matches.1.i = select i1 %11, i32 0, i32 %matches.05.i
    %12 = icmp slt i32 %lsr.iv, %size
    %13 = icmp ne i32 %matches.1.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %14, label %.lr.ph.i, label %compareParams.exit
  
  compareParams.exit:                               ; preds = %.lr.ph.i
    %15 = icmp eq i32 %matches.1.i, 0
    br i1 %15, label %18, label %compareParams.exit.thread
  
  compareParams.exit.thread:                        ; preds = %compareParams.exit, %3
    %16 = bitcast %struct.model* %endList.03 to i32*
    %17 = load i32, i32* %16, align 4, !tbaa !10
    br label %.loopexit
  
  ; <label>:18                                      ; preds = %compareParams.exit
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 1
    %endList.0 = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0, null
    br i1 %20, label %.loopexit, label %3
  
  .loopexit:                                        ; preds = %18, %compareParams.exit.thread, %0
    %.0 = phi i32 [ %17, %compareParams.exit.thread ], [ 0, %0 ], [ 0, %18 ]
    ret i32 %.0
  }
  
  declare void @glNewList(i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @makeModelPtr(i32 signext %lindex, double* %sizeArray, i32 signext %count) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = tail call i32 @glGenLists(i32 signext 1) #4
    %3 = bitcast i8* %1 to i32*
    store i32 %2, i32* %3, align 4, !tbaa !10
    %4 = getelementptr inbounds i8, i8* %1, i32 8
    %5 = bitcast i8* %4 to i32*
    store i32 %count, i32* %5, align 4, !tbaa !11
    %6 = getelementptr inbounds i8, i8* %1, i32 12
    %7 = bitcast i8* %6 to double**
    store double* %sizeArray, double** %7, align 4, !tbaa !7
    %8 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %9 = bitcast %struct.model** %8 to i32*
    %10 = load i32, i32* %9, align 4, !tbaa !5
    %11 = getelementptr inbounds i8, i8* %1, i32 4
    %12 = bitcast i8* %11 to i32*
    store i32 %10, i32* %12, align 4, !tbaa !12
    %13 = bitcast %struct.model** %8 to i8**
    store i8* %1, i8** %13, align 4, !tbaa !5
    ret i32 %2
  }
  
  declare %struct.GLUquadricObj* @gluNewQuadric() #3
  
  declare void @gluQuadricDrawStyle(%struct.GLUquadricObj*, i32 signext) #3
  
  declare void @gluSphere(%struct.GLUquadricObj*, double, i32 signext, i32 signext) #3
  
  declare void @glEndList() #3
  
  declare void @glCallList(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  define void @auxSolidSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %23, i32 signext 100000) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  declare void @gluQuadricNormals(%struct.GLUquadricObj*, i32 signext) #3
  
  ; Function Attrs: nounwind
  define void @auxWireCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 2)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawbox(double %x0, double %x1, double %y0, double %y1, double %z0, double %z1, i32 signext %type) unnamed_addr #0 {
    %v = alloca [8 x [3 x double]], align 8
    %1 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.start(i64 192, i8* %1) #4
    %2 = fcmp ogt double %x0, %x1
    %.05 = select i1 %2, double %x0, double %x1
    %.0 = select i1 %2, double %x1, double %x0
    %3 = fcmp ogt double %y0, %y1
    %.04 = select i1 %3, double %y1, double %y0
    %.03 = select i1 %3, double %y0, double %y1
    %4 = fcmp ogt double %z0, %z1
    %.02 = select i1 %4, double %z1, double %z0
    %.01 = select i1 %4, double %z0, double %z1
    %5 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 0
    store double %.0, double* %5, align 8, !tbaa !1
    %6 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 0
    store double %.0, double* %6, align 8, !tbaa !1
    %7 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 0
    store double %.0, double* %7, align 8, !tbaa !1
    %8 = bitcast [8 x [3 x double]]* %v to double*
    store double %.0, double* %8, align 8, !tbaa !1
    %9 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 0
    store double %.05, double* %9, align 8, !tbaa !1
    %10 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 0
    store double %.05, double* %10, align 8, !tbaa !1
    %11 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 0
    store double %.05, double* %11, align 8, !tbaa !1
    %12 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 0
    store double %.05, double* %12, align 8, !tbaa !1
    %13 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 1
    store double %.04, double* %13, align 8, !tbaa !1
    %14 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 1
    store double %.04, double* %14, align 8, !tbaa !1
    %15 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 1
    store double %.04, double* %15, align 8, !tbaa !1
    %16 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 1
    store double %.04, double* %16, align 8, !tbaa !1
    %17 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 1
    store double %.03, double* %17, align 8, !tbaa !1
    %18 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 1
    store double %.03, double* %18, align 8, !tbaa !1
    %19 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 1
    store double %.03, double* %19, align 8, !tbaa !1
    %20 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 1
    store double %.03, double* %20, align 8, !tbaa !1
    %21 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 2
    store double %.02, double* %21, align 8, !tbaa !1
    %22 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 2
    store double %.02, double* %22, align 8, !tbaa !1
    %23 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 2
    store double %.02, double* %23, align 8, !tbaa !1
    %24 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 2
    store double %.02, double* %24, align 8, !tbaa !1
    %25 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 2
    store double %.01, double* %25, align 8, !tbaa !1
    %26 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 2
    store double %.01, double* %26, align 8, !tbaa !1
    %27 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 2
    store double %.01, double* %27, align 8, !tbaa !1
    %28 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 2
    store double %.01, double* %28, align 8, !tbaa !1
    br label %29
  
  ; <label>:29                                      ; preds = %29, %0
    %lsr.iv1 = phi [6 x [4 x i32]]* [ %38, %29 ], [ bitcast (i32* getelementptr inbounds ([6 x [4 x i32]], [6 x [4 x i32]]* @drawbox.faces, i32 0, i32 0, i32 2) to [6 x [4 x i32]]*), %0 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %29 ], [ 0, %0 ]
    %lsr.iv12 = bitcast [6 x [4 x i32]]* %lsr.iv1 to i32*
    call void @glBegin(i32 signext %type) #4
    %uglygep11 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep1112 = bitcast i8* %uglygep11 to double*
    call void @glNormal3dv(double* %uglygep1112) #4
    %scevgep5 = getelementptr i32, i32* %lsr.iv12, i32 -2
    %30 = load i32, i32* %scevgep5, align 4, !tbaa !13
    %31 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %30, i32 0
    call void @glVertex3dv(double* %31) #4
    %uglygep9 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep910 = bitcast i8* %uglygep9 to double*
    call void @glNormal3dv(double* %uglygep910) #4
    %scevgep4 = getelementptr i32, i32* %lsr.iv12, i32 -1
    %32 = load i32, i32* %scevgep4, align 4, !tbaa !13
    %33 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %32, i32 0
    call void @glVertex3dv(double* %33) #4
    %uglygep7 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep78 = bitcast i8* %uglygep7 to double*
    call void @glNormal3dv(double* %uglygep78) #4
    %34 = load i32, i32* %lsr.iv12, align 4, !tbaa !13
    %35 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %34, i32 0
    call void @glVertex3dv(double* %35) #4
    %uglygep = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep6 = bitcast i8* %uglygep to double*
    call void @glNormal3dv(double* %uglygep6) #4
    %scevgep3 = getelementptr i32, i32* %lsr.iv12, i32 1
    %36 = load i32, i32* %scevgep3, align 4, !tbaa !13
    %37 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %36, i32 0
    call void @glVertex3dv(double* %37) #4
    call void @glEnd() #4
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 24
    %scevgep = getelementptr [6 x [4 x i32]], [6 x [4 x i32]]* %lsr.iv1, i32 0, i32 1, i32 0
    %38 = bitcast i32* %scevgep to [6 x [4 x i32]]*
    %exitcond = icmp eq i32 %lsr.iv.next, 144
    br i1 %exitcond, label %39, label %29
  
  ; <label>:39                                      ; preds = %29
    %40 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.end(i64 192, i8* %40) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 7)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 2)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 7)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 5, i32 signext 10, i32 signext 2)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @doughnut(double %r, double %R, i32 signext %nsides, i32 signext %rings, i32 signext %type) unnamed_addr #0 {
    %p0 = alloca [3 x double], align 8
    %p1 = alloca [3 x double], align 8
    %p2 = alloca [3 x double], align 8
    %p3 = alloca [3 x double], align 8
    %n0 = alloca [3 x double], align 8
    %n1 = alloca [3 x double], align 8
    %n2 = alloca [3 x double], align 8
    %n3 = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %p1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %p2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %p3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %n1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %n2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = bitcast [3 x double]* %n3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %8) #4
    %9 = icmp sgt i32 %rings, 0
    br i1 %9, label %.lr.ph3, label %._crit_edge
  
  .lr.ph3:                                          ; preds = %0
    %10 = sitofp i32 %rings to double
    %11 = sitofp i32 %nsides to double
    br label %12
  
  .loopexit:                                        ; preds = %.lr.ph, %12
    %exitcond4 = icmp eq i32 %17, %rings
    br i1 %exitcond4, label %._crit_edge, label %12
  
  ; <label>:12                                      ; preds = %.loopexit, %.lr.ph3
    %IV.S.1 = phi double [ 0.000000e+00, %.lr.ph3 ], [ %IV.S.next.2, %.loopexit ]
    %i.02 = phi i32 [ 0, %.lr.ph3 ], [ %17, %.loopexit ]
    %13 = icmp sgt i32 %nsides, 0
    %14 = fmul double %IV.S.1, 2.000000e+00
    %15 = fmul double %14, 0x400921FB54442C46
    %16 = fdiv double %15, %10
    %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
    %17 = add nuw nsw i32 %i.02, 1
    %18 = sitofp i32 %17 to double
    %19 = fmul double %18, 2.000000e+00
    %20 = fmul double %19, 0x400921FB54442C46
    %21 = fdiv double %20, %10
    br i1 %13, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %12, %.lr.ph
    %IV.S. = phi double [ %IV.S.next., %.lr.ph ], [ 0.000000e+00, %12 ]
    %j.01 = phi i32 [ %33, %.lr.ph ], [ 0, %12 ]
    %22 = bitcast [3 x double]* %n3 to double*
    %23 = bitcast [3 x double]* %n2 to double*
    %24 = bitcast [3 x double]* %n1 to double*
    %25 = bitcast [3 x double]* %n0 to double*
    %26 = bitcast [3 x double]* %p3 to double*
    %27 = bitcast [3 x double]* %p2 to double*
    %28 = bitcast [3 x double]* %p1 to double*
    %29 = bitcast [3 x double]* %p0 to double*
    %30 = fmul double %IV.S., 2.000000e+00
    %31 = fmul double %30, 0x400921FB54442C46
    %32 = fdiv double %31, %11
    %IV.S.next. = fadd double %IV.S., 1.000000e+00
    %33 = add nuw nsw i32 %j.01, 1
    %34 = sitofp i32 %33 to double
    %35 = fmul double %34, 2.000000e+00
    %36 = fmul double %35, 0x400921FB54442C46
    %37 = fdiv double %36, %11
    %38 = call double @cos(double %16) #4
    %39 = call double @cos(double %32) #4
    %40 = fmul double %39, %r
    %41 = fadd double %40, %R
    %42 = fmul double %38, %41
    store double %42, double* %29, align 8, !tbaa !1
    %43 = call double @sin(double %16) #4
    %44 = call double @cos(double %32) #4
    %45 = fmul double %44, %r
    %46 = fadd double %45, %R
    %47 = fmul double %43, %46
    %48 = fsub double -0.000000e+00, %47
    %sunkaddr = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    store double %48, double* %sunkaddr4, align 8, !tbaa !1
    %49 = call double @sin(double %32) #4
    %50 = fmul double %49, %r
    %sunkaddr5 = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr6 = add i32 %sunkaddr5, 16
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %50, double* %sunkaddr7, align 8, !tbaa !1
    %51 = call double @cos(double %21) #4
    %52 = call double @cos(double %32) #4
    %53 = fmul double %52, %r
    %54 = fadd double %53, %R
    %55 = fmul double %51, %54
    store double %55, double* %28, align 8, !tbaa !1
    %56 = call double @sin(double %21) #4
    %57 = call double @cos(double %32) #4
    %58 = fmul double %57, %r
    %59 = fadd double %58, %R
    %60 = fmul double %56, %59
    %61 = fsub double -0.000000e+00, %60
    %sunkaddr8 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %61, double* %sunkaddr10, align 8, !tbaa !1
    %62 = call double @sin(double %32) #4
    %63 = fmul double %62, %r
    %sunkaddr11 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr12 = add i32 %sunkaddr11, 16
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %63, double* %sunkaddr13, align 8, !tbaa !1
    %64 = call double @cos(double %21) #4
    %65 = call double @cos(double %37) #4
    %66 = fmul double %65, %r
    %67 = fadd double %66, %R
    %68 = fmul double %64, %67
    store double %68, double* %27, align 8, !tbaa !1
    %69 = call double @sin(double %21) #4
    %70 = call double @cos(double %37) #4
    %71 = fmul double %70, %r
    %72 = fadd double %71, %R
    %73 = fmul double %69, %72
    %74 = fsub double -0.000000e+00, %73
    %sunkaddr14 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 8
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    store double %74, double* %sunkaddr16, align 8, !tbaa !1
    %75 = call double @sin(double %37) #4
    %76 = fmul double %75, %r
    %sunkaddr17 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %76, double* %sunkaddr19, align 8, !tbaa !1
    %77 = call double @cos(double %16) #4
    %78 = call double @cos(double %37) #4
    %79 = fmul double %78, %r
    %80 = fadd double %79, %R
    %81 = fmul double %77, %80
    store double %81, double* %26, align 8, !tbaa !1
    %82 = call double @sin(double %16) #4
    %83 = call double @cos(double %37) #4
    %84 = fmul double %83, %r
    %85 = fadd double %84, %R
    %86 = fmul double %82, %85
    %87 = fsub double -0.000000e+00, %86
    %sunkaddr20 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr21 = add i32 %sunkaddr20, 8
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %87, double* %sunkaddr22, align 8, !tbaa !1
    %88 = call double @sin(double %37) #4
    %89 = fmul double %88, %r
    %sunkaddr23 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %89, double* %sunkaddr25, align 8, !tbaa !1
    %90 = call double @cos(double %16) #4
    %91 = call double @cos(double %32) #4
    %92 = fmul double %90, %91
    store double %92, double* %25, align 8, !tbaa !1
    %93 = call double @sin(double %16) #4
    %94 = call double @cos(double %32) #4
    %95 = fmul double %93, %94
    %96 = fsub double -0.000000e+00, %95
    %sunkaddr26 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr27 = add i32 %sunkaddr26, 8
    %sunkaddr28 = inttoptr i32 %sunkaddr27 to double*
    store double %96, double* %sunkaddr28, align 8, !tbaa !1
    %97 = call double @sin(double %32) #4
    %sunkaddr29 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr30 = add i32 %sunkaddr29, 16
    %sunkaddr31 = inttoptr i32 %sunkaddr30 to double*
    store double %97, double* %sunkaddr31, align 8, !tbaa !1
    %98 = call double @cos(double %21) #4
    %99 = call double @cos(double %32) #4
    %100 = fmul double %98, %99
    store double %100, double* %24, align 8, !tbaa !1
    %101 = call double @sin(double %21) #4
    %102 = call double @cos(double %32) #4
    %103 = fmul double %101, %102
    %104 = fsub double -0.000000e+00, %103
    %sunkaddr32 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr33 = add i32 %sunkaddr32, 8
    %sunkaddr34 = inttoptr i32 %sunkaddr33 to double*
    store double %104, double* %sunkaddr34, align 8, !tbaa !1
    %105 = call double @sin(double %32) #4
    %sunkaddr35 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr36 = add i32 %sunkaddr35, 16
    %sunkaddr37 = inttoptr i32 %sunkaddr36 to double*
    store double %105, double* %sunkaddr37, align 8, !tbaa !1
    %106 = call double @cos(double %21) #4
    %107 = call double @cos(double %37) #4
    %108 = fmul double %106, %107
    store double %108, double* %23, align 8, !tbaa !1
    %109 = call double @sin(double %21) #4
    %110 = call double @cos(double %37) #4
    %111 = fmul double %109, %110
    %112 = fsub double -0.000000e+00, %111
    %sunkaddr38 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr39 = add i32 %sunkaddr38, 8
    %sunkaddr40 = inttoptr i32 %sunkaddr39 to double*
    store double %112, double* %sunkaddr40, align 8, !tbaa !1
    %113 = call double @sin(double %37) #4
    %sunkaddr41 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr42 = add i32 %sunkaddr41, 16
    %sunkaddr43 = inttoptr i32 %sunkaddr42 to double*
    store double %113, double* %sunkaddr43, align 8, !tbaa !1
    %114 = call double @cos(double %16) #4
    %115 = call double @cos(double %37) #4
    %116 = fmul double %114, %115
    store double %116, double* %22, align 8, !tbaa !1
    %117 = call double @sin(double %16) #4
    %118 = call double @cos(double %37) #4
    %119 = fmul double %117, %118
    %120 = fsub double -0.000000e+00, %119
    %sunkaddr44 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr45 = add i32 %sunkaddr44, 8
    %sunkaddr46 = inttoptr i32 %sunkaddr45 to double*
    store double %120, double* %sunkaddr46, align 8, !tbaa !1
    %121 = call double @sin(double %37) #4
    %sunkaddr47 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr48 = add i32 %sunkaddr47, 16
    %sunkaddr49 = inttoptr i32 %sunkaddr48 to double*
    store double %121, double* %sunkaddr49, align 8, !tbaa !1
    call void @m_xformpt(double* %29, double* %29, double* %25, double* %25) #4
    call void @m_xformpt(double* %28, double* %28, double* %24, double* %24) #4
    call void @m_xformpt(double* %27, double* %27, double* %23, double* %23) #4
    call void @m_xformpt(double* %26, double* %26, double* %22, double* %22) #4
    call void @glBegin(i32 signext %type) #4
    call void @glNormal3dv(double* %22) #4
    call void @glVertex3dv(double* %26) #4
    call void @glNormal3dv(double* %23) #4
    call void @glVertex3dv(double* %27) #4
    call void @glNormal3dv(double* %24) #4
    call void @glVertex3dv(double* %28) #4
    call void @glNormal3dv(double* %25) #4
    call void @glVertex3dv(double* %29) #4
    call void @glEnd() #4
    %exitcond = icmp eq i32 %nsides, %33
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.loopexit, %0
    %122 = bitcast [3 x double]* %n3 to i8*
    %123 = bitcast [3 x double]* %n2 to i8*
    %124 = bitcast [3 x double]* %n1 to i8*
    %125 = bitcast [3 x double]* %n0 to i8*
    %126 = bitcast [3 x double]* %p3 to i8*
    %127 = bitcast [3 x double]* %p2 to i8*
    %128 = bitcast [3 x double]* %p1 to i8*
    %129 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.end(i64 24, i8* %122) #4
    call void @llvm.lifetime.end(i64 24, i8* %123) #4
    call void @llvm.lifetime.end(i64 24, i8* %124) #4
    call void @llvm.lifetime.end(i64 24, i8* %125) #4
    call void @llvm.lifetime.end(i64 24, i8* %126) #4
    call void @llvm.lifetime.end(i64 24, i8* %127) #4
    call void @llvm.lifetime.end(i64 24, i8* %128) #4
    call void @llvm.lifetime.end(i64 24, i8* %129) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 8, i32 signext 15, i32 signext 7)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  declare void @glPushMatrix() #3
  
  declare void @glRotatef(float, float, float, float) #3
  
  declare void @glTranslatef(float, float, float) #3
  
  declare void @gluCylinder(%struct.GLUquadricObj*, double, double, double, i32 signext, i32 signext) #3
  
  declare void @glPopMatrix() #3
  
  ; Function Attrs: nounwind
  define void @auxSolidCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @icosahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 8, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 9, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 10, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 11, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 12, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 13, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 14, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 15, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 16, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 17, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 18, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 19, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireOctahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @octahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidOctahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireDodecahedron.center, i32 0, i32 0), double %23, i32 signext 2)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @dodecahedron(double* nocapture readonly %center, double %sc, i32 signext %type) unnamed_addr #0 {
    %.b = load i1, i1* @dodecahedron.inited, align 1
    br i1 %.b, label %2, label %1
  
  ; <label>:1                                       ; preds = %0
    store i1 true, i1* @dodecahedron.inited, align 1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 2), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 2), align 8, !tbaa !1
    br label %2
  
  ; <label>:2                                       ; preds = %1, %0
    tail call void @m_pushmatrix() #4
    %3 = load double, double* %center, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %center, i32 1
    %5 = load double, double* %4, align 8, !tbaa !1
    %6 = getelementptr inbounds double, double* %center, i32 2
    %7 = load double, double* %6, align 8, !tbaa !1
    tail call void @m_translate(double %3, double %5, double %7) #4
    tail call void @m_scale(double %sc, double %sc, double %sc) #4
    tail call fastcc void @pentagon(i32 signext 0, i32 signext 1, i32 signext 9, i32 signext 16, i32 signext 5, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 0, i32 signext 3, i32 signext 18, i32 signext 7, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 7, i32 signext 11, i32 signext 10, i32 signext 9, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 11, i32 signext 7, i32 signext 18, i32 signext 19, i32 signext 6, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 8, i32 signext 17, i32 signext 16, i32 signext 9, i32 signext 10, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 14, i32 signext 15, i32 signext 6, i32 signext 19, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 13, i32 signext 12, i32 signext 4, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 19, i32 signext 18, i32 signext 3, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 3, i32 signext 0, i32 signext 5, i32 signext 12, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 6, i32 signext 15, i32 signext 8, i32 signext 10, i32 signext 11, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 17, i32 signext 8, i32 signext 15, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 12, i32 signext 5, i32 signext 16, i32 signext 17, i32 signext %type)
    tail call void @m_popmatrix() #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidDodecahedron.center, i32 0, i32 0), double %23, i32 signext 6)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @compareParams(double* nocapture readonly %oneArray, double* nocapture readonly %twoArray, i32 signext %size) #2 {
    %1 = icmp sgt i32 %size, 0
    br i1 %1, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ 1, %0 ]
    %matches.05 = phi i32 [ %matches.1, %.lr.ph ], [ 1, %0 ]
    %.03 = phi double* [ %2, %.lr.ph ], [ %oneArray, %0 ]
    %.012 = phi double* [ %4, %.lr.ph ], [ %twoArray, %0 ]
    %2 = getelementptr inbounds double, double* %.03, i32 1
    %3 = load double, double* %.03, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %.012, i32 1
    %5 = load double, double* %.012, align 8, !tbaa !1
    %6 = fcmp une double %3, %5
    %matches.1 = select i1 %6, i32 0, i32 %matches.05
    %7 = icmp slt i32 %lsr.iv, %size
    %8 = icmp ne i32 %matches.1, 0
    %9 = and i1 %7, %8
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    %matches.0.lcssa = phi i32 [ 1, %0 ], [ %matches.1, %.lr.ph ]
    ret i32 %matches.0.lcssa
  }
  
  declare i32 @glGenLists(i32 signext) #3
  
  declare void @glBegin(i32 signext) #3
  
  declare void @glNormal3dv(double*) #3
  
  declare void @glVertex3dv(double*) #3
  
  declare void @glEnd() #3
  
  ; Function Attrs: nounwind
  declare double @cos(double) #0
  
  ; Function Attrs: nounwind
  declare double @sin(double) #0
  
  declare void @m_xformpt(double*, double*, double*, double*) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawtriangle(i32 signext %i, i32 signext %geomType, double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    %p1.i.i = alloca [3 x double], align 8
    %p2.i.i = alloca [3 x double], align 8
    %p3.i.i = alloca [3 x double], align 8
    %q0.i.i = alloca [3 x double], align 8
    %q1.i.i = alloca [3 x double], align 8
    %n11.i.i = alloca [3 x double], align 8
    switch i32 %geomType, label %31 [
      i32 0, label %1
      i32 1, label %11
      i32 2, label %21
    ]
  
  ; <label>:1                                       ; preds = %0
    %2 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 0
    %3 = load i32, i32* %2, align 4, !tbaa !13
    %4 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %3, i32 0
    %5 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 1
    %6 = load i32, i32* %5, align 4, !tbaa !13
    %7 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %6, i32 0
    %8 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 2
    %9 = load i32, i32* %8, align 4, !tbaa !13
    %10 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %9, i32 0
    br label %31
  
  ; <label>:11                                      ; preds = %0
    %12 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 0
    %13 = load i32, i32* %12, align 4, !tbaa !13
    %14 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %13, i32 0
    %15 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 1
    %16 = load i32, i32* %15, align 4, !tbaa !13
    %17 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %16, i32 0
    %18 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 2
    %19 = load i32, i32* %18, align 4, !tbaa !13
    %20 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %19, i32 0
    br label %31
  
  ; <label>:21                                      ; preds = %0
    %22 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 0
    %23 = load i32, i32* %22, align 4, !tbaa !13
    %24 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %23, i32 0
    %25 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 1
    %26 = load i32, i32* %25, align 4, !tbaa !13
    %27 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %26, i32 0
    %28 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 2
    %29 = load i32, i32* %28, align 4, !tbaa !13
    %30 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %29, i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %21, %11, %1, %0
    %x0.0 = phi double* [ undef, %0 ], [ %24, %21 ], [ %14, %11 ], [ %4, %1 ]
    %x1.0 = phi double* [ undef, %0 ], [ %27, %21 ], [ %17, %11 ], [ %7, %1 ]
    %x2.0 = phi double* [ undef, %0 ], [ %30, %21 ], [ %20, %11 ], [ %10, %1 ]
    %32 = load double, double* %x0.0, align 8, !tbaa !1
    %33 = fmul double %32, 0.000000e+00
    %34 = load double, double* %x1.0, align 8, !tbaa !1
    %35 = fmul double %34, 0.000000e+00
    %36 = fadd double %33, %35
    %37 = load double, double* %x2.0, align 8, !tbaa !1
    %38 = fadd double %37, %36
    %39 = fadd double %32, %35
    %40 = fmul double %37, 0.000000e+00
    %41 = fadd double %39, %40
    %42 = fadd double %33, %34
    %43 = fadd double %42, %40
    %44 = getelementptr inbounds double, double* %x0.0, i32 1
    %45 = load double, double* %44, align 8, !tbaa !1
    %46 = fmul double %45, 0.000000e+00
    %47 = getelementptr inbounds double, double* %x1.0, i32 1
    %48 = load double, double* %47, align 8, !tbaa !1
    %49 = fmul double %48, 0.000000e+00
    %50 = fadd double %46, %49
    %51 = getelementptr inbounds double, double* %x2.0, i32 1
    %52 = load double, double* %51, align 8, !tbaa !1
    %53 = fadd double %52, %50
    %54 = fadd double %45, %49
    %55 = fmul double %52, 0.000000e+00
    %56 = fadd double %54, %55
    %57 = fadd double %46, %48
    %58 = fadd double %57, %55
    %59 = getelementptr inbounds double, double* %x0.0, i32 2
    %60 = load double, double* %59, align 8, !tbaa !1
    %61 = fmul double %60, 0.000000e+00
    %62 = getelementptr inbounds double, double* %x1.0, i32 2
    %63 = load double, double* %62, align 8, !tbaa !1
    %64 = fmul double %63, 0.000000e+00
    %65 = fadd double %61, %64
    %66 = getelementptr inbounds double, double* %x2.0, i32 2
    %67 = load double, double* %66, align 8, !tbaa !1
    %68 = fadd double %67, %65
    %69 = fadd double %60, %64
    %70 = fmul double %67, 0.000000e+00
    %71 = fadd double %69, %70
    %72 = fadd double %61, %63
    %73 = fadd double %72, %70
    %74 = fmul double %38, %38
    %75 = fmul double %53, %53
    %76 = fadd double %74, %75
    %77 = fmul double %68, %68
    %78 = fadd double %76, %77
    %79 = tail call double @sqrt(double %78) #5
    %80 = fcmp oeq double %79, %79
    br i1 %80, label %.split, label %call.sqrt
  
  call.sqrt:                                        ; preds = %31
    %81 = tail call double @sqrt(double %78) #4
    br label %.split
  
  .split:                                           ; preds = %31, %call.sqrt
    %82 = phi double [ %79, %31 ], [ %81, %call.sqrt ]
    %83 = fdiv double %38, %82
    %84 = fdiv double %53, %82
    %85 = fdiv double %68, %82
    %86 = fmul double %41, %41
    %87 = fmul double %56, %56
    %88 = fadd double %86, %87
    %89 = fmul double %71, %71
    %90 = fadd double %88, %89
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %.split.split, label %call.sqrt1
  
  call.sqrt1:                                       ; preds = %.split
    %93 = tail call double @sqrt(double %90) #4
    br label %.split.split
  
  .split.split:                                     ; preds = %.split, %call.sqrt1
    %94 = phi double [ %91, %.split ], [ %93, %call.sqrt1 ]
    %95 = fdiv double %41, %94
    %96 = fdiv double %56, %94
    %97 = fdiv double %71, %94
    %98 = fmul double %43, %43
    %99 = fmul double %58, %58
    %100 = fadd double %98, %99
    %101 = fmul double %73, %73
    %102 = fadd double %100, %101
    %103 = tail call double @sqrt(double %102) #5
    %104 = fcmp oeq double %103, %103
    br i1 %104, label %.split.split.split, label %call.sqrt2
  
  call.sqrt2:                                       ; preds = %.split.split
    %105 = tail call double @sqrt(double %102) #4
    br label %.split.split.split
  
  .split.split.split:                               ; preds = %.split.split, %call.sqrt2
    %106 = phi double [ %103, %.split.split ], [ %105, %call.sqrt2 ]
    %107 = bitcast [3 x double]* %n11.i.i to double*
    %108 = bitcast [3 x double]* %q1.i.i to double*
    %109 = bitcast [3 x double]* %q0.i.i to double*
    %110 = bitcast [3 x double]* %p3.i.i to double*
    %111 = bitcast [3 x double]* %p2.i.i to double*
    %112 = bitcast [3 x double]* %p1.i.i to double*
    %113 = bitcast [3 x double]* %n11.i.i to i8*
    %114 = bitcast [3 x double]* %q1.i.i to i8*
    %115 = bitcast [3 x double]* %q0.i.i to i8*
    %116 = bitcast [3 x double]* %p3.i.i to i8*
    %117 = bitcast [3 x double]* %p2.i.i to i8*
    %118 = bitcast [3 x double]* %p1.i.i to i8*
    %119 = fdiv double %43, %106
    %120 = fdiv double %58, %106
    %121 = fdiv double %73, %106
    call void @llvm.lifetime.start(i64 24, i8* %118) #4
    call void @llvm.lifetime.start(i64 24, i8* %117) #4
    call void @llvm.lifetime.start(i64 24, i8* %116) #4
    call void @llvm.lifetime.start(i64 24, i8* %115) #4
    call void @llvm.lifetime.start(i64 24, i8* %114) #4
    call void @llvm.lifetime.start(i64 24, i8* %113) #4
    %122 = fmul double %95, %radius
    %123 = load double, double* %p0, align 8, !tbaa !1
    %124 = fadd double %122, %123
    store double %124, double* %112, align 8, !tbaa !1
    %125 = fmul double %83, %radius
    %126 = fadd double %125, %123
    store double %126, double* %111, align 8, !tbaa !1
    %127 = fmul double %119, %radius
    %128 = fadd double %127, %123
    store double %128, double* %110, align 8, !tbaa !1
    %129 = fmul double %96, %radius
    %sunkaddr = ptrtoint double* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    %130 = load double, double* %sunkaddr4, align 8, !tbaa !1
    %131 = fadd double %129, %130
    %sunkaddr5 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr6 = add i32 %sunkaddr5, 8
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %131, double* %sunkaddr7, align 8, !tbaa !1
    %132 = fmul double %84, %radius
    %133 = fadd double %132, %130
    %sunkaddr8 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %133, double* %sunkaddr10, align 8, !tbaa !1
    %134 = fmul double %120, %radius
    %135 = fadd double %134, %130
    %sunkaddr11 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr12 = add i32 %sunkaddr11, 8
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %135, double* %sunkaddr13, align 8, !tbaa !1
    %136 = fmul double %97, %radius
    %sunkaddr14 = ptrtoint double* %p0 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 16
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    %137 = load double, double* %sunkaddr16, align 8, !tbaa !1
    %138 = fadd double %136, %137
    %sunkaddr17 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %138, double* %sunkaddr19, align 8, !tbaa !1
    %139 = fmul double %85, %radius
    %140 = fadd double %139, %137
    %sunkaddr20 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr21 = add i32 %sunkaddr20, 16
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %140, double* %sunkaddr22, align 8, !tbaa !1
    %141 = fmul double %121, %radius
    %142 = fadd double %141, %137
    %sunkaddr23 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %142, double* %sunkaddr25, align 8, !tbaa !1
    call void @diff3(double* %112, double* %111, double* %109) #4
    call void @diff3(double* %111, double* %110, double* %108) #4
    call void @crossprod(double* %109, double* %108, double* %108) #4
    call void @normalize(double* %108) #4
    call void @m_xformpt(double* %112, double* %112, double* %108, double* %107) #4
    call void @m_xformptonly(double* %111, double* %111) #4
    call void @m_xformptonly(double* %110, double* %110) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %107) #4
    call void @glVertex3dv(double* %112) #4
    call void @glVertex3dv(double* %111) #4
    call void @glVertex3dv(double* %110) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %113) #4
    call void @llvm.lifetime.end(i64 24, i8* %114) #4
    call void @llvm.lifetime.end(i64 24, i8* %115) #4
    call void @llvm.lifetime.end(i64 24, i8* %116) #4
    call void @llvm.lifetime.end(i64 24, i8* %117) #4
    call void @llvm.lifetime.end(i64 24, i8* %118) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  declare void @diff3(double*, double*, double*) #3
  
  declare void @crossprod(double*, double*, double*) #3
  
  declare void @normalize(double*) #3
  
  declare void @m_xformptonly(double*, double*) #3
  
  declare void @m_pushmatrix() #3
  
  declare void @m_translate(double, double, double) #3
  
  declare void @m_scale(double, double, double) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @pentagon(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %shadeType) unnamed_addr #0 {
    %n0 = alloca [3 x double], align 8
    %d1 = alloca [3 x double], align 8
    %d2 = alloca [3 x double], align 8
    %d3 = alloca [3 x double], align 8
    %d4 = alloca [3 x double], align 8
    %d5 = alloca [3 x double], align 8
    %nout = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %d1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %d2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %d3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %d4 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %d5 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %nout to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %a, i32 0
    %9 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %b, i32 0
    %10 = bitcast [3 x double]* %d1 to double*
    call void @diff3(double* %8, double* %9, double* %10) #4
    %11 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %c, i32 0
    %12 = bitcast [3 x double]* %d2 to double*
    call void @diff3(double* %9, double* %11, double* %12) #4
    %13 = bitcast [3 x double]* %n0 to double*
    call void @crossprod(double* %10, double* %12, double* %13) #4
    call void @normalize(double* %13) #4
    %14 = bitcast [3 x double]* %nout to double*
    call void @m_xformpt(double* %8, double* %10, double* %13, double* %14) #4
    call void @m_xformptonly(double* %9, double* %12) #4
    %15 = bitcast [3 x double]* %d3 to double*
    call void @m_xformptonly(double* %11, double* %15) #4
    %16 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %d, i32 0
    %17 = bitcast [3 x double]* %d4 to double*
    call void @m_xformptonly(double* %16, double* %17) #4
    %18 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %e, i32 0
    %19 = bitcast [3 x double]* %d5 to double*
    call void @m_xformptonly(double* %18, double* %19) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %14) #4
    call void @glVertex3dv(double* %10) #4
    call void @glVertex3dv(double* %12) #4
    call void @glVertex3dv(double* %15) #4
    call void @glVertex3dv(double* %17) #4
    call void @glVertex3dv(double* %19) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %7) #4
    call void @llvm.lifetime.end(i64 24, i8* %6) #4
    call void @llvm.lifetime.end(i64 24, i8* %5) #4
    call void @llvm.lifetime.end(i64 24, i8* %4) #4
    call void @llvm.lifetime.end(i64 24, i8* %3) #4
    call void @llvm.lifetime.end(i64 24, i8* %2) #4
    call void @llvm.lifetime.end(i64 24, i8* %1) #4
    ret void
  }
  
  declare void @m_popmatrix() #3
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { norecurse nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { nounwind }
  attributes #5 = { nounwind readnone }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !2, i64 0}
  !2 = !{!"double", !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"any pointer", !3, i64 0}
  !7 = !{!8, !6, i64 12}
  !8 = !{!"model", !9, i64 0, !6, i64 4, !9, i64 8, !6, i64 12}
  !9 = !{!"int", !3, i64 0}
  !10 = !{!8, !9, i64 0}
  !11 = !{!8, !9, i64 8}
  !12 = !{!8, !6, i64 4}
  !13 = !{!9, !9, i64 0}

...
---
name:            drawbox
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: afgr64 }
  - { id: 5, class: afgr64 }
  - { id: 6, class: afgr64 }
  - { id: 7, class: afgr64 }
  - { id: 8, class: afgr64 }
  - { id: 9, class: afgr64 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: afgr64 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: afgr64 }
  - { id: 18, class: afgr64 }
  - { id: 19, class: afgr64 }
  - { id: 20, class: afgr64 }
  - { id: 21, class: afgr64 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
liveins:         
  - { reg: '%d0', virtual-reg: '%4' }
  - { reg: '%d1', virtual-reg: '%5' }
  - { reg: '%d2', virtual-reg: '%6' }
  - { reg: '%d3', virtual-reg: '%7' }
  - { reg: '%d4', virtual-reg: '%8' }
  - { reg: '%d5', virtual-reg: '%9' }
  - { reg: '%a0', virtual-reg: '%10' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    8
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
stack:           
  - { id: 0, name: v, offset: 0, size: 192, alignment: 8 }
body:             |
  bb.0 (%ir-block.0, freq 8):
    successors: %bb.1(100)
    liveins: %d0, %d1, %d2, %d3, %d4, %d5, %a0, %t9, %v0
  
    %13 = ADDu %v0, %t9
    %10 = COPY %a0
    %9 = COPY %d5
    %8 = COPY %d4
    %7 = COPY %d3
    %6 = COPY %d2
    %5 = COPY %d1
    %4 = COPY %d0
    FCMP_D32 %4, %5, 23, implicit-def %fcc0
    %14 = MOVF_D32 %5, %fcc0, %4
    SDC1 %14, %stack.0.v, 72, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.5, !tbaa !1)
    %15 = LW %13, target-flags(<unknown>) @drawbox.faces, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SDC1 %14, %stack.0.v, 48, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.6, !tbaa !1)
    %16 = ADDiu killed %15, target-flags(<unknown>) @drawbox.faces
    SDC1 %14, %stack.0.v, 24, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.7, !tbaa !1)
    %11 = ADDiu killed %16, 8
    FCMP_D32 %8, %9, 23, implicit-def %fcc0
    %17 = MOVF_D32 %8, %fcc0, %9
    %18 = MOVF_D32 %9, %fcc0, %8
    FCMP_D32 %6, %7, 23, implicit-def %fcc0
    %19 = MOVF_D32 %6, %fcc0, %7
    %20 = MOVF_D32 %7, %fcc0, %6
    FCMP_D32 %4, %5, 23, implicit-def %fcc0
    %21 = MOVF_D32 %4, %fcc0, %5
    %12 = ADDiu %zero, 0
    SDC1 %14, %stack.0.v, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.8, !tbaa !1)
    SDC1 %21, %stack.0.v, 168, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.9, !tbaa !1)
    SDC1 %21, %stack.0.v, 144, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.10, !tbaa !1)
    SDC1 %21, %stack.0.v, 120, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.11, !tbaa !1)
    SDC1 %21, %stack.0.v, 96, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.12, !tbaa !1)
    SDC1 %20, %stack.0.v, 128, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.13, !tbaa !1)
    SDC1 %20, %stack.0.v, 104, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.14, !tbaa !1)
    SDC1 %20, %stack.0.v, 32, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.15, !tbaa !1)
    SDC1 %20, %stack.0.v, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.16, !tbaa !1)
    SDC1 %19, %stack.0.v, 176, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.17, !tbaa !1)
    SDC1 %19, %stack.0.v, 152, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.18, !tbaa !1)
    SDC1 %19, %stack.0.v, 80, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.19, !tbaa !1)
    SDC1 %19, %stack.0.v, 56, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.20, !tbaa !1)
    SDC1 %18, %stack.0.v, 184, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.21, !tbaa !1)
    SDC1 %18, %stack.0.v, 112, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.22, !tbaa !1)
    SDC1 %18, %stack.0.v, 88, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.23, !tbaa !1)
    SDC1 %18, %stack.0.v, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.24, !tbaa !1)
    SDC1 %17, %stack.0.v, 160, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.25, !tbaa !1)
    SDC1 %17, %stack.0.v, 136, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.26, !tbaa !1)
    SDC1 %17, %stack.0.v, 64, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.27, !tbaa !1)
    SDC1 %17, %stack.0.v, 40, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.28, !tbaa !1)
    %23 = LW %13, target-flags(<unknown>) @drawbox.n, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %24 = ADDiu %23, target-flags(<unknown>) @drawbox.n
    %27 = LEA_ADDiu %stack.0.v, 0
    %56 = ADDiu %zero, 144
  
  bb.1 (%ir-block.29, freq 255):
    successors: %bb.2(3), %bb.1(96)
  
    %0 = PHI %11, %bb.0, %3, %bb.1
    %1 = PHI %12, %bb.0, %2, %bb.1
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %22 = LW %13, target-flags(<unknown>) @glBegin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glBegin)
    %a0 = COPY %10
    %gp = COPY %13
    %t9 = COPY %22
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %25 = ADDu %24, %1
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %26 = LW %13, target-flags(<unknown>) @glNormal3dv, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @glNormal3dv)
    %a0 = COPY %25
    %gp = COPY %13
    %t9 = COPY %26
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %28 = LW %0, -8, <0x32ee510> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.scevgep5, !tbaa !13)
    %29 = SLL %28, 3
    %30 = SLL %28, 4
    %31 = ADDu killed %30, killed %29
    %32 = ADDu %27, killed %31
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %33 = LW %13, target-flags(<unknown>) @glVertex3dv, <0x3322920> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @glVertex3dv)
    %a0 = COPY %32
    %gp = COPY %13
    %t9 = COPY %33
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %34 = LW %13, target-flags(<unknown>) @glNormal3dv, <0x32f43d0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @glNormal3dv)
    %a0 = COPY %25
    %t9 = COPY %34
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %35 = LW %0, -4, <0x3322770> = !{!"unison-memory-partition", i32 5} :: (load 4 from %ir.scevgep4, !tbaa !13)
    %36 = SLL %35, 3
    %37 = SLL %35, 4
    %38 = ADDu killed %37, killed %36
    %39 = ADDu %27, killed %38
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %40 = LW %13, target-flags(<unknown>) @glVertex3dv, <0x32fb4e0> = !{!"unison-memory-partition", i32 6} :: (load 4 from call-entry @glVertex3dv)
    %a0 = COPY %39
    %t9 = COPY %40
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %41 = LW %13, target-flags(<unknown>) @glNormal3dv, <0x32ca370> = !{!"unison-memory-partition", i32 7} :: (load 4 from call-entry @glNormal3dv)
    %a0 = COPY %25
    %t9 = COPY %41
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %42 = LW %0, 0, <0x331ffa0> = !{!"unison-memory-partition", i32 8} :: (load 4 from %ir.lsr.iv12, !tbaa !13)
    %43 = SLL %42, 3
    %44 = SLL %42, 4
    %45 = ADDu killed %44, killed %43
    %46 = ADDu %27, killed %45
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %47 = LW %13, target-flags(<unknown>) @glVertex3dv, <0x32f3e40> = !{!"unison-memory-partition", i32 9} :: (load 4 from call-entry @glVertex3dv)
    %a0 = COPY %46
    %t9 = COPY %47
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %48 = LW %13, target-flags(<unknown>) @glNormal3dv, <0x32f3f10> = !{!"unison-memory-partition", i32 10} :: (load 4 from call-entry @glNormal3dv)
    %a0 = COPY %25
    %t9 = COPY %48
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %49 = LW %0, 4, <0x32f3fe0> = !{!"unison-memory-partition", i32 11} :: (load 4 from %ir.scevgep3, !tbaa !13)
    %50 = SLL %49, 3
    %51 = SLL %49, 4
    %52 = ADDu killed %51, killed %50
    %53 = ADDu %27, killed %52
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %54 = LW %13, target-flags(<unknown>) @glVertex3dv, <0x32f40b0> = !{!"unison-memory-partition", i32 12} :: (load 4 from call-entry @glVertex3dv)
    %a0 = COPY %53
    %t9 = COPY %54
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %55 = LW %13, target-flags(<unknown>) @glEnd, <0x32f4180> = !{!"unison-memory-partition", i32 13} :: (load 4 from call-entry @glEnd)
    %gp = COPY %13
    %t9 = COPY %55
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %3 = ADDiu %0, 16
    %2 = ADDiu %1, 24
    BNE %2, %56, %bb.1, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.39, freq 8):
    liveouts:
  
    RetRA

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/mesa/mesa.shapes.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.model = type { i32, %struct.model*, i32, double* }
  %struct.GLUquadricObj = type opaque
  
  @auxWireIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @lists = internal unnamed_addr global [25 x %struct.model*] zeroinitializer, align 4
  @drawbox.n = internal global [6 x [3 x double]] [[3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @drawbox.faces = internal unnamed_addr constant [6 x [4 x i32]] [[4 x i32] [i32 0, i32 1, i32 2, i32 3], [4 x i32] [i32 3, i32 2, i32 6, i32 7], [4 x i32] [i32 7, i32 6, i32 5, i32 4], [4 x i32] [i32 4, i32 5, i32 1, i32 0], [4 x i32] [i32 5, i32 6, i32 2, i32 1], [4 x i32] [i32 7, i32 4, i32 0, i32 3]], align 4
  @iindex = internal unnamed_addr constant [20 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 1], [3 x i32] [i32 0, i32 9, i32 4], [3 x i32] [i32 9, i32 5, i32 4], [3 x i32] [i32 4, i32 5, i32 8], [3 x i32] [i32 4, i32 8, i32 1], [3 x i32] [i32 8, i32 10, i32 1], [3 x i32] [i32 8, i32 3, i32 10], [3 x i32] [i32 5, i32 3, i32 8], [3 x i32] [i32 5, i32 2, i32 3], [3 x i32] [i32 2, i32 7, i32 3], [3 x i32] [i32 7, i32 10, i32 3], [3 x i32] [i32 7, i32 6, i32 10], [3 x i32] [i32 7, i32 11, i32 6], [3 x i32] [i32 11, i32 0, i32 6], [3 x i32] [i32 0, i32 1, i32 6], [3 x i32] [i32 6, i32 1, i32 10], [3 x i32] [i32 9, i32 0, i32 11], [3 x i32] [i32 9, i32 11, i32 2], [3 x i32] [i32 9, i32 2, i32 5], [3 x i32] [i32 7, i32 2, i32 11]], align 4
  @idata = internal global [12 x [3 x double]] [[3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00]], align 8
  @ondex = internal unnamed_addr constant [8 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 2], [3 x i32] [i32 1, i32 2, i32 4], [3 x i32] [i32 0, i32 3, i32 4], [3 x i32] [i32 1, i32 4, i32 3], [3 x i32] [i32 0, i32 2, i32 5], [3 x i32] [i32 1, i32 5, i32 2], [3 x i32] [i32 0, i32 5, i32 3], [3 x i32] [i32 1, i32 3, i32 5]], align 4
  @odata = internal global [6 x [3 x double]] [[3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @tndex = internal unnamed_addr constant [4 x [3 x i32]] [[3 x i32] [i32 0, i32 1, i32 3], [3 x i32] [i32 2, i32 1, i32 0], [3 x i32] [i32 3, i32 2, i32 0], [3 x i32] [i32 1, i32 2, i32 3]], align 4
  @tdata = internal global [4 x [3 x double]] [[3 x double] [double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA], [3 x double] [double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA]], align 8
  @dodecahedron.inited = internal unnamed_addr global i1 false
  @dodec = internal global [20 x [3 x double]] zeroinitializer, align 8
  
  ; Function Attrs: nounwind
  define void @auxWireSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast ([25 x %struct.model*]* @lists to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast ([25 x %struct.model*]* @lists to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100011) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare noalias i8* @malloc(i32 signext) #0
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @findList(i32 signext %lindex, double* nocapture readonly %paramArray, i32 signext %size) #2 {
    %1 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %endList.02 = load %struct.model*, %struct.model** %1, align 4, !tbaa !5
    %2 = icmp eq %struct.model* %endList.02, null
    br i1 %2, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0
    br label %3
  
  ; <label>:3                                       ; preds = %18, %.lr.ph
    %endList.03 = phi %struct.model* [ %endList.02, %.lr.ph ], [ %endList.0, %18 ]
    %4 = icmp sgt i32 %size, 0
    br i1 %4, label %.lr.ph.i.preheader, label %compareParams.exit.thread
  
  .lr.ph.i.preheader:                               ; preds = %3
    %5 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 3
    %6 = load double*, double** %5, align 4, !tbaa !7
    br label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %matches.05.i = phi i32 [ %matches.1.i, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %.03.i = phi double* [ %7, %.lr.ph.i ], [ %6, %.lr.ph.i.preheader ]
    %.012.i = phi double* [ %9, %.lr.ph.i ], [ %paramArray, %.lr.ph.i.preheader ]
    %7 = getelementptr inbounds double, double* %.03.i, i32 1
    %8 = load double, double* %.03.i, align 8, !tbaa !1
    %9 = getelementptr inbounds double, double* %.012.i, i32 1
    %10 = load double, double* %.012.i, align 8, !tbaa !1
    %11 = fcmp une double %8, %10
    %matches.1.i = select i1 %11, i32 0, i32 %matches.05.i
    %12 = icmp slt i32 %lsr.iv, %size
    %13 = icmp ne i32 %matches.1.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %14, label %.lr.ph.i, label %compareParams.exit
  
  compareParams.exit:                               ; preds = %.lr.ph.i
    %15 = icmp eq i32 %matches.1.i, 0
    br i1 %15, label %18, label %compareParams.exit.thread
  
  compareParams.exit.thread:                        ; preds = %compareParams.exit, %3
    %16 = bitcast %struct.model* %endList.03 to i32*
    %17 = load i32, i32* %16, align 4, !tbaa !10
    br label %.loopexit
  
  ; <label>:18                                      ; preds = %compareParams.exit
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 1
    %endList.0 = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0, null
    br i1 %20, label %.loopexit, label %3
  
  .loopexit:                                        ; preds = %18, %compareParams.exit.thread, %0
    %.0 = phi i32 [ %17, %compareParams.exit.thread ], [ 0, %0 ], [ 0, %18 ]
    ret i32 %.0
  }
  
  declare void @glNewList(i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @makeModelPtr(i32 signext %lindex, double* %sizeArray, i32 signext %count) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = tail call i32 @glGenLists(i32 signext 1) #4
    %3 = bitcast i8* %1 to i32*
    store i32 %2, i32* %3, align 4, !tbaa !10
    %4 = getelementptr inbounds i8, i8* %1, i32 8
    %5 = bitcast i8* %4 to i32*
    store i32 %count, i32* %5, align 4, !tbaa !11
    %6 = getelementptr inbounds i8, i8* %1, i32 12
    %7 = bitcast i8* %6 to double**
    store double* %sizeArray, double** %7, align 4, !tbaa !7
    %8 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %9 = bitcast %struct.model** %8 to i32*
    %10 = load i32, i32* %9, align 4, !tbaa !5
    %11 = getelementptr inbounds i8, i8* %1, i32 4
    %12 = bitcast i8* %11 to i32*
    store i32 %10, i32* %12, align 4, !tbaa !12
    %13 = bitcast %struct.model** %8 to i8**
    store i8* %1, i8** %13, align 4, !tbaa !5
    ret i32 %2
  }
  
  declare %struct.GLUquadricObj* @gluNewQuadric() #3
  
  declare void @gluQuadricDrawStyle(%struct.GLUquadricObj*, i32 signext) #3
  
  declare void @gluSphere(%struct.GLUquadricObj*, double, i32 signext, i32 signext) #3
  
  declare void @glEndList() #3
  
  declare void @glCallList(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  define void @auxSolidSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %23, i32 signext 100000) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  declare void @gluQuadricNormals(%struct.GLUquadricObj*, i32 signext) #3
  
  ; Function Attrs: nounwind
  define void @auxWireCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 2)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawbox(double %x0, double %x1, double %y0, double %y1, double %z0, double %z1, i32 signext %type) unnamed_addr #0 {
    %v = alloca [8 x [3 x double]], align 8
    %1 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.start(i64 192, i8* %1) #4
    %2 = fcmp ogt double %x0, %x1
    %.05 = select i1 %2, double %x0, double %x1
    %.0 = select i1 %2, double %x1, double %x0
    %3 = fcmp ogt double %y0, %y1
    %.04 = select i1 %3, double %y1, double %y0
    %.03 = select i1 %3, double %y0, double %y1
    %4 = fcmp ogt double %z0, %z1
    %.02 = select i1 %4, double %z1, double %z0
    %.01 = select i1 %4, double %z0, double %z1
    %5 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 0
    store double %.0, double* %5, align 8, !tbaa !1
    %6 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 0
    store double %.0, double* %6, align 8, !tbaa !1
    %7 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 0
    store double %.0, double* %7, align 8, !tbaa !1
    %8 = bitcast [8 x [3 x double]]* %v to double*
    store double %.0, double* %8, align 8, !tbaa !1
    %9 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 0
    store double %.05, double* %9, align 8, !tbaa !1
    %10 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 0
    store double %.05, double* %10, align 8, !tbaa !1
    %11 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 0
    store double %.05, double* %11, align 8, !tbaa !1
    %12 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 0
    store double %.05, double* %12, align 8, !tbaa !1
    %13 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 1
    store double %.04, double* %13, align 8, !tbaa !1
    %14 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 1
    store double %.04, double* %14, align 8, !tbaa !1
    %15 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 1
    store double %.04, double* %15, align 8, !tbaa !1
    %16 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 1
    store double %.04, double* %16, align 8, !tbaa !1
    %17 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 1
    store double %.03, double* %17, align 8, !tbaa !1
    %18 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 1
    store double %.03, double* %18, align 8, !tbaa !1
    %19 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 1
    store double %.03, double* %19, align 8, !tbaa !1
    %20 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 1
    store double %.03, double* %20, align 8, !tbaa !1
    %21 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 2
    store double %.02, double* %21, align 8, !tbaa !1
    %22 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 2
    store double %.02, double* %22, align 8, !tbaa !1
    %23 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 2
    store double %.02, double* %23, align 8, !tbaa !1
    %24 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 2
    store double %.02, double* %24, align 8, !tbaa !1
    %25 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 2
    store double %.01, double* %25, align 8, !tbaa !1
    %26 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 2
    store double %.01, double* %26, align 8, !tbaa !1
    %27 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 2
    store double %.01, double* %27, align 8, !tbaa !1
    %28 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 2
    store double %.01, double* %28, align 8, !tbaa !1
    br label %29
  
  ; <label>:29                                      ; preds = %29, %0
    %lsr.iv1 = phi [6 x [4 x i32]]* [ %38, %29 ], [ bitcast (i32* getelementptr inbounds ([6 x [4 x i32]], [6 x [4 x i32]]* @drawbox.faces, i32 0, i32 0, i32 2) to [6 x [4 x i32]]*), %0 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %29 ], [ 0, %0 ]
    %lsr.iv12 = bitcast [6 x [4 x i32]]* %lsr.iv1 to i32*
    call void @glBegin(i32 signext %type) #4
    %uglygep11 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep1112 = bitcast i8* %uglygep11 to double*
    call void @glNormal3dv(double* %uglygep1112) #4
    %scevgep5 = getelementptr i32, i32* %lsr.iv12, i32 -2
    %30 = load i32, i32* %scevgep5, align 4, !tbaa !13
    %31 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %30, i32 0
    call void @glVertex3dv(double* %31) #4
    %uglygep9 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep910 = bitcast i8* %uglygep9 to double*
    call void @glNormal3dv(double* %uglygep910) #4
    %scevgep4 = getelementptr i32, i32* %lsr.iv12, i32 -1
    %32 = load i32, i32* %scevgep4, align 4, !tbaa !13
    %33 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %32, i32 0
    call void @glVertex3dv(double* %33) #4
    %uglygep7 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep78 = bitcast i8* %uglygep7 to double*
    call void @glNormal3dv(double* %uglygep78) #4
    %34 = load i32, i32* %lsr.iv12, align 4, !tbaa !13
    %35 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %34, i32 0
    call void @glVertex3dv(double* %35) #4
    %uglygep = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep6 = bitcast i8* %uglygep to double*
    call void @glNormal3dv(double* %uglygep6) #4
    %scevgep3 = getelementptr i32, i32* %lsr.iv12, i32 1
    %36 = load i32, i32* %scevgep3, align 4, !tbaa !13
    %37 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %36, i32 0
    call void @glVertex3dv(double* %37) #4
    call void @glEnd() #4
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 24
    %scevgep = getelementptr [6 x [4 x i32]], [6 x [4 x i32]]* %lsr.iv1, i32 0, i32 1, i32 0
    %38 = bitcast i32* %scevgep to [6 x [4 x i32]]*
    %exitcond = icmp eq i32 %lsr.iv.next, 144
    br i1 %exitcond, label %39, label %29
  
  ; <label>:39                                      ; preds = %29
    %40 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.end(i64 192, i8* %40) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 7)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 2)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 7)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 5, i32 signext 10, i32 signext 2)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @doughnut(double %r, double %R, i32 signext %nsides, i32 signext %rings, i32 signext %type) unnamed_addr #0 {
    %p0 = alloca [3 x double], align 8
    %p1 = alloca [3 x double], align 8
    %p2 = alloca [3 x double], align 8
    %p3 = alloca [3 x double], align 8
    %n0 = alloca [3 x double], align 8
    %n1 = alloca [3 x double], align 8
    %n2 = alloca [3 x double], align 8
    %n3 = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %p1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %p2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %p3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %n1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %n2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = bitcast [3 x double]* %n3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %8) #4
    %9 = icmp sgt i32 %rings, 0
    br i1 %9, label %.lr.ph3, label %._crit_edge
  
  .lr.ph3:                                          ; preds = %0
    %10 = sitofp i32 %rings to double
    %11 = sitofp i32 %nsides to double
    br label %12
  
  .loopexit:                                        ; preds = %.lr.ph, %12
    %exitcond4 = icmp eq i32 %17, %rings
    br i1 %exitcond4, label %._crit_edge, label %12
  
  ; <label>:12                                      ; preds = %.loopexit, %.lr.ph3
    %IV.S.1 = phi double [ 0.000000e+00, %.lr.ph3 ], [ %IV.S.next.2, %.loopexit ]
    %i.02 = phi i32 [ 0, %.lr.ph3 ], [ %17, %.loopexit ]
    %13 = icmp sgt i32 %nsides, 0
    %14 = fmul double %IV.S.1, 2.000000e+00
    %15 = fmul double %14, 0x400921FB54442C46
    %16 = fdiv double %15, %10
    %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
    %17 = add nuw nsw i32 %i.02, 1
    %18 = sitofp i32 %17 to double
    %19 = fmul double %18, 2.000000e+00
    %20 = fmul double %19, 0x400921FB54442C46
    %21 = fdiv double %20, %10
    br i1 %13, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %12, %.lr.ph
    %IV.S. = phi double [ %IV.S.next., %.lr.ph ], [ 0.000000e+00, %12 ]
    %j.01 = phi i32 [ %33, %.lr.ph ], [ 0, %12 ]
    %22 = bitcast [3 x double]* %n3 to double*
    %23 = bitcast [3 x double]* %n2 to double*
    %24 = bitcast [3 x double]* %n1 to double*
    %25 = bitcast [3 x double]* %n0 to double*
    %26 = bitcast [3 x double]* %p3 to double*
    %27 = bitcast [3 x double]* %p2 to double*
    %28 = bitcast [3 x double]* %p1 to double*
    %29 = bitcast [3 x double]* %p0 to double*
    %30 = fmul double %IV.S., 2.000000e+00
    %31 = fmul double %30, 0x400921FB54442C46
    %32 = fdiv double %31, %11
    %IV.S.next. = fadd double %IV.S., 1.000000e+00
    %33 = add nuw nsw i32 %j.01, 1
    %34 = sitofp i32 %33 to double
    %35 = fmul double %34, 2.000000e+00
    %36 = fmul double %35, 0x400921FB54442C46
    %37 = fdiv double %36, %11
    %38 = call double @cos(double %16) #4
    %39 = call double @cos(double %32) #4
    %40 = fmul double %39, %r
    %41 = fadd double %40, %R
    %42 = fmul double %38, %41
    store double %42, double* %29, align 8, !tbaa !1
    %43 = call double @sin(double %16) #4
    %44 = call double @cos(double %32) #4
    %45 = fmul double %44, %r
    %46 = fadd double %45, %R
    %47 = fmul double %43, %46
    %48 = fsub double -0.000000e+00, %47
    %sunkaddr = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    store double %48, double* %sunkaddr4, align 8, !tbaa !1
    %49 = call double @sin(double %32) #4
    %50 = fmul double %49, %r
    %sunkaddr5 = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr6 = add i32 %sunkaddr5, 16
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %50, double* %sunkaddr7, align 8, !tbaa !1
    %51 = call double @cos(double %21) #4
    %52 = call double @cos(double %32) #4
    %53 = fmul double %52, %r
    %54 = fadd double %53, %R
    %55 = fmul double %51, %54
    store double %55, double* %28, align 8, !tbaa !1
    %56 = call double @sin(double %21) #4
    %57 = call double @cos(double %32) #4
    %58 = fmul double %57, %r
    %59 = fadd double %58, %R
    %60 = fmul double %56, %59
    %61 = fsub double -0.000000e+00, %60
    %sunkaddr8 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %61, double* %sunkaddr10, align 8, !tbaa !1
    %62 = call double @sin(double %32) #4
    %63 = fmul double %62, %r
    %sunkaddr11 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr12 = add i32 %sunkaddr11, 16
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %63, double* %sunkaddr13, align 8, !tbaa !1
    %64 = call double @cos(double %21) #4
    %65 = call double @cos(double %37) #4
    %66 = fmul double %65, %r
    %67 = fadd double %66, %R
    %68 = fmul double %64, %67
    store double %68, double* %27, align 8, !tbaa !1
    %69 = call double @sin(double %21) #4
    %70 = call double @cos(double %37) #4
    %71 = fmul double %70, %r
    %72 = fadd double %71, %R
    %73 = fmul double %69, %72
    %74 = fsub double -0.000000e+00, %73
    %sunkaddr14 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 8
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    store double %74, double* %sunkaddr16, align 8, !tbaa !1
    %75 = call double @sin(double %37) #4
    %76 = fmul double %75, %r
    %sunkaddr17 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %76, double* %sunkaddr19, align 8, !tbaa !1
    %77 = call double @cos(double %16) #4
    %78 = call double @cos(double %37) #4
    %79 = fmul double %78, %r
    %80 = fadd double %79, %R
    %81 = fmul double %77, %80
    store double %81, double* %26, align 8, !tbaa !1
    %82 = call double @sin(double %16) #4
    %83 = call double @cos(double %37) #4
    %84 = fmul double %83, %r
    %85 = fadd double %84, %R
    %86 = fmul double %82, %85
    %87 = fsub double -0.000000e+00, %86
    %sunkaddr20 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr21 = add i32 %sunkaddr20, 8
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %87, double* %sunkaddr22, align 8, !tbaa !1
    %88 = call double @sin(double %37) #4
    %89 = fmul double %88, %r
    %sunkaddr23 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %89, double* %sunkaddr25, align 8, !tbaa !1
    %90 = call double @cos(double %16) #4
    %91 = call double @cos(double %32) #4
    %92 = fmul double %90, %91
    store double %92, double* %25, align 8, !tbaa !1
    %93 = call double @sin(double %16) #4
    %94 = call double @cos(double %32) #4
    %95 = fmul double %93, %94
    %96 = fsub double -0.000000e+00, %95
    %sunkaddr26 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr27 = add i32 %sunkaddr26, 8
    %sunkaddr28 = inttoptr i32 %sunkaddr27 to double*
    store double %96, double* %sunkaddr28, align 8, !tbaa !1
    %97 = call double @sin(double %32) #4
    %sunkaddr29 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr30 = add i32 %sunkaddr29, 16
    %sunkaddr31 = inttoptr i32 %sunkaddr30 to double*
    store double %97, double* %sunkaddr31, align 8, !tbaa !1
    %98 = call double @cos(double %21) #4
    %99 = call double @cos(double %32) #4
    %100 = fmul double %98, %99
    store double %100, double* %24, align 8, !tbaa !1
    %101 = call double @sin(double %21) #4
    %102 = call double @cos(double %32) #4
    %103 = fmul double %101, %102
    %104 = fsub double -0.000000e+00, %103
    %sunkaddr32 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr33 = add i32 %sunkaddr32, 8
    %sunkaddr34 = inttoptr i32 %sunkaddr33 to double*
    store double %104, double* %sunkaddr34, align 8, !tbaa !1
    %105 = call double @sin(double %32) #4
    %sunkaddr35 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr36 = add i32 %sunkaddr35, 16
    %sunkaddr37 = inttoptr i32 %sunkaddr36 to double*
    store double %105, double* %sunkaddr37, align 8, !tbaa !1
    %106 = call double @cos(double %21) #4
    %107 = call double @cos(double %37) #4
    %108 = fmul double %106, %107
    store double %108, double* %23, align 8, !tbaa !1
    %109 = call double @sin(double %21) #4
    %110 = call double @cos(double %37) #4
    %111 = fmul double %109, %110
    %112 = fsub double -0.000000e+00, %111
    %sunkaddr38 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr39 = add i32 %sunkaddr38, 8
    %sunkaddr40 = inttoptr i32 %sunkaddr39 to double*
    store double %112, double* %sunkaddr40, align 8, !tbaa !1
    %113 = call double @sin(double %37) #4
    %sunkaddr41 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr42 = add i32 %sunkaddr41, 16
    %sunkaddr43 = inttoptr i32 %sunkaddr42 to double*
    store double %113, double* %sunkaddr43, align 8, !tbaa !1
    %114 = call double @cos(double %16) #4
    %115 = call double @cos(double %37) #4
    %116 = fmul double %114, %115
    store double %116, double* %22, align 8, !tbaa !1
    %117 = call double @sin(double %16) #4
    %118 = call double @cos(double %37) #4
    %119 = fmul double %117, %118
    %120 = fsub double -0.000000e+00, %119
    %sunkaddr44 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr45 = add i32 %sunkaddr44, 8
    %sunkaddr46 = inttoptr i32 %sunkaddr45 to double*
    store double %120, double* %sunkaddr46, align 8, !tbaa !1
    %121 = call double @sin(double %37) #4
    %sunkaddr47 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr48 = add i32 %sunkaddr47, 16
    %sunkaddr49 = inttoptr i32 %sunkaddr48 to double*
    store double %121, double* %sunkaddr49, align 8, !tbaa !1
    call void @m_xformpt(double* %29, double* %29, double* %25, double* %25) #4
    call void @m_xformpt(double* %28, double* %28, double* %24, double* %24) #4
    call void @m_xformpt(double* %27, double* %27, double* %23, double* %23) #4
    call void @m_xformpt(double* %26, double* %26, double* %22, double* %22) #4
    call void @glBegin(i32 signext %type) #4
    call void @glNormal3dv(double* %22) #4
    call void @glVertex3dv(double* %26) #4
    call void @glNormal3dv(double* %23) #4
    call void @glVertex3dv(double* %27) #4
    call void @glNormal3dv(double* %24) #4
    call void @glVertex3dv(double* %28) #4
    call void @glNormal3dv(double* %25) #4
    call void @glVertex3dv(double* %29) #4
    call void @glEnd() #4
    %exitcond = icmp eq i32 %nsides, %33
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.loopexit, %0
    %122 = bitcast [3 x double]* %n3 to i8*
    %123 = bitcast [3 x double]* %n2 to i8*
    %124 = bitcast [3 x double]* %n1 to i8*
    %125 = bitcast [3 x double]* %n0 to i8*
    %126 = bitcast [3 x double]* %p3 to i8*
    %127 = bitcast [3 x double]* %p2 to i8*
    %128 = bitcast [3 x double]* %p1 to i8*
    %129 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.end(i64 24, i8* %122) #4
    call void @llvm.lifetime.end(i64 24, i8* %123) #4
    call void @llvm.lifetime.end(i64 24, i8* %124) #4
    call void @llvm.lifetime.end(i64 24, i8* %125) #4
    call void @llvm.lifetime.end(i64 24, i8* %126) #4
    call void @llvm.lifetime.end(i64 24, i8* %127) #4
    call void @llvm.lifetime.end(i64 24, i8* %128) #4
    call void @llvm.lifetime.end(i64 24, i8* %129) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 8, i32 signext 15, i32 signext 7)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  declare void @glPushMatrix() #3
  
  declare void @glRotatef(float, float, float, float) #3
  
  declare void @glTranslatef(float, float, float) #3
  
  declare void @gluCylinder(%struct.GLUquadricObj*, double, double, double, i32 signext, i32 signext) #3
  
  declare void @glPopMatrix() #3
  
  ; Function Attrs: nounwind
  define void @auxSolidCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @icosahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 8, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 9, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 10, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 11, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 12, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 13, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 14, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 15, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 16, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 17, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 18, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 19, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireOctahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @octahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidOctahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireDodecahedron.center, i32 0, i32 0), double %23, i32 signext 2)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @dodecahedron(double* nocapture readonly %center, double %sc, i32 signext %type) unnamed_addr #0 {
    %.b = load i1, i1* @dodecahedron.inited, align 1
    br i1 %.b, label %2, label %1
  
  ; <label>:1                                       ; preds = %0
    store i1 true, i1* @dodecahedron.inited, align 1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 2), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 2), align 8, !tbaa !1
    br label %2
  
  ; <label>:2                                       ; preds = %1, %0
    tail call void @m_pushmatrix() #4
    %3 = load double, double* %center, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %center, i32 1
    %5 = load double, double* %4, align 8, !tbaa !1
    %6 = getelementptr inbounds double, double* %center, i32 2
    %7 = load double, double* %6, align 8, !tbaa !1
    tail call void @m_translate(double %3, double %5, double %7) #4
    tail call void @m_scale(double %sc, double %sc, double %sc) #4
    tail call fastcc void @pentagon(i32 signext 0, i32 signext 1, i32 signext 9, i32 signext 16, i32 signext 5, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 0, i32 signext 3, i32 signext 18, i32 signext 7, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 7, i32 signext 11, i32 signext 10, i32 signext 9, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 11, i32 signext 7, i32 signext 18, i32 signext 19, i32 signext 6, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 8, i32 signext 17, i32 signext 16, i32 signext 9, i32 signext 10, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 14, i32 signext 15, i32 signext 6, i32 signext 19, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 13, i32 signext 12, i32 signext 4, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 19, i32 signext 18, i32 signext 3, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 3, i32 signext 0, i32 signext 5, i32 signext 12, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 6, i32 signext 15, i32 signext 8, i32 signext 10, i32 signext 11, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 17, i32 signext 8, i32 signext 15, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 12, i32 signext 5, i32 signext 16, i32 signext 17, i32 signext %type)
    tail call void @m_popmatrix() #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidDodecahedron.center, i32 0, i32 0), double %23, i32 signext 6)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @compareParams(double* nocapture readonly %oneArray, double* nocapture readonly %twoArray, i32 signext %size) #2 {
    %1 = icmp sgt i32 %size, 0
    br i1 %1, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ 1, %0 ]
    %matches.05 = phi i32 [ %matches.1, %.lr.ph ], [ 1, %0 ]
    %.03 = phi double* [ %2, %.lr.ph ], [ %oneArray, %0 ]
    %.012 = phi double* [ %4, %.lr.ph ], [ %twoArray, %0 ]
    %2 = getelementptr inbounds double, double* %.03, i32 1
    %3 = load double, double* %.03, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %.012, i32 1
    %5 = load double, double* %.012, align 8, !tbaa !1
    %6 = fcmp une double %3, %5
    %matches.1 = select i1 %6, i32 0, i32 %matches.05
    %7 = icmp slt i32 %lsr.iv, %size
    %8 = icmp ne i32 %matches.1, 0
    %9 = and i1 %7, %8
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    %matches.0.lcssa = phi i32 [ 1, %0 ], [ %matches.1, %.lr.ph ]
    ret i32 %matches.0.lcssa
  }
  
  declare i32 @glGenLists(i32 signext) #3
  
  declare void @glBegin(i32 signext) #3
  
  declare void @glNormal3dv(double*) #3
  
  declare void @glVertex3dv(double*) #3
  
  declare void @glEnd() #3
  
  ; Function Attrs: nounwind
  declare double @cos(double) #0
  
  ; Function Attrs: nounwind
  declare double @sin(double) #0
  
  declare void @m_xformpt(double*, double*, double*, double*) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawtriangle(i32 signext %i, i32 signext %geomType, double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    %p1.i.i = alloca [3 x double], align 8
    %p2.i.i = alloca [3 x double], align 8
    %p3.i.i = alloca [3 x double], align 8
    %q0.i.i = alloca [3 x double], align 8
    %q1.i.i = alloca [3 x double], align 8
    %n11.i.i = alloca [3 x double], align 8
    switch i32 %geomType, label %31 [
      i32 0, label %1
      i32 1, label %11
      i32 2, label %21
    ]
  
  ; <label>:1                                       ; preds = %0
    %2 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 0
    %3 = load i32, i32* %2, align 4, !tbaa !13
    %4 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %3, i32 0
    %5 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 1
    %6 = load i32, i32* %5, align 4, !tbaa !13
    %7 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %6, i32 0
    %8 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 2
    %9 = load i32, i32* %8, align 4, !tbaa !13
    %10 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %9, i32 0
    br label %31
  
  ; <label>:11                                      ; preds = %0
    %12 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 0
    %13 = load i32, i32* %12, align 4, !tbaa !13
    %14 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %13, i32 0
    %15 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 1
    %16 = load i32, i32* %15, align 4, !tbaa !13
    %17 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %16, i32 0
    %18 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 2
    %19 = load i32, i32* %18, align 4, !tbaa !13
    %20 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %19, i32 0
    br label %31
  
  ; <label>:21                                      ; preds = %0
    %22 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 0
    %23 = load i32, i32* %22, align 4, !tbaa !13
    %24 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %23, i32 0
    %25 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 1
    %26 = load i32, i32* %25, align 4, !tbaa !13
    %27 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %26, i32 0
    %28 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 2
    %29 = load i32, i32* %28, align 4, !tbaa !13
    %30 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %29, i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %21, %11, %1, %0
    %x0.0 = phi double* [ undef, %0 ], [ %24, %21 ], [ %14, %11 ], [ %4, %1 ]
    %x1.0 = phi double* [ undef, %0 ], [ %27, %21 ], [ %17, %11 ], [ %7, %1 ]
    %x2.0 = phi double* [ undef, %0 ], [ %30, %21 ], [ %20, %11 ], [ %10, %1 ]
    %32 = load double, double* %x0.0, align 8, !tbaa !1
    %33 = fmul double %32, 0.000000e+00
    %34 = load double, double* %x1.0, align 8, !tbaa !1
    %35 = fmul double %34, 0.000000e+00
    %36 = fadd double %33, %35
    %37 = load double, double* %x2.0, align 8, !tbaa !1
    %38 = fadd double %37, %36
    %39 = fadd double %32, %35
    %40 = fmul double %37, 0.000000e+00
    %41 = fadd double %39, %40
    %42 = fadd double %33, %34
    %43 = fadd double %42, %40
    %44 = getelementptr inbounds double, double* %x0.0, i32 1
    %45 = load double, double* %44, align 8, !tbaa !1
    %46 = fmul double %45, 0.000000e+00
    %47 = getelementptr inbounds double, double* %x1.0, i32 1
    %48 = load double, double* %47, align 8, !tbaa !1
    %49 = fmul double %48, 0.000000e+00
    %50 = fadd double %46, %49
    %51 = getelementptr inbounds double, double* %x2.0, i32 1
    %52 = load double, double* %51, align 8, !tbaa !1
    %53 = fadd double %52, %50
    %54 = fadd double %45, %49
    %55 = fmul double %52, 0.000000e+00
    %56 = fadd double %54, %55
    %57 = fadd double %46, %48
    %58 = fadd double %57, %55
    %59 = getelementptr inbounds double, double* %x0.0, i32 2
    %60 = load double, double* %59, align 8, !tbaa !1
    %61 = fmul double %60, 0.000000e+00
    %62 = getelementptr inbounds double, double* %x1.0, i32 2
    %63 = load double, double* %62, align 8, !tbaa !1
    %64 = fmul double %63, 0.000000e+00
    %65 = fadd double %61, %64
    %66 = getelementptr inbounds double, double* %x2.0, i32 2
    %67 = load double, double* %66, align 8, !tbaa !1
    %68 = fadd double %67, %65
    %69 = fadd double %60, %64
    %70 = fmul double %67, 0.000000e+00
    %71 = fadd double %69, %70
    %72 = fadd double %61, %63
    %73 = fadd double %72, %70
    %74 = fmul double %38, %38
    %75 = fmul double %53, %53
    %76 = fadd double %74, %75
    %77 = fmul double %68, %68
    %78 = fadd double %76, %77
    %79 = tail call double @sqrt(double %78) #5
    %80 = fcmp oeq double %79, %79
    br i1 %80, label %.split, label %call.sqrt
  
  call.sqrt:                                        ; preds = %31
    %81 = tail call double @sqrt(double %78) #4
    br label %.split
  
  .split:                                           ; preds = %31, %call.sqrt
    %82 = phi double [ %79, %31 ], [ %81, %call.sqrt ]
    %83 = fdiv double %38, %82
    %84 = fdiv double %53, %82
    %85 = fdiv double %68, %82
    %86 = fmul double %41, %41
    %87 = fmul double %56, %56
    %88 = fadd double %86, %87
    %89 = fmul double %71, %71
    %90 = fadd double %88, %89
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %.split.split, label %call.sqrt1
  
  call.sqrt1:                                       ; preds = %.split
    %93 = tail call double @sqrt(double %90) #4
    br label %.split.split
  
  .split.split:                                     ; preds = %.split, %call.sqrt1
    %94 = phi double [ %91, %.split ], [ %93, %call.sqrt1 ]
    %95 = fdiv double %41, %94
    %96 = fdiv double %56, %94
    %97 = fdiv double %71, %94
    %98 = fmul double %43, %43
    %99 = fmul double %58, %58
    %100 = fadd double %98, %99
    %101 = fmul double %73, %73
    %102 = fadd double %100, %101
    %103 = tail call double @sqrt(double %102) #5
    %104 = fcmp oeq double %103, %103
    br i1 %104, label %.split.split.split, label %call.sqrt2
  
  call.sqrt2:                                       ; preds = %.split.split
    %105 = tail call double @sqrt(double %102) #4
    br label %.split.split.split
  
  .split.split.split:                               ; preds = %.split.split, %call.sqrt2
    %106 = phi double [ %103, %.split.split ], [ %105, %call.sqrt2 ]
    %107 = bitcast [3 x double]* %n11.i.i to double*
    %108 = bitcast [3 x double]* %q1.i.i to double*
    %109 = bitcast [3 x double]* %q0.i.i to double*
    %110 = bitcast [3 x double]* %p3.i.i to double*
    %111 = bitcast [3 x double]* %p2.i.i to double*
    %112 = bitcast [3 x double]* %p1.i.i to double*
    %113 = bitcast [3 x double]* %n11.i.i to i8*
    %114 = bitcast [3 x double]* %q1.i.i to i8*
    %115 = bitcast [3 x double]* %q0.i.i to i8*
    %116 = bitcast [3 x double]* %p3.i.i to i8*
    %117 = bitcast [3 x double]* %p2.i.i to i8*
    %118 = bitcast [3 x double]* %p1.i.i to i8*
    %119 = fdiv double %43, %106
    %120 = fdiv double %58, %106
    %121 = fdiv double %73, %106
    call void @llvm.lifetime.start(i64 24, i8* %118) #4
    call void @llvm.lifetime.start(i64 24, i8* %117) #4
    call void @llvm.lifetime.start(i64 24, i8* %116) #4
    call void @llvm.lifetime.start(i64 24, i8* %115) #4
    call void @llvm.lifetime.start(i64 24, i8* %114) #4
    call void @llvm.lifetime.start(i64 24, i8* %113) #4
    %122 = fmul double %95, %radius
    %123 = load double, double* %p0, align 8, !tbaa !1
    %124 = fadd double %122, %123
    store double %124, double* %112, align 8, !tbaa !1
    %125 = fmul double %83, %radius
    %126 = fadd double %125, %123
    store double %126, double* %111, align 8, !tbaa !1
    %127 = fmul double %119, %radius
    %128 = fadd double %127, %123
    store double %128, double* %110, align 8, !tbaa !1
    %129 = fmul double %96, %radius
    %sunkaddr = ptrtoint double* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    %130 = load double, double* %sunkaddr4, align 8, !tbaa !1
    %131 = fadd double %129, %130
    %sunkaddr5 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr6 = add i32 %sunkaddr5, 8
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %131, double* %sunkaddr7, align 8, !tbaa !1
    %132 = fmul double %84, %radius
    %133 = fadd double %132, %130
    %sunkaddr8 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %133, double* %sunkaddr10, align 8, !tbaa !1
    %134 = fmul double %120, %radius
    %135 = fadd double %134, %130
    %sunkaddr11 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr12 = add i32 %sunkaddr11, 8
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %135, double* %sunkaddr13, align 8, !tbaa !1
    %136 = fmul double %97, %radius
    %sunkaddr14 = ptrtoint double* %p0 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 16
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    %137 = load double, double* %sunkaddr16, align 8, !tbaa !1
    %138 = fadd double %136, %137
    %sunkaddr17 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %138, double* %sunkaddr19, align 8, !tbaa !1
    %139 = fmul double %85, %radius
    %140 = fadd double %139, %137
    %sunkaddr20 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr21 = add i32 %sunkaddr20, 16
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %140, double* %sunkaddr22, align 8, !tbaa !1
    %141 = fmul double %121, %radius
    %142 = fadd double %141, %137
    %sunkaddr23 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %142, double* %sunkaddr25, align 8, !tbaa !1
    call void @diff3(double* %112, double* %111, double* %109) #4
    call void @diff3(double* %111, double* %110, double* %108) #4
    call void @crossprod(double* %109, double* %108, double* %108) #4
    call void @normalize(double* %108) #4
    call void @m_xformpt(double* %112, double* %112, double* %108, double* %107) #4
    call void @m_xformptonly(double* %111, double* %111) #4
    call void @m_xformptonly(double* %110, double* %110) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %107) #4
    call void @glVertex3dv(double* %112) #4
    call void @glVertex3dv(double* %111) #4
    call void @glVertex3dv(double* %110) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %113) #4
    call void @llvm.lifetime.end(i64 24, i8* %114) #4
    call void @llvm.lifetime.end(i64 24, i8* %115) #4
    call void @llvm.lifetime.end(i64 24, i8* %116) #4
    call void @llvm.lifetime.end(i64 24, i8* %117) #4
    call void @llvm.lifetime.end(i64 24, i8* %118) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  declare void @diff3(double*, double*, double*) #3
  
  declare void @crossprod(double*, double*, double*) #3
  
  declare void @normalize(double*) #3
  
  declare void @m_xformptonly(double*, double*) #3
  
  declare void @m_pushmatrix() #3
  
  declare void @m_translate(double, double, double) #3
  
  declare void @m_scale(double, double, double) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @pentagon(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %shadeType) unnamed_addr #0 {
    %n0 = alloca [3 x double], align 8
    %d1 = alloca [3 x double], align 8
    %d2 = alloca [3 x double], align 8
    %d3 = alloca [3 x double], align 8
    %d4 = alloca [3 x double], align 8
    %d5 = alloca [3 x double], align 8
    %nout = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %d1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %d2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %d3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %d4 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %d5 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %nout to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %a, i32 0
    %9 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %b, i32 0
    %10 = bitcast [3 x double]* %d1 to double*
    call void @diff3(double* %8, double* %9, double* %10) #4
    %11 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %c, i32 0
    %12 = bitcast [3 x double]* %d2 to double*
    call void @diff3(double* %9, double* %11, double* %12) #4
    %13 = bitcast [3 x double]* %n0 to double*
    call void @crossprod(double* %10, double* %12, double* %13) #4
    call void @normalize(double* %13) #4
    %14 = bitcast [3 x double]* %nout to double*
    call void @m_xformpt(double* %8, double* %10, double* %13, double* %14) #4
    call void @m_xformptonly(double* %9, double* %12) #4
    %15 = bitcast [3 x double]* %d3 to double*
    call void @m_xformptonly(double* %11, double* %15) #4
    %16 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %d, i32 0
    %17 = bitcast [3 x double]* %d4 to double*
    call void @m_xformptonly(double* %16, double* %17) #4
    %18 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %e, i32 0
    %19 = bitcast [3 x double]* %d5 to double*
    call void @m_xformptonly(double* %18, double* %19) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %14) #4
    call void @glVertex3dv(double* %10) #4
    call void @glVertex3dv(double* %12) #4
    call void @glVertex3dv(double* %15) #4
    call void @glVertex3dv(double* %17) #4
    call void @glVertex3dv(double* %19) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %7) #4
    call void @llvm.lifetime.end(i64 24, i8* %6) #4
    call void @llvm.lifetime.end(i64 24, i8* %5) #4
    call void @llvm.lifetime.end(i64 24, i8* %4) #4
    call void @llvm.lifetime.end(i64 24, i8* %3) #4
    call void @llvm.lifetime.end(i64 24, i8* %2) #4
    call void @llvm.lifetime.end(i64 24, i8* %1) #4
    ret void
  }
  
  declare void @m_popmatrix() #3
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { norecurse nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { nounwind }
  attributes #5 = { nounwind readnone }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !2, i64 0}
  !2 = !{!"double", !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"any pointer", !3, i64 0}
  !7 = !{!8, !6, i64 12}
  !8 = !{!"model", !9, i64 0, !6, i64 4, !9, i64 8, !6, i64 12}
  !9 = !{!"int", !3, i64 0}
  !10 = !{!8, !9, i64 0}
  !11 = !{!8, !9, i64 8}
  !12 = !{!8, !6, i64 4}
  !13 = !{!9, !9, i64 0}

...
---
name:            auxSolidCube
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: afgr64 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: afgr64 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: afgr64 }
  - { id: 29, class: afgr64 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: afgr64 }
  - { id: 32, class: afgr64 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
liveins:         
  - { reg: '%d6', virtual-reg: '%5' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
constants:       
  - id:              0
    value:           double -5.000000e-01
    alignment:       8
  - id:              1
    value:           double 5.000000e-01
    alignment:       8
body:             |
  bb.0 (%ir-block.0, freq 40):
    successors: %bb.4.findList.exit.thread(37), %bb.7(62)
    liveins: %d6, %t9, %v0
  
    %6 = ADDu %v0, %t9
    %5 = COPY %d6
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %7 = LW %6, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %8 = ADDiu %zero, 8
    %a0 = COPY %8
    %gp = COPY %6
    %t9 = COPY %7
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %9 = COPY %v0
    SDC1 %5, %9, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.2, !tbaa !1)
    %10 = LW %6, target-flags(<unknown>) @lists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %11 = ADDiu %10, target-flags(<unknown>) @lists
    %1 = LW %11, 44, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from `%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11)`, !tbaa !5)
    %0 = COPY %9
    BEQ %1, %zero, %bb.4.findList.exit.thread, implicit-def %at
  
  bb.7 (freq 25):
    successors: %bb.1.compareParams.exit.i(100)
  
  
  bb.1.compareParams.exit.i (freq 409):
    successors: %bb.2(96), %bb.3.findList.exit(3)
  
    %2 = PHI %1, %bb.7, %3, %bb.2
    %12 = LW %2, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.4, !tbaa !7)
    %13 = LDC1 killed %12, 0, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 8 from %ir.5, !tbaa !1)
    FCMP_D32 killed %13, %5, 2, implicit-def %fcc0
    BC1T %fcc0, %bb.3.findList.exit, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.7, freq 396):
    successors: %bb.4.findList.exit.thread(3), %bb.1.compareParams.exit.i(96)
  
    %3 = LW %2, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.8, !tbaa !5)
    BEQ %3, %zero, %bb.4.findList.exit.thread, implicit-def dead %at
    B %bb.1.compareParams.exit.i, implicit-def dead %at
  
  bb.3.findList.exit (freq 12):
    successors: %bb.4.findList.exit.thread(37), %bb.5(62)
  
    %4 = LW %2, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.10, !tbaa !10)
    BNE %4, %zero, %bb.5, implicit-def dead %at
    B %bb.4.findList.exit.thread, implicit-def dead %at
  
  bb.4.findList.exit.thread (freq 32):
    successors: %bb.6(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %16 = LW %6, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %17 = ADDiu %zero, 16
    %a0 = COPY %17
    %t9 = COPY %16
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %18 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %19 = LW %6, target-flags(<unknown>) @glGenLists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glGenLists)
    %20 = ADDiu %zero, 1
    %a0 = COPY %20
    %gp = COPY %6
    %t9 = COPY %19
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %21 = COPY %v0
    %24 = ADDiu %zero, 4865
    SW %21, %18, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.15, !tbaa !10)
    SW %20, %18, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.17, !tbaa !11)
    SW %0, %18, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.19, !tbaa !7)
    %25 = LW %11, 44, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*)`, !tbaa !5)
    SW killed %25, %18, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.22, !tbaa !12)
    SW %18, %11, 44, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**)`, !tbaa !5)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %26 = LW %6, target-flags(<unknown>) @glNewList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glNewList)
    %a0 = COPY %21
    %a1 = COPY %24
    %gp = COPY %6
    %t9 = COPY %26
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %27 = LW %6, target-flags(<unknown>) %const.0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %28 = LDC1 killed %27, target-flags(<unknown>) %const.0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %29 = FMUL_D32 %5, killed %28
    %30 = LW %6, target-flags(<unknown>) %const.1, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %31 = LDC1 killed %30, target-flags(<unknown>) %const.1, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %32 = FMUL_D32 %5, killed %31
    %33 = LW %6, target-flags(<unknown>) @drawbox, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %34 = ADDiu killed %33, target-flags(<unknown>) @drawbox
    %35 = ADDiu %zero, 7
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %d0 = COPY %29
    %d1 = COPY %32
    %d2 = COPY %29
    %d3 = COPY %32
    %d4 = COPY %29
    %d5 = COPY %32
    %a0 = COPY %35
    %t9 = COPY %34
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d0, implicit %d1, implicit %d2, implicit %d3, implicit %d4, implicit %d5, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %36 = LW %6, target-flags(<unknown>) @glEndList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glEndList)
    %gp = COPY %6
    %t9 = COPY %36
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.6, implicit-def dead %at
  
  bb.5 (%ir-block.25, freq 7):
    successors: %bb.6(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %14 = LW %6, target-flags(<unknown>) @glCallList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glCallList)
    %a0 = COPY %4
    %gp = COPY %6
    %t9 = COPY %14
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %15 = LW %6, target-flags(<unknown>) @free, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @free)
    %a0 = COPY %0
    %gp = COPY %6
    %t9 = COPY %15
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.6 (%ir-block.26, freq 40):
    liveouts:
  
    RetRA

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/mesa/mesa.shapes.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.model = type { i32, %struct.model*, i32, double* }
  %struct.GLUquadricObj = type opaque
  
  @auxWireIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @lists = internal unnamed_addr global [25 x %struct.model*] zeroinitializer, align 4
  @drawbox.n = internal global [6 x [3 x double]] [[3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @drawbox.faces = internal unnamed_addr constant [6 x [4 x i32]] [[4 x i32] [i32 0, i32 1, i32 2, i32 3], [4 x i32] [i32 3, i32 2, i32 6, i32 7], [4 x i32] [i32 7, i32 6, i32 5, i32 4], [4 x i32] [i32 4, i32 5, i32 1, i32 0], [4 x i32] [i32 5, i32 6, i32 2, i32 1], [4 x i32] [i32 7, i32 4, i32 0, i32 3]], align 4
  @iindex = internal unnamed_addr constant [20 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 1], [3 x i32] [i32 0, i32 9, i32 4], [3 x i32] [i32 9, i32 5, i32 4], [3 x i32] [i32 4, i32 5, i32 8], [3 x i32] [i32 4, i32 8, i32 1], [3 x i32] [i32 8, i32 10, i32 1], [3 x i32] [i32 8, i32 3, i32 10], [3 x i32] [i32 5, i32 3, i32 8], [3 x i32] [i32 5, i32 2, i32 3], [3 x i32] [i32 2, i32 7, i32 3], [3 x i32] [i32 7, i32 10, i32 3], [3 x i32] [i32 7, i32 6, i32 10], [3 x i32] [i32 7, i32 11, i32 6], [3 x i32] [i32 11, i32 0, i32 6], [3 x i32] [i32 0, i32 1, i32 6], [3 x i32] [i32 6, i32 1, i32 10], [3 x i32] [i32 9, i32 0, i32 11], [3 x i32] [i32 9, i32 11, i32 2], [3 x i32] [i32 9, i32 2, i32 5], [3 x i32] [i32 7, i32 2, i32 11]], align 4
  @idata = internal global [12 x [3 x double]] [[3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00]], align 8
  @ondex = internal unnamed_addr constant [8 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 2], [3 x i32] [i32 1, i32 2, i32 4], [3 x i32] [i32 0, i32 3, i32 4], [3 x i32] [i32 1, i32 4, i32 3], [3 x i32] [i32 0, i32 2, i32 5], [3 x i32] [i32 1, i32 5, i32 2], [3 x i32] [i32 0, i32 5, i32 3], [3 x i32] [i32 1, i32 3, i32 5]], align 4
  @odata = internal global [6 x [3 x double]] [[3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @tndex = internal unnamed_addr constant [4 x [3 x i32]] [[3 x i32] [i32 0, i32 1, i32 3], [3 x i32] [i32 2, i32 1, i32 0], [3 x i32] [i32 3, i32 2, i32 0], [3 x i32] [i32 1, i32 2, i32 3]], align 4
  @tdata = internal global [4 x [3 x double]] [[3 x double] [double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA], [3 x double] [double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA]], align 8
  @dodecahedron.inited = internal unnamed_addr global i1 false
  @dodec = internal global [20 x [3 x double]] zeroinitializer, align 8
  
  ; Function Attrs: nounwind
  define void @auxWireSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast ([25 x %struct.model*]* @lists to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast ([25 x %struct.model*]* @lists to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100011) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare noalias i8* @malloc(i32 signext) #0
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @findList(i32 signext %lindex, double* nocapture readonly %paramArray, i32 signext %size) #2 {
    %1 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %endList.02 = load %struct.model*, %struct.model** %1, align 4, !tbaa !5
    %2 = icmp eq %struct.model* %endList.02, null
    br i1 %2, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0
    br label %3
  
  ; <label>:3                                       ; preds = %18, %.lr.ph
    %endList.03 = phi %struct.model* [ %endList.02, %.lr.ph ], [ %endList.0, %18 ]
    %4 = icmp sgt i32 %size, 0
    br i1 %4, label %.lr.ph.i.preheader, label %compareParams.exit.thread
  
  .lr.ph.i.preheader:                               ; preds = %3
    %5 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 3
    %6 = load double*, double** %5, align 4, !tbaa !7
    br label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %matches.05.i = phi i32 [ %matches.1.i, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %.03.i = phi double* [ %7, %.lr.ph.i ], [ %6, %.lr.ph.i.preheader ]
    %.012.i = phi double* [ %9, %.lr.ph.i ], [ %paramArray, %.lr.ph.i.preheader ]
    %7 = getelementptr inbounds double, double* %.03.i, i32 1
    %8 = load double, double* %.03.i, align 8, !tbaa !1
    %9 = getelementptr inbounds double, double* %.012.i, i32 1
    %10 = load double, double* %.012.i, align 8, !tbaa !1
    %11 = fcmp une double %8, %10
    %matches.1.i = select i1 %11, i32 0, i32 %matches.05.i
    %12 = icmp slt i32 %lsr.iv, %size
    %13 = icmp ne i32 %matches.1.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %14, label %.lr.ph.i, label %compareParams.exit
  
  compareParams.exit:                               ; preds = %.lr.ph.i
    %15 = icmp eq i32 %matches.1.i, 0
    br i1 %15, label %18, label %compareParams.exit.thread
  
  compareParams.exit.thread:                        ; preds = %compareParams.exit, %3
    %16 = bitcast %struct.model* %endList.03 to i32*
    %17 = load i32, i32* %16, align 4, !tbaa !10
    br label %.loopexit
  
  ; <label>:18                                      ; preds = %compareParams.exit
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 1
    %endList.0 = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0, null
    br i1 %20, label %.loopexit, label %3
  
  .loopexit:                                        ; preds = %18, %compareParams.exit.thread, %0
    %.0 = phi i32 [ %17, %compareParams.exit.thread ], [ 0, %0 ], [ 0, %18 ]
    ret i32 %.0
  }
  
  declare void @glNewList(i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @makeModelPtr(i32 signext %lindex, double* %sizeArray, i32 signext %count) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = tail call i32 @glGenLists(i32 signext 1) #4
    %3 = bitcast i8* %1 to i32*
    store i32 %2, i32* %3, align 4, !tbaa !10
    %4 = getelementptr inbounds i8, i8* %1, i32 8
    %5 = bitcast i8* %4 to i32*
    store i32 %count, i32* %5, align 4, !tbaa !11
    %6 = getelementptr inbounds i8, i8* %1, i32 12
    %7 = bitcast i8* %6 to double**
    store double* %sizeArray, double** %7, align 4, !tbaa !7
    %8 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %9 = bitcast %struct.model** %8 to i32*
    %10 = load i32, i32* %9, align 4, !tbaa !5
    %11 = getelementptr inbounds i8, i8* %1, i32 4
    %12 = bitcast i8* %11 to i32*
    store i32 %10, i32* %12, align 4, !tbaa !12
    %13 = bitcast %struct.model** %8 to i8**
    store i8* %1, i8** %13, align 4, !tbaa !5
    ret i32 %2
  }
  
  declare %struct.GLUquadricObj* @gluNewQuadric() #3
  
  declare void @gluQuadricDrawStyle(%struct.GLUquadricObj*, i32 signext) #3
  
  declare void @gluSphere(%struct.GLUquadricObj*, double, i32 signext, i32 signext) #3
  
  declare void @glEndList() #3
  
  declare void @glCallList(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  define void @auxSolidSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %23, i32 signext 100000) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  declare void @gluQuadricNormals(%struct.GLUquadricObj*, i32 signext) #3
  
  ; Function Attrs: nounwind
  define void @auxWireCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 2)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawbox(double %x0, double %x1, double %y0, double %y1, double %z0, double %z1, i32 signext %type) unnamed_addr #0 {
    %v = alloca [8 x [3 x double]], align 8
    %1 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.start(i64 192, i8* %1) #4
    %2 = fcmp ogt double %x0, %x1
    %.05 = select i1 %2, double %x0, double %x1
    %.0 = select i1 %2, double %x1, double %x0
    %3 = fcmp ogt double %y0, %y1
    %.04 = select i1 %3, double %y1, double %y0
    %.03 = select i1 %3, double %y0, double %y1
    %4 = fcmp ogt double %z0, %z1
    %.02 = select i1 %4, double %z1, double %z0
    %.01 = select i1 %4, double %z0, double %z1
    %5 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 0
    store double %.0, double* %5, align 8, !tbaa !1
    %6 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 0
    store double %.0, double* %6, align 8, !tbaa !1
    %7 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 0
    store double %.0, double* %7, align 8, !tbaa !1
    %8 = bitcast [8 x [3 x double]]* %v to double*
    store double %.0, double* %8, align 8, !tbaa !1
    %9 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 0
    store double %.05, double* %9, align 8, !tbaa !1
    %10 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 0
    store double %.05, double* %10, align 8, !tbaa !1
    %11 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 0
    store double %.05, double* %11, align 8, !tbaa !1
    %12 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 0
    store double %.05, double* %12, align 8, !tbaa !1
    %13 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 1
    store double %.04, double* %13, align 8, !tbaa !1
    %14 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 1
    store double %.04, double* %14, align 8, !tbaa !1
    %15 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 1
    store double %.04, double* %15, align 8, !tbaa !1
    %16 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 1
    store double %.04, double* %16, align 8, !tbaa !1
    %17 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 1
    store double %.03, double* %17, align 8, !tbaa !1
    %18 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 1
    store double %.03, double* %18, align 8, !tbaa !1
    %19 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 1
    store double %.03, double* %19, align 8, !tbaa !1
    %20 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 1
    store double %.03, double* %20, align 8, !tbaa !1
    %21 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 2
    store double %.02, double* %21, align 8, !tbaa !1
    %22 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 2
    store double %.02, double* %22, align 8, !tbaa !1
    %23 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 2
    store double %.02, double* %23, align 8, !tbaa !1
    %24 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 2
    store double %.02, double* %24, align 8, !tbaa !1
    %25 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 2
    store double %.01, double* %25, align 8, !tbaa !1
    %26 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 2
    store double %.01, double* %26, align 8, !tbaa !1
    %27 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 2
    store double %.01, double* %27, align 8, !tbaa !1
    %28 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 2
    store double %.01, double* %28, align 8, !tbaa !1
    br label %29
  
  ; <label>:29                                      ; preds = %29, %0
    %lsr.iv1 = phi [6 x [4 x i32]]* [ %38, %29 ], [ bitcast (i32* getelementptr inbounds ([6 x [4 x i32]], [6 x [4 x i32]]* @drawbox.faces, i32 0, i32 0, i32 2) to [6 x [4 x i32]]*), %0 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %29 ], [ 0, %0 ]
    %lsr.iv12 = bitcast [6 x [4 x i32]]* %lsr.iv1 to i32*
    call void @glBegin(i32 signext %type) #4
    %uglygep11 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep1112 = bitcast i8* %uglygep11 to double*
    call void @glNormal3dv(double* %uglygep1112) #4
    %scevgep5 = getelementptr i32, i32* %lsr.iv12, i32 -2
    %30 = load i32, i32* %scevgep5, align 4, !tbaa !13
    %31 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %30, i32 0
    call void @glVertex3dv(double* %31) #4
    %uglygep9 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep910 = bitcast i8* %uglygep9 to double*
    call void @glNormal3dv(double* %uglygep910) #4
    %scevgep4 = getelementptr i32, i32* %lsr.iv12, i32 -1
    %32 = load i32, i32* %scevgep4, align 4, !tbaa !13
    %33 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %32, i32 0
    call void @glVertex3dv(double* %33) #4
    %uglygep7 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep78 = bitcast i8* %uglygep7 to double*
    call void @glNormal3dv(double* %uglygep78) #4
    %34 = load i32, i32* %lsr.iv12, align 4, !tbaa !13
    %35 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %34, i32 0
    call void @glVertex3dv(double* %35) #4
    %uglygep = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep6 = bitcast i8* %uglygep to double*
    call void @glNormal3dv(double* %uglygep6) #4
    %scevgep3 = getelementptr i32, i32* %lsr.iv12, i32 1
    %36 = load i32, i32* %scevgep3, align 4, !tbaa !13
    %37 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %36, i32 0
    call void @glVertex3dv(double* %37) #4
    call void @glEnd() #4
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 24
    %scevgep = getelementptr [6 x [4 x i32]], [6 x [4 x i32]]* %lsr.iv1, i32 0, i32 1, i32 0
    %38 = bitcast i32* %scevgep to [6 x [4 x i32]]*
    %exitcond = icmp eq i32 %lsr.iv.next, 144
    br i1 %exitcond, label %39, label %29
  
  ; <label>:39                                      ; preds = %29
    %40 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.end(i64 192, i8* %40) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 7)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 2)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 7)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 5, i32 signext 10, i32 signext 2)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @doughnut(double %r, double %R, i32 signext %nsides, i32 signext %rings, i32 signext %type) unnamed_addr #0 {
    %p0 = alloca [3 x double], align 8
    %p1 = alloca [3 x double], align 8
    %p2 = alloca [3 x double], align 8
    %p3 = alloca [3 x double], align 8
    %n0 = alloca [3 x double], align 8
    %n1 = alloca [3 x double], align 8
    %n2 = alloca [3 x double], align 8
    %n3 = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %p1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %p2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %p3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %n1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %n2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = bitcast [3 x double]* %n3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %8) #4
    %9 = icmp sgt i32 %rings, 0
    br i1 %9, label %.lr.ph3, label %._crit_edge
  
  .lr.ph3:                                          ; preds = %0
    %10 = sitofp i32 %rings to double
    %11 = sitofp i32 %nsides to double
    br label %12
  
  .loopexit:                                        ; preds = %.lr.ph, %12
    %exitcond4 = icmp eq i32 %17, %rings
    br i1 %exitcond4, label %._crit_edge, label %12
  
  ; <label>:12                                      ; preds = %.loopexit, %.lr.ph3
    %IV.S.1 = phi double [ 0.000000e+00, %.lr.ph3 ], [ %IV.S.next.2, %.loopexit ]
    %i.02 = phi i32 [ 0, %.lr.ph3 ], [ %17, %.loopexit ]
    %13 = icmp sgt i32 %nsides, 0
    %14 = fmul double %IV.S.1, 2.000000e+00
    %15 = fmul double %14, 0x400921FB54442C46
    %16 = fdiv double %15, %10
    %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
    %17 = add nuw nsw i32 %i.02, 1
    %18 = sitofp i32 %17 to double
    %19 = fmul double %18, 2.000000e+00
    %20 = fmul double %19, 0x400921FB54442C46
    %21 = fdiv double %20, %10
    br i1 %13, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %12, %.lr.ph
    %IV.S. = phi double [ %IV.S.next., %.lr.ph ], [ 0.000000e+00, %12 ]
    %j.01 = phi i32 [ %33, %.lr.ph ], [ 0, %12 ]
    %22 = bitcast [3 x double]* %n3 to double*
    %23 = bitcast [3 x double]* %n2 to double*
    %24 = bitcast [3 x double]* %n1 to double*
    %25 = bitcast [3 x double]* %n0 to double*
    %26 = bitcast [3 x double]* %p3 to double*
    %27 = bitcast [3 x double]* %p2 to double*
    %28 = bitcast [3 x double]* %p1 to double*
    %29 = bitcast [3 x double]* %p0 to double*
    %30 = fmul double %IV.S., 2.000000e+00
    %31 = fmul double %30, 0x400921FB54442C46
    %32 = fdiv double %31, %11
    %IV.S.next. = fadd double %IV.S., 1.000000e+00
    %33 = add nuw nsw i32 %j.01, 1
    %34 = sitofp i32 %33 to double
    %35 = fmul double %34, 2.000000e+00
    %36 = fmul double %35, 0x400921FB54442C46
    %37 = fdiv double %36, %11
    %38 = call double @cos(double %16) #4
    %39 = call double @cos(double %32) #4
    %40 = fmul double %39, %r
    %41 = fadd double %40, %R
    %42 = fmul double %38, %41
    store double %42, double* %29, align 8, !tbaa !1
    %43 = call double @sin(double %16) #4
    %44 = call double @cos(double %32) #4
    %45 = fmul double %44, %r
    %46 = fadd double %45, %R
    %47 = fmul double %43, %46
    %48 = fsub double -0.000000e+00, %47
    %sunkaddr = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    store double %48, double* %sunkaddr4, align 8, !tbaa !1
    %49 = call double @sin(double %32) #4
    %50 = fmul double %49, %r
    %sunkaddr5 = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr6 = add i32 %sunkaddr5, 16
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %50, double* %sunkaddr7, align 8, !tbaa !1
    %51 = call double @cos(double %21) #4
    %52 = call double @cos(double %32) #4
    %53 = fmul double %52, %r
    %54 = fadd double %53, %R
    %55 = fmul double %51, %54
    store double %55, double* %28, align 8, !tbaa !1
    %56 = call double @sin(double %21) #4
    %57 = call double @cos(double %32) #4
    %58 = fmul double %57, %r
    %59 = fadd double %58, %R
    %60 = fmul double %56, %59
    %61 = fsub double -0.000000e+00, %60
    %sunkaddr8 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %61, double* %sunkaddr10, align 8, !tbaa !1
    %62 = call double @sin(double %32) #4
    %63 = fmul double %62, %r
    %sunkaddr11 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr12 = add i32 %sunkaddr11, 16
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %63, double* %sunkaddr13, align 8, !tbaa !1
    %64 = call double @cos(double %21) #4
    %65 = call double @cos(double %37) #4
    %66 = fmul double %65, %r
    %67 = fadd double %66, %R
    %68 = fmul double %64, %67
    store double %68, double* %27, align 8, !tbaa !1
    %69 = call double @sin(double %21) #4
    %70 = call double @cos(double %37) #4
    %71 = fmul double %70, %r
    %72 = fadd double %71, %R
    %73 = fmul double %69, %72
    %74 = fsub double -0.000000e+00, %73
    %sunkaddr14 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 8
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    store double %74, double* %sunkaddr16, align 8, !tbaa !1
    %75 = call double @sin(double %37) #4
    %76 = fmul double %75, %r
    %sunkaddr17 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %76, double* %sunkaddr19, align 8, !tbaa !1
    %77 = call double @cos(double %16) #4
    %78 = call double @cos(double %37) #4
    %79 = fmul double %78, %r
    %80 = fadd double %79, %R
    %81 = fmul double %77, %80
    store double %81, double* %26, align 8, !tbaa !1
    %82 = call double @sin(double %16) #4
    %83 = call double @cos(double %37) #4
    %84 = fmul double %83, %r
    %85 = fadd double %84, %R
    %86 = fmul double %82, %85
    %87 = fsub double -0.000000e+00, %86
    %sunkaddr20 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr21 = add i32 %sunkaddr20, 8
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %87, double* %sunkaddr22, align 8, !tbaa !1
    %88 = call double @sin(double %37) #4
    %89 = fmul double %88, %r
    %sunkaddr23 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %89, double* %sunkaddr25, align 8, !tbaa !1
    %90 = call double @cos(double %16) #4
    %91 = call double @cos(double %32) #4
    %92 = fmul double %90, %91
    store double %92, double* %25, align 8, !tbaa !1
    %93 = call double @sin(double %16) #4
    %94 = call double @cos(double %32) #4
    %95 = fmul double %93, %94
    %96 = fsub double -0.000000e+00, %95
    %sunkaddr26 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr27 = add i32 %sunkaddr26, 8
    %sunkaddr28 = inttoptr i32 %sunkaddr27 to double*
    store double %96, double* %sunkaddr28, align 8, !tbaa !1
    %97 = call double @sin(double %32) #4
    %sunkaddr29 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr30 = add i32 %sunkaddr29, 16
    %sunkaddr31 = inttoptr i32 %sunkaddr30 to double*
    store double %97, double* %sunkaddr31, align 8, !tbaa !1
    %98 = call double @cos(double %21) #4
    %99 = call double @cos(double %32) #4
    %100 = fmul double %98, %99
    store double %100, double* %24, align 8, !tbaa !1
    %101 = call double @sin(double %21) #4
    %102 = call double @cos(double %32) #4
    %103 = fmul double %101, %102
    %104 = fsub double -0.000000e+00, %103
    %sunkaddr32 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr33 = add i32 %sunkaddr32, 8
    %sunkaddr34 = inttoptr i32 %sunkaddr33 to double*
    store double %104, double* %sunkaddr34, align 8, !tbaa !1
    %105 = call double @sin(double %32) #4
    %sunkaddr35 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr36 = add i32 %sunkaddr35, 16
    %sunkaddr37 = inttoptr i32 %sunkaddr36 to double*
    store double %105, double* %sunkaddr37, align 8, !tbaa !1
    %106 = call double @cos(double %21) #4
    %107 = call double @cos(double %37) #4
    %108 = fmul double %106, %107
    store double %108, double* %23, align 8, !tbaa !1
    %109 = call double @sin(double %21) #4
    %110 = call double @cos(double %37) #4
    %111 = fmul double %109, %110
    %112 = fsub double -0.000000e+00, %111
    %sunkaddr38 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr39 = add i32 %sunkaddr38, 8
    %sunkaddr40 = inttoptr i32 %sunkaddr39 to double*
    store double %112, double* %sunkaddr40, align 8, !tbaa !1
    %113 = call double @sin(double %37) #4
    %sunkaddr41 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr42 = add i32 %sunkaddr41, 16
    %sunkaddr43 = inttoptr i32 %sunkaddr42 to double*
    store double %113, double* %sunkaddr43, align 8, !tbaa !1
    %114 = call double @cos(double %16) #4
    %115 = call double @cos(double %37) #4
    %116 = fmul double %114, %115
    store double %116, double* %22, align 8, !tbaa !1
    %117 = call double @sin(double %16) #4
    %118 = call double @cos(double %37) #4
    %119 = fmul double %117, %118
    %120 = fsub double -0.000000e+00, %119
    %sunkaddr44 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr45 = add i32 %sunkaddr44, 8
    %sunkaddr46 = inttoptr i32 %sunkaddr45 to double*
    store double %120, double* %sunkaddr46, align 8, !tbaa !1
    %121 = call double @sin(double %37) #4
    %sunkaddr47 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr48 = add i32 %sunkaddr47, 16
    %sunkaddr49 = inttoptr i32 %sunkaddr48 to double*
    store double %121, double* %sunkaddr49, align 8, !tbaa !1
    call void @m_xformpt(double* %29, double* %29, double* %25, double* %25) #4
    call void @m_xformpt(double* %28, double* %28, double* %24, double* %24) #4
    call void @m_xformpt(double* %27, double* %27, double* %23, double* %23) #4
    call void @m_xformpt(double* %26, double* %26, double* %22, double* %22) #4
    call void @glBegin(i32 signext %type) #4
    call void @glNormal3dv(double* %22) #4
    call void @glVertex3dv(double* %26) #4
    call void @glNormal3dv(double* %23) #4
    call void @glVertex3dv(double* %27) #4
    call void @glNormal3dv(double* %24) #4
    call void @glVertex3dv(double* %28) #4
    call void @glNormal3dv(double* %25) #4
    call void @glVertex3dv(double* %29) #4
    call void @glEnd() #4
    %exitcond = icmp eq i32 %nsides, %33
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.loopexit, %0
    %122 = bitcast [3 x double]* %n3 to i8*
    %123 = bitcast [3 x double]* %n2 to i8*
    %124 = bitcast [3 x double]* %n1 to i8*
    %125 = bitcast [3 x double]* %n0 to i8*
    %126 = bitcast [3 x double]* %p3 to i8*
    %127 = bitcast [3 x double]* %p2 to i8*
    %128 = bitcast [3 x double]* %p1 to i8*
    %129 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.end(i64 24, i8* %122) #4
    call void @llvm.lifetime.end(i64 24, i8* %123) #4
    call void @llvm.lifetime.end(i64 24, i8* %124) #4
    call void @llvm.lifetime.end(i64 24, i8* %125) #4
    call void @llvm.lifetime.end(i64 24, i8* %126) #4
    call void @llvm.lifetime.end(i64 24, i8* %127) #4
    call void @llvm.lifetime.end(i64 24, i8* %128) #4
    call void @llvm.lifetime.end(i64 24, i8* %129) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 8, i32 signext 15, i32 signext 7)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  declare void @glPushMatrix() #3
  
  declare void @glRotatef(float, float, float, float) #3
  
  declare void @glTranslatef(float, float, float) #3
  
  declare void @gluCylinder(%struct.GLUquadricObj*, double, double, double, i32 signext, i32 signext) #3
  
  declare void @glPopMatrix() #3
  
  ; Function Attrs: nounwind
  define void @auxSolidCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @icosahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 8, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 9, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 10, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 11, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 12, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 13, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 14, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 15, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 16, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 17, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 18, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 19, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireOctahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @octahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidOctahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireDodecahedron.center, i32 0, i32 0), double %23, i32 signext 2)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @dodecahedron(double* nocapture readonly %center, double %sc, i32 signext %type) unnamed_addr #0 {
    %.b = load i1, i1* @dodecahedron.inited, align 1
    br i1 %.b, label %2, label %1
  
  ; <label>:1                                       ; preds = %0
    store i1 true, i1* @dodecahedron.inited, align 1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 2), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 2), align 8, !tbaa !1
    br label %2
  
  ; <label>:2                                       ; preds = %1, %0
    tail call void @m_pushmatrix() #4
    %3 = load double, double* %center, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %center, i32 1
    %5 = load double, double* %4, align 8, !tbaa !1
    %6 = getelementptr inbounds double, double* %center, i32 2
    %7 = load double, double* %6, align 8, !tbaa !1
    tail call void @m_translate(double %3, double %5, double %7) #4
    tail call void @m_scale(double %sc, double %sc, double %sc) #4
    tail call fastcc void @pentagon(i32 signext 0, i32 signext 1, i32 signext 9, i32 signext 16, i32 signext 5, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 0, i32 signext 3, i32 signext 18, i32 signext 7, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 7, i32 signext 11, i32 signext 10, i32 signext 9, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 11, i32 signext 7, i32 signext 18, i32 signext 19, i32 signext 6, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 8, i32 signext 17, i32 signext 16, i32 signext 9, i32 signext 10, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 14, i32 signext 15, i32 signext 6, i32 signext 19, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 13, i32 signext 12, i32 signext 4, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 19, i32 signext 18, i32 signext 3, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 3, i32 signext 0, i32 signext 5, i32 signext 12, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 6, i32 signext 15, i32 signext 8, i32 signext 10, i32 signext 11, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 17, i32 signext 8, i32 signext 15, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 12, i32 signext 5, i32 signext 16, i32 signext 17, i32 signext %type)
    tail call void @m_popmatrix() #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidDodecahedron.center, i32 0, i32 0), double %23, i32 signext 6)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @compareParams(double* nocapture readonly %oneArray, double* nocapture readonly %twoArray, i32 signext %size) #2 {
    %1 = icmp sgt i32 %size, 0
    br i1 %1, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ 1, %0 ]
    %matches.05 = phi i32 [ %matches.1, %.lr.ph ], [ 1, %0 ]
    %.03 = phi double* [ %2, %.lr.ph ], [ %oneArray, %0 ]
    %.012 = phi double* [ %4, %.lr.ph ], [ %twoArray, %0 ]
    %2 = getelementptr inbounds double, double* %.03, i32 1
    %3 = load double, double* %.03, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %.012, i32 1
    %5 = load double, double* %.012, align 8, !tbaa !1
    %6 = fcmp une double %3, %5
    %matches.1 = select i1 %6, i32 0, i32 %matches.05
    %7 = icmp slt i32 %lsr.iv, %size
    %8 = icmp ne i32 %matches.1, 0
    %9 = and i1 %7, %8
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    %matches.0.lcssa = phi i32 [ 1, %0 ], [ %matches.1, %.lr.ph ]
    ret i32 %matches.0.lcssa
  }
  
  declare i32 @glGenLists(i32 signext) #3
  
  declare void @glBegin(i32 signext) #3
  
  declare void @glNormal3dv(double*) #3
  
  declare void @glVertex3dv(double*) #3
  
  declare void @glEnd() #3
  
  ; Function Attrs: nounwind
  declare double @cos(double) #0
  
  ; Function Attrs: nounwind
  declare double @sin(double) #0
  
  declare void @m_xformpt(double*, double*, double*, double*) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawtriangle(i32 signext %i, i32 signext %geomType, double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    %p1.i.i = alloca [3 x double], align 8
    %p2.i.i = alloca [3 x double], align 8
    %p3.i.i = alloca [3 x double], align 8
    %q0.i.i = alloca [3 x double], align 8
    %q1.i.i = alloca [3 x double], align 8
    %n11.i.i = alloca [3 x double], align 8
    switch i32 %geomType, label %31 [
      i32 0, label %1
      i32 1, label %11
      i32 2, label %21
    ]
  
  ; <label>:1                                       ; preds = %0
    %2 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 0
    %3 = load i32, i32* %2, align 4, !tbaa !13
    %4 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %3, i32 0
    %5 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 1
    %6 = load i32, i32* %5, align 4, !tbaa !13
    %7 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %6, i32 0
    %8 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 2
    %9 = load i32, i32* %8, align 4, !tbaa !13
    %10 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %9, i32 0
    br label %31
  
  ; <label>:11                                      ; preds = %0
    %12 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 0
    %13 = load i32, i32* %12, align 4, !tbaa !13
    %14 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %13, i32 0
    %15 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 1
    %16 = load i32, i32* %15, align 4, !tbaa !13
    %17 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %16, i32 0
    %18 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 2
    %19 = load i32, i32* %18, align 4, !tbaa !13
    %20 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %19, i32 0
    br label %31
  
  ; <label>:21                                      ; preds = %0
    %22 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 0
    %23 = load i32, i32* %22, align 4, !tbaa !13
    %24 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %23, i32 0
    %25 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 1
    %26 = load i32, i32* %25, align 4, !tbaa !13
    %27 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %26, i32 0
    %28 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 2
    %29 = load i32, i32* %28, align 4, !tbaa !13
    %30 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %29, i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %21, %11, %1, %0
    %x0.0 = phi double* [ undef, %0 ], [ %24, %21 ], [ %14, %11 ], [ %4, %1 ]
    %x1.0 = phi double* [ undef, %0 ], [ %27, %21 ], [ %17, %11 ], [ %7, %1 ]
    %x2.0 = phi double* [ undef, %0 ], [ %30, %21 ], [ %20, %11 ], [ %10, %1 ]
    %32 = load double, double* %x0.0, align 8, !tbaa !1
    %33 = fmul double %32, 0.000000e+00
    %34 = load double, double* %x1.0, align 8, !tbaa !1
    %35 = fmul double %34, 0.000000e+00
    %36 = fadd double %33, %35
    %37 = load double, double* %x2.0, align 8, !tbaa !1
    %38 = fadd double %37, %36
    %39 = fadd double %32, %35
    %40 = fmul double %37, 0.000000e+00
    %41 = fadd double %39, %40
    %42 = fadd double %33, %34
    %43 = fadd double %42, %40
    %44 = getelementptr inbounds double, double* %x0.0, i32 1
    %45 = load double, double* %44, align 8, !tbaa !1
    %46 = fmul double %45, 0.000000e+00
    %47 = getelementptr inbounds double, double* %x1.0, i32 1
    %48 = load double, double* %47, align 8, !tbaa !1
    %49 = fmul double %48, 0.000000e+00
    %50 = fadd double %46, %49
    %51 = getelementptr inbounds double, double* %x2.0, i32 1
    %52 = load double, double* %51, align 8, !tbaa !1
    %53 = fadd double %52, %50
    %54 = fadd double %45, %49
    %55 = fmul double %52, 0.000000e+00
    %56 = fadd double %54, %55
    %57 = fadd double %46, %48
    %58 = fadd double %57, %55
    %59 = getelementptr inbounds double, double* %x0.0, i32 2
    %60 = load double, double* %59, align 8, !tbaa !1
    %61 = fmul double %60, 0.000000e+00
    %62 = getelementptr inbounds double, double* %x1.0, i32 2
    %63 = load double, double* %62, align 8, !tbaa !1
    %64 = fmul double %63, 0.000000e+00
    %65 = fadd double %61, %64
    %66 = getelementptr inbounds double, double* %x2.0, i32 2
    %67 = load double, double* %66, align 8, !tbaa !1
    %68 = fadd double %67, %65
    %69 = fadd double %60, %64
    %70 = fmul double %67, 0.000000e+00
    %71 = fadd double %69, %70
    %72 = fadd double %61, %63
    %73 = fadd double %72, %70
    %74 = fmul double %38, %38
    %75 = fmul double %53, %53
    %76 = fadd double %74, %75
    %77 = fmul double %68, %68
    %78 = fadd double %76, %77
    %79 = tail call double @sqrt(double %78) #5
    %80 = fcmp oeq double %79, %79
    br i1 %80, label %.split, label %call.sqrt
  
  call.sqrt:                                        ; preds = %31
    %81 = tail call double @sqrt(double %78) #4
    br label %.split
  
  .split:                                           ; preds = %31, %call.sqrt
    %82 = phi double [ %79, %31 ], [ %81, %call.sqrt ]
    %83 = fdiv double %38, %82
    %84 = fdiv double %53, %82
    %85 = fdiv double %68, %82
    %86 = fmul double %41, %41
    %87 = fmul double %56, %56
    %88 = fadd double %86, %87
    %89 = fmul double %71, %71
    %90 = fadd double %88, %89
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %.split.split, label %call.sqrt1
  
  call.sqrt1:                                       ; preds = %.split
    %93 = tail call double @sqrt(double %90) #4
    br label %.split.split
  
  .split.split:                                     ; preds = %.split, %call.sqrt1
    %94 = phi double [ %91, %.split ], [ %93, %call.sqrt1 ]
    %95 = fdiv double %41, %94
    %96 = fdiv double %56, %94
    %97 = fdiv double %71, %94
    %98 = fmul double %43, %43
    %99 = fmul double %58, %58
    %100 = fadd double %98, %99
    %101 = fmul double %73, %73
    %102 = fadd double %100, %101
    %103 = tail call double @sqrt(double %102) #5
    %104 = fcmp oeq double %103, %103
    br i1 %104, label %.split.split.split, label %call.sqrt2
  
  call.sqrt2:                                       ; preds = %.split.split
    %105 = tail call double @sqrt(double %102) #4
    br label %.split.split.split
  
  .split.split.split:                               ; preds = %.split.split, %call.sqrt2
    %106 = phi double [ %103, %.split.split ], [ %105, %call.sqrt2 ]
    %107 = bitcast [3 x double]* %n11.i.i to double*
    %108 = bitcast [3 x double]* %q1.i.i to double*
    %109 = bitcast [3 x double]* %q0.i.i to double*
    %110 = bitcast [3 x double]* %p3.i.i to double*
    %111 = bitcast [3 x double]* %p2.i.i to double*
    %112 = bitcast [3 x double]* %p1.i.i to double*
    %113 = bitcast [3 x double]* %n11.i.i to i8*
    %114 = bitcast [3 x double]* %q1.i.i to i8*
    %115 = bitcast [3 x double]* %q0.i.i to i8*
    %116 = bitcast [3 x double]* %p3.i.i to i8*
    %117 = bitcast [3 x double]* %p2.i.i to i8*
    %118 = bitcast [3 x double]* %p1.i.i to i8*
    %119 = fdiv double %43, %106
    %120 = fdiv double %58, %106
    %121 = fdiv double %73, %106
    call void @llvm.lifetime.start(i64 24, i8* %118) #4
    call void @llvm.lifetime.start(i64 24, i8* %117) #4
    call void @llvm.lifetime.start(i64 24, i8* %116) #4
    call void @llvm.lifetime.start(i64 24, i8* %115) #4
    call void @llvm.lifetime.start(i64 24, i8* %114) #4
    call void @llvm.lifetime.start(i64 24, i8* %113) #4
    %122 = fmul double %95, %radius
    %123 = load double, double* %p0, align 8, !tbaa !1
    %124 = fadd double %122, %123
    store double %124, double* %112, align 8, !tbaa !1
    %125 = fmul double %83, %radius
    %126 = fadd double %125, %123
    store double %126, double* %111, align 8, !tbaa !1
    %127 = fmul double %119, %radius
    %128 = fadd double %127, %123
    store double %128, double* %110, align 8, !tbaa !1
    %129 = fmul double %96, %radius
    %sunkaddr = ptrtoint double* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    %130 = load double, double* %sunkaddr4, align 8, !tbaa !1
    %131 = fadd double %129, %130
    %sunkaddr5 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr6 = add i32 %sunkaddr5, 8
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %131, double* %sunkaddr7, align 8, !tbaa !1
    %132 = fmul double %84, %radius
    %133 = fadd double %132, %130
    %sunkaddr8 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %133, double* %sunkaddr10, align 8, !tbaa !1
    %134 = fmul double %120, %radius
    %135 = fadd double %134, %130
    %sunkaddr11 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr12 = add i32 %sunkaddr11, 8
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %135, double* %sunkaddr13, align 8, !tbaa !1
    %136 = fmul double %97, %radius
    %sunkaddr14 = ptrtoint double* %p0 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 16
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    %137 = load double, double* %sunkaddr16, align 8, !tbaa !1
    %138 = fadd double %136, %137
    %sunkaddr17 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %138, double* %sunkaddr19, align 8, !tbaa !1
    %139 = fmul double %85, %radius
    %140 = fadd double %139, %137
    %sunkaddr20 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr21 = add i32 %sunkaddr20, 16
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %140, double* %sunkaddr22, align 8, !tbaa !1
    %141 = fmul double %121, %radius
    %142 = fadd double %141, %137
    %sunkaddr23 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %142, double* %sunkaddr25, align 8, !tbaa !1
    call void @diff3(double* %112, double* %111, double* %109) #4
    call void @diff3(double* %111, double* %110, double* %108) #4
    call void @crossprod(double* %109, double* %108, double* %108) #4
    call void @normalize(double* %108) #4
    call void @m_xformpt(double* %112, double* %112, double* %108, double* %107) #4
    call void @m_xformptonly(double* %111, double* %111) #4
    call void @m_xformptonly(double* %110, double* %110) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %107) #4
    call void @glVertex3dv(double* %112) #4
    call void @glVertex3dv(double* %111) #4
    call void @glVertex3dv(double* %110) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %113) #4
    call void @llvm.lifetime.end(i64 24, i8* %114) #4
    call void @llvm.lifetime.end(i64 24, i8* %115) #4
    call void @llvm.lifetime.end(i64 24, i8* %116) #4
    call void @llvm.lifetime.end(i64 24, i8* %117) #4
    call void @llvm.lifetime.end(i64 24, i8* %118) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  declare void @diff3(double*, double*, double*) #3
  
  declare void @crossprod(double*, double*, double*) #3
  
  declare void @normalize(double*) #3
  
  declare void @m_xformptonly(double*, double*) #3
  
  declare void @m_pushmatrix() #3
  
  declare void @m_translate(double, double, double) #3
  
  declare void @m_scale(double, double, double) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @pentagon(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %shadeType) unnamed_addr #0 {
    %n0 = alloca [3 x double], align 8
    %d1 = alloca [3 x double], align 8
    %d2 = alloca [3 x double], align 8
    %d3 = alloca [3 x double], align 8
    %d4 = alloca [3 x double], align 8
    %d5 = alloca [3 x double], align 8
    %nout = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %d1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %d2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %d3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %d4 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %d5 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %nout to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %a, i32 0
    %9 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %b, i32 0
    %10 = bitcast [3 x double]* %d1 to double*
    call void @diff3(double* %8, double* %9, double* %10) #4
    %11 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %c, i32 0
    %12 = bitcast [3 x double]* %d2 to double*
    call void @diff3(double* %9, double* %11, double* %12) #4
    %13 = bitcast [3 x double]* %n0 to double*
    call void @crossprod(double* %10, double* %12, double* %13) #4
    call void @normalize(double* %13) #4
    %14 = bitcast [3 x double]* %nout to double*
    call void @m_xformpt(double* %8, double* %10, double* %13, double* %14) #4
    call void @m_xformptonly(double* %9, double* %12) #4
    %15 = bitcast [3 x double]* %d3 to double*
    call void @m_xformptonly(double* %11, double* %15) #4
    %16 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %d, i32 0
    %17 = bitcast [3 x double]* %d4 to double*
    call void @m_xformptonly(double* %16, double* %17) #4
    %18 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %e, i32 0
    %19 = bitcast [3 x double]* %d5 to double*
    call void @m_xformptonly(double* %18, double* %19) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %14) #4
    call void @glVertex3dv(double* %10) #4
    call void @glVertex3dv(double* %12) #4
    call void @glVertex3dv(double* %15) #4
    call void @glVertex3dv(double* %17) #4
    call void @glVertex3dv(double* %19) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %7) #4
    call void @llvm.lifetime.end(i64 24, i8* %6) #4
    call void @llvm.lifetime.end(i64 24, i8* %5) #4
    call void @llvm.lifetime.end(i64 24, i8* %4) #4
    call void @llvm.lifetime.end(i64 24, i8* %3) #4
    call void @llvm.lifetime.end(i64 24, i8* %2) #4
    call void @llvm.lifetime.end(i64 24, i8* %1) #4
    ret void
  }
  
  declare void @m_popmatrix() #3
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { norecurse nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { nounwind }
  attributes #5 = { nounwind readnone }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !2, i64 0}
  !2 = !{!"double", !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"any pointer", !3, i64 0}
  !7 = !{!8, !6, i64 12}
  !8 = !{!"model", !9, i64 0, !6, i64 4, !9, i64 8, !6, i64 12}
  !9 = !{!"int", !3, i64 0}
  !10 = !{!8, !9, i64 0}
  !11 = !{!8, !9, i64 8}
  !12 = !{!8, !6, i64 4}
  !13 = !{!9, !9, i64 0}

...
---
name:            auxWireBox
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: afgr64 }
  - { id: 13, class: afgr64 }
  - { id: 14, class: afgr64 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: afgr64 }
  - { id: 24, class: afgr64 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: afgr64 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: afgr64 }
  - { id: 45, class: afgr64 }
  - { id: 46, class: afgr64 }
  - { id: 47, class: afgr64 }
  - { id: 48, class: afgr64 }
  - { id: 49, class: afgr64 }
  - { id: 50, class: afgr64 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
liveins:         
  - { reg: '%d6', virtual-reg: '%12' }
  - { reg: '%d7', virtual-reg: '%13' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    8
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 16, size: 8, alignment: 8, isImmutable: true, isAliased: false }
constants:       
  - id:              0
    value:           double 5.000000e-01
    alignment:       8
  - id:              1
    value:           double -5.000000e-01
    alignment:       8
body:             |
  bb.0 (%ir-block.0, freq 40):
    successors: %bb.6.findList.exit.thread(37), %bb.10(62)
    liveins: %d6, %d7, %t9, %v0
  
    %15 = ADDu %v0, %t9
    %13 = COPY %d7
    %12 = COPY %d6
    %14 = LDC1 %fixed-stack.0, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from stack)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %16 = LW %15, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %17 = ADDiu %zero, 24
    %a0 = COPY %17
    %gp = COPY %15
    %t9 = COPY %16
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %18 = COPY %v0
    SDC1 %12, %18, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.2, !tbaa !1)
    %19 = LW %15, target-flags(<unknown>) @lists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SDC1 %13, %18, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.4, !tbaa !1)
    SDC1 %14, %18, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.6, !tbaa !1)
    %20 = ADDiu %19, target-flags(<unknown>) @lists
    %1 = LW %20, 8, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from `%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2)`, !tbaa !5)
    %0 = COPY %18
    BEQ %1, %zero, %bb.6.findList.exit.thread, implicit-def %at
  
  bb.10 (freq 25):
    successors: %bb.1..lr.ph.i(100)
  
  
  bb.1..lr.ph.i (freq 409):
    successors: %bb.2..lr.ph.i.i(100)
  
    %2 = PHI %1, %bb.10, %10, %bb.4
    %3 = LW %2, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.8, !tbaa !7)
    %22 = ADDiu %zero, 1
    %21 = ADDiu %zero, 0
  
  bb.2..lr.ph.i.i (freq 13107):
    successors: %bb.9..lr.ph.i.i(98), %bb.3.compareParams.exit.i(1)
  
    %4 = PHI %21, %bb.1..lr.ph.i, %9, %bb.9..lr.ph.i.i
    %5 = PHI %22, %bb.1..lr.ph.i, %8, %bb.9..lr.ph.i.i
    %6 = PHI %22, %bb.1..lr.ph.i, %7, %bb.9..lr.ph.i.i
    %23 = LDXC1 %0, %4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from %ir.scevgep4, !tbaa !1)
    %24 = LDXC1 %3, %4, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 8 from %ir.uglygep3, !tbaa !1)
    FCMP_D32 killed %24, killed %23, 18, implicit-def %fcc0
    %7 = MOVF_I killed %zero, %fcc0, %6
    %26 = SLTi %5, 3
    BEQ killed %26, %zero, %bb.3.compareParams.exit.i, implicit-def dead %at
    B %bb.9..lr.ph.i.i, implicit-def dead %at
  
  bb.9..lr.ph.i.i (freq 12902):
    successors: %bb.2..lr.ph.i.i(98), %bb.3.compareParams.exit.i(1)
  
    %9 = ADDiu %4, 8
    %8 = ADDiu %5, 1
    BNE %7, %zero, %bb.2..lr.ph.i.i, implicit-def dead %at
    B %bb.3.compareParams.exit.i, implicit-def dead %at
  
  bb.3.compareParams.exit.i (freq 409):
    successors: %bb.4(96), %bb.5.findList.exit(3)
  
    BNE %7, %zero, %bb.5.findList.exit, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.18, freq 396):
    successors: %bb.6.findList.exit.thread(3), %bb.1..lr.ph.i(96)
  
    %10 = LW %2, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.19, !tbaa !5)
    BEQ %10, %zero, %bb.6.findList.exit.thread, implicit-def dead %at
    B %bb.1..lr.ph.i, implicit-def dead %at
  
  bb.5.findList.exit (freq 12):
    successors: %bb.6.findList.exit.thread(37), %bb.7(62)
  
    %11 = LW %2, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.21, !tbaa !10)
    BNE %11, %zero, %bb.7, implicit-def dead %at
    B %bb.6.findList.exit.thread, implicit-def dead %at
  
  bb.6.findList.exit.thread (freq 32):
    successors: %bb.8(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %29 = LW %15, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %30 = ADDiu %zero, 16
    %a0 = COPY %30
    %t9 = COPY %29
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %31 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %32 = LW %15, target-flags(<unknown>) @glGenLists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glGenLists)
    %33 = ADDiu %zero, 1
    %a0 = COPY %33
    %gp = COPY %15
    %t9 = COPY %32
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %34 = COPY %v0
    %37 = ADDiu %zero, 3
    %38 = ADDiu %zero, 4865
    SW %34, %31, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.26, !tbaa !10)
    SW killed %37, %31, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.28, !tbaa !11)
    SW %0, %31, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.30, !tbaa !7)
    %39 = LW %20, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*)`, !tbaa !5)
    SW killed %39, %31, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.33, !tbaa !12)
    SW %31, %20, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**)`, !tbaa !5)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %40 = LW %15, target-flags(<unknown>) @glNewList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glNewList)
    %a0 = COPY %34
    %a1 = COPY %38
    %gp = COPY %15
    %t9 = COPY %40
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %41 = LW %15, target-flags(<unknown>) %const.0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %42 = LDC1 killed %41, target-flags(<unknown>) %const.0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %43 = LW %15, target-flags(<unknown>) %const.1, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %44 = LDC1 killed %43, target-flags(<unknown>) %const.1, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %45 = FMUL_D32 %12, %44
    %46 = FMUL_D32 %12, %42
    %47 = FMUL_D32 %13, %44
    %48 = FMUL_D32 %13, %42
    %49 = FMUL_D32 %14, %44
    %50 = FMUL_D32 %14, %42
    %51 = LW %15, target-flags(<unknown>) @drawbox, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %52 = ADDiu killed %51, target-flags(<unknown>) @drawbox
    %53 = ADDiu %zero, 2
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %d0 = COPY %45
    %d1 = COPY %46
    %d2 = COPY %47
    %d3 = COPY %48
    %d4 = COPY %49
    %d5 = COPY %50
    %a0 = COPY %53
    %t9 = COPY %52
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d0, implicit %d1, implicit %d2, implicit %d3, implicit %d4, implicit %d5, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %54 = LW %15, target-flags(<unknown>) @glEndList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glEndList)
    %gp = COPY %15
    %t9 = COPY %54
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.8, implicit-def dead %at
  
  bb.7 (%ir-block.40, freq 7):
    successors: %bb.8(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %27 = LW %15, target-flags(<unknown>) @glCallList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glCallList)
    %a0 = COPY %11
    %gp = COPY %15
    %t9 = COPY %27
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %28 = LW %15, target-flags(<unknown>) @free, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @free)
    %a0 = COPY %0
    %gp = COPY %15
    %t9 = COPY %28
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.8 (%ir-block.41, freq 40):
    liveouts:
  
    RetRA

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/mesa/mesa.shapes.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.model = type { i32, %struct.model*, i32, double* }
  %struct.GLUquadricObj = type opaque
  
  @auxWireIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @lists = internal unnamed_addr global [25 x %struct.model*] zeroinitializer, align 4
  @drawbox.n = internal global [6 x [3 x double]] [[3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @drawbox.faces = internal unnamed_addr constant [6 x [4 x i32]] [[4 x i32] [i32 0, i32 1, i32 2, i32 3], [4 x i32] [i32 3, i32 2, i32 6, i32 7], [4 x i32] [i32 7, i32 6, i32 5, i32 4], [4 x i32] [i32 4, i32 5, i32 1, i32 0], [4 x i32] [i32 5, i32 6, i32 2, i32 1], [4 x i32] [i32 7, i32 4, i32 0, i32 3]], align 4
  @iindex = internal unnamed_addr constant [20 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 1], [3 x i32] [i32 0, i32 9, i32 4], [3 x i32] [i32 9, i32 5, i32 4], [3 x i32] [i32 4, i32 5, i32 8], [3 x i32] [i32 4, i32 8, i32 1], [3 x i32] [i32 8, i32 10, i32 1], [3 x i32] [i32 8, i32 3, i32 10], [3 x i32] [i32 5, i32 3, i32 8], [3 x i32] [i32 5, i32 2, i32 3], [3 x i32] [i32 2, i32 7, i32 3], [3 x i32] [i32 7, i32 10, i32 3], [3 x i32] [i32 7, i32 6, i32 10], [3 x i32] [i32 7, i32 11, i32 6], [3 x i32] [i32 11, i32 0, i32 6], [3 x i32] [i32 0, i32 1, i32 6], [3 x i32] [i32 6, i32 1, i32 10], [3 x i32] [i32 9, i32 0, i32 11], [3 x i32] [i32 9, i32 11, i32 2], [3 x i32] [i32 9, i32 2, i32 5], [3 x i32] [i32 7, i32 2, i32 11]], align 4
  @idata = internal global [12 x [3 x double]] [[3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00]], align 8
  @ondex = internal unnamed_addr constant [8 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 2], [3 x i32] [i32 1, i32 2, i32 4], [3 x i32] [i32 0, i32 3, i32 4], [3 x i32] [i32 1, i32 4, i32 3], [3 x i32] [i32 0, i32 2, i32 5], [3 x i32] [i32 1, i32 5, i32 2], [3 x i32] [i32 0, i32 5, i32 3], [3 x i32] [i32 1, i32 3, i32 5]], align 4
  @odata = internal global [6 x [3 x double]] [[3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @tndex = internal unnamed_addr constant [4 x [3 x i32]] [[3 x i32] [i32 0, i32 1, i32 3], [3 x i32] [i32 2, i32 1, i32 0], [3 x i32] [i32 3, i32 2, i32 0], [3 x i32] [i32 1, i32 2, i32 3]], align 4
  @tdata = internal global [4 x [3 x double]] [[3 x double] [double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA], [3 x double] [double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA]], align 8
  @dodecahedron.inited = internal unnamed_addr global i1 false
  @dodec = internal global [20 x [3 x double]] zeroinitializer, align 8
  
  ; Function Attrs: nounwind
  define void @auxWireSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast ([25 x %struct.model*]* @lists to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast ([25 x %struct.model*]* @lists to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100011) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare noalias i8* @malloc(i32 signext) #0
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @findList(i32 signext %lindex, double* nocapture readonly %paramArray, i32 signext %size) #2 {
    %1 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %endList.02 = load %struct.model*, %struct.model** %1, align 4, !tbaa !5
    %2 = icmp eq %struct.model* %endList.02, null
    br i1 %2, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0
    br label %3
  
  ; <label>:3                                       ; preds = %18, %.lr.ph
    %endList.03 = phi %struct.model* [ %endList.02, %.lr.ph ], [ %endList.0, %18 ]
    %4 = icmp sgt i32 %size, 0
    br i1 %4, label %.lr.ph.i.preheader, label %compareParams.exit.thread
  
  .lr.ph.i.preheader:                               ; preds = %3
    %5 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 3
    %6 = load double*, double** %5, align 4, !tbaa !7
    br label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %matches.05.i = phi i32 [ %matches.1.i, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %.03.i = phi double* [ %7, %.lr.ph.i ], [ %6, %.lr.ph.i.preheader ]
    %.012.i = phi double* [ %9, %.lr.ph.i ], [ %paramArray, %.lr.ph.i.preheader ]
    %7 = getelementptr inbounds double, double* %.03.i, i32 1
    %8 = load double, double* %.03.i, align 8, !tbaa !1
    %9 = getelementptr inbounds double, double* %.012.i, i32 1
    %10 = load double, double* %.012.i, align 8, !tbaa !1
    %11 = fcmp une double %8, %10
    %matches.1.i = select i1 %11, i32 0, i32 %matches.05.i
    %12 = icmp slt i32 %lsr.iv, %size
    %13 = icmp ne i32 %matches.1.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %14, label %.lr.ph.i, label %compareParams.exit
  
  compareParams.exit:                               ; preds = %.lr.ph.i
    %15 = icmp eq i32 %matches.1.i, 0
    br i1 %15, label %18, label %compareParams.exit.thread
  
  compareParams.exit.thread:                        ; preds = %compareParams.exit, %3
    %16 = bitcast %struct.model* %endList.03 to i32*
    %17 = load i32, i32* %16, align 4, !tbaa !10
    br label %.loopexit
  
  ; <label>:18                                      ; preds = %compareParams.exit
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 1
    %endList.0 = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0, null
    br i1 %20, label %.loopexit, label %3
  
  .loopexit:                                        ; preds = %18, %compareParams.exit.thread, %0
    %.0 = phi i32 [ %17, %compareParams.exit.thread ], [ 0, %0 ], [ 0, %18 ]
    ret i32 %.0
  }
  
  declare void @glNewList(i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @makeModelPtr(i32 signext %lindex, double* %sizeArray, i32 signext %count) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = tail call i32 @glGenLists(i32 signext 1) #4
    %3 = bitcast i8* %1 to i32*
    store i32 %2, i32* %3, align 4, !tbaa !10
    %4 = getelementptr inbounds i8, i8* %1, i32 8
    %5 = bitcast i8* %4 to i32*
    store i32 %count, i32* %5, align 4, !tbaa !11
    %6 = getelementptr inbounds i8, i8* %1, i32 12
    %7 = bitcast i8* %6 to double**
    store double* %sizeArray, double** %7, align 4, !tbaa !7
    %8 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %9 = bitcast %struct.model** %8 to i32*
    %10 = load i32, i32* %9, align 4, !tbaa !5
    %11 = getelementptr inbounds i8, i8* %1, i32 4
    %12 = bitcast i8* %11 to i32*
    store i32 %10, i32* %12, align 4, !tbaa !12
    %13 = bitcast %struct.model** %8 to i8**
    store i8* %1, i8** %13, align 4, !tbaa !5
    ret i32 %2
  }
  
  declare %struct.GLUquadricObj* @gluNewQuadric() #3
  
  declare void @gluQuadricDrawStyle(%struct.GLUquadricObj*, i32 signext) #3
  
  declare void @gluSphere(%struct.GLUquadricObj*, double, i32 signext, i32 signext) #3
  
  declare void @glEndList() #3
  
  declare void @glCallList(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  define void @auxSolidSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %23, i32 signext 100000) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  declare void @gluQuadricNormals(%struct.GLUquadricObj*, i32 signext) #3
  
  ; Function Attrs: nounwind
  define void @auxWireCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 2)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawbox(double %x0, double %x1, double %y0, double %y1, double %z0, double %z1, i32 signext %type) unnamed_addr #0 {
    %v = alloca [8 x [3 x double]], align 8
    %1 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.start(i64 192, i8* %1) #4
    %2 = fcmp ogt double %x0, %x1
    %.05 = select i1 %2, double %x0, double %x1
    %.0 = select i1 %2, double %x1, double %x0
    %3 = fcmp ogt double %y0, %y1
    %.04 = select i1 %3, double %y1, double %y0
    %.03 = select i1 %3, double %y0, double %y1
    %4 = fcmp ogt double %z0, %z1
    %.02 = select i1 %4, double %z1, double %z0
    %.01 = select i1 %4, double %z0, double %z1
    %5 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 0
    store double %.0, double* %5, align 8, !tbaa !1
    %6 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 0
    store double %.0, double* %6, align 8, !tbaa !1
    %7 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 0
    store double %.0, double* %7, align 8, !tbaa !1
    %8 = bitcast [8 x [3 x double]]* %v to double*
    store double %.0, double* %8, align 8, !tbaa !1
    %9 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 0
    store double %.05, double* %9, align 8, !tbaa !1
    %10 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 0
    store double %.05, double* %10, align 8, !tbaa !1
    %11 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 0
    store double %.05, double* %11, align 8, !tbaa !1
    %12 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 0
    store double %.05, double* %12, align 8, !tbaa !1
    %13 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 1
    store double %.04, double* %13, align 8, !tbaa !1
    %14 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 1
    store double %.04, double* %14, align 8, !tbaa !1
    %15 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 1
    store double %.04, double* %15, align 8, !tbaa !1
    %16 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 1
    store double %.04, double* %16, align 8, !tbaa !1
    %17 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 1
    store double %.03, double* %17, align 8, !tbaa !1
    %18 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 1
    store double %.03, double* %18, align 8, !tbaa !1
    %19 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 1
    store double %.03, double* %19, align 8, !tbaa !1
    %20 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 1
    store double %.03, double* %20, align 8, !tbaa !1
    %21 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 2
    store double %.02, double* %21, align 8, !tbaa !1
    %22 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 2
    store double %.02, double* %22, align 8, !tbaa !1
    %23 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 2
    store double %.02, double* %23, align 8, !tbaa !1
    %24 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 2
    store double %.02, double* %24, align 8, !tbaa !1
    %25 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 2
    store double %.01, double* %25, align 8, !tbaa !1
    %26 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 2
    store double %.01, double* %26, align 8, !tbaa !1
    %27 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 2
    store double %.01, double* %27, align 8, !tbaa !1
    %28 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 2
    store double %.01, double* %28, align 8, !tbaa !1
    br label %29
  
  ; <label>:29                                      ; preds = %29, %0
    %lsr.iv1 = phi [6 x [4 x i32]]* [ %38, %29 ], [ bitcast (i32* getelementptr inbounds ([6 x [4 x i32]], [6 x [4 x i32]]* @drawbox.faces, i32 0, i32 0, i32 2) to [6 x [4 x i32]]*), %0 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %29 ], [ 0, %0 ]
    %lsr.iv12 = bitcast [6 x [4 x i32]]* %lsr.iv1 to i32*
    call void @glBegin(i32 signext %type) #4
    %uglygep11 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep1112 = bitcast i8* %uglygep11 to double*
    call void @glNormal3dv(double* %uglygep1112) #4
    %scevgep5 = getelementptr i32, i32* %lsr.iv12, i32 -2
    %30 = load i32, i32* %scevgep5, align 4, !tbaa !13
    %31 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %30, i32 0
    call void @glVertex3dv(double* %31) #4
    %uglygep9 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep910 = bitcast i8* %uglygep9 to double*
    call void @glNormal3dv(double* %uglygep910) #4
    %scevgep4 = getelementptr i32, i32* %lsr.iv12, i32 -1
    %32 = load i32, i32* %scevgep4, align 4, !tbaa !13
    %33 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %32, i32 0
    call void @glVertex3dv(double* %33) #4
    %uglygep7 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep78 = bitcast i8* %uglygep7 to double*
    call void @glNormal3dv(double* %uglygep78) #4
    %34 = load i32, i32* %lsr.iv12, align 4, !tbaa !13
    %35 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %34, i32 0
    call void @glVertex3dv(double* %35) #4
    %uglygep = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep6 = bitcast i8* %uglygep to double*
    call void @glNormal3dv(double* %uglygep6) #4
    %scevgep3 = getelementptr i32, i32* %lsr.iv12, i32 1
    %36 = load i32, i32* %scevgep3, align 4, !tbaa !13
    %37 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %36, i32 0
    call void @glVertex3dv(double* %37) #4
    call void @glEnd() #4
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 24
    %scevgep = getelementptr [6 x [4 x i32]], [6 x [4 x i32]]* %lsr.iv1, i32 0, i32 1, i32 0
    %38 = bitcast i32* %scevgep to [6 x [4 x i32]]*
    %exitcond = icmp eq i32 %lsr.iv.next, 144
    br i1 %exitcond, label %39, label %29
  
  ; <label>:39                                      ; preds = %29
    %40 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.end(i64 192, i8* %40) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 7)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 2)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 7)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 5, i32 signext 10, i32 signext 2)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @doughnut(double %r, double %R, i32 signext %nsides, i32 signext %rings, i32 signext %type) unnamed_addr #0 {
    %p0 = alloca [3 x double], align 8
    %p1 = alloca [3 x double], align 8
    %p2 = alloca [3 x double], align 8
    %p3 = alloca [3 x double], align 8
    %n0 = alloca [3 x double], align 8
    %n1 = alloca [3 x double], align 8
    %n2 = alloca [3 x double], align 8
    %n3 = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %p1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %p2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %p3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %n1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %n2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = bitcast [3 x double]* %n3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %8) #4
    %9 = icmp sgt i32 %rings, 0
    br i1 %9, label %.lr.ph3, label %._crit_edge
  
  .lr.ph3:                                          ; preds = %0
    %10 = sitofp i32 %rings to double
    %11 = sitofp i32 %nsides to double
    br label %12
  
  .loopexit:                                        ; preds = %.lr.ph, %12
    %exitcond4 = icmp eq i32 %17, %rings
    br i1 %exitcond4, label %._crit_edge, label %12
  
  ; <label>:12                                      ; preds = %.loopexit, %.lr.ph3
    %IV.S.1 = phi double [ 0.000000e+00, %.lr.ph3 ], [ %IV.S.next.2, %.loopexit ]
    %i.02 = phi i32 [ 0, %.lr.ph3 ], [ %17, %.loopexit ]
    %13 = icmp sgt i32 %nsides, 0
    %14 = fmul double %IV.S.1, 2.000000e+00
    %15 = fmul double %14, 0x400921FB54442C46
    %16 = fdiv double %15, %10
    %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
    %17 = add nuw nsw i32 %i.02, 1
    %18 = sitofp i32 %17 to double
    %19 = fmul double %18, 2.000000e+00
    %20 = fmul double %19, 0x400921FB54442C46
    %21 = fdiv double %20, %10
    br i1 %13, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %12, %.lr.ph
    %IV.S. = phi double [ %IV.S.next., %.lr.ph ], [ 0.000000e+00, %12 ]
    %j.01 = phi i32 [ %33, %.lr.ph ], [ 0, %12 ]
    %22 = bitcast [3 x double]* %n3 to double*
    %23 = bitcast [3 x double]* %n2 to double*
    %24 = bitcast [3 x double]* %n1 to double*
    %25 = bitcast [3 x double]* %n0 to double*
    %26 = bitcast [3 x double]* %p3 to double*
    %27 = bitcast [3 x double]* %p2 to double*
    %28 = bitcast [3 x double]* %p1 to double*
    %29 = bitcast [3 x double]* %p0 to double*
    %30 = fmul double %IV.S., 2.000000e+00
    %31 = fmul double %30, 0x400921FB54442C46
    %32 = fdiv double %31, %11
    %IV.S.next. = fadd double %IV.S., 1.000000e+00
    %33 = add nuw nsw i32 %j.01, 1
    %34 = sitofp i32 %33 to double
    %35 = fmul double %34, 2.000000e+00
    %36 = fmul double %35, 0x400921FB54442C46
    %37 = fdiv double %36, %11
    %38 = call double @cos(double %16) #4
    %39 = call double @cos(double %32) #4
    %40 = fmul double %39, %r
    %41 = fadd double %40, %R
    %42 = fmul double %38, %41
    store double %42, double* %29, align 8, !tbaa !1
    %43 = call double @sin(double %16) #4
    %44 = call double @cos(double %32) #4
    %45 = fmul double %44, %r
    %46 = fadd double %45, %R
    %47 = fmul double %43, %46
    %48 = fsub double -0.000000e+00, %47
    %sunkaddr = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    store double %48, double* %sunkaddr4, align 8, !tbaa !1
    %49 = call double @sin(double %32) #4
    %50 = fmul double %49, %r
    %sunkaddr5 = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr6 = add i32 %sunkaddr5, 16
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %50, double* %sunkaddr7, align 8, !tbaa !1
    %51 = call double @cos(double %21) #4
    %52 = call double @cos(double %32) #4
    %53 = fmul double %52, %r
    %54 = fadd double %53, %R
    %55 = fmul double %51, %54
    store double %55, double* %28, align 8, !tbaa !1
    %56 = call double @sin(double %21) #4
    %57 = call double @cos(double %32) #4
    %58 = fmul double %57, %r
    %59 = fadd double %58, %R
    %60 = fmul double %56, %59
    %61 = fsub double -0.000000e+00, %60
    %sunkaddr8 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %61, double* %sunkaddr10, align 8, !tbaa !1
    %62 = call double @sin(double %32) #4
    %63 = fmul double %62, %r
    %sunkaddr11 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr12 = add i32 %sunkaddr11, 16
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %63, double* %sunkaddr13, align 8, !tbaa !1
    %64 = call double @cos(double %21) #4
    %65 = call double @cos(double %37) #4
    %66 = fmul double %65, %r
    %67 = fadd double %66, %R
    %68 = fmul double %64, %67
    store double %68, double* %27, align 8, !tbaa !1
    %69 = call double @sin(double %21) #4
    %70 = call double @cos(double %37) #4
    %71 = fmul double %70, %r
    %72 = fadd double %71, %R
    %73 = fmul double %69, %72
    %74 = fsub double -0.000000e+00, %73
    %sunkaddr14 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 8
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    store double %74, double* %sunkaddr16, align 8, !tbaa !1
    %75 = call double @sin(double %37) #4
    %76 = fmul double %75, %r
    %sunkaddr17 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %76, double* %sunkaddr19, align 8, !tbaa !1
    %77 = call double @cos(double %16) #4
    %78 = call double @cos(double %37) #4
    %79 = fmul double %78, %r
    %80 = fadd double %79, %R
    %81 = fmul double %77, %80
    store double %81, double* %26, align 8, !tbaa !1
    %82 = call double @sin(double %16) #4
    %83 = call double @cos(double %37) #4
    %84 = fmul double %83, %r
    %85 = fadd double %84, %R
    %86 = fmul double %82, %85
    %87 = fsub double -0.000000e+00, %86
    %sunkaddr20 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr21 = add i32 %sunkaddr20, 8
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %87, double* %sunkaddr22, align 8, !tbaa !1
    %88 = call double @sin(double %37) #4
    %89 = fmul double %88, %r
    %sunkaddr23 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %89, double* %sunkaddr25, align 8, !tbaa !1
    %90 = call double @cos(double %16) #4
    %91 = call double @cos(double %32) #4
    %92 = fmul double %90, %91
    store double %92, double* %25, align 8, !tbaa !1
    %93 = call double @sin(double %16) #4
    %94 = call double @cos(double %32) #4
    %95 = fmul double %93, %94
    %96 = fsub double -0.000000e+00, %95
    %sunkaddr26 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr27 = add i32 %sunkaddr26, 8
    %sunkaddr28 = inttoptr i32 %sunkaddr27 to double*
    store double %96, double* %sunkaddr28, align 8, !tbaa !1
    %97 = call double @sin(double %32) #4
    %sunkaddr29 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr30 = add i32 %sunkaddr29, 16
    %sunkaddr31 = inttoptr i32 %sunkaddr30 to double*
    store double %97, double* %sunkaddr31, align 8, !tbaa !1
    %98 = call double @cos(double %21) #4
    %99 = call double @cos(double %32) #4
    %100 = fmul double %98, %99
    store double %100, double* %24, align 8, !tbaa !1
    %101 = call double @sin(double %21) #4
    %102 = call double @cos(double %32) #4
    %103 = fmul double %101, %102
    %104 = fsub double -0.000000e+00, %103
    %sunkaddr32 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr33 = add i32 %sunkaddr32, 8
    %sunkaddr34 = inttoptr i32 %sunkaddr33 to double*
    store double %104, double* %sunkaddr34, align 8, !tbaa !1
    %105 = call double @sin(double %32) #4
    %sunkaddr35 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr36 = add i32 %sunkaddr35, 16
    %sunkaddr37 = inttoptr i32 %sunkaddr36 to double*
    store double %105, double* %sunkaddr37, align 8, !tbaa !1
    %106 = call double @cos(double %21) #4
    %107 = call double @cos(double %37) #4
    %108 = fmul double %106, %107
    store double %108, double* %23, align 8, !tbaa !1
    %109 = call double @sin(double %21) #4
    %110 = call double @cos(double %37) #4
    %111 = fmul double %109, %110
    %112 = fsub double -0.000000e+00, %111
    %sunkaddr38 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr39 = add i32 %sunkaddr38, 8
    %sunkaddr40 = inttoptr i32 %sunkaddr39 to double*
    store double %112, double* %sunkaddr40, align 8, !tbaa !1
    %113 = call double @sin(double %37) #4
    %sunkaddr41 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr42 = add i32 %sunkaddr41, 16
    %sunkaddr43 = inttoptr i32 %sunkaddr42 to double*
    store double %113, double* %sunkaddr43, align 8, !tbaa !1
    %114 = call double @cos(double %16) #4
    %115 = call double @cos(double %37) #4
    %116 = fmul double %114, %115
    store double %116, double* %22, align 8, !tbaa !1
    %117 = call double @sin(double %16) #4
    %118 = call double @cos(double %37) #4
    %119 = fmul double %117, %118
    %120 = fsub double -0.000000e+00, %119
    %sunkaddr44 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr45 = add i32 %sunkaddr44, 8
    %sunkaddr46 = inttoptr i32 %sunkaddr45 to double*
    store double %120, double* %sunkaddr46, align 8, !tbaa !1
    %121 = call double @sin(double %37) #4
    %sunkaddr47 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr48 = add i32 %sunkaddr47, 16
    %sunkaddr49 = inttoptr i32 %sunkaddr48 to double*
    store double %121, double* %sunkaddr49, align 8, !tbaa !1
    call void @m_xformpt(double* %29, double* %29, double* %25, double* %25) #4
    call void @m_xformpt(double* %28, double* %28, double* %24, double* %24) #4
    call void @m_xformpt(double* %27, double* %27, double* %23, double* %23) #4
    call void @m_xformpt(double* %26, double* %26, double* %22, double* %22) #4
    call void @glBegin(i32 signext %type) #4
    call void @glNormal3dv(double* %22) #4
    call void @glVertex3dv(double* %26) #4
    call void @glNormal3dv(double* %23) #4
    call void @glVertex3dv(double* %27) #4
    call void @glNormal3dv(double* %24) #4
    call void @glVertex3dv(double* %28) #4
    call void @glNormal3dv(double* %25) #4
    call void @glVertex3dv(double* %29) #4
    call void @glEnd() #4
    %exitcond = icmp eq i32 %nsides, %33
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.loopexit, %0
    %122 = bitcast [3 x double]* %n3 to i8*
    %123 = bitcast [3 x double]* %n2 to i8*
    %124 = bitcast [3 x double]* %n1 to i8*
    %125 = bitcast [3 x double]* %n0 to i8*
    %126 = bitcast [3 x double]* %p3 to i8*
    %127 = bitcast [3 x double]* %p2 to i8*
    %128 = bitcast [3 x double]* %p1 to i8*
    %129 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.end(i64 24, i8* %122) #4
    call void @llvm.lifetime.end(i64 24, i8* %123) #4
    call void @llvm.lifetime.end(i64 24, i8* %124) #4
    call void @llvm.lifetime.end(i64 24, i8* %125) #4
    call void @llvm.lifetime.end(i64 24, i8* %126) #4
    call void @llvm.lifetime.end(i64 24, i8* %127) #4
    call void @llvm.lifetime.end(i64 24, i8* %128) #4
    call void @llvm.lifetime.end(i64 24, i8* %129) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 8, i32 signext 15, i32 signext 7)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  declare void @glPushMatrix() #3
  
  declare void @glRotatef(float, float, float, float) #3
  
  declare void @glTranslatef(float, float, float) #3
  
  declare void @gluCylinder(%struct.GLUquadricObj*, double, double, double, i32 signext, i32 signext) #3
  
  declare void @glPopMatrix() #3
  
  ; Function Attrs: nounwind
  define void @auxSolidCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @icosahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 8, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 9, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 10, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 11, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 12, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 13, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 14, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 15, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 16, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 17, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 18, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 19, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireOctahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @octahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidOctahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireDodecahedron.center, i32 0, i32 0), double %23, i32 signext 2)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @dodecahedron(double* nocapture readonly %center, double %sc, i32 signext %type) unnamed_addr #0 {
    %.b = load i1, i1* @dodecahedron.inited, align 1
    br i1 %.b, label %2, label %1
  
  ; <label>:1                                       ; preds = %0
    store i1 true, i1* @dodecahedron.inited, align 1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 2), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 2), align 8, !tbaa !1
    br label %2
  
  ; <label>:2                                       ; preds = %1, %0
    tail call void @m_pushmatrix() #4
    %3 = load double, double* %center, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %center, i32 1
    %5 = load double, double* %4, align 8, !tbaa !1
    %6 = getelementptr inbounds double, double* %center, i32 2
    %7 = load double, double* %6, align 8, !tbaa !1
    tail call void @m_translate(double %3, double %5, double %7) #4
    tail call void @m_scale(double %sc, double %sc, double %sc) #4
    tail call fastcc void @pentagon(i32 signext 0, i32 signext 1, i32 signext 9, i32 signext 16, i32 signext 5, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 0, i32 signext 3, i32 signext 18, i32 signext 7, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 7, i32 signext 11, i32 signext 10, i32 signext 9, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 11, i32 signext 7, i32 signext 18, i32 signext 19, i32 signext 6, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 8, i32 signext 17, i32 signext 16, i32 signext 9, i32 signext 10, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 14, i32 signext 15, i32 signext 6, i32 signext 19, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 13, i32 signext 12, i32 signext 4, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 19, i32 signext 18, i32 signext 3, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 3, i32 signext 0, i32 signext 5, i32 signext 12, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 6, i32 signext 15, i32 signext 8, i32 signext 10, i32 signext 11, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 17, i32 signext 8, i32 signext 15, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 12, i32 signext 5, i32 signext 16, i32 signext 17, i32 signext %type)
    tail call void @m_popmatrix() #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidDodecahedron.center, i32 0, i32 0), double %23, i32 signext 6)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @compareParams(double* nocapture readonly %oneArray, double* nocapture readonly %twoArray, i32 signext %size) #2 {
    %1 = icmp sgt i32 %size, 0
    br i1 %1, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ 1, %0 ]
    %matches.05 = phi i32 [ %matches.1, %.lr.ph ], [ 1, %0 ]
    %.03 = phi double* [ %2, %.lr.ph ], [ %oneArray, %0 ]
    %.012 = phi double* [ %4, %.lr.ph ], [ %twoArray, %0 ]
    %2 = getelementptr inbounds double, double* %.03, i32 1
    %3 = load double, double* %.03, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %.012, i32 1
    %5 = load double, double* %.012, align 8, !tbaa !1
    %6 = fcmp une double %3, %5
    %matches.1 = select i1 %6, i32 0, i32 %matches.05
    %7 = icmp slt i32 %lsr.iv, %size
    %8 = icmp ne i32 %matches.1, 0
    %9 = and i1 %7, %8
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    %matches.0.lcssa = phi i32 [ 1, %0 ], [ %matches.1, %.lr.ph ]
    ret i32 %matches.0.lcssa
  }
  
  declare i32 @glGenLists(i32 signext) #3
  
  declare void @glBegin(i32 signext) #3
  
  declare void @glNormal3dv(double*) #3
  
  declare void @glVertex3dv(double*) #3
  
  declare void @glEnd() #3
  
  ; Function Attrs: nounwind
  declare double @cos(double) #0
  
  ; Function Attrs: nounwind
  declare double @sin(double) #0
  
  declare void @m_xformpt(double*, double*, double*, double*) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawtriangle(i32 signext %i, i32 signext %geomType, double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    %p1.i.i = alloca [3 x double], align 8
    %p2.i.i = alloca [3 x double], align 8
    %p3.i.i = alloca [3 x double], align 8
    %q0.i.i = alloca [3 x double], align 8
    %q1.i.i = alloca [3 x double], align 8
    %n11.i.i = alloca [3 x double], align 8
    switch i32 %geomType, label %31 [
      i32 0, label %1
      i32 1, label %11
      i32 2, label %21
    ]
  
  ; <label>:1                                       ; preds = %0
    %2 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 0
    %3 = load i32, i32* %2, align 4, !tbaa !13
    %4 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %3, i32 0
    %5 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 1
    %6 = load i32, i32* %5, align 4, !tbaa !13
    %7 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %6, i32 0
    %8 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 2
    %9 = load i32, i32* %8, align 4, !tbaa !13
    %10 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %9, i32 0
    br label %31
  
  ; <label>:11                                      ; preds = %0
    %12 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 0
    %13 = load i32, i32* %12, align 4, !tbaa !13
    %14 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %13, i32 0
    %15 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 1
    %16 = load i32, i32* %15, align 4, !tbaa !13
    %17 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %16, i32 0
    %18 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 2
    %19 = load i32, i32* %18, align 4, !tbaa !13
    %20 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %19, i32 0
    br label %31
  
  ; <label>:21                                      ; preds = %0
    %22 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 0
    %23 = load i32, i32* %22, align 4, !tbaa !13
    %24 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %23, i32 0
    %25 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 1
    %26 = load i32, i32* %25, align 4, !tbaa !13
    %27 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %26, i32 0
    %28 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 2
    %29 = load i32, i32* %28, align 4, !tbaa !13
    %30 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %29, i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %21, %11, %1, %0
    %x0.0 = phi double* [ undef, %0 ], [ %24, %21 ], [ %14, %11 ], [ %4, %1 ]
    %x1.0 = phi double* [ undef, %0 ], [ %27, %21 ], [ %17, %11 ], [ %7, %1 ]
    %x2.0 = phi double* [ undef, %0 ], [ %30, %21 ], [ %20, %11 ], [ %10, %1 ]
    %32 = load double, double* %x0.0, align 8, !tbaa !1
    %33 = fmul double %32, 0.000000e+00
    %34 = load double, double* %x1.0, align 8, !tbaa !1
    %35 = fmul double %34, 0.000000e+00
    %36 = fadd double %33, %35
    %37 = load double, double* %x2.0, align 8, !tbaa !1
    %38 = fadd double %37, %36
    %39 = fadd double %32, %35
    %40 = fmul double %37, 0.000000e+00
    %41 = fadd double %39, %40
    %42 = fadd double %33, %34
    %43 = fadd double %42, %40
    %44 = getelementptr inbounds double, double* %x0.0, i32 1
    %45 = load double, double* %44, align 8, !tbaa !1
    %46 = fmul double %45, 0.000000e+00
    %47 = getelementptr inbounds double, double* %x1.0, i32 1
    %48 = load double, double* %47, align 8, !tbaa !1
    %49 = fmul double %48, 0.000000e+00
    %50 = fadd double %46, %49
    %51 = getelementptr inbounds double, double* %x2.0, i32 1
    %52 = load double, double* %51, align 8, !tbaa !1
    %53 = fadd double %52, %50
    %54 = fadd double %45, %49
    %55 = fmul double %52, 0.000000e+00
    %56 = fadd double %54, %55
    %57 = fadd double %46, %48
    %58 = fadd double %57, %55
    %59 = getelementptr inbounds double, double* %x0.0, i32 2
    %60 = load double, double* %59, align 8, !tbaa !1
    %61 = fmul double %60, 0.000000e+00
    %62 = getelementptr inbounds double, double* %x1.0, i32 2
    %63 = load double, double* %62, align 8, !tbaa !1
    %64 = fmul double %63, 0.000000e+00
    %65 = fadd double %61, %64
    %66 = getelementptr inbounds double, double* %x2.0, i32 2
    %67 = load double, double* %66, align 8, !tbaa !1
    %68 = fadd double %67, %65
    %69 = fadd double %60, %64
    %70 = fmul double %67, 0.000000e+00
    %71 = fadd double %69, %70
    %72 = fadd double %61, %63
    %73 = fadd double %72, %70
    %74 = fmul double %38, %38
    %75 = fmul double %53, %53
    %76 = fadd double %74, %75
    %77 = fmul double %68, %68
    %78 = fadd double %76, %77
    %79 = tail call double @sqrt(double %78) #5
    %80 = fcmp oeq double %79, %79
    br i1 %80, label %.split, label %call.sqrt
  
  call.sqrt:                                        ; preds = %31
    %81 = tail call double @sqrt(double %78) #4
    br label %.split
  
  .split:                                           ; preds = %31, %call.sqrt
    %82 = phi double [ %79, %31 ], [ %81, %call.sqrt ]
    %83 = fdiv double %38, %82
    %84 = fdiv double %53, %82
    %85 = fdiv double %68, %82
    %86 = fmul double %41, %41
    %87 = fmul double %56, %56
    %88 = fadd double %86, %87
    %89 = fmul double %71, %71
    %90 = fadd double %88, %89
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %.split.split, label %call.sqrt1
  
  call.sqrt1:                                       ; preds = %.split
    %93 = tail call double @sqrt(double %90) #4
    br label %.split.split
  
  .split.split:                                     ; preds = %.split, %call.sqrt1
    %94 = phi double [ %91, %.split ], [ %93, %call.sqrt1 ]
    %95 = fdiv double %41, %94
    %96 = fdiv double %56, %94
    %97 = fdiv double %71, %94
    %98 = fmul double %43, %43
    %99 = fmul double %58, %58
    %100 = fadd double %98, %99
    %101 = fmul double %73, %73
    %102 = fadd double %100, %101
    %103 = tail call double @sqrt(double %102) #5
    %104 = fcmp oeq double %103, %103
    br i1 %104, label %.split.split.split, label %call.sqrt2
  
  call.sqrt2:                                       ; preds = %.split.split
    %105 = tail call double @sqrt(double %102) #4
    br label %.split.split.split
  
  .split.split.split:                               ; preds = %.split.split, %call.sqrt2
    %106 = phi double [ %103, %.split.split ], [ %105, %call.sqrt2 ]
    %107 = bitcast [3 x double]* %n11.i.i to double*
    %108 = bitcast [3 x double]* %q1.i.i to double*
    %109 = bitcast [3 x double]* %q0.i.i to double*
    %110 = bitcast [3 x double]* %p3.i.i to double*
    %111 = bitcast [3 x double]* %p2.i.i to double*
    %112 = bitcast [3 x double]* %p1.i.i to double*
    %113 = bitcast [3 x double]* %n11.i.i to i8*
    %114 = bitcast [3 x double]* %q1.i.i to i8*
    %115 = bitcast [3 x double]* %q0.i.i to i8*
    %116 = bitcast [3 x double]* %p3.i.i to i8*
    %117 = bitcast [3 x double]* %p2.i.i to i8*
    %118 = bitcast [3 x double]* %p1.i.i to i8*
    %119 = fdiv double %43, %106
    %120 = fdiv double %58, %106
    %121 = fdiv double %73, %106
    call void @llvm.lifetime.start(i64 24, i8* %118) #4
    call void @llvm.lifetime.start(i64 24, i8* %117) #4
    call void @llvm.lifetime.start(i64 24, i8* %116) #4
    call void @llvm.lifetime.start(i64 24, i8* %115) #4
    call void @llvm.lifetime.start(i64 24, i8* %114) #4
    call void @llvm.lifetime.start(i64 24, i8* %113) #4
    %122 = fmul double %95, %radius
    %123 = load double, double* %p0, align 8, !tbaa !1
    %124 = fadd double %122, %123
    store double %124, double* %112, align 8, !tbaa !1
    %125 = fmul double %83, %radius
    %126 = fadd double %125, %123
    store double %126, double* %111, align 8, !tbaa !1
    %127 = fmul double %119, %radius
    %128 = fadd double %127, %123
    store double %128, double* %110, align 8, !tbaa !1
    %129 = fmul double %96, %radius
    %sunkaddr = ptrtoint double* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    %130 = load double, double* %sunkaddr4, align 8, !tbaa !1
    %131 = fadd double %129, %130
    %sunkaddr5 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr6 = add i32 %sunkaddr5, 8
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %131, double* %sunkaddr7, align 8, !tbaa !1
    %132 = fmul double %84, %radius
    %133 = fadd double %132, %130
    %sunkaddr8 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %133, double* %sunkaddr10, align 8, !tbaa !1
    %134 = fmul double %120, %radius
    %135 = fadd double %134, %130
    %sunkaddr11 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr12 = add i32 %sunkaddr11, 8
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %135, double* %sunkaddr13, align 8, !tbaa !1
    %136 = fmul double %97, %radius
    %sunkaddr14 = ptrtoint double* %p0 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 16
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    %137 = load double, double* %sunkaddr16, align 8, !tbaa !1
    %138 = fadd double %136, %137
    %sunkaddr17 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %138, double* %sunkaddr19, align 8, !tbaa !1
    %139 = fmul double %85, %radius
    %140 = fadd double %139, %137
    %sunkaddr20 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr21 = add i32 %sunkaddr20, 16
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %140, double* %sunkaddr22, align 8, !tbaa !1
    %141 = fmul double %121, %radius
    %142 = fadd double %141, %137
    %sunkaddr23 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %142, double* %sunkaddr25, align 8, !tbaa !1
    call void @diff3(double* %112, double* %111, double* %109) #4
    call void @diff3(double* %111, double* %110, double* %108) #4
    call void @crossprod(double* %109, double* %108, double* %108) #4
    call void @normalize(double* %108) #4
    call void @m_xformpt(double* %112, double* %112, double* %108, double* %107) #4
    call void @m_xformptonly(double* %111, double* %111) #4
    call void @m_xformptonly(double* %110, double* %110) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %107) #4
    call void @glVertex3dv(double* %112) #4
    call void @glVertex3dv(double* %111) #4
    call void @glVertex3dv(double* %110) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %113) #4
    call void @llvm.lifetime.end(i64 24, i8* %114) #4
    call void @llvm.lifetime.end(i64 24, i8* %115) #4
    call void @llvm.lifetime.end(i64 24, i8* %116) #4
    call void @llvm.lifetime.end(i64 24, i8* %117) #4
    call void @llvm.lifetime.end(i64 24, i8* %118) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  declare void @diff3(double*, double*, double*) #3
  
  declare void @crossprod(double*, double*, double*) #3
  
  declare void @normalize(double*) #3
  
  declare void @m_xformptonly(double*, double*) #3
  
  declare void @m_pushmatrix() #3
  
  declare void @m_translate(double, double, double) #3
  
  declare void @m_scale(double, double, double) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @pentagon(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %shadeType) unnamed_addr #0 {
    %n0 = alloca [3 x double], align 8
    %d1 = alloca [3 x double], align 8
    %d2 = alloca [3 x double], align 8
    %d3 = alloca [3 x double], align 8
    %d4 = alloca [3 x double], align 8
    %d5 = alloca [3 x double], align 8
    %nout = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %d1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %d2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %d3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %d4 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %d5 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %nout to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %a, i32 0
    %9 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %b, i32 0
    %10 = bitcast [3 x double]* %d1 to double*
    call void @diff3(double* %8, double* %9, double* %10) #4
    %11 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %c, i32 0
    %12 = bitcast [3 x double]* %d2 to double*
    call void @diff3(double* %9, double* %11, double* %12) #4
    %13 = bitcast [3 x double]* %n0 to double*
    call void @crossprod(double* %10, double* %12, double* %13) #4
    call void @normalize(double* %13) #4
    %14 = bitcast [3 x double]* %nout to double*
    call void @m_xformpt(double* %8, double* %10, double* %13, double* %14) #4
    call void @m_xformptonly(double* %9, double* %12) #4
    %15 = bitcast [3 x double]* %d3 to double*
    call void @m_xformptonly(double* %11, double* %15) #4
    %16 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %d, i32 0
    %17 = bitcast [3 x double]* %d4 to double*
    call void @m_xformptonly(double* %16, double* %17) #4
    %18 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %e, i32 0
    %19 = bitcast [3 x double]* %d5 to double*
    call void @m_xformptonly(double* %18, double* %19) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %14) #4
    call void @glVertex3dv(double* %10) #4
    call void @glVertex3dv(double* %12) #4
    call void @glVertex3dv(double* %15) #4
    call void @glVertex3dv(double* %17) #4
    call void @glVertex3dv(double* %19) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %7) #4
    call void @llvm.lifetime.end(i64 24, i8* %6) #4
    call void @llvm.lifetime.end(i64 24, i8* %5) #4
    call void @llvm.lifetime.end(i64 24, i8* %4) #4
    call void @llvm.lifetime.end(i64 24, i8* %3) #4
    call void @llvm.lifetime.end(i64 24, i8* %2) #4
    call void @llvm.lifetime.end(i64 24, i8* %1) #4
    ret void
  }
  
  declare void @m_popmatrix() #3
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { norecurse nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { nounwind }
  attributes #5 = { nounwind readnone }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !2, i64 0}
  !2 = !{!"double", !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"any pointer", !3, i64 0}
  !7 = !{!8, !6, i64 12}
  !8 = !{!"model", !9, i64 0, !6, i64 4, !9, i64 8, !6, i64 12}
  !9 = !{!"int", !3, i64 0}
  !10 = !{!8, !9, i64 0}
  !11 = !{!8, !9, i64 8}
  !12 = !{!8, !6, i64 4}
  !13 = !{!9, !9, i64 0}

...
---
name:            auxSolidBox
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: afgr64 }
  - { id: 13, class: afgr64 }
  - { id: 14, class: afgr64 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: afgr64 }
  - { id: 24, class: afgr64 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: afgr64 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: afgr64 }
  - { id: 45, class: afgr64 }
  - { id: 46, class: afgr64 }
  - { id: 47, class: afgr64 }
  - { id: 48, class: afgr64 }
  - { id: 49, class: afgr64 }
  - { id: 50, class: afgr64 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
liveins:         
  - { reg: '%d6', virtual-reg: '%12' }
  - { reg: '%d7', virtual-reg: '%13' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    8
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 16, size: 8, alignment: 8, isImmutable: true, isAliased: false }
constants:       
  - id:              0
    value:           double 5.000000e-01
    alignment:       8
  - id:              1
    value:           double -5.000000e-01
    alignment:       8
body:             |
  bb.0 (%ir-block.0, freq 40):
    successors: %bb.6.findList.exit.thread(37), %bb.10(62)
    liveins: %d6, %d7, %t9, %v0
  
    %15 = ADDu %v0, %t9
    %13 = COPY %d7
    %12 = COPY %d6
    %14 = LDC1 %fixed-stack.0, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from stack)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %16 = LW %15, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %17 = ADDiu %zero, 24
    %a0 = COPY %17
    %gp = COPY %15
    %t9 = COPY %16
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %18 = COPY %v0
    SDC1 %12, %18, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.2, !tbaa !1)
    %19 = LW %15, target-flags(<unknown>) @lists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SDC1 %13, %18, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.4, !tbaa !1)
    SDC1 %14, %18, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.6, !tbaa !1)
    %20 = ADDiu %19, target-flags(<unknown>) @lists
    %1 = LW %20, 48, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from `%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12)`, !tbaa !5)
    %0 = COPY %18
    BEQ %1, %zero, %bb.6.findList.exit.thread, implicit-def %at
  
  bb.10 (freq 25):
    successors: %bb.1..lr.ph.i(100)
  
  
  bb.1..lr.ph.i (freq 409):
    successors: %bb.2..lr.ph.i.i(100)
  
    %2 = PHI %1, %bb.10, %10, %bb.4
    %3 = LW %2, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.8, !tbaa !7)
    %22 = ADDiu %zero, 1
    %21 = ADDiu %zero, 0
  
  bb.2..lr.ph.i.i (freq 13107):
    successors: %bb.9..lr.ph.i.i(98), %bb.3.compareParams.exit.i(1)
  
    %4 = PHI %21, %bb.1..lr.ph.i, %9, %bb.9..lr.ph.i.i
    %5 = PHI %22, %bb.1..lr.ph.i, %8, %bb.9..lr.ph.i.i
    %6 = PHI %22, %bb.1..lr.ph.i, %7, %bb.9..lr.ph.i.i
    %23 = LDXC1 %0, %4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from %ir.scevgep4, !tbaa !1)
    %24 = LDXC1 %3, %4, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 8 from %ir.uglygep3, !tbaa !1)
    FCMP_D32 killed %24, killed %23, 18, implicit-def %fcc0
    %7 = MOVF_I killed %zero, %fcc0, %6
    %26 = SLTi %5, 3
    BEQ killed %26, %zero, %bb.3.compareParams.exit.i, implicit-def dead %at
    B %bb.9..lr.ph.i.i, implicit-def dead %at
  
  bb.9..lr.ph.i.i (freq 12902):
    successors: %bb.2..lr.ph.i.i(98), %bb.3.compareParams.exit.i(1)
  
    %9 = ADDiu %4, 8
    %8 = ADDiu %5, 1
    BNE %7, %zero, %bb.2..lr.ph.i.i, implicit-def dead %at
    B %bb.3.compareParams.exit.i, implicit-def dead %at
  
  bb.3.compareParams.exit.i (freq 409):
    successors: %bb.4(96), %bb.5.findList.exit(3)
  
    BNE %7, %zero, %bb.5.findList.exit, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.18, freq 396):
    successors: %bb.6.findList.exit.thread(3), %bb.1..lr.ph.i(96)
  
    %10 = LW %2, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.19, !tbaa !5)
    BEQ %10, %zero, %bb.6.findList.exit.thread, implicit-def dead %at
    B %bb.1..lr.ph.i, implicit-def dead %at
  
  bb.5.findList.exit (freq 12):
    successors: %bb.6.findList.exit.thread(37), %bb.7(62)
  
    %11 = LW %2, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.21, !tbaa !10)
    BNE %11, %zero, %bb.7, implicit-def dead %at
    B %bb.6.findList.exit.thread, implicit-def dead %at
  
  bb.6.findList.exit.thread (freq 32):
    successors: %bb.8(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %29 = LW %15, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %30 = ADDiu %zero, 16
    %a0 = COPY %30
    %t9 = COPY %29
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %31 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %32 = LW %15, target-flags(<unknown>) @glGenLists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glGenLists)
    %33 = ADDiu %zero, 1
    %a0 = COPY %33
    %gp = COPY %15
    %t9 = COPY %32
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %34 = COPY %v0
    %37 = ADDiu %zero, 3
    %38 = ADDiu %zero, 4865
    SW %34, %31, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.26, !tbaa !10)
    SW killed %37, %31, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.28, !tbaa !11)
    SW %0, %31, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.30, !tbaa !7)
    %39 = LW %20, 48, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*)`, !tbaa !5)
    SW killed %39, %31, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.33, !tbaa !12)
    SW %31, %20, 48, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**)`, !tbaa !5)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %40 = LW %15, target-flags(<unknown>) @glNewList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glNewList)
    %a0 = COPY %34
    %a1 = COPY %38
    %gp = COPY %15
    %t9 = COPY %40
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %41 = LW %15, target-flags(<unknown>) %const.0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %42 = LDC1 killed %41, target-flags(<unknown>) %const.0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %43 = LW %15, target-flags(<unknown>) %const.1, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %44 = LDC1 killed %43, target-flags(<unknown>) %const.1, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from constant-pool)
    %45 = FMUL_D32 %12, %44
    %46 = FMUL_D32 %12, %42
    %47 = FMUL_D32 %13, %44
    %48 = FMUL_D32 %13, %42
    %49 = FMUL_D32 %14, %44
    %50 = FMUL_D32 %14, %42
    %51 = LW %15, target-flags(<unknown>) @drawbox, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %52 = ADDiu killed %51, target-flags(<unknown>) @drawbox
    %53 = ADDiu %zero, 7
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %d0 = COPY %45
    %d1 = COPY %46
    %d2 = COPY %47
    %d3 = COPY %48
    %d4 = COPY %49
    %d5 = COPY %50
    %a0 = COPY %53
    %t9 = COPY %52
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d0, implicit %d1, implicit %d2, implicit %d3, implicit %d4, implicit %d5, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %54 = LW %15, target-flags(<unknown>) @glEndList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glEndList)
    %gp = COPY %15
    %t9 = COPY %54
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.8, implicit-def dead %at
  
  bb.7 (%ir-block.40, freq 7):
    successors: %bb.8(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %27 = LW %15, target-flags(<unknown>) @glCallList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glCallList)
    %a0 = COPY %11
    %gp = COPY %15
    %t9 = COPY %27
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %28 = LW %15, target-flags(<unknown>) @free, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @free)
    %a0 = COPY %0
    %gp = COPY %15
    %t9 = COPY %28
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.8 (%ir-block.41, freq 40):
    liveouts:
  
    RetRA

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/mesa/mesa.shapes.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.model = type { i32, %struct.model*, i32, double* }
  %struct.GLUquadricObj = type opaque
  
  @auxWireIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @lists = internal unnamed_addr global [25 x %struct.model*] zeroinitializer, align 4
  @drawbox.n = internal global [6 x [3 x double]] [[3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @drawbox.faces = internal unnamed_addr constant [6 x [4 x i32]] [[4 x i32] [i32 0, i32 1, i32 2, i32 3], [4 x i32] [i32 3, i32 2, i32 6, i32 7], [4 x i32] [i32 7, i32 6, i32 5, i32 4], [4 x i32] [i32 4, i32 5, i32 1, i32 0], [4 x i32] [i32 5, i32 6, i32 2, i32 1], [4 x i32] [i32 7, i32 4, i32 0, i32 3]], align 4
  @iindex = internal unnamed_addr constant [20 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 1], [3 x i32] [i32 0, i32 9, i32 4], [3 x i32] [i32 9, i32 5, i32 4], [3 x i32] [i32 4, i32 5, i32 8], [3 x i32] [i32 4, i32 8, i32 1], [3 x i32] [i32 8, i32 10, i32 1], [3 x i32] [i32 8, i32 3, i32 10], [3 x i32] [i32 5, i32 3, i32 8], [3 x i32] [i32 5, i32 2, i32 3], [3 x i32] [i32 2, i32 7, i32 3], [3 x i32] [i32 7, i32 10, i32 3], [3 x i32] [i32 7, i32 6, i32 10], [3 x i32] [i32 7, i32 11, i32 6], [3 x i32] [i32 11, i32 0, i32 6], [3 x i32] [i32 0, i32 1, i32 6], [3 x i32] [i32 6, i32 1, i32 10], [3 x i32] [i32 9, i32 0, i32 11], [3 x i32] [i32 9, i32 11, i32 2], [3 x i32] [i32 9, i32 2, i32 5], [3 x i32] [i32 7, i32 2, i32 11]], align 4
  @idata = internal global [12 x [3 x double]] [[3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00]], align 8
  @ondex = internal unnamed_addr constant [8 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 2], [3 x i32] [i32 1, i32 2, i32 4], [3 x i32] [i32 0, i32 3, i32 4], [3 x i32] [i32 1, i32 4, i32 3], [3 x i32] [i32 0, i32 2, i32 5], [3 x i32] [i32 1, i32 5, i32 2], [3 x i32] [i32 0, i32 5, i32 3], [3 x i32] [i32 1, i32 3, i32 5]], align 4
  @odata = internal global [6 x [3 x double]] [[3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @tndex = internal unnamed_addr constant [4 x [3 x i32]] [[3 x i32] [i32 0, i32 1, i32 3], [3 x i32] [i32 2, i32 1, i32 0], [3 x i32] [i32 3, i32 2, i32 0], [3 x i32] [i32 1, i32 2, i32 3]], align 4
  @tdata = internal global [4 x [3 x double]] [[3 x double] [double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA], [3 x double] [double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA]], align 8
  @dodecahedron.inited = internal unnamed_addr global i1 false
  @dodec = internal global [20 x [3 x double]] zeroinitializer, align 8
  
  ; Function Attrs: nounwind
  define void @auxWireSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast ([25 x %struct.model*]* @lists to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast ([25 x %struct.model*]* @lists to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100011) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare noalias i8* @malloc(i32 signext) #0
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @findList(i32 signext %lindex, double* nocapture readonly %paramArray, i32 signext %size) #2 {
    %1 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %endList.02 = load %struct.model*, %struct.model** %1, align 4, !tbaa !5
    %2 = icmp eq %struct.model* %endList.02, null
    br i1 %2, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0
    br label %3
  
  ; <label>:3                                       ; preds = %18, %.lr.ph
    %endList.03 = phi %struct.model* [ %endList.02, %.lr.ph ], [ %endList.0, %18 ]
    %4 = icmp sgt i32 %size, 0
    br i1 %4, label %.lr.ph.i.preheader, label %compareParams.exit.thread
  
  .lr.ph.i.preheader:                               ; preds = %3
    %5 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 3
    %6 = load double*, double** %5, align 4, !tbaa !7
    br label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %matches.05.i = phi i32 [ %matches.1.i, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %.03.i = phi double* [ %7, %.lr.ph.i ], [ %6, %.lr.ph.i.preheader ]
    %.012.i = phi double* [ %9, %.lr.ph.i ], [ %paramArray, %.lr.ph.i.preheader ]
    %7 = getelementptr inbounds double, double* %.03.i, i32 1
    %8 = load double, double* %.03.i, align 8, !tbaa !1
    %9 = getelementptr inbounds double, double* %.012.i, i32 1
    %10 = load double, double* %.012.i, align 8, !tbaa !1
    %11 = fcmp une double %8, %10
    %matches.1.i = select i1 %11, i32 0, i32 %matches.05.i
    %12 = icmp slt i32 %lsr.iv, %size
    %13 = icmp ne i32 %matches.1.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %14, label %.lr.ph.i, label %compareParams.exit
  
  compareParams.exit:                               ; preds = %.lr.ph.i
    %15 = icmp eq i32 %matches.1.i, 0
    br i1 %15, label %18, label %compareParams.exit.thread
  
  compareParams.exit.thread:                        ; preds = %compareParams.exit, %3
    %16 = bitcast %struct.model* %endList.03 to i32*
    %17 = load i32, i32* %16, align 4, !tbaa !10
    br label %.loopexit
  
  ; <label>:18                                      ; preds = %compareParams.exit
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 1
    %endList.0 = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0, null
    br i1 %20, label %.loopexit, label %3
  
  .loopexit:                                        ; preds = %18, %compareParams.exit.thread, %0
    %.0 = phi i32 [ %17, %compareParams.exit.thread ], [ 0, %0 ], [ 0, %18 ]
    ret i32 %.0
  }
  
  declare void @glNewList(i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @makeModelPtr(i32 signext %lindex, double* %sizeArray, i32 signext %count) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = tail call i32 @glGenLists(i32 signext 1) #4
    %3 = bitcast i8* %1 to i32*
    store i32 %2, i32* %3, align 4, !tbaa !10
    %4 = getelementptr inbounds i8, i8* %1, i32 8
    %5 = bitcast i8* %4 to i32*
    store i32 %count, i32* %5, align 4, !tbaa !11
    %6 = getelementptr inbounds i8, i8* %1, i32 12
    %7 = bitcast i8* %6 to double**
    store double* %sizeArray, double** %7, align 4, !tbaa !7
    %8 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %9 = bitcast %struct.model** %8 to i32*
    %10 = load i32, i32* %9, align 4, !tbaa !5
    %11 = getelementptr inbounds i8, i8* %1, i32 4
    %12 = bitcast i8* %11 to i32*
    store i32 %10, i32* %12, align 4, !tbaa !12
    %13 = bitcast %struct.model** %8 to i8**
    store i8* %1, i8** %13, align 4, !tbaa !5
    ret i32 %2
  }
  
  declare %struct.GLUquadricObj* @gluNewQuadric() #3
  
  declare void @gluQuadricDrawStyle(%struct.GLUquadricObj*, i32 signext) #3
  
  declare void @gluSphere(%struct.GLUquadricObj*, double, i32 signext, i32 signext) #3
  
  declare void @glEndList() #3
  
  declare void @glCallList(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  define void @auxSolidSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %23, i32 signext 100000) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  declare void @gluQuadricNormals(%struct.GLUquadricObj*, i32 signext) #3
  
  ; Function Attrs: nounwind
  define void @auxWireCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 2)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawbox(double %x0, double %x1, double %y0, double %y1, double %z0, double %z1, i32 signext %type) unnamed_addr #0 {
    %v = alloca [8 x [3 x double]], align 8
    %1 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.start(i64 192, i8* %1) #4
    %2 = fcmp ogt double %x0, %x1
    %.05 = select i1 %2, double %x0, double %x1
    %.0 = select i1 %2, double %x1, double %x0
    %3 = fcmp ogt double %y0, %y1
    %.04 = select i1 %3, double %y1, double %y0
    %.03 = select i1 %3, double %y0, double %y1
    %4 = fcmp ogt double %z0, %z1
    %.02 = select i1 %4, double %z1, double %z0
    %.01 = select i1 %4, double %z0, double %z1
    %5 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 0
    store double %.0, double* %5, align 8, !tbaa !1
    %6 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 0
    store double %.0, double* %6, align 8, !tbaa !1
    %7 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 0
    store double %.0, double* %7, align 8, !tbaa !1
    %8 = bitcast [8 x [3 x double]]* %v to double*
    store double %.0, double* %8, align 8, !tbaa !1
    %9 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 0
    store double %.05, double* %9, align 8, !tbaa !1
    %10 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 0
    store double %.05, double* %10, align 8, !tbaa !1
    %11 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 0
    store double %.05, double* %11, align 8, !tbaa !1
    %12 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 0
    store double %.05, double* %12, align 8, !tbaa !1
    %13 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 1
    store double %.04, double* %13, align 8, !tbaa !1
    %14 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 1
    store double %.04, double* %14, align 8, !tbaa !1
    %15 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 1
    store double %.04, double* %15, align 8, !tbaa !1
    %16 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 1
    store double %.04, double* %16, align 8, !tbaa !1
    %17 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 1
    store double %.03, double* %17, align 8, !tbaa !1
    %18 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 1
    store double %.03, double* %18, align 8, !tbaa !1
    %19 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 1
    store double %.03, double* %19, align 8, !tbaa !1
    %20 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 1
    store double %.03, double* %20, align 8, !tbaa !1
    %21 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 2
    store double %.02, double* %21, align 8, !tbaa !1
    %22 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 2
    store double %.02, double* %22, align 8, !tbaa !1
    %23 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 2
    store double %.02, double* %23, align 8, !tbaa !1
    %24 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 2
    store double %.02, double* %24, align 8, !tbaa !1
    %25 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 2
    store double %.01, double* %25, align 8, !tbaa !1
    %26 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 2
    store double %.01, double* %26, align 8, !tbaa !1
    %27 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 2
    store double %.01, double* %27, align 8, !tbaa !1
    %28 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 2
    store double %.01, double* %28, align 8, !tbaa !1
    br label %29
  
  ; <label>:29                                      ; preds = %29, %0
    %lsr.iv1 = phi [6 x [4 x i32]]* [ %38, %29 ], [ bitcast (i32* getelementptr inbounds ([6 x [4 x i32]], [6 x [4 x i32]]* @drawbox.faces, i32 0, i32 0, i32 2) to [6 x [4 x i32]]*), %0 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %29 ], [ 0, %0 ]
    %lsr.iv12 = bitcast [6 x [4 x i32]]* %lsr.iv1 to i32*
    call void @glBegin(i32 signext %type) #4
    %uglygep11 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep1112 = bitcast i8* %uglygep11 to double*
    call void @glNormal3dv(double* %uglygep1112) #4
    %scevgep5 = getelementptr i32, i32* %lsr.iv12, i32 -2
    %30 = load i32, i32* %scevgep5, align 4, !tbaa !13
    %31 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %30, i32 0
    call void @glVertex3dv(double* %31) #4
    %uglygep9 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep910 = bitcast i8* %uglygep9 to double*
    call void @glNormal3dv(double* %uglygep910) #4
    %scevgep4 = getelementptr i32, i32* %lsr.iv12, i32 -1
    %32 = load i32, i32* %scevgep4, align 4, !tbaa !13
    %33 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %32, i32 0
    call void @glVertex3dv(double* %33) #4
    %uglygep7 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep78 = bitcast i8* %uglygep7 to double*
    call void @glNormal3dv(double* %uglygep78) #4
    %34 = load i32, i32* %lsr.iv12, align 4, !tbaa !13
    %35 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %34, i32 0
    call void @glVertex3dv(double* %35) #4
    %uglygep = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep6 = bitcast i8* %uglygep to double*
    call void @glNormal3dv(double* %uglygep6) #4
    %scevgep3 = getelementptr i32, i32* %lsr.iv12, i32 1
    %36 = load i32, i32* %scevgep3, align 4, !tbaa !13
    %37 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %36, i32 0
    call void @glVertex3dv(double* %37) #4
    call void @glEnd() #4
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 24
    %scevgep = getelementptr [6 x [4 x i32]], [6 x [4 x i32]]* %lsr.iv1, i32 0, i32 1, i32 0
    %38 = bitcast i32* %scevgep to [6 x [4 x i32]]*
    %exitcond = icmp eq i32 %lsr.iv.next, 144
    br i1 %exitcond, label %39, label %29
  
  ; <label>:39                                      ; preds = %29
    %40 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.end(i64 192, i8* %40) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 7)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 2)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 7)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 5, i32 signext 10, i32 signext 2)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @doughnut(double %r, double %R, i32 signext %nsides, i32 signext %rings, i32 signext %type) unnamed_addr #0 {
    %p0 = alloca [3 x double], align 8
    %p1 = alloca [3 x double], align 8
    %p2 = alloca [3 x double], align 8
    %p3 = alloca [3 x double], align 8
    %n0 = alloca [3 x double], align 8
    %n1 = alloca [3 x double], align 8
    %n2 = alloca [3 x double], align 8
    %n3 = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %p1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %p2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %p3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %n1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %n2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = bitcast [3 x double]* %n3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %8) #4
    %9 = icmp sgt i32 %rings, 0
    br i1 %9, label %.lr.ph3, label %._crit_edge
  
  .lr.ph3:                                          ; preds = %0
    %10 = sitofp i32 %rings to double
    %11 = sitofp i32 %nsides to double
    br label %12
  
  .loopexit:                                        ; preds = %.lr.ph, %12
    %exitcond4 = icmp eq i32 %17, %rings
    br i1 %exitcond4, label %._crit_edge, label %12
  
  ; <label>:12                                      ; preds = %.loopexit, %.lr.ph3
    %IV.S.1 = phi double [ 0.000000e+00, %.lr.ph3 ], [ %IV.S.next.2, %.loopexit ]
    %i.02 = phi i32 [ 0, %.lr.ph3 ], [ %17, %.loopexit ]
    %13 = icmp sgt i32 %nsides, 0
    %14 = fmul double %IV.S.1, 2.000000e+00
    %15 = fmul double %14, 0x400921FB54442C46
    %16 = fdiv double %15, %10
    %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
    %17 = add nuw nsw i32 %i.02, 1
    %18 = sitofp i32 %17 to double
    %19 = fmul double %18, 2.000000e+00
    %20 = fmul double %19, 0x400921FB54442C46
    %21 = fdiv double %20, %10
    br i1 %13, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %12, %.lr.ph
    %IV.S. = phi double [ %IV.S.next., %.lr.ph ], [ 0.000000e+00, %12 ]
    %j.01 = phi i32 [ %33, %.lr.ph ], [ 0, %12 ]
    %22 = bitcast [3 x double]* %n3 to double*
    %23 = bitcast [3 x double]* %n2 to double*
    %24 = bitcast [3 x double]* %n1 to double*
    %25 = bitcast [3 x double]* %n0 to double*
    %26 = bitcast [3 x double]* %p3 to double*
    %27 = bitcast [3 x double]* %p2 to double*
    %28 = bitcast [3 x double]* %p1 to double*
    %29 = bitcast [3 x double]* %p0 to double*
    %30 = fmul double %IV.S., 2.000000e+00
    %31 = fmul double %30, 0x400921FB54442C46
    %32 = fdiv double %31, %11
    %IV.S.next. = fadd double %IV.S., 1.000000e+00
    %33 = add nuw nsw i32 %j.01, 1
    %34 = sitofp i32 %33 to double
    %35 = fmul double %34, 2.000000e+00
    %36 = fmul double %35, 0x400921FB54442C46
    %37 = fdiv double %36, %11
    %38 = call double @cos(double %16) #4
    %39 = call double @cos(double %32) #4
    %40 = fmul double %39, %r
    %41 = fadd double %40, %R
    %42 = fmul double %38, %41
    store double %42, double* %29, align 8, !tbaa !1
    %43 = call double @sin(double %16) #4
    %44 = call double @cos(double %32) #4
    %45 = fmul double %44, %r
    %46 = fadd double %45, %R
    %47 = fmul double %43, %46
    %48 = fsub double -0.000000e+00, %47
    %sunkaddr = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    store double %48, double* %sunkaddr4, align 8, !tbaa !1
    %49 = call double @sin(double %32) #4
    %50 = fmul double %49, %r
    %sunkaddr5 = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr6 = add i32 %sunkaddr5, 16
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %50, double* %sunkaddr7, align 8, !tbaa !1
    %51 = call double @cos(double %21) #4
    %52 = call double @cos(double %32) #4
    %53 = fmul double %52, %r
    %54 = fadd double %53, %R
    %55 = fmul double %51, %54
    store double %55, double* %28, align 8, !tbaa !1
    %56 = call double @sin(double %21) #4
    %57 = call double @cos(double %32) #4
    %58 = fmul double %57, %r
    %59 = fadd double %58, %R
    %60 = fmul double %56, %59
    %61 = fsub double -0.000000e+00, %60
    %sunkaddr8 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %61, double* %sunkaddr10, align 8, !tbaa !1
    %62 = call double @sin(double %32) #4
    %63 = fmul double %62, %r
    %sunkaddr11 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr12 = add i32 %sunkaddr11, 16
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %63, double* %sunkaddr13, align 8, !tbaa !1
    %64 = call double @cos(double %21) #4
    %65 = call double @cos(double %37) #4
    %66 = fmul double %65, %r
    %67 = fadd double %66, %R
    %68 = fmul double %64, %67
    store double %68, double* %27, align 8, !tbaa !1
    %69 = call double @sin(double %21) #4
    %70 = call double @cos(double %37) #4
    %71 = fmul double %70, %r
    %72 = fadd double %71, %R
    %73 = fmul double %69, %72
    %74 = fsub double -0.000000e+00, %73
    %sunkaddr14 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 8
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    store double %74, double* %sunkaddr16, align 8, !tbaa !1
    %75 = call double @sin(double %37) #4
    %76 = fmul double %75, %r
    %sunkaddr17 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %76, double* %sunkaddr19, align 8, !tbaa !1
    %77 = call double @cos(double %16) #4
    %78 = call double @cos(double %37) #4
    %79 = fmul double %78, %r
    %80 = fadd double %79, %R
    %81 = fmul double %77, %80
    store double %81, double* %26, align 8, !tbaa !1
    %82 = call double @sin(double %16) #4
    %83 = call double @cos(double %37) #4
    %84 = fmul double %83, %r
    %85 = fadd double %84, %R
    %86 = fmul double %82, %85
    %87 = fsub double -0.000000e+00, %86
    %sunkaddr20 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr21 = add i32 %sunkaddr20, 8
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %87, double* %sunkaddr22, align 8, !tbaa !1
    %88 = call double @sin(double %37) #4
    %89 = fmul double %88, %r
    %sunkaddr23 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %89, double* %sunkaddr25, align 8, !tbaa !1
    %90 = call double @cos(double %16) #4
    %91 = call double @cos(double %32) #4
    %92 = fmul double %90, %91
    store double %92, double* %25, align 8, !tbaa !1
    %93 = call double @sin(double %16) #4
    %94 = call double @cos(double %32) #4
    %95 = fmul double %93, %94
    %96 = fsub double -0.000000e+00, %95
    %sunkaddr26 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr27 = add i32 %sunkaddr26, 8
    %sunkaddr28 = inttoptr i32 %sunkaddr27 to double*
    store double %96, double* %sunkaddr28, align 8, !tbaa !1
    %97 = call double @sin(double %32) #4
    %sunkaddr29 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr30 = add i32 %sunkaddr29, 16
    %sunkaddr31 = inttoptr i32 %sunkaddr30 to double*
    store double %97, double* %sunkaddr31, align 8, !tbaa !1
    %98 = call double @cos(double %21) #4
    %99 = call double @cos(double %32) #4
    %100 = fmul double %98, %99
    store double %100, double* %24, align 8, !tbaa !1
    %101 = call double @sin(double %21) #4
    %102 = call double @cos(double %32) #4
    %103 = fmul double %101, %102
    %104 = fsub double -0.000000e+00, %103
    %sunkaddr32 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr33 = add i32 %sunkaddr32, 8
    %sunkaddr34 = inttoptr i32 %sunkaddr33 to double*
    store double %104, double* %sunkaddr34, align 8, !tbaa !1
    %105 = call double @sin(double %32) #4
    %sunkaddr35 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr36 = add i32 %sunkaddr35, 16
    %sunkaddr37 = inttoptr i32 %sunkaddr36 to double*
    store double %105, double* %sunkaddr37, align 8, !tbaa !1
    %106 = call double @cos(double %21) #4
    %107 = call double @cos(double %37) #4
    %108 = fmul double %106, %107
    store double %108, double* %23, align 8, !tbaa !1
    %109 = call double @sin(double %21) #4
    %110 = call double @cos(double %37) #4
    %111 = fmul double %109, %110
    %112 = fsub double -0.000000e+00, %111
    %sunkaddr38 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr39 = add i32 %sunkaddr38, 8
    %sunkaddr40 = inttoptr i32 %sunkaddr39 to double*
    store double %112, double* %sunkaddr40, align 8, !tbaa !1
    %113 = call double @sin(double %37) #4
    %sunkaddr41 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr42 = add i32 %sunkaddr41, 16
    %sunkaddr43 = inttoptr i32 %sunkaddr42 to double*
    store double %113, double* %sunkaddr43, align 8, !tbaa !1
    %114 = call double @cos(double %16) #4
    %115 = call double @cos(double %37) #4
    %116 = fmul double %114, %115
    store double %116, double* %22, align 8, !tbaa !1
    %117 = call double @sin(double %16) #4
    %118 = call double @cos(double %37) #4
    %119 = fmul double %117, %118
    %120 = fsub double -0.000000e+00, %119
    %sunkaddr44 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr45 = add i32 %sunkaddr44, 8
    %sunkaddr46 = inttoptr i32 %sunkaddr45 to double*
    store double %120, double* %sunkaddr46, align 8, !tbaa !1
    %121 = call double @sin(double %37) #4
    %sunkaddr47 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr48 = add i32 %sunkaddr47, 16
    %sunkaddr49 = inttoptr i32 %sunkaddr48 to double*
    store double %121, double* %sunkaddr49, align 8, !tbaa !1
    call void @m_xformpt(double* %29, double* %29, double* %25, double* %25) #4
    call void @m_xformpt(double* %28, double* %28, double* %24, double* %24) #4
    call void @m_xformpt(double* %27, double* %27, double* %23, double* %23) #4
    call void @m_xformpt(double* %26, double* %26, double* %22, double* %22) #4
    call void @glBegin(i32 signext %type) #4
    call void @glNormal3dv(double* %22) #4
    call void @glVertex3dv(double* %26) #4
    call void @glNormal3dv(double* %23) #4
    call void @glVertex3dv(double* %27) #4
    call void @glNormal3dv(double* %24) #4
    call void @glVertex3dv(double* %28) #4
    call void @glNormal3dv(double* %25) #4
    call void @glVertex3dv(double* %29) #4
    call void @glEnd() #4
    %exitcond = icmp eq i32 %nsides, %33
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.loopexit, %0
    %122 = bitcast [3 x double]* %n3 to i8*
    %123 = bitcast [3 x double]* %n2 to i8*
    %124 = bitcast [3 x double]* %n1 to i8*
    %125 = bitcast [3 x double]* %n0 to i8*
    %126 = bitcast [3 x double]* %p3 to i8*
    %127 = bitcast [3 x double]* %p2 to i8*
    %128 = bitcast [3 x double]* %p1 to i8*
    %129 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.end(i64 24, i8* %122) #4
    call void @llvm.lifetime.end(i64 24, i8* %123) #4
    call void @llvm.lifetime.end(i64 24, i8* %124) #4
    call void @llvm.lifetime.end(i64 24, i8* %125) #4
    call void @llvm.lifetime.end(i64 24, i8* %126) #4
    call void @llvm.lifetime.end(i64 24, i8* %127) #4
    call void @llvm.lifetime.end(i64 24, i8* %128) #4
    call void @llvm.lifetime.end(i64 24, i8* %129) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 8, i32 signext 15, i32 signext 7)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  declare void @glPushMatrix() #3
  
  declare void @glRotatef(float, float, float, float) #3
  
  declare void @glTranslatef(float, float, float) #3
  
  declare void @gluCylinder(%struct.GLUquadricObj*, double, double, double, i32 signext, i32 signext) #3
  
  declare void @glPopMatrix() #3
  
  ; Function Attrs: nounwind
  define void @auxSolidCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @icosahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 8, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 9, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 10, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 11, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 12, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 13, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 14, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 15, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 16, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 17, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 18, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 19, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireOctahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @octahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidOctahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireDodecahedron.center, i32 0, i32 0), double %23, i32 signext 2)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @dodecahedron(double* nocapture readonly %center, double %sc, i32 signext %type) unnamed_addr #0 {
    %.b = load i1, i1* @dodecahedron.inited, align 1
    br i1 %.b, label %2, label %1
  
  ; <label>:1                                       ; preds = %0
    store i1 true, i1* @dodecahedron.inited, align 1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 2), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 2), align 8, !tbaa !1
    br label %2
  
  ; <label>:2                                       ; preds = %1, %0
    tail call void @m_pushmatrix() #4
    %3 = load double, double* %center, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %center, i32 1
    %5 = load double, double* %4, align 8, !tbaa !1
    %6 = getelementptr inbounds double, double* %center, i32 2
    %7 = load double, double* %6, align 8, !tbaa !1
    tail call void @m_translate(double %3, double %5, double %7) #4
    tail call void @m_scale(double %sc, double %sc, double %sc) #4
    tail call fastcc void @pentagon(i32 signext 0, i32 signext 1, i32 signext 9, i32 signext 16, i32 signext 5, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 0, i32 signext 3, i32 signext 18, i32 signext 7, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 7, i32 signext 11, i32 signext 10, i32 signext 9, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 11, i32 signext 7, i32 signext 18, i32 signext 19, i32 signext 6, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 8, i32 signext 17, i32 signext 16, i32 signext 9, i32 signext 10, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 14, i32 signext 15, i32 signext 6, i32 signext 19, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 13, i32 signext 12, i32 signext 4, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 19, i32 signext 18, i32 signext 3, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 3, i32 signext 0, i32 signext 5, i32 signext 12, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 6, i32 signext 15, i32 signext 8, i32 signext 10, i32 signext 11, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 17, i32 signext 8, i32 signext 15, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 12, i32 signext 5, i32 signext 16, i32 signext 17, i32 signext %type)
    tail call void @m_popmatrix() #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidDodecahedron.center, i32 0, i32 0), double %23, i32 signext 6)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @compareParams(double* nocapture readonly %oneArray, double* nocapture readonly %twoArray, i32 signext %size) #2 {
    %1 = icmp sgt i32 %size, 0
    br i1 %1, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ 1, %0 ]
    %matches.05 = phi i32 [ %matches.1, %.lr.ph ], [ 1, %0 ]
    %.03 = phi double* [ %2, %.lr.ph ], [ %oneArray, %0 ]
    %.012 = phi double* [ %4, %.lr.ph ], [ %twoArray, %0 ]
    %2 = getelementptr inbounds double, double* %.03, i32 1
    %3 = load double, double* %.03, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %.012, i32 1
    %5 = load double, double* %.012, align 8, !tbaa !1
    %6 = fcmp une double %3, %5
    %matches.1 = select i1 %6, i32 0, i32 %matches.05
    %7 = icmp slt i32 %lsr.iv, %size
    %8 = icmp ne i32 %matches.1, 0
    %9 = and i1 %7, %8
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    %matches.0.lcssa = phi i32 [ 1, %0 ], [ %matches.1, %.lr.ph ]
    ret i32 %matches.0.lcssa
  }
  
  declare i32 @glGenLists(i32 signext) #3
  
  declare void @glBegin(i32 signext) #3
  
  declare void @glNormal3dv(double*) #3
  
  declare void @glVertex3dv(double*) #3
  
  declare void @glEnd() #3
  
  ; Function Attrs: nounwind
  declare double @cos(double) #0
  
  ; Function Attrs: nounwind
  declare double @sin(double) #0
  
  declare void @m_xformpt(double*, double*, double*, double*) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawtriangle(i32 signext %i, i32 signext %geomType, double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    %p1.i.i = alloca [3 x double], align 8
    %p2.i.i = alloca [3 x double], align 8
    %p3.i.i = alloca [3 x double], align 8
    %q0.i.i = alloca [3 x double], align 8
    %q1.i.i = alloca [3 x double], align 8
    %n11.i.i = alloca [3 x double], align 8
    switch i32 %geomType, label %31 [
      i32 0, label %1
      i32 1, label %11
      i32 2, label %21
    ]
  
  ; <label>:1                                       ; preds = %0
    %2 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 0
    %3 = load i32, i32* %2, align 4, !tbaa !13
    %4 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %3, i32 0
    %5 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 1
    %6 = load i32, i32* %5, align 4, !tbaa !13
    %7 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %6, i32 0
    %8 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 2
    %9 = load i32, i32* %8, align 4, !tbaa !13
    %10 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %9, i32 0
    br label %31
  
  ; <label>:11                                      ; preds = %0
    %12 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 0
    %13 = load i32, i32* %12, align 4, !tbaa !13
    %14 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %13, i32 0
    %15 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 1
    %16 = load i32, i32* %15, align 4, !tbaa !13
    %17 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %16, i32 0
    %18 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 2
    %19 = load i32, i32* %18, align 4, !tbaa !13
    %20 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %19, i32 0
    br label %31
  
  ; <label>:21                                      ; preds = %0
    %22 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 0
    %23 = load i32, i32* %22, align 4, !tbaa !13
    %24 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %23, i32 0
    %25 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 1
    %26 = load i32, i32* %25, align 4, !tbaa !13
    %27 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %26, i32 0
    %28 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 2
    %29 = load i32, i32* %28, align 4, !tbaa !13
    %30 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %29, i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %21, %11, %1, %0
    %x0.0 = phi double* [ undef, %0 ], [ %24, %21 ], [ %14, %11 ], [ %4, %1 ]
    %x1.0 = phi double* [ undef, %0 ], [ %27, %21 ], [ %17, %11 ], [ %7, %1 ]
    %x2.0 = phi double* [ undef, %0 ], [ %30, %21 ], [ %20, %11 ], [ %10, %1 ]
    %32 = load double, double* %x0.0, align 8, !tbaa !1
    %33 = fmul double %32, 0.000000e+00
    %34 = load double, double* %x1.0, align 8, !tbaa !1
    %35 = fmul double %34, 0.000000e+00
    %36 = fadd double %33, %35
    %37 = load double, double* %x2.0, align 8, !tbaa !1
    %38 = fadd double %37, %36
    %39 = fadd double %32, %35
    %40 = fmul double %37, 0.000000e+00
    %41 = fadd double %39, %40
    %42 = fadd double %33, %34
    %43 = fadd double %42, %40
    %44 = getelementptr inbounds double, double* %x0.0, i32 1
    %45 = load double, double* %44, align 8, !tbaa !1
    %46 = fmul double %45, 0.000000e+00
    %47 = getelementptr inbounds double, double* %x1.0, i32 1
    %48 = load double, double* %47, align 8, !tbaa !1
    %49 = fmul double %48, 0.000000e+00
    %50 = fadd double %46, %49
    %51 = getelementptr inbounds double, double* %x2.0, i32 1
    %52 = load double, double* %51, align 8, !tbaa !1
    %53 = fadd double %52, %50
    %54 = fadd double %45, %49
    %55 = fmul double %52, 0.000000e+00
    %56 = fadd double %54, %55
    %57 = fadd double %46, %48
    %58 = fadd double %57, %55
    %59 = getelementptr inbounds double, double* %x0.0, i32 2
    %60 = load double, double* %59, align 8, !tbaa !1
    %61 = fmul double %60, 0.000000e+00
    %62 = getelementptr inbounds double, double* %x1.0, i32 2
    %63 = load double, double* %62, align 8, !tbaa !1
    %64 = fmul double %63, 0.000000e+00
    %65 = fadd double %61, %64
    %66 = getelementptr inbounds double, double* %x2.0, i32 2
    %67 = load double, double* %66, align 8, !tbaa !1
    %68 = fadd double %67, %65
    %69 = fadd double %60, %64
    %70 = fmul double %67, 0.000000e+00
    %71 = fadd double %69, %70
    %72 = fadd double %61, %63
    %73 = fadd double %72, %70
    %74 = fmul double %38, %38
    %75 = fmul double %53, %53
    %76 = fadd double %74, %75
    %77 = fmul double %68, %68
    %78 = fadd double %76, %77
    %79 = tail call double @sqrt(double %78) #5
    %80 = fcmp oeq double %79, %79
    br i1 %80, label %.split, label %call.sqrt
  
  call.sqrt:                                        ; preds = %31
    %81 = tail call double @sqrt(double %78) #4
    br label %.split
  
  .split:                                           ; preds = %31, %call.sqrt
    %82 = phi double [ %79, %31 ], [ %81, %call.sqrt ]
    %83 = fdiv double %38, %82
    %84 = fdiv double %53, %82
    %85 = fdiv double %68, %82
    %86 = fmul double %41, %41
    %87 = fmul double %56, %56
    %88 = fadd double %86, %87
    %89 = fmul double %71, %71
    %90 = fadd double %88, %89
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %.split.split, label %call.sqrt1
  
  call.sqrt1:                                       ; preds = %.split
    %93 = tail call double @sqrt(double %90) #4
    br label %.split.split
  
  .split.split:                                     ; preds = %.split, %call.sqrt1
    %94 = phi double [ %91, %.split ], [ %93, %call.sqrt1 ]
    %95 = fdiv double %41, %94
    %96 = fdiv double %56, %94
    %97 = fdiv double %71, %94
    %98 = fmul double %43, %43
    %99 = fmul double %58, %58
    %100 = fadd double %98, %99
    %101 = fmul double %73, %73
    %102 = fadd double %100, %101
    %103 = tail call double @sqrt(double %102) #5
    %104 = fcmp oeq double %103, %103
    br i1 %104, label %.split.split.split, label %call.sqrt2
  
  call.sqrt2:                                       ; preds = %.split.split
    %105 = tail call double @sqrt(double %102) #4
    br label %.split.split.split
  
  .split.split.split:                               ; preds = %.split.split, %call.sqrt2
    %106 = phi double [ %103, %.split.split ], [ %105, %call.sqrt2 ]
    %107 = bitcast [3 x double]* %n11.i.i to double*
    %108 = bitcast [3 x double]* %q1.i.i to double*
    %109 = bitcast [3 x double]* %q0.i.i to double*
    %110 = bitcast [3 x double]* %p3.i.i to double*
    %111 = bitcast [3 x double]* %p2.i.i to double*
    %112 = bitcast [3 x double]* %p1.i.i to double*
    %113 = bitcast [3 x double]* %n11.i.i to i8*
    %114 = bitcast [3 x double]* %q1.i.i to i8*
    %115 = bitcast [3 x double]* %q0.i.i to i8*
    %116 = bitcast [3 x double]* %p3.i.i to i8*
    %117 = bitcast [3 x double]* %p2.i.i to i8*
    %118 = bitcast [3 x double]* %p1.i.i to i8*
    %119 = fdiv double %43, %106
    %120 = fdiv double %58, %106
    %121 = fdiv double %73, %106
    call void @llvm.lifetime.start(i64 24, i8* %118) #4
    call void @llvm.lifetime.start(i64 24, i8* %117) #4
    call void @llvm.lifetime.start(i64 24, i8* %116) #4
    call void @llvm.lifetime.start(i64 24, i8* %115) #4
    call void @llvm.lifetime.start(i64 24, i8* %114) #4
    call void @llvm.lifetime.start(i64 24, i8* %113) #4
    %122 = fmul double %95, %radius
    %123 = load double, double* %p0, align 8, !tbaa !1
    %124 = fadd double %122, %123
    store double %124, double* %112, align 8, !tbaa !1
    %125 = fmul double %83, %radius
    %126 = fadd double %125, %123
    store double %126, double* %111, align 8, !tbaa !1
    %127 = fmul double %119, %radius
    %128 = fadd double %127, %123
    store double %128, double* %110, align 8, !tbaa !1
    %129 = fmul double %96, %radius
    %sunkaddr = ptrtoint double* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    %130 = load double, double* %sunkaddr4, align 8, !tbaa !1
    %131 = fadd double %129, %130
    %sunkaddr5 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr6 = add i32 %sunkaddr5, 8
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %131, double* %sunkaddr7, align 8, !tbaa !1
    %132 = fmul double %84, %radius
    %133 = fadd double %132, %130
    %sunkaddr8 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %133, double* %sunkaddr10, align 8, !tbaa !1
    %134 = fmul double %120, %radius
    %135 = fadd double %134, %130
    %sunkaddr11 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr12 = add i32 %sunkaddr11, 8
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %135, double* %sunkaddr13, align 8, !tbaa !1
    %136 = fmul double %97, %radius
    %sunkaddr14 = ptrtoint double* %p0 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 16
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    %137 = load double, double* %sunkaddr16, align 8, !tbaa !1
    %138 = fadd double %136, %137
    %sunkaddr17 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %138, double* %sunkaddr19, align 8, !tbaa !1
    %139 = fmul double %85, %radius
    %140 = fadd double %139, %137
    %sunkaddr20 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr21 = add i32 %sunkaddr20, 16
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %140, double* %sunkaddr22, align 8, !tbaa !1
    %141 = fmul double %121, %radius
    %142 = fadd double %141, %137
    %sunkaddr23 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %142, double* %sunkaddr25, align 8, !tbaa !1
    call void @diff3(double* %112, double* %111, double* %109) #4
    call void @diff3(double* %111, double* %110, double* %108) #4
    call void @crossprod(double* %109, double* %108, double* %108) #4
    call void @normalize(double* %108) #4
    call void @m_xformpt(double* %112, double* %112, double* %108, double* %107) #4
    call void @m_xformptonly(double* %111, double* %111) #4
    call void @m_xformptonly(double* %110, double* %110) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %107) #4
    call void @glVertex3dv(double* %112) #4
    call void @glVertex3dv(double* %111) #4
    call void @glVertex3dv(double* %110) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %113) #4
    call void @llvm.lifetime.end(i64 24, i8* %114) #4
    call void @llvm.lifetime.end(i64 24, i8* %115) #4
    call void @llvm.lifetime.end(i64 24, i8* %116) #4
    call void @llvm.lifetime.end(i64 24, i8* %117) #4
    call void @llvm.lifetime.end(i64 24, i8* %118) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  declare void @diff3(double*, double*, double*) #3
  
  declare void @crossprod(double*, double*, double*) #3
  
  declare void @normalize(double*) #3
  
  declare void @m_xformptonly(double*, double*) #3
  
  declare void @m_pushmatrix() #3
  
  declare void @m_translate(double, double, double) #3
  
  declare void @m_scale(double, double, double) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @pentagon(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %shadeType) unnamed_addr #0 {
    %n0 = alloca [3 x double], align 8
    %d1 = alloca [3 x double], align 8
    %d2 = alloca [3 x double], align 8
    %d3 = alloca [3 x double], align 8
    %d4 = alloca [3 x double], align 8
    %d5 = alloca [3 x double], align 8
    %nout = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %d1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %d2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %d3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %d4 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %d5 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %nout to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %a, i32 0
    %9 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %b, i32 0
    %10 = bitcast [3 x double]* %d1 to double*
    call void @diff3(double* %8, double* %9, double* %10) #4
    %11 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %c, i32 0
    %12 = bitcast [3 x double]* %d2 to double*
    call void @diff3(double* %9, double* %11, double* %12) #4
    %13 = bitcast [3 x double]* %n0 to double*
    call void @crossprod(double* %10, double* %12, double* %13) #4
    call void @normalize(double* %13) #4
    %14 = bitcast [3 x double]* %nout to double*
    call void @m_xformpt(double* %8, double* %10, double* %13, double* %14) #4
    call void @m_xformptonly(double* %9, double* %12) #4
    %15 = bitcast [3 x double]* %d3 to double*
    call void @m_xformptonly(double* %11, double* %15) #4
    %16 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %d, i32 0
    %17 = bitcast [3 x double]* %d4 to double*
    call void @m_xformptonly(double* %16, double* %17) #4
    %18 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %e, i32 0
    %19 = bitcast [3 x double]* %d5 to double*
    call void @m_xformptonly(double* %18, double* %19) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %14) #4
    call void @glVertex3dv(double* %10) #4
    call void @glVertex3dv(double* %12) #4
    call void @glVertex3dv(double* %15) #4
    call void @glVertex3dv(double* %17) #4
    call void @glVertex3dv(double* %19) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %7) #4
    call void @llvm.lifetime.end(i64 24, i8* %6) #4
    call void @llvm.lifetime.end(i64 24, i8* %5) #4
    call void @llvm.lifetime.end(i64 24, i8* %4) #4
    call void @llvm.lifetime.end(i64 24, i8* %3) #4
    call void @llvm.lifetime.end(i64 24, i8* %2) #4
    call void @llvm.lifetime.end(i64 24, i8* %1) #4
    ret void
  }
  
  declare void @m_popmatrix() #3
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { norecurse nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { nounwind }
  attributes #5 = { nounwind readnone }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !2, i64 0}
  !2 = !{!"double", !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"any pointer", !3, i64 0}
  !7 = !{!8, !6, i64 12}
  !8 = !{!"model", !9, i64 0, !6, i64 4, !9, i64 8, !6, i64 12}
  !9 = !{!"int", !3, i64 0}
  !10 = !{!8, !9, i64 0}
  !11 = !{!8, !9, i64 8}
  !12 = !{!8, !6, i64 4}
  !13 = !{!9, !9, i64 0}

...
---
name:            auxWireTorus
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: afgr64 }
  - { id: 13, class: afgr64 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: afgr64 }
  - { id: 23, class: afgr64 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
liveins:         
  - { reg: '%d6', virtual-reg: '%12' }
  - { reg: '%d7', virtual-reg: '%13' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 40):
    successors: %bb.6.findList.exit.thread(37), %bb.10(62)
    liveins: %d6, %d7, %t9, %v0
  
    %14 = ADDu %v0, %t9
    %13 = COPY %d7
    %12 = COPY %d6
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %15 = LW %14, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %16 = ADDiu %zero, 16
    %a0 = COPY %16
    %gp = COPY %14
    %t9 = COPY %15
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %17 = COPY %v0
    SDC1 %12, %17, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.2, !tbaa !1)
    SDC1 %13, %17, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.4, !tbaa !1)
    %18 = LW %14, target-flags(<unknown>) @lists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %19 = ADDiu %18, target-flags(<unknown>) @lists
    %1 = LW %19, 12, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from `%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3)`, !tbaa !5)
    %0 = COPY %17
    BEQ %1, %zero, %bb.6.findList.exit.thread, implicit-def %at
  
  bb.10 (freq 25):
    successors: %bb.1..lr.ph.i(100)
  
  
  bb.1..lr.ph.i (freq 409):
    successors: %bb.2..lr.ph.i.i(100)
  
    %2 = PHI %1, %bb.10, %10, %bb.4
    %3 = LW %2, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.6, !tbaa !7)
    %21 = ADDiu %zero, 1
    %20 = ADDiu %zero, 0
  
  bb.2..lr.ph.i.i (freq 13107):
    successors: %bb.9..lr.ph.i.i(98), %bb.3.compareParams.exit.i(1)
  
    %4 = PHI %20, %bb.1..lr.ph.i, %9, %bb.9..lr.ph.i.i
    %5 = PHI %21, %bb.1..lr.ph.i, %8, %bb.9..lr.ph.i.i
    %6 = PHI %21, %bb.1..lr.ph.i, %7, %bb.9..lr.ph.i.i
    %22 = LDXC1 %0, %4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 8 from %ir.scevgep4, !tbaa !1)
    %23 = LDXC1 %3, %4, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 8 from %ir.uglygep3, !tbaa !1)
    FCMP_D32 killed %23, killed %22, 18, implicit-def %fcc0
    %7 = MOVF_I killed %zero, %fcc0, %6
    %25 = SLTi %5, 2
    BEQ killed %25, %zero, %bb.3.compareParams.exit.i, implicit-def dead %at
    B %bb.9..lr.ph.i.i, implicit-def dead %at
  
  bb.9..lr.ph.i.i (freq 12902):
    successors: %bb.2..lr.ph.i.i(98), %bb.3.compareParams.exit.i(1)
  
    %9 = ADDiu %4, 8
    %8 = ADDiu %5, 1
    BNE %7, %zero, %bb.2..lr.ph.i.i, implicit-def dead %at
    B %bb.3.compareParams.exit.i, implicit-def dead %at
  
  bb.3.compareParams.exit.i (freq 409):
    successors: %bb.4(96), %bb.5.findList.exit(3)
  
    BNE %7, %zero, %bb.5.findList.exit, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.16, freq 396):
    successors: %bb.6.findList.exit.thread(3), %bb.1..lr.ph.i(96)
  
    %10 = LW %2, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.17, !tbaa !5)
    BEQ %10, %zero, %bb.6.findList.exit.thread, implicit-def dead %at
    B %bb.1..lr.ph.i, implicit-def dead %at
  
  bb.5.findList.exit (freq 12):
    successors: %bb.6.findList.exit.thread(37), %bb.7(62)
  
    %11 = LW %2, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.19, !tbaa !10)
    BNE %11, %zero, %bb.7, implicit-def dead %at
    B %bb.6.findList.exit.thread, implicit-def dead %at
  
  bb.6.findList.exit.thread (freq 32):
    successors: %bb.8(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %28 = LW %14, target-flags(<unknown>) @malloc, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @malloc)
    %29 = ADDiu %zero, 16
    %a0 = COPY %29
    %t9 = COPY %28
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %30 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %31 = LW %14, target-flags(<unknown>) @glGenLists, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glGenLists)
    %32 = ADDiu %zero, 1
    %a0 = COPY %32
    %gp = COPY %14
    %t9 = COPY %31
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %33 = COPY %v0
    %36 = ADDiu %zero, 2
    %37 = ADDiu %zero, 4865
    SW %33, %30, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.24, !tbaa !10)
    SW %36, %30, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.26, !tbaa !11)
    SW %0, %30, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.28, !tbaa !7)
    %38 = LW %19, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*)`, !tbaa !5)
    SW killed %38, %30, 4, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.31, !tbaa !12)
    SW %30, %19, 12, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**)`, !tbaa !5)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %39 = LW %14, target-flags(<unknown>) @glNewList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glNewList)
    %a0 = COPY %33
    %a1 = COPY %37
    %gp = COPY %14
    %t9 = COPY %39
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %40 = LW %14, target-flags(<unknown>) @doughnut, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %41 = ADDiu killed %40, target-flags(<unknown>) @doughnut
    %42 = ADDiu %zero, 5
    %43 = ADDiu %zero, 10
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %d0 = COPY %12
    %d1 = COPY %13
    %a0 = COPY %42
    %a1 = COPY %43
    %a2 = COPY %36
    %t9 = COPY %41
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d0, implicit %d1, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %44 = LW %14, target-flags(<unknown>) @glEndList, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glEndList)
    %gp = COPY %14
    %t9 = COPY %44
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.8, implicit-def dead %at
  
  bb.7 (%ir-block.32, freq 7):
    successors: %bb.8(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %26 = LW %14, target-flags(<unknown>) @glCallList, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @glCallList)
    %a0 = COPY %11
    %gp = COPY %14
    %t9 = COPY %26
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %27 = LW %14, target-flags(<unknown>) @free, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @free)
    %a0 = COPY %0
    %gp = COPY %14
    %t9 = COPY %27
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.8 (%ir-block.33, freq 40):
    liveouts:
  
    RetRA

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/mesa/mesa.shapes.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct.model = type { i32, %struct.model*, i32, double* }
  %struct.GLUquadricObj = type opaque
  
  @auxWireIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidIcosahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidOctahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidTetrahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxWireDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @auxSolidDodecahedron.center = internal global [3 x double] zeroinitializer, align 8
  @lists = internal unnamed_addr global [25 x %struct.model*] zeroinitializer, align 4
  @drawbox.n = internal global [6 x [3 x double]] [[3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @drawbox.faces = internal unnamed_addr constant [6 x [4 x i32]] [[4 x i32] [i32 0, i32 1, i32 2, i32 3], [4 x i32] [i32 3, i32 2, i32 6, i32 7], [4 x i32] [i32 7, i32 6, i32 5, i32 4], [4 x i32] [i32 4, i32 5, i32 1, i32 0], [4 x i32] [i32 5, i32 6, i32 2, i32 1], [4 x i32] [i32 7, i32 4, i32 0, i32 3]], align 4
  @iindex = internal unnamed_addr constant [20 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 1], [3 x i32] [i32 0, i32 9, i32 4], [3 x i32] [i32 9, i32 5, i32 4], [3 x i32] [i32 4, i32 5, i32 8], [3 x i32] [i32 4, i32 8, i32 1], [3 x i32] [i32 8, i32 10, i32 1], [3 x i32] [i32 8, i32 3, i32 10], [3 x i32] [i32 5, i32 3, i32 8], [3 x i32] [i32 5, i32 2, i32 3], [3 x i32] [i32 2, i32 7, i32 3], [3 x i32] [i32 7, i32 10, i32 3], [3 x i32] [i32 7, i32 6, i32 10], [3 x i32] [i32 7, i32 11, i32 6], [3 x i32] [i32 11, i32 0, i32 6], [3 x i32] [i32 0, i32 1, i32 6], [3 x i32] [i32 6, i32 1, i32 10], [3 x i32] [i32 9, i32 0, i32 11], [3 x i32] [i32 9, i32 11, i32 2], [3 x i32] [i32 9, i32 2, i32 5], [3 x i32] [i32 7, i32 2, i32 11]], align 4
  @idata = internal global [12 x [3 x double]] [[3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0x3FEB38880B4603E4], [3 x double] [double 0xBFE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0x3FE0D2CA0DA1530D, double 0.000000e+00, double 0xBFEB38880B4603E4], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D], [3 x double] [double 0.000000e+00, double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D], [3 x double] [double 0x3FEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0x3FE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0x3FEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00], [3 x double] [double 0xBFEB38880B4603E4, double 0xBFE0D2CA0DA1530D, double 0.000000e+00]], align 8
  @ondex = internal unnamed_addr constant [8 x [3 x i32]] [[3 x i32] [i32 0, i32 4, i32 2], [3 x i32] [i32 1, i32 2, i32 4], [3 x i32] [i32 0, i32 3, i32 4], [3 x i32] [i32 1, i32 4, i32 3], [3 x i32] [i32 0, i32 2, i32 5], [3 x i32] [i32 1, i32 5, i32 2], [3 x i32] [i32 0, i32 5, i32 3], [3 x i32] [i32 1, i32 3, i32 5]], align 4
  @odata = internal global [6 x [3 x double]] [[3 x double] [double 1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double -1.000000e+00, double 0.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double -1.000000e+00, double 0.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double 1.000000e+00], [3 x double] [double 0.000000e+00, double 0.000000e+00, double -1.000000e+00]], align 8
  @tndex = internal unnamed_addr constant [4 x [3 x i32]] [[3 x i32] [i32 0, i32 1, i32 3], [3 x i32] [i32 2, i32 1, i32 0], [3 x i32] [i32 3, i32 2, i32 0], [3 x i32] [i32 1, i32 2, i32 3]], align 4
  @tdata = internal global [4 x [3 x double]] [[3 x double] [double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0x3FFBB67AE8584CAA], [3 x double] [double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA, double 0xBFFBB67AE8584CAA], [3 x double] [double 0xBFFBB67AE8584CAA, double 0xBFFBB67AE8584CAA, double 0x3FFBB67AE8584CAA]], align 8
  @dodecahedron.inited = internal unnamed_addr global i1 false
  @dodec = internal global [20 x [3 x double]] zeroinitializer, align 8
  
  ; Function Attrs: nounwind
  define void @auxWireSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 0), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast ([25 x %struct.model*]* @lists to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast ([25 x %struct.model*]* @lists to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100011) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare noalias i8* @malloc(i32 signext) #0
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @findList(i32 signext %lindex, double* nocapture readonly %paramArray, i32 signext %size) #2 {
    %1 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %endList.02 = load %struct.model*, %struct.model** %1, align 4, !tbaa !5
    %2 = icmp eq %struct.model* %endList.02, null
    br i1 %2, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0
    br label %3
  
  ; <label>:3                                       ; preds = %18, %.lr.ph
    %endList.03 = phi %struct.model* [ %endList.02, %.lr.ph ], [ %endList.0, %18 ]
    %4 = icmp sgt i32 %size, 0
    br i1 %4, label %.lr.ph.i.preheader, label %compareParams.exit.thread
  
  .lr.ph.i.preheader:                               ; preds = %3
    %5 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 3
    %6 = load double*, double** %5, align 4, !tbaa !7
    br label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %matches.05.i = phi i32 [ %matches.1.i, %.lr.ph.i ], [ 1, %.lr.ph.i.preheader ]
    %.03.i = phi double* [ %7, %.lr.ph.i ], [ %6, %.lr.ph.i.preheader ]
    %.012.i = phi double* [ %9, %.lr.ph.i ], [ %paramArray, %.lr.ph.i.preheader ]
    %7 = getelementptr inbounds double, double* %.03.i, i32 1
    %8 = load double, double* %.03.i, align 8, !tbaa !1
    %9 = getelementptr inbounds double, double* %.012.i, i32 1
    %10 = load double, double* %.012.i, align 8, !tbaa !1
    %11 = fcmp une double %8, %10
    %matches.1.i = select i1 %11, i32 0, i32 %matches.05.i
    %12 = icmp slt i32 %lsr.iv, %size
    %13 = icmp ne i32 %matches.1.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %14, label %.lr.ph.i, label %compareParams.exit
  
  compareParams.exit:                               ; preds = %.lr.ph.i
    %15 = icmp eq i32 %matches.1.i, 0
    br i1 %15, label %18, label %compareParams.exit.thread
  
  compareParams.exit.thread:                        ; preds = %compareParams.exit, %3
    %16 = bitcast %struct.model* %endList.03 to i32*
    %17 = load i32, i32* %16, align 4, !tbaa !10
    br label %.loopexit
  
  ; <label>:18                                      ; preds = %compareParams.exit
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03, i32 0, i32 1
    %endList.0 = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0, null
    br i1 %20, label %.loopexit, label %3
  
  .loopexit:                                        ; preds = %18, %compareParams.exit.thread, %0
    %.0 = phi i32 [ %17, %compareParams.exit.thread ], [ 0, %0 ], [ 0, %18 ]
    ret i32 %.0
  }
  
  declare void @glNewList(i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @makeModelPtr(i32 signext %lindex, double* %sizeArray, i32 signext %count) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = tail call i32 @glGenLists(i32 signext 1) #4
    %3 = bitcast i8* %1 to i32*
    store i32 %2, i32* %3, align 4, !tbaa !10
    %4 = getelementptr inbounds i8, i8* %1, i32 8
    %5 = bitcast i8* %4 to i32*
    store i32 %count, i32* %5, align 4, !tbaa !11
    %6 = getelementptr inbounds i8, i8* %1, i32 12
    %7 = bitcast i8* %6 to double**
    store double* %sizeArray, double** %7, align 4, !tbaa !7
    %8 = getelementptr inbounds [25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 %lindex
    %9 = bitcast %struct.model** %8 to i32*
    %10 = load i32, i32* %9, align 4, !tbaa !5
    %11 = getelementptr inbounds i8, i8* %1, i32 4
    %12 = bitcast i8* %11 to i32*
    store i32 %10, i32* %12, align 4, !tbaa !12
    %13 = bitcast %struct.model** %8 to i8**
    store i8* %1, i8** %13, align 4, !tbaa !5
    ret i32 %2
  }
  
  declare %struct.GLUquadricObj* @gluNewQuadric() #3
  
  declare void @gluQuadricDrawStyle(%struct.GLUquadricObj*, i32 signext) #3
  
  declare void @gluSphere(%struct.GLUquadricObj*, double, i32 signext, i32 signext) #3
  
  declare void @glEndList() #3
  
  declare void @glCallList(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  define void @auxSolidSphere(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 10) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %23, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %23, i32 signext 100000) #4
    tail call void @gluSphere(%struct.GLUquadricObj* %23, double %radius, i32 signext 16, i32 signext 16) #4
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  declare void @gluQuadricNormals(%struct.GLUquadricObj*, i32 signext) #3
  
  ; Function Attrs: nounwind
  define void @auxWireCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 1) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 2)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawbox(double %x0, double %x1, double %y0, double %y1, double %z0, double %z1, i32 signext %type) unnamed_addr #0 {
    %v = alloca [8 x [3 x double]], align 8
    %1 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.start(i64 192, i8* %1) #4
    %2 = fcmp ogt double %x0, %x1
    %.05 = select i1 %2, double %x0, double %x1
    %.0 = select i1 %2, double %x1, double %x0
    %3 = fcmp ogt double %y0, %y1
    %.04 = select i1 %3, double %y1, double %y0
    %.03 = select i1 %3, double %y0, double %y1
    %4 = fcmp ogt double %z0, %z1
    %.02 = select i1 %4, double %z1, double %z0
    %.01 = select i1 %4, double %z0, double %z1
    %5 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 0
    store double %.0, double* %5, align 8, !tbaa !1
    %6 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 0
    store double %.0, double* %6, align 8, !tbaa !1
    %7 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 0
    store double %.0, double* %7, align 8, !tbaa !1
    %8 = bitcast [8 x [3 x double]]* %v to double*
    store double %.0, double* %8, align 8, !tbaa !1
    %9 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 0
    store double %.05, double* %9, align 8, !tbaa !1
    %10 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 0
    store double %.05, double* %10, align 8, !tbaa !1
    %11 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 0
    store double %.05, double* %11, align 8, !tbaa !1
    %12 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 0
    store double %.05, double* %12, align 8, !tbaa !1
    %13 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 1
    store double %.04, double* %13, align 8, !tbaa !1
    %14 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 1
    store double %.04, double* %14, align 8, !tbaa !1
    %15 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 1
    store double %.04, double* %15, align 8, !tbaa !1
    %16 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 1
    store double %.04, double* %16, align 8, !tbaa !1
    %17 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 1
    store double %.03, double* %17, align 8, !tbaa !1
    %18 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 1
    store double %.03, double* %18, align 8, !tbaa !1
    %19 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 1
    store double %.03, double* %19, align 8, !tbaa !1
    %20 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 1
    store double %.03, double* %20, align 8, !tbaa !1
    %21 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 7, i32 2
    store double %.02, double* %21, align 8, !tbaa !1
    %22 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 4, i32 2
    store double %.02, double* %22, align 8, !tbaa !1
    %23 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 3, i32 2
    store double %.02, double* %23, align 8, !tbaa !1
    %24 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 0, i32 2
    store double %.02, double* %24, align 8, !tbaa !1
    %25 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 6, i32 2
    store double %.01, double* %25, align 8, !tbaa !1
    %26 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 5, i32 2
    store double %.01, double* %26, align 8, !tbaa !1
    %27 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 2, i32 2
    store double %.01, double* %27, align 8, !tbaa !1
    %28 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 1, i32 2
    store double %.01, double* %28, align 8, !tbaa !1
    br label %29
  
  ; <label>:29                                      ; preds = %29, %0
    %lsr.iv1 = phi [6 x [4 x i32]]* [ %38, %29 ], [ bitcast (i32* getelementptr inbounds ([6 x [4 x i32]], [6 x [4 x i32]]* @drawbox.faces, i32 0, i32 0, i32 2) to [6 x [4 x i32]]*), %0 ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %29 ], [ 0, %0 ]
    %lsr.iv12 = bitcast [6 x [4 x i32]]* %lsr.iv1 to i32*
    call void @glBegin(i32 signext %type) #4
    %uglygep11 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep1112 = bitcast i8* %uglygep11 to double*
    call void @glNormal3dv(double* %uglygep1112) #4
    %scevgep5 = getelementptr i32, i32* %lsr.iv12, i32 -2
    %30 = load i32, i32* %scevgep5, align 4, !tbaa !13
    %31 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %30, i32 0
    call void @glVertex3dv(double* %31) #4
    %uglygep9 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep910 = bitcast i8* %uglygep9 to double*
    call void @glNormal3dv(double* %uglygep910) #4
    %scevgep4 = getelementptr i32, i32* %lsr.iv12, i32 -1
    %32 = load i32, i32* %scevgep4, align 4, !tbaa !13
    %33 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %32, i32 0
    call void @glVertex3dv(double* %33) #4
    %uglygep7 = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep78 = bitcast i8* %uglygep7 to double*
    call void @glNormal3dv(double* %uglygep78) #4
    %34 = load i32, i32* %lsr.iv12, align 4, !tbaa !13
    %35 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %34, i32 0
    call void @glVertex3dv(double* %35) #4
    %uglygep = getelementptr i8, i8* bitcast ([6 x [3 x double]]* @drawbox.n to i8*), i32 %lsr.iv
    %uglygep6 = bitcast i8* %uglygep to double*
    call void @glNormal3dv(double* %uglygep6) #4
    %scevgep3 = getelementptr i32, i32* %lsr.iv12, i32 1
    %36 = load i32, i32* %scevgep3, align 4, !tbaa !13
    %37 = getelementptr inbounds [8 x [3 x double]], [8 x [3 x double]]* %v, i32 0, i32 %36, i32 0
    call void @glVertex3dv(double* %37) #4
    call void @glEnd() #4
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 24
    %scevgep = getelementptr [6 x [4 x i32]], [6 x [4 x i32]]* %lsr.iv1, i32 0, i32 1, i32 0
    %38 = bitcast i32* %scevgep to [6 x [4 x i32]]*
    %exitcond = icmp eq i32 %lsr.iv.next, 144
    br i1 %exitcond, label %39, label %29
  
  ; <label>:39                                      ; preds = %29
    %40 = bitcast [8 x [3 x double]]* %v to i8*
    call void @llvm.lifetime.end(i64 192, i8* %40) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCube(double %size) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %size, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %size
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %25
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 11) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fmul double %size, -5.000000e-01
    %24 = fmul double %size, 5.000000e-01
    tail call fastcc void @drawbox(double %23, double %24, double %23, double %24, double %23, double %24, i32 signext 7)
    tail call void @glEndList() #4
    br label %26
  
  ; <label>:25                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %26
  
  ; <label>:26                                      ; preds = %25, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 2) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 2)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidBox(double %width, double %height, double %depth) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 24) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %width, double* %2, align 8, !tbaa !1
    %5 = getelementptr inbounds i8, i8* %1, i32 16
    %6 = bitcast i8* %5 to double*
    store double %height, double* %4, align 8, !tbaa !1
    store double %depth, double* %6, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12), align 4, !tbaa !5
    %7 = icmp eq %struct.model* %endList.02.i, null
    br i1 %7, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %18
    %endList.03.i = phi %struct.model* [ %endList.0.i, %18 ], [ %endList.02.i, %0 ]
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %9 = load double*, double** %8, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %10 = bitcast double* %9 to i8*
    %uglygep = getelementptr i8, i8* %10, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %11 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %12 = load double, double* %scevgep4, align 8, !tbaa !1
    %13 = fcmp une double %11, %12
    %matches.1.i.i = select i1 %13, i32 0, i32 %matches.05.i.i
    %14 = icmp slt i32 %lsr.iv, 3
    %15 = icmp ne i32 %matches.1.i.i, 0
    %16 = and i1 %14, %15
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %16, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %17 = icmp eq i32 %matches.1.i.i, 0
    br i1 %17, label %18, label %findList.exit
  
  ; <label>:18                                      ; preds = %compareParams.exit.i
    %19 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %19, align 4, !tbaa !5
    %20 = icmp eq %struct.model* %endList.0.i, null
    br i1 %20, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %21 = bitcast %struct.model* %endList.03.i to i32*
    %22 = load i32, i32* %21, align 4, !tbaa !10
    %23 = icmp eq i32 %22, 0
    br i1 %23, label %findList.exit.thread, label %40
  
  findList.exit.thread:                             ; preds = %18, %findList.exit, %0
    %24 = tail call noalias i8* @malloc(i32 signext 16) #4
    %25 = tail call i32 @glGenLists(i32 signext 1) #4
    %26 = bitcast i8* %24 to i32*
    store i32 %25, i32* %26, align 4, !tbaa !10
    %27 = getelementptr inbounds i8, i8* %24, i32 8
    %28 = bitcast i8* %27 to i32*
    store i32 3, i32* %28, align 4, !tbaa !11
    %29 = getelementptr inbounds i8, i8* %24, i32 12
    %30 = bitcast i8* %29 to i8**
    store i8* %1, i8** %30, align 4, !tbaa !7
    %31 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i32*), align 4, !tbaa !5
    %32 = getelementptr inbounds i8, i8* %24, i32 4
    %33 = bitcast i8* %32 to i32*
    store i32 %31, i32* %33, align 4, !tbaa !12
    store i8* %24, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 12) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %25, i32 signext 4865) #4
    %34 = fmul double %width, -5.000000e-01
    %35 = fmul double %width, 5.000000e-01
    %36 = fmul double %height, -5.000000e-01
    %37 = fmul double %height, 5.000000e-01
    %38 = fmul double %depth, -5.000000e-01
    %39 = fmul double %depth, 5.000000e-01
    tail call fastcc void @drawbox(double %34, double %35, double %36, double %37, double %38, double %39, i32 signext 7)
    tail call void @glEndList() #4
    br label %41
  
  ; <label>:40                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %22) #4
    tail call void @free(i8* %1) #4
    br label %41
  
  ; <label>:41                                      ; preds = %40, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 3) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 5, i32 signext 10, i32 signext 2)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @doughnut(double %r, double %R, i32 signext %nsides, i32 signext %rings, i32 signext %type) unnamed_addr #0 {
    %p0 = alloca [3 x double], align 8
    %p1 = alloca [3 x double], align 8
    %p2 = alloca [3 x double], align 8
    %p3 = alloca [3 x double], align 8
    %n0 = alloca [3 x double], align 8
    %n1 = alloca [3 x double], align 8
    %n2 = alloca [3 x double], align 8
    %n3 = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %p1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %p2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %p3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %n1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %n2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = bitcast [3 x double]* %n3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %8) #4
    %9 = icmp sgt i32 %rings, 0
    br i1 %9, label %.lr.ph3, label %._crit_edge
  
  .lr.ph3:                                          ; preds = %0
    %10 = sitofp i32 %rings to double
    %11 = sitofp i32 %nsides to double
    br label %12
  
  .loopexit:                                        ; preds = %.lr.ph, %12
    %exitcond4 = icmp eq i32 %17, %rings
    br i1 %exitcond4, label %._crit_edge, label %12
  
  ; <label>:12                                      ; preds = %.loopexit, %.lr.ph3
    %IV.S.1 = phi double [ 0.000000e+00, %.lr.ph3 ], [ %IV.S.next.2, %.loopexit ]
    %i.02 = phi i32 [ 0, %.lr.ph3 ], [ %17, %.loopexit ]
    %13 = icmp sgt i32 %nsides, 0
    %14 = fmul double %IV.S.1, 2.000000e+00
    %15 = fmul double %14, 0x400921FB54442C46
    %16 = fdiv double %15, %10
    %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
    %17 = add nuw nsw i32 %i.02, 1
    %18 = sitofp i32 %17 to double
    %19 = fmul double %18, 2.000000e+00
    %20 = fmul double %19, 0x400921FB54442C46
    %21 = fdiv double %20, %10
    br i1 %13, label %.lr.ph, label %.loopexit
  
  .lr.ph:                                           ; preds = %12, %.lr.ph
    %IV.S. = phi double [ %IV.S.next., %.lr.ph ], [ 0.000000e+00, %12 ]
    %j.01 = phi i32 [ %33, %.lr.ph ], [ 0, %12 ]
    %22 = bitcast [3 x double]* %n3 to double*
    %23 = bitcast [3 x double]* %n2 to double*
    %24 = bitcast [3 x double]* %n1 to double*
    %25 = bitcast [3 x double]* %n0 to double*
    %26 = bitcast [3 x double]* %p3 to double*
    %27 = bitcast [3 x double]* %p2 to double*
    %28 = bitcast [3 x double]* %p1 to double*
    %29 = bitcast [3 x double]* %p0 to double*
    %30 = fmul double %IV.S., 2.000000e+00
    %31 = fmul double %30, 0x400921FB54442C46
    %32 = fdiv double %31, %11
    %IV.S.next. = fadd double %IV.S., 1.000000e+00
    %33 = add nuw nsw i32 %j.01, 1
    %34 = sitofp i32 %33 to double
    %35 = fmul double %34, 2.000000e+00
    %36 = fmul double %35, 0x400921FB54442C46
    %37 = fdiv double %36, %11
    %38 = call double @cos(double %16) #4
    %39 = call double @cos(double %32) #4
    %40 = fmul double %39, %r
    %41 = fadd double %40, %R
    %42 = fmul double %38, %41
    store double %42, double* %29, align 8, !tbaa !1
    %43 = call double @sin(double %16) #4
    %44 = call double @cos(double %32) #4
    %45 = fmul double %44, %r
    %46 = fadd double %45, %R
    %47 = fmul double %43, %46
    %48 = fsub double -0.000000e+00, %47
    %sunkaddr = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    store double %48, double* %sunkaddr4, align 8, !tbaa !1
    %49 = call double @sin(double %32) #4
    %50 = fmul double %49, %r
    %sunkaddr5 = ptrtoint [3 x double]* %p0 to i32
    %sunkaddr6 = add i32 %sunkaddr5, 16
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %50, double* %sunkaddr7, align 8, !tbaa !1
    %51 = call double @cos(double %21) #4
    %52 = call double @cos(double %32) #4
    %53 = fmul double %52, %r
    %54 = fadd double %53, %R
    %55 = fmul double %51, %54
    store double %55, double* %28, align 8, !tbaa !1
    %56 = call double @sin(double %21) #4
    %57 = call double @cos(double %32) #4
    %58 = fmul double %57, %r
    %59 = fadd double %58, %R
    %60 = fmul double %56, %59
    %61 = fsub double -0.000000e+00, %60
    %sunkaddr8 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %61, double* %sunkaddr10, align 8, !tbaa !1
    %62 = call double @sin(double %32) #4
    %63 = fmul double %62, %r
    %sunkaddr11 = ptrtoint [3 x double]* %p1 to i32
    %sunkaddr12 = add i32 %sunkaddr11, 16
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %63, double* %sunkaddr13, align 8, !tbaa !1
    %64 = call double @cos(double %21) #4
    %65 = call double @cos(double %37) #4
    %66 = fmul double %65, %r
    %67 = fadd double %66, %R
    %68 = fmul double %64, %67
    store double %68, double* %27, align 8, !tbaa !1
    %69 = call double @sin(double %21) #4
    %70 = call double @cos(double %37) #4
    %71 = fmul double %70, %r
    %72 = fadd double %71, %R
    %73 = fmul double %69, %72
    %74 = fsub double -0.000000e+00, %73
    %sunkaddr14 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 8
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    store double %74, double* %sunkaddr16, align 8, !tbaa !1
    %75 = call double @sin(double %37) #4
    %76 = fmul double %75, %r
    %sunkaddr17 = ptrtoint [3 x double]* %p2 to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %76, double* %sunkaddr19, align 8, !tbaa !1
    %77 = call double @cos(double %16) #4
    %78 = call double @cos(double %37) #4
    %79 = fmul double %78, %r
    %80 = fadd double %79, %R
    %81 = fmul double %77, %80
    store double %81, double* %26, align 8, !tbaa !1
    %82 = call double @sin(double %16) #4
    %83 = call double @cos(double %37) #4
    %84 = fmul double %83, %r
    %85 = fadd double %84, %R
    %86 = fmul double %82, %85
    %87 = fsub double -0.000000e+00, %86
    %sunkaddr20 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr21 = add i32 %sunkaddr20, 8
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %87, double* %sunkaddr22, align 8, !tbaa !1
    %88 = call double @sin(double %37) #4
    %89 = fmul double %88, %r
    %sunkaddr23 = ptrtoint [3 x double]* %p3 to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %89, double* %sunkaddr25, align 8, !tbaa !1
    %90 = call double @cos(double %16) #4
    %91 = call double @cos(double %32) #4
    %92 = fmul double %90, %91
    store double %92, double* %25, align 8, !tbaa !1
    %93 = call double @sin(double %16) #4
    %94 = call double @cos(double %32) #4
    %95 = fmul double %93, %94
    %96 = fsub double -0.000000e+00, %95
    %sunkaddr26 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr27 = add i32 %sunkaddr26, 8
    %sunkaddr28 = inttoptr i32 %sunkaddr27 to double*
    store double %96, double* %sunkaddr28, align 8, !tbaa !1
    %97 = call double @sin(double %32) #4
    %sunkaddr29 = ptrtoint [3 x double]* %n0 to i32
    %sunkaddr30 = add i32 %sunkaddr29, 16
    %sunkaddr31 = inttoptr i32 %sunkaddr30 to double*
    store double %97, double* %sunkaddr31, align 8, !tbaa !1
    %98 = call double @cos(double %21) #4
    %99 = call double @cos(double %32) #4
    %100 = fmul double %98, %99
    store double %100, double* %24, align 8, !tbaa !1
    %101 = call double @sin(double %21) #4
    %102 = call double @cos(double %32) #4
    %103 = fmul double %101, %102
    %104 = fsub double -0.000000e+00, %103
    %sunkaddr32 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr33 = add i32 %sunkaddr32, 8
    %sunkaddr34 = inttoptr i32 %sunkaddr33 to double*
    store double %104, double* %sunkaddr34, align 8, !tbaa !1
    %105 = call double @sin(double %32) #4
    %sunkaddr35 = ptrtoint [3 x double]* %n1 to i32
    %sunkaddr36 = add i32 %sunkaddr35, 16
    %sunkaddr37 = inttoptr i32 %sunkaddr36 to double*
    store double %105, double* %sunkaddr37, align 8, !tbaa !1
    %106 = call double @cos(double %21) #4
    %107 = call double @cos(double %37) #4
    %108 = fmul double %106, %107
    store double %108, double* %23, align 8, !tbaa !1
    %109 = call double @sin(double %21) #4
    %110 = call double @cos(double %37) #4
    %111 = fmul double %109, %110
    %112 = fsub double -0.000000e+00, %111
    %sunkaddr38 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr39 = add i32 %sunkaddr38, 8
    %sunkaddr40 = inttoptr i32 %sunkaddr39 to double*
    store double %112, double* %sunkaddr40, align 8, !tbaa !1
    %113 = call double @sin(double %37) #4
    %sunkaddr41 = ptrtoint [3 x double]* %n2 to i32
    %sunkaddr42 = add i32 %sunkaddr41, 16
    %sunkaddr43 = inttoptr i32 %sunkaddr42 to double*
    store double %113, double* %sunkaddr43, align 8, !tbaa !1
    %114 = call double @cos(double %16) #4
    %115 = call double @cos(double %37) #4
    %116 = fmul double %114, %115
    store double %116, double* %22, align 8, !tbaa !1
    %117 = call double @sin(double %16) #4
    %118 = call double @cos(double %37) #4
    %119 = fmul double %117, %118
    %120 = fsub double -0.000000e+00, %119
    %sunkaddr44 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr45 = add i32 %sunkaddr44, 8
    %sunkaddr46 = inttoptr i32 %sunkaddr45 to double*
    store double %120, double* %sunkaddr46, align 8, !tbaa !1
    %121 = call double @sin(double %37) #4
    %sunkaddr47 = ptrtoint [3 x double]* %n3 to i32
    %sunkaddr48 = add i32 %sunkaddr47, 16
    %sunkaddr49 = inttoptr i32 %sunkaddr48 to double*
    store double %121, double* %sunkaddr49, align 8, !tbaa !1
    call void @m_xformpt(double* %29, double* %29, double* %25, double* %25) #4
    call void @m_xformpt(double* %28, double* %28, double* %24, double* %24) #4
    call void @m_xformpt(double* %27, double* %27, double* %23, double* %23) #4
    call void @m_xformpt(double* %26, double* %26, double* %22, double* %22) #4
    call void @glBegin(i32 signext %type) #4
    call void @glNormal3dv(double* %22) #4
    call void @glVertex3dv(double* %26) #4
    call void @glNormal3dv(double* %23) #4
    call void @glVertex3dv(double* %27) #4
    call void @glNormal3dv(double* %24) #4
    call void @glVertex3dv(double* %28) #4
    call void @glNormal3dv(double* %25) #4
    call void @glVertex3dv(double* %29) #4
    call void @glEnd() #4
    %exitcond = icmp eq i32 %nsides, %33
    br i1 %exitcond, label %.loopexit, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.loopexit, %0
    %122 = bitcast [3 x double]* %n3 to i8*
    %123 = bitcast [3 x double]* %n2 to i8*
    %124 = bitcast [3 x double]* %n1 to i8*
    %125 = bitcast [3 x double]* %n0 to i8*
    %126 = bitcast [3 x double]* %p3 to i8*
    %127 = bitcast [3 x double]* %p2 to i8*
    %128 = bitcast [3 x double]* %p1 to i8*
    %129 = bitcast [3 x double]* %p0 to i8*
    call void @llvm.lifetime.end(i64 24, i8* %122) #4
    call void @llvm.lifetime.end(i64 24, i8* %123) #4
    call void @llvm.lifetime.end(i64 24, i8* %124) #4
    call void @llvm.lifetime.end(i64 24, i8* %125) #4
    call void @llvm.lifetime.end(i64 24, i8* %126) #4
    call void @llvm.lifetime.end(i64 24, i8* %127) #4
    call void @llvm.lifetime.end(i64 24, i8* %128) #4
    call void @llvm.lifetime.end(i64 24, i8* %129) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTorus(double %innerRadius, double %outerRadius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %innerRadius, double* %2, align 8, !tbaa !1
    store double %outerRadius, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %32
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 13) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call fastcc void @doughnut(double %innerRadius, double %outerRadius, i32 signext 8, i32 signext 15, i32 signext 7)
    tail call void @glEndList() #4
    br label %33
  
  ; <label>:32                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %33
  
  ; <label>:33                                      ; preds = %32, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 4) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  declare void @glPushMatrix() #3
  
  declare void @glRotatef(float, float, float, float) #3
  
  declare void @glTranslatef(float, float, float) #3
  
  declare void @gluCylinder(%struct.GLUquadricObj*, double, double, double, i32 signext, i32 signext) #3
  
  declare void @glPopMatrix() #3
  
  ; Function Attrs: nounwind
  define void @auxSolidCylinder(double %radius, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 14) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    tail call void @glPushMatrix() #4
    tail call void @glRotatef(float 9.000000e+01, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00) #4
    tail call void @glTranslatef(float 0.000000e+00, float 0.000000e+00, float -1.000000e+00) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %radius, double %radius, double %height, i32 signext 12, i32 signext 2) #4
    tail call void @glPopMatrix() #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 5) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @icosahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 8, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 9, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 10, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 11, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 12, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 13, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 14, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 15, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 16, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 17, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 18, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 19, i32 signext 0, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidIcosahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 15) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @icosahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidIcosahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 6) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireOctahedron.center, i32 0, i32 0), double %radius, i32 signext 2)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @octahedron(double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 4, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 5, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 6, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    tail call fastcc void @drawtriangle(i32 signext 7, i32 signext 1, double* %p0, double %radius, i32 signext %shadeType)
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidOctahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 16) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @octahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidOctahedron.center, i32 0, i32 0), double %radius, i32 signext 4)
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 7) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 2) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidTetrahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %23
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 17) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    tail call fastcc void @drawtriangle(i32 signext 0, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 1, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 2, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call fastcc void @drawtriangle(i32 signext 3, i32 signext 2, double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidTetrahedron.center, i32 0, i32 0), double %radius, i32 signext 4) #4
    tail call void @glEndList() #4
    br label %24
  
  ; <label>:23                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %24
  
  ; <label>:24                                      ; preds = %23, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 8) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxWireDodecahedron.center, i32 0, i32 0), double %23, i32 signext 2)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define internal fastcc void @dodecahedron(double* nocapture readonly %center, double %sc, i32 signext %type) unnamed_addr #0 {
    %.b = load i1, i1* @dodecahedron.inited, align 1
    br i1 %.b, label %2, label %1
  
  ; <label>:1                                       ; preds = %0
    store i1 true, i1* @dodecahedron.inited, align 1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 0, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 1), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 1, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 2, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 3, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 4, i32 2), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 5, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 6, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 0), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 7, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 1), align 8, !tbaa !1
    store double -1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 8, i32 2), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 0), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 1), align 8, !tbaa !1
    store double 1.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 9, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 10, i32 2), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 11, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 0), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 12, i32 2), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 0), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 1), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 13, i32 2), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 14, i32 2), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 0), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 1), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 15, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 16, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 0), align 8, !tbaa !1
    store double 0x3FF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 17, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 1), align 8, !tbaa !1
    store double 0x3FE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 18, i32 2), align 8, !tbaa !1
    store double 0.000000e+00, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 0), align 8, !tbaa !1
    store double 0xBFF9E3779B97F4A8, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 1), align 8, !tbaa !1
    store double 0xBFE3C6EF372FE950, double* getelementptr inbounds ([20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 19, i32 2), align 8, !tbaa !1
    br label %2
  
  ; <label>:2                                       ; preds = %1, %0
    tail call void @m_pushmatrix() #4
    %3 = load double, double* %center, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %center, i32 1
    %5 = load double, double* %4, align 8, !tbaa !1
    %6 = getelementptr inbounds double, double* %center, i32 2
    %7 = load double, double* %6, align 8, !tbaa !1
    tail call void @m_translate(double %3, double %5, double %7) #4
    tail call void @m_scale(double %sc, double %sc, double %sc) #4
    tail call fastcc void @pentagon(i32 signext 0, i32 signext 1, i32 signext 9, i32 signext 16, i32 signext 5, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 0, i32 signext 3, i32 signext 18, i32 signext 7, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 1, i32 signext 7, i32 signext 11, i32 signext 10, i32 signext 9, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 11, i32 signext 7, i32 signext 18, i32 signext 19, i32 signext 6, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 8, i32 signext 17, i32 signext 16, i32 signext 9, i32 signext 10, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 14, i32 signext 15, i32 signext 6, i32 signext 19, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 13, i32 signext 12, i32 signext 4, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 2, i32 signext 19, i32 signext 18, i32 signext 3, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 3, i32 signext 0, i32 signext 5, i32 signext 12, i32 signext 13, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 6, i32 signext 15, i32 signext 8, i32 signext 10, i32 signext 11, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 17, i32 signext 8, i32 signext 15, i32 signext 14, i32 signext %type)
    tail call fastcc void @pentagon(i32 signext 4, i32 signext 12, i32 signext 5, i32 signext 16, i32 signext 17, i32 signext %type)
    tail call void @m_popmatrix() #4
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidDodecahedron(double %radius) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 8) #4
    %2 = bitcast i8* %1 to double*
    store double %radius, double* %2, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18), align 4, !tbaa !5
    %3 = icmp eq %struct.model* %endList.02.i, null
    br i1 %3, label %findList.exit.thread, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %0, %7
    %endList.03.i = phi %struct.model* [ %endList.0.i, %7 ], [ %endList.02.i, %0 ]
    %4 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %5 = load double*, double** %4, align 4, !tbaa !7
    %.pre = load double, double* %5, align 8, !tbaa !1
    %6 = fcmp une double %.pre, %radius
    br i1 %6, label %7, label %findList.exit
  
  ; <label>:7                                       ; preds = %compareParams.exit.i
    %8 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %8, align 4, !tbaa !5
    %9 = icmp eq %struct.model* %endList.0.i, null
    br i1 %9, label %findList.exit.thread, label %compareParams.exit.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %10 = bitcast %struct.model* %endList.03.i to i32*
    %11 = load i32, i32* %10, align 4, !tbaa !10
    %12 = icmp eq i32 %11, 0
    br i1 %12, label %findList.exit.thread, label %24
  
  findList.exit.thread:                             ; preds = %7, %findList.exit, %0
    %13 = tail call noalias i8* @malloc(i32 signext 16) #4
    %14 = tail call i32 @glGenLists(i32 signext 1) #4
    %15 = bitcast i8* %13 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !10
    %16 = getelementptr inbounds i8, i8* %13, i32 8
    %17 = bitcast i8* %16 to i32*
    store i32 1, i32* %17, align 4, !tbaa !11
    %18 = getelementptr inbounds i8, i8* %13, i32 12
    %19 = bitcast i8* %18 to i8**
    store i8* %1, i8** %19, align 4, !tbaa !7
    %20 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i32*), align 4, !tbaa !5
    %21 = getelementptr inbounds i8, i8* %13, i32 4
    %22 = bitcast i8* %21 to i32*
    store i32 %20, i32* %22, align 4, !tbaa !12
    store i8* %13, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 18) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %14, i32 signext 4865) #4
    %23 = fdiv double %radius, 1.730000e+00
    tail call fastcc void @dodecahedron(double* nonnull getelementptr inbounds ([3 x double], [3 x double]* @auxSolidDodecahedron.center, i32 0, i32 0), double %23, i32 signext 6)
    tail call void @glEndList() #4
    br label %25
  
  ; <label>:24                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %11) #4
    tail call void @free(i8* %1) #4
    br label %25
  
  ; <label>:25                                      ; preds = %24, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxWireCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100011) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: nounwind
  define void @auxSolidCone(double %base, double %height) #0 {
    %1 = tail call noalias i8* @malloc(i32 signext 16) #4
    %2 = bitcast i8* %1 to double*
    %3 = getelementptr inbounds i8, i8* %1, i32 8
    %4 = bitcast i8* %3 to double*
    store double %base, double* %2, align 8, !tbaa !1
    store double %height, double* %4, align 8, !tbaa !1
    %endList.02.i = load %struct.model*, %struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9), align 4, !tbaa !5
    %5 = icmp eq %struct.model* %endList.02.i, null
    br i1 %5, label %findList.exit.thread, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %0, %16
    %endList.03.i = phi %struct.model* [ %endList.0.i, %16 ], [ %endList.02.i, %0 ]
    %6 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 3
    %7 = load double*, double** %6, align 4, !tbaa !7
    br label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %.lr.ph.i.i, %.lr.ph.i
    %lsr.iv1 = phi i32 [ %lsr.iv.next2, %.lr.ph.i.i ], [ 0, %.lr.ph.i ]
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %matches.05.i.i = phi i32 [ %matches.1.i.i, %.lr.ph.i.i ], [ 1, %.lr.ph.i ]
    %8 = bitcast double* %7 to i8*
    %uglygep = getelementptr i8, i8* %8, i32 %lsr.iv1
    %uglygep3 = bitcast i8* %uglygep to double*
    %9 = load double, double* %uglygep3, align 8, !tbaa !1
    %scevgep = getelementptr i8, i8* %1, i32 %lsr.iv1
    %scevgep4 = bitcast i8* %scevgep to double*
    %10 = load double, double* %scevgep4, align 8, !tbaa !1
    %11 = fcmp une double %9, %10
    %matches.1.i.i = select i1 %11, i32 0, i32 %matches.05.i.i
    %12 = icmp slt i32 %lsr.iv, 2
    %13 = icmp ne i32 %matches.1.i.i, 0
    %14 = and i1 %12, %13
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
    %lsr.iv.next2 = add nuw nsw i32 %lsr.iv1, 8
    br i1 %14, label %.lr.ph.i.i, label %compareParams.exit.i
  
  compareParams.exit.i:                             ; preds = %.lr.ph.i.i
    %15 = icmp eq i32 %matches.1.i.i, 0
    br i1 %15, label %16, label %findList.exit
  
  ; <label>:16                                      ; preds = %compareParams.exit.i
    %17 = getelementptr inbounds %struct.model, %struct.model* %endList.03.i, i32 0, i32 1
    %endList.0.i = load %struct.model*, %struct.model** %17, align 4, !tbaa !5
    %18 = icmp eq %struct.model* %endList.0.i, null
    br i1 %18, label %findList.exit.thread, label %.lr.ph.i
  
  findList.exit:                                    ; preds = %compareParams.exit.i
    %19 = bitcast %struct.model* %endList.03.i to i32*
    %20 = load i32, i32* %19, align 4, !tbaa !10
    %21 = icmp eq i32 %20, 0
    br i1 %21, label %findList.exit.thread, label %33
  
  findList.exit.thread:                             ; preds = %16, %findList.exit, %0
    %22 = tail call noalias i8* @malloc(i32 signext 16) #4
    %23 = tail call i32 @glGenLists(i32 signext 1) #4
    %24 = bitcast i8* %22 to i32*
    store i32 %23, i32* %24, align 4, !tbaa !10
    %25 = getelementptr inbounds i8, i8* %22, i32 8
    %26 = bitcast i8* %25 to i32*
    store i32 2, i32* %26, align 4, !tbaa !11
    %27 = getelementptr inbounds i8, i8* %22, i32 12
    %28 = bitcast i8* %27 to i8**
    store i8* %1, i8** %28, align 4, !tbaa !7
    %29 = load i32, i32* bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i32*), align 4, !tbaa !5
    %30 = getelementptr inbounds i8, i8* %22, i32 4
    %31 = bitcast i8* %30 to i32*
    store i32 %29, i32* %31, align 4, !tbaa !12
    store i8* %22, i8** bitcast (%struct.model** getelementptr inbounds ([25 x %struct.model*], [25 x %struct.model*]* @lists, i32 0, i32 9) to i8**), align 4, !tbaa !5
    tail call void @glNewList(i32 signext %23, i32 signext 4865) #4
    %32 = tail call %struct.GLUquadricObj* @gluNewQuadric() #4
    tail call void @gluQuadricDrawStyle(%struct.GLUquadricObj* %32, i32 signext 100012) #4
    tail call void @gluQuadricNormals(%struct.GLUquadricObj* %32, i32 signext 100000) #4
    tail call void @gluCylinder(%struct.GLUquadricObj* %32, double %base, double 0.000000e+00, double %height, i32 signext 15, i32 signext 10) #4
    tail call void @glEndList() #4
    br label %34
  
  ; <label>:33                                      ; preds = %findList.exit
    tail call void @glCallList(i32 signext %20) #4
    tail call void @free(i8* %1) #4
    br label %34
  
  ; <label>:34                                      ; preds = %33, %findList.exit.thread
    ret void
  }
  
  ; Function Attrs: norecurse nounwind readonly
  define i32 @compareParams(double* nocapture readonly %oneArray, double* nocapture readonly %twoArray, i32 signext %size) #2 {
    %1 = icmp sgt i32 %size, 0
    br i1 %1, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %lsr.iv = phi i32 [ %lsr.iv.next, %.lr.ph ], [ 1, %0 ]
    %matches.05 = phi i32 [ %matches.1, %.lr.ph ], [ 1, %0 ]
    %.03 = phi double* [ %2, %.lr.ph ], [ %oneArray, %0 ]
    %.012 = phi double* [ %4, %.lr.ph ], [ %twoArray, %0 ]
    %2 = getelementptr inbounds double, double* %.03, i32 1
    %3 = load double, double* %.03, align 8, !tbaa !1
    %4 = getelementptr inbounds double, double* %.012, i32 1
    %5 = load double, double* %.012, align 8, !tbaa !1
    %6 = fcmp une double %3, %5
    %matches.1 = select i1 %6, i32 0, i32 %matches.05
    %7 = icmp slt i32 %lsr.iv, %size
    %8 = icmp ne i32 %matches.1, 0
    %9 = and i1 %7, %8
    %lsr.iv.next = add nuw i32 %lsr.iv, 1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    %matches.0.lcssa = phi i32 [ 1, %0 ], [ %matches.1, %.lr.ph ]
    ret i32 %matches.0.lcssa
  }
  
  declare i32 @glGenLists(i32 signext) #3
  
  declare void @glBegin(i32 signext) #3
  
  declare void @glNormal3dv(double*) #3
  
  declare void @glVertex3dv(double*) #3
  
  declare void @glEnd() #3
  
  ; Function Attrs: nounwind
  declare double @cos(double) #0
  
  ; Function Attrs: nounwind
  declare double @sin(double) #0
  
  declare void @m_xformpt(double*, double*, double*, double*) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @drawtriangle(i32 signext %i, i32 signext %geomType, double* nocapture readonly %p0, double %radius, i32 signext %shadeType) unnamed_addr #0 {
    %p1.i.i = alloca [3 x double], align 8
    %p2.i.i = alloca [3 x double], align 8
    %p3.i.i = alloca [3 x double], align 8
    %q0.i.i = alloca [3 x double], align 8
    %q1.i.i = alloca [3 x double], align 8
    %n11.i.i = alloca [3 x double], align 8
    switch i32 %geomType, label %31 [
      i32 0, label %1
      i32 1, label %11
      i32 2, label %21
    ]
  
  ; <label>:1                                       ; preds = %0
    %2 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 0
    %3 = load i32, i32* %2, align 4, !tbaa !13
    %4 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %3, i32 0
    %5 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 1
    %6 = load i32, i32* %5, align 4, !tbaa !13
    %7 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %6, i32 0
    %8 = getelementptr inbounds [20 x [3 x i32]], [20 x [3 x i32]]* @iindex, i32 0, i32 %i, i32 2
    %9 = load i32, i32* %8, align 4, !tbaa !13
    %10 = getelementptr inbounds [12 x [3 x double]], [12 x [3 x double]]* @idata, i32 0, i32 %9, i32 0
    br label %31
  
  ; <label>:11                                      ; preds = %0
    %12 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 0
    %13 = load i32, i32* %12, align 4, !tbaa !13
    %14 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %13, i32 0
    %15 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 1
    %16 = load i32, i32* %15, align 4, !tbaa !13
    %17 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %16, i32 0
    %18 = getelementptr inbounds [8 x [3 x i32]], [8 x [3 x i32]]* @ondex, i32 0, i32 %i, i32 2
    %19 = load i32, i32* %18, align 4, !tbaa !13
    %20 = getelementptr inbounds [6 x [3 x double]], [6 x [3 x double]]* @odata, i32 0, i32 %19, i32 0
    br label %31
  
  ; <label>:21                                      ; preds = %0
    %22 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 0
    %23 = load i32, i32* %22, align 4, !tbaa !13
    %24 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %23, i32 0
    %25 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 1
    %26 = load i32, i32* %25, align 4, !tbaa !13
    %27 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %26, i32 0
    %28 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* @tndex, i32 0, i32 %i, i32 2
    %29 = load i32, i32* %28, align 4, !tbaa !13
    %30 = getelementptr inbounds [4 x [3 x double]], [4 x [3 x double]]* @tdata, i32 0, i32 %29, i32 0
    br label %31
  
  ; <label>:31                                      ; preds = %21, %11, %1, %0
    %x0.0 = phi double* [ undef, %0 ], [ %24, %21 ], [ %14, %11 ], [ %4, %1 ]
    %x1.0 = phi double* [ undef, %0 ], [ %27, %21 ], [ %17, %11 ], [ %7, %1 ]
    %x2.0 = phi double* [ undef, %0 ], [ %30, %21 ], [ %20, %11 ], [ %10, %1 ]
    %32 = load double, double* %x0.0, align 8, !tbaa !1
    %33 = fmul double %32, 0.000000e+00
    %34 = load double, double* %x1.0, align 8, !tbaa !1
    %35 = fmul double %34, 0.000000e+00
    %36 = fadd double %33, %35
    %37 = load double, double* %x2.0, align 8, !tbaa !1
    %38 = fadd double %37, %36
    %39 = fadd double %32, %35
    %40 = fmul double %37, 0.000000e+00
    %41 = fadd double %39, %40
    %42 = fadd double %33, %34
    %43 = fadd double %42, %40
    %44 = getelementptr inbounds double, double* %x0.0, i32 1
    %45 = load double, double* %44, align 8, !tbaa !1
    %46 = fmul double %45, 0.000000e+00
    %47 = getelementptr inbounds double, double* %x1.0, i32 1
    %48 = load double, double* %47, align 8, !tbaa !1
    %49 = fmul double %48, 0.000000e+00
    %50 = fadd double %46, %49
    %51 = getelementptr inbounds double, double* %x2.0, i32 1
    %52 = load double, double* %51, align 8, !tbaa !1
    %53 = fadd double %52, %50
    %54 = fadd double %45, %49
    %55 = fmul double %52, 0.000000e+00
    %56 = fadd double %54, %55
    %57 = fadd double %46, %48
    %58 = fadd double %57, %55
    %59 = getelementptr inbounds double, double* %x0.0, i32 2
    %60 = load double, double* %59, align 8, !tbaa !1
    %61 = fmul double %60, 0.000000e+00
    %62 = getelementptr inbounds double, double* %x1.0, i32 2
    %63 = load double, double* %62, align 8, !tbaa !1
    %64 = fmul double %63, 0.000000e+00
    %65 = fadd double %61, %64
    %66 = getelementptr inbounds double, double* %x2.0, i32 2
    %67 = load double, double* %66, align 8, !tbaa !1
    %68 = fadd double %67, %65
    %69 = fadd double %60, %64
    %70 = fmul double %67, 0.000000e+00
    %71 = fadd double %69, %70
    %72 = fadd double %61, %63
    %73 = fadd double %72, %70
    %74 = fmul double %38, %38
    %75 = fmul double %53, %53
    %76 = fadd double %74, %75
    %77 = fmul double %68, %68
    %78 = fadd double %76, %77
    %79 = tail call double @sqrt(double %78) #5
    %80 = fcmp oeq double %79, %79
    br i1 %80, label %.split, label %call.sqrt
  
  call.sqrt:                                        ; preds = %31
    %81 = tail call double @sqrt(double %78) #4
    br label %.split
  
  .split:                                           ; preds = %31, %call.sqrt
    %82 = phi double [ %79, %31 ], [ %81, %call.sqrt ]
    %83 = fdiv double %38, %82
    %84 = fdiv double %53, %82
    %85 = fdiv double %68, %82
    %86 = fmul double %41, %41
    %87 = fmul double %56, %56
    %88 = fadd double %86, %87
    %89 = fmul double %71, %71
    %90 = fadd double %88, %89
    %91 = tail call double @sqrt(double %90) #5
    %92 = fcmp oeq double %91, %91
    br i1 %92, label %.split.split, label %call.sqrt1
  
  call.sqrt1:                                       ; preds = %.split
    %93 = tail call double @sqrt(double %90) #4
    br label %.split.split
  
  .split.split:                                     ; preds = %.split, %call.sqrt1
    %94 = phi double [ %91, %.split ], [ %93, %call.sqrt1 ]
    %95 = fdiv double %41, %94
    %96 = fdiv double %56, %94
    %97 = fdiv double %71, %94
    %98 = fmul double %43, %43
    %99 = fmul double %58, %58
    %100 = fadd double %98, %99
    %101 = fmul double %73, %73
    %102 = fadd double %100, %101
    %103 = tail call double @sqrt(double %102) #5
    %104 = fcmp oeq double %103, %103
    br i1 %104, label %.split.split.split, label %call.sqrt2
  
  call.sqrt2:                                       ; preds = %.split.split
    %105 = tail call double @sqrt(double %102) #4
    br label %.split.split.split
  
  .split.split.split:                               ; preds = %.split.split, %call.sqrt2
    %106 = phi double [ %103, %.split.split ], [ %105, %call.sqrt2 ]
    %107 = bitcast [3 x double]* %n11.i.i to double*
    %108 = bitcast [3 x double]* %q1.i.i to double*
    %109 = bitcast [3 x double]* %q0.i.i to double*
    %110 = bitcast [3 x double]* %p3.i.i to double*
    %111 = bitcast [3 x double]* %p2.i.i to double*
    %112 = bitcast [3 x double]* %p1.i.i to double*
    %113 = bitcast [3 x double]* %n11.i.i to i8*
    %114 = bitcast [3 x double]* %q1.i.i to i8*
    %115 = bitcast [3 x double]* %q0.i.i to i8*
    %116 = bitcast [3 x double]* %p3.i.i to i8*
    %117 = bitcast [3 x double]* %p2.i.i to i8*
    %118 = bitcast [3 x double]* %p1.i.i to i8*
    %119 = fdiv double %43, %106
    %120 = fdiv double %58, %106
    %121 = fdiv double %73, %106
    call void @llvm.lifetime.start(i64 24, i8* %118) #4
    call void @llvm.lifetime.start(i64 24, i8* %117) #4
    call void @llvm.lifetime.start(i64 24, i8* %116) #4
    call void @llvm.lifetime.start(i64 24, i8* %115) #4
    call void @llvm.lifetime.start(i64 24, i8* %114) #4
    call void @llvm.lifetime.start(i64 24, i8* %113) #4
    %122 = fmul double %95, %radius
    %123 = load double, double* %p0, align 8, !tbaa !1
    %124 = fadd double %122, %123
    store double %124, double* %112, align 8, !tbaa !1
    %125 = fmul double %83, %radius
    %126 = fadd double %125, %123
    store double %126, double* %111, align 8, !tbaa !1
    %127 = fmul double %119, %radius
    %128 = fadd double %127, %123
    store double %128, double* %110, align 8, !tbaa !1
    %129 = fmul double %96, %radius
    %sunkaddr = ptrtoint double* %p0 to i32
    %sunkaddr3 = add i32 %sunkaddr, 8
    %sunkaddr4 = inttoptr i32 %sunkaddr3 to double*
    %130 = load double, double* %sunkaddr4, align 8, !tbaa !1
    %131 = fadd double %129, %130
    %sunkaddr5 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr6 = add i32 %sunkaddr5, 8
    %sunkaddr7 = inttoptr i32 %sunkaddr6 to double*
    store double %131, double* %sunkaddr7, align 8, !tbaa !1
    %132 = fmul double %84, %radius
    %133 = fadd double %132, %130
    %sunkaddr8 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr9 = add i32 %sunkaddr8, 8
    %sunkaddr10 = inttoptr i32 %sunkaddr9 to double*
    store double %133, double* %sunkaddr10, align 8, !tbaa !1
    %134 = fmul double %120, %radius
    %135 = fadd double %134, %130
    %sunkaddr11 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr12 = add i32 %sunkaddr11, 8
    %sunkaddr13 = inttoptr i32 %sunkaddr12 to double*
    store double %135, double* %sunkaddr13, align 8, !tbaa !1
    %136 = fmul double %97, %radius
    %sunkaddr14 = ptrtoint double* %p0 to i32
    %sunkaddr15 = add i32 %sunkaddr14, 16
    %sunkaddr16 = inttoptr i32 %sunkaddr15 to double*
    %137 = load double, double* %sunkaddr16, align 8, !tbaa !1
    %138 = fadd double %136, %137
    %sunkaddr17 = ptrtoint [3 x double]* %p1.i.i to i32
    %sunkaddr18 = add i32 %sunkaddr17, 16
    %sunkaddr19 = inttoptr i32 %sunkaddr18 to double*
    store double %138, double* %sunkaddr19, align 8, !tbaa !1
    %139 = fmul double %85, %radius
    %140 = fadd double %139, %137
    %sunkaddr20 = ptrtoint [3 x double]* %p2.i.i to i32
    %sunkaddr21 = add i32 %sunkaddr20, 16
    %sunkaddr22 = inttoptr i32 %sunkaddr21 to double*
    store double %140, double* %sunkaddr22, align 8, !tbaa !1
    %141 = fmul double %121, %radius
    %142 = fadd double %141, %137
    %sunkaddr23 = ptrtoint [3 x double]* %p3.i.i to i32
    %sunkaddr24 = add i32 %sunkaddr23, 16
    %sunkaddr25 = inttoptr i32 %sunkaddr24 to double*
    store double %142, double* %sunkaddr25, align 8, !tbaa !1
    call void @diff3(double* %112, double* %111, double* %109) #4
    call void @diff3(double* %111, double* %110, double* %108) #4
    call void @crossprod(double* %109, double* %108, double* %108) #4
    call void @normalize(double* %108) #4
    call void @m_xformpt(double* %112, double* %112, double* %108, double* %107) #4
    call void @m_xformptonly(double* %111, double* %111) #4
    call void @m_xformptonly(double* %110, double* %110) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %107) #4
    call void @glVertex3dv(double* %112) #4
    call void @glVertex3dv(double* %111) #4
    call void @glVertex3dv(double* %110) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %113) #4
    call void @llvm.lifetime.end(i64 24, i8* %114) #4
    call void @llvm.lifetime.end(i64 24, i8* %115) #4
    call void @llvm.lifetime.end(i64 24, i8* %116) #4
    call void @llvm.lifetime.end(i64 24, i8* %117) #4
    call void @llvm.lifetime.end(i64 24, i8* %118) #4
    ret void
  }
  
  ; Function Attrs: nounwind
  declare double @sqrt(double) #0
  
  declare void @diff3(double*, double*, double*) #3
  
  declare void @crossprod(double*, double*, double*) #3
  
  declare void @normalize(double*) #3
  
  declare void @m_xformptonly(double*, double*) #3
  
  declare void @m_pushmatrix() #3
  
  declare void @m_translate(double, double, double) #3
  
  declare void @m_scale(double, double, double) #3
  
  ; Function Attrs: nounwind
  define internal fastcc void @pentagon(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %shadeType) unnamed_addr #0 {
    %n0 = alloca [3 x double], align 8
    %d1 = alloca [3 x double], align 8
    %d2 = alloca [3 x double], align 8
    %d3 = alloca [3 x double], align 8
    %d4 = alloca [3 x double], align 8
    %d5 = alloca [3 x double], align 8
    %nout = alloca [3 x double], align 8
    %1 = bitcast [3 x double]* %n0 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %1) #4
    %2 = bitcast [3 x double]* %d1 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %2) #4
    %3 = bitcast [3 x double]* %d2 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %3) #4
    %4 = bitcast [3 x double]* %d3 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %4) #4
    %5 = bitcast [3 x double]* %d4 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %5) #4
    %6 = bitcast [3 x double]* %d5 to i8*
    call void @llvm.lifetime.start(i64 24, i8* %6) #4
    %7 = bitcast [3 x double]* %nout to i8*
    call void @llvm.lifetime.start(i64 24, i8* %7) #4
    %8 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %a, i32 0
    %9 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %b, i32 0
    %10 = bitcast [3 x double]* %d1 to double*
    call void @diff3(double* %8, double* %9, double* %10) #4
    %11 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %c, i32 0
    %12 = bitcast [3 x double]* %d2 to double*
    call void @diff3(double* %9, double* %11, double* %12) #4
    %13 = bitcast [3 x double]* %n0 to double*
    call void @crossprod(double* %10, double* %12, double* %13) #4
    call void @normalize(double* %13) #4
    %14 = bitcast [3 x double]* %nout to double*
    call void @m_xformpt(double* %8, double* %10, double* %13, double* %14) #4
    call void @m_xformptonly(double* %9, double* %12) #4
    %15 = bitcast [3 x double]* %d3 to double*
    call void @m_xformptonly(double* %11, double* %15) #4
    %16 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %d, i32 0
    %17 = bitcast [3 x double]* %d4 to double*
    call void @m_xformptonly(double* %16, double* %17) #4
    %18 = getelementptr inbounds [20 x [3 x double]], [20 x [3 x double]]* @dodec, i32 0, i32 %e, i32 0
    %19 = bitcast [3 x double]* %d5 to double*
    call void @m_xformptonly(double* %18, double* %19) #4
    call void @glBegin(i32 signext %shadeType) #4
    call void @glNormal3dv(double* %14) #4
    call void @glVertex3dv(double* %10) #4
    call void @glVertex3dv(double* %12) #4
    call void @glVertex3dv(double* %15) #4
    call void @glVertex3dv(double* %17) #4
    call void @glVertex3dv(double* %19) #4
    call void @glEnd() #4
    call void @llvm.lifetime.end(i64 24, i8* %7) #4
    call void @llvm.lifetime.end(i64 24, i8* %6) #4
    call void @llvm.lifetime.end(i64 24, i8* %5) #4
    call void @llvm.lifetime.end(i64 24, i8* %4) #4
    call void @llvm.lifetime.end(i64 24, i8* %3) #4
    call void @llvm.lifetime.end(i64 24, i8* %2) #4
    call void @llvm.lifetime.end(i64 24, i8* %1) #4
    ret void
  }
  
  declare void @m_popmatrix() #3
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { norecurse nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { nounwind }
  attributes #5 = { nounwind readnone }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !2, i64 0}
  !2 = !{!"double", !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"any pointer", !3, i64 0}
  !7 = !{!8, !6, i64 12}
  !8 = !{!"model", !9, i64 0, !6, i64 4, !9, i64 8, !6, i64 12}
  !9 = !{!"int", !3, i64 0}
  !10 = !{!8, !9, i64 0}
  !11 = !{!8, !9, i64 8}
  !12 = !{!8, !6, i64 4}
  !13 = !{!9, !9, i64 0}

...
---
name:            doughnut
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: afgr64 }
  - { id: 1, class: afgr64 }
  - { id: 2, class: afgr64 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: afgr64 }
  - { id: 5, class: afgr64 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: afgr64 }
  - { id: 8, class: afgr64 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: afgr64 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: afgr64 }
  - { id: 13, class: afgr64 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: afgr64 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: afgr64 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: afgr64 }
  - { id: 24, class: afgr64 }
  - { id: 25, class: afgr64 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: afgr64 }
  - { id: 28, class: afgr64 }
  - { id: 29, class: afgr64 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: afgr64 }
  - { id: 33, class: afgr64 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: afgr64 }
  - { id: 36, class: afgr64 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: afgr64 }
  - { id: 39, class: afgr64 }
  - { id: 40, class: afgr64 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: afgr64 }
  - { id: 43, class: afgr64 }
  - { id: 44, class: afgr64 }
  - { id: 45, class: afgr64 }
  - { id: 46, class: afgr64 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: afgr64 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: afgr64 }
  - { id: 51, class: afgr64 }
  - { id: 52, class: afgr64 }
  - { id: 53, class: afgr64 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: afgr64 }
  - { id: 56, class: afgr64 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: afgr64 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: afgr64 }
  - { id: 61, class: afgr64 }
  - { id: 62, class: afgr64 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: afgr64 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: afgr64 }
  - { id: 67, class: afgr64 }
  - { id: 68, class: afgr64 }
  - { id: 69, class: afgr64 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: afgr64 }
  - { id: 72, class: afgr64 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: afgr64 }
  - { id: 75, class: afgr64 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: afgr64 }
  - { id: 78, class: afgr64 }
  - { id: 79, class: afgr64 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: afgr64 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: afgr64 }
  - { id: 84, class: afgr64 }
  - { id: 85, class: afgr64 }
  - { id: 86, class: afgr64 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: afgr64 }
  - { id: 89, class: afgr64 }
  - { id: 90, class: gpr32 }
  - { id: 91, class: afgr64 }
  - { id: 92, class: gpr32 }
  - { id: 93, class: afgr64 }
  - { id: 94, class: afgr64 }
  - { id: 95, class: afgr64 }
  - { id: 96, class: gpr32 }
  - { id: 97, class: afgr64 }
  - { id: 98, class: gpr32 }
  - { id: 99, class: afgr64 }
  - { id: 100, class: afgr64 }
  - { id: 101, class: afgr64 }
  - { id: 102, class: afgr64 }
  - { id: 103, class: gpr32 }
  - { id: 104, class: afgr64 }
  - { id: 105, class: afgr64 }
  - { id: 106, class: gpr32 }
  - { id: 107, class: afgr64 }
  - { id: 108, class: gpr32 }
  - { id: 109, class: afgr64 }
  - { id: 110, class: afgr64 }
  - { id: 111, class: gpr32 }
  - { id: 112, class: afgr64 }
  - { id: 113, class: gpr32 }
  - { id: 114, class: afgr64 }
  - { id: 115, class: afgr64 }
  - { id: 116, class: afgr64 }
  - { id: 117, class: gpr32 }
  - { id: 118, class: afgr64 }
  - { id: 119, class: gpr32 }
  - { id: 120, class: afgr64 }
  - { id: 121, class: gpr32 }
  - { id: 122, class: afgr64 }
  - { id: 123, class: afgr64 }
  - { id: 124, class: gpr32 }
  - { id: 125, class: afgr64 }
  - { id: 126, class: gpr32 }
  - { id: 127, class: afgr64 }
  - { id: 128, class: afgr64 }
  - { id: 129, class: afgr64 }
  - { id: 130, class: gpr32 }
  - { id: 131, class: afgr64 }
  - { id: 132, class: gpr32 }
  - { id: 133, class: afgr64 }
  - { id: 134, class: gpr32 }
  - { id: 135, class: afgr64 }
  - { id: 136, class: afgr64 }
  - { id: 137, class: gpr32 }
  - { id: 138, class: afgr64 }
  - { id: 139, class: gpr32 }
  - { id: 140, class: afgr64 }
  - { id: 141, class: afgr64 }
  - { id: 142, class: afgr64 }
  - { id: 143, class: gpr32 }
  - { id: 144, class: afgr64 }
  - { id: 145, class: gpr32 }
  - { id: 146, class: afgr64 }
  - { id: 147, class: gpr32 }
  - { id: 148, class: afgr64 }
  - { id: 149, class: afgr64 }
  - { id: 150, class: gpr32 }
  - { id: 151, class: afgr64 }
  - { id: 152, class: gpr32 }
  - { id: 153, class: afgr64 }
  - { id: 154, class: afgr64 }
  - { id: 155, class: afgr64 }
  - { id: 156, class: gpr32 }
  - { id: 157, class: afgr64 }
  - { id: 158, class: gpr32 }
  - { id: 159, class: gpr32 }
  - { id: 160, class: gpr32 }
  - { id: 161, class: gpr32 }
  - { id: 162, class: gpr32 }
  - { id: 163, class: gpr32 }
  - { id: 164, class: gpr32 }
  - { id: 165, class: gpr32 }
  - { id: 166, class: gpr32 }
  - { id: 167, class: gpr32 }
  - { id: 168, class: gpr32 }
  - { id: 169, class: gpr32 }
  - { id: 170, class: gpr32 }
  - { id: 171, class: gpr32 }
  - { id: 172, class: gpr32 }
  - { id: 173, class: gpr32 }
  - { id: 174, class: gpr32 }
  - { id: 175, class: gpr32 }
  - { id: 176, class: gpr32 }
  - { id: 177, class: gpr32 }
  - { id: 178, class: gpr32 }
  - { id: 179, class: gpr32 }
  - { id: 180, class: gpr32 }
  - { id: 181, class: afgr64 }
  - { id: 182, class: gpr32 }
  - { id: 183, class: gpr32 }
liveins:         
  - { reg: '%d0', virtual-reg: '%12' }
  - { reg: '%d1', virtual-reg: '%13' }
  - { reg: '%a0', virtual-reg: '%14' }
  - { reg: '%a1', virtual-reg: '%15' }
  - { reg: '%a2', virtual-reg: '%16' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    8
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
stack:           
  - { id: 0, name: p0, offset: 0, size: 24, alignment: 8 }
  - { id: 1, name: p1, offset: 0, size: 24, alignment: 8 }
  - { id: 2, name: p2, offset: 0, size: 24, alignment: 8 }
  - { id: 3, name: p3, offset: 0, size: 24, alignment: 8 }
  - { id: 4, name: n0, offset: 0, size: 24, alignment: 8 }
  - { id: 5, name: n1, offset: 0, size: 24, alignment: 8 }
  - { id: 6, name: n2, offset: 0, size: 24, alignment: 8 }
  - { id: 7, name: n3, offset: 0, size: 24, alignment: 8 }
constants:       
  - id:              0
    value:           double 0x400921FB54442C46
    alignment:       8
  - id:              1
    value:           'double 1.000000e+00'
    alignment:       8
body:             |
  bb.0 (%ir-block.0, freq 12):
    successors: %bb.1..lr.ph3(62), %bb.5.._crit_edge(37)
    liveins: %d0, %d1, %a0, %a1, %a2, %t9, %v0
  
    %22 = ADDu %v0, %t9
    %16 = COPY %a2
    %15 = COPY %a1
    %14 = COPY %a0
    %13 = COPY %d1
    %12 = COPY %d0
    BLEZ %15, %bb.5.._crit_edge, implicit-def dead %at
    B %bb.1..lr.ph3, implicit-def dead %at
  
  bb.1..lr.ph3 (freq 8):
    successors: %bb.3(100)
  
    %19 = COPY %zero
    %17 = BuildPairF64 %19, %19
    %1 = PseudoCVT_D32_W %14
    %0 = PseudoCVT_D32_W %15
    %18 = ADDiu %zero, 0
    %26 = LW %22, target-flags(<unknown>) %const.0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %27 = LDC1 %26, target-flags(<unknown>) %const.0, <0x3225690> = !{!"unison-memory-partition", i32 1} :: (load 8 from constant-pool)
    %30 = LW %22, target-flags(<unknown>) %const.1, <0x32ee510> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %32 = LDC1 %30, target-flags(<unknown>) %const.1, <0x3322920> = !{!"unison-memory-partition", i32 3} :: (load 8 from constant-pool)
    %158 = LEA_ADDiu %stack.0.p0, 0
    %159 = LEA_ADDiu %stack.4.n0, 0
    %161 = LEA_ADDiu %stack.1.p1, 0
    %162 = LEA_ADDiu %stack.5.n1, 0
    %164 = LEA_ADDiu %stack.2.p2, 0
    %165 = LEA_ADDiu %stack.6.n2, 0
    %167 = LEA_ADDiu %stack.3.p3, 0
    %168 = LEA_ADDiu %stack.7.n3, 0
    B %bb.3, implicit-def dead %at
  
  bb.2..loopexit (freq 255):
    successors: %bb.5.._crit_edge(3), %bb.3(96)
  
    %5 = FADD_D32 %2, %32
    BEQ %6, %15, %bb.5.._crit_edge, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.12, freq 255):
    successors: %bb.6(62), %bb.2..loopexit(37)
  
    %2 = PHI %17, %bb.1..lr.ph3, %5, %bb.2..loopexit
    %3 = PHI %18, %bb.1..lr.ph3, %6, %bb.2..loopexit
    %6 = ADDiu %3, 1
    BLEZ %14, %bb.2..loopexit, implicit-def %at
  
  bb.6 (freq 159):
    successors: %bb.4..lr.ph(100)
  
    %23 = PseudoCVT_D32_W %6
    %24 = FADD_D32 %23, %23
    %25 = FADD_D32 %2, %2
    %28 = FMUL_D32 %25, %27
    %29 = FMUL_D32 %24, %27
    %31 = COPY %zero
    %20 = BuildPairF64 %31, %31
    %7 = FDIV_D32 %29, %0
    %4 = FDIV_D32 %28, %0
  
  bb.4..lr.ph (freq 5119):
    successors: %bb.2..loopexit(3), %bb.4..lr.ph(96)
  
    %8 = PHI %20, %bb.6, %10, %bb.4..lr.ph
    %9 = PHI %18, %bb.6, %11, %bb.4..lr.ph
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %33 = FADD_D32 %8, %8
    %36 = FMUL_D32 killed %33, %27
    %37 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %4
    %gp = COPY %22
    %t9 = COPY %37
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit %gp, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %38 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %11 = ADDiu %9, 1
    %39 = PseudoCVT_D32_W %11
    %40 = FADD_D32 %39, %39
    %41 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %42 = FMUL_D32 killed %40, %27
    %43 = FDIV_D32 killed %36, %1
    %d6 = COPY %43
    %t9 = COPY %41
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %44 = COPY %d0
    %45 = MADD_D32 %13, %44, %12
    %46 = FMUL_D32 %38, killed %45
    SDC1 killed %46, %stack.0.p0, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.29, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %47 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %4
    %gp = COPY %22
    %t9 = COPY %47
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit %gp, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %48 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %49 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %43
    %t9 = COPY %49
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %50 = COPY %d0
    %51 = MADD_D32 %13, %50, %12
    %52 = FMUL_D32 %48, killed %51
    %53 = FNEG_D32 killed %52
    SDC1 killed %53, %stack.0.p0, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr4, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %54 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %43
    %t9 = COPY %54
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %55 = COPY %d0
    %56 = FMUL_D32 %55, %12
    SDC1 killed %56, %stack.0.p0, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr7, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %57 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %7
    %t9 = COPY %57
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %58 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %59 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %43
    %t9 = COPY %59
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %60 = COPY %d0
    %61 = MADD_D32 %13, %60, %12
    %62 = FMUL_D32 %58, killed %61
    SDC1 killed %62, %stack.1.p1, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.28, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %63 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %7
    %t9 = COPY %63
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %64 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %65 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %43
    %t9 = COPY %65
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %66 = COPY %d0
    %67 = MADD_D32 %13, %66, %12
    %68 = FMUL_D32 %64, killed %67
    %69 = FNEG_D32 killed %68
    SDC1 killed %69, %stack.1.p1, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr10, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %70 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %43
    %t9 = COPY %70
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %71 = COPY %d0
    %72 = FMUL_D32 %71, %12
    SDC1 killed %72, %stack.1.p1, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr13, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %73 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %7
    %t9 = COPY %73
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %74 = COPY %d0
    %75 = FDIV_D32 killed %42, %1
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %76 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %75
    %t9 = COPY %76
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %77 = COPY %d0
    %78 = MADD_D32 %13, %77, %12
    %79 = FMUL_D32 %74, killed %78
    SDC1 killed %79, %stack.2.p2, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.27, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %80 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %7
    %t9 = COPY %80
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %81 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %82 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %75
    %t9 = COPY %82
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %83 = COPY %d0
    %84 = MADD_D32 %13, %83, %12
    %85 = FMUL_D32 %81, killed %84
    %86 = FNEG_D32 killed %85
    SDC1 killed %86, %stack.2.p2, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr16, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %87 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %75
    %t9 = COPY %87
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %88 = COPY %d0
    %89 = FMUL_D32 %88, %12
    SDC1 killed %89, %stack.2.p2, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr19, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %90 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %4
    %t9 = COPY %90
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %91 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %92 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %75
    %t9 = COPY %92
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %93 = COPY %d0
    %94 = MADD_D32 %13, %93, %12
    %95 = FMUL_D32 %91, killed %94
    SDC1 killed %95, %stack.3.p3, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.26, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %96 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %4
    %t9 = COPY %96
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %97 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %98 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %75
    %t9 = COPY %98
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %99 = COPY %d0
    %100 = MADD_D32 %13, %99, %12
    %101 = FMUL_D32 %97, killed %100
    %102 = FNEG_D32 killed %101
    SDC1 killed %102, %stack.3.p3, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr22, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %103 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %75
    %t9 = COPY %103
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %104 = COPY %d0
    %105 = FMUL_D32 %104, %12
    SDC1 killed %105, %stack.3.p3, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr25, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %106 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %4
    %t9 = COPY %106
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %107 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %108 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %43
    %t9 = COPY %108
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %109 = COPY %d0
    %110 = FMUL_D32 %107, %109
    SDC1 killed %110, %stack.4.n0, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.25, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %111 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %4
    %t9 = COPY %111
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %112 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %113 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %43
    %t9 = COPY %113
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %114 = COPY %d0
    %115 = FMUL_D32 %112, %114
    %116 = FNEG_D32 killed %115
    SDC1 killed %116, %stack.4.n0, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr28, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %117 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %43
    %t9 = COPY %117
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %118 = COPY %d0
    SDC1 %118, %stack.4.n0, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr31, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %119 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %7
    %t9 = COPY %119
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %120 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %121 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %43
    %t9 = COPY %121
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %122 = COPY %d0
    %123 = FMUL_D32 %120, %122
    SDC1 killed %123, %stack.5.n1, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.24, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %124 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %7
    %t9 = COPY %124
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %125 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %126 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %43
    %t9 = COPY %126
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %127 = COPY %d0
    %128 = FMUL_D32 %125, %127
    %129 = FNEG_D32 killed %128
    SDC1 killed %129, %stack.5.n1, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr34, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %130 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %43
    %t9 = COPY %130
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %131 = COPY %d0
    SDC1 %131, %stack.5.n1, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr37, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %132 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %7
    %t9 = COPY %132
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %133 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %134 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %75
    %t9 = COPY %134
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %135 = COPY %d0
    %136 = FMUL_D32 %133, %135
    SDC1 killed %136, %stack.6.n2, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.23, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %137 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %7
    %t9 = COPY %137
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %138 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %139 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %75
    %t9 = COPY %139
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %140 = COPY %d0
    %141 = FMUL_D32 %138, %140
    %142 = FNEG_D32 killed %141
    SDC1 killed %142, %stack.6.n2, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr40, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %143 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %75
    %t9 = COPY %143
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %144 = COPY %d0
    SDC1 %144, %stack.6.n2, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr43, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %145 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %4
    %t9 = COPY %145
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %146 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %147 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %75
    %t9 = COPY %147
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %148 = COPY %d0
    %149 = FMUL_D32 %146, %148
    SDC1 killed %149, %stack.7.n3, 0, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.22, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %150 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %4
    %t9 = COPY %150
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %151 = COPY %d0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %152 = LW %22, target-flags(<unknown>) @cos, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cos)
    %d6 = COPY %75
    %t9 = COPY %152
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %153 = COPY %d0
    %154 = FMUL_D32 %151, %153
    %155 = FNEG_D32 killed %154
    SDC1 killed %155, %stack.7.n3, 8, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr46, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %156 = LW %22, target-flags(<unknown>) @sin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @sin)
    %d6 = COPY %75
    %t9 = COPY %156
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %d6, implicit-def %sp, implicit-def %d0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %157 = COPY %d0
    SDC1 %157, %stack.7.n3, 16, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (store 8 into %ir.sunkaddr49, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %160 = LW %22, target-flags(<unknown>) @m_xformpt, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @m_xformpt)
    %a0 = COPY %158
    %a1 = COPY %158
    %a2 = COPY %159
    %a3 = COPY %159
    %gp = COPY %22
    %t9 = COPY %160
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %163 = LW %22, target-flags(<unknown>) @m_xformpt, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @m_xformpt)
    %a0 = COPY %161
    %a1 = COPY %161
    %a2 = COPY %162
    %a3 = COPY %162
    %t9 = COPY %163
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %166 = LW %22, target-flags(<unknown>) @m_xformpt, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @m_xformpt)
    %a0 = COPY %164
    %a1 = COPY %164
    %a2 = COPY %165
    %a3 = COPY %165
    %t9 = COPY %166
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %169 = LW %22, target-flags(<unknown>) @m_xformpt, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @m_xformpt)
    %a0 = COPY %167
    %a1 = COPY %167
    %a2 = COPY %168
    %a3 = COPY %168
    %t9 = COPY %169
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %170 = LW %22, target-flags(<unknown>) @glBegin, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glBegin)
    %a0 = COPY %16
    %gp = COPY %22
    %t9 = COPY %170
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %171 = LW %22, target-flags(<unknown>) @glNormal3dv, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glNormal3dv)
    %a0 = COPY %168
    %gp = COPY %22
    %t9 = COPY %171
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %172 = LW %22, target-flags(<unknown>) @glVertex3dv, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glVertex3dv)
    %a0 = COPY %167
    %gp = COPY %22
    %t9 = COPY %172
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %173 = LW %22, target-flags(<unknown>) @glNormal3dv, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glNormal3dv)
    %a0 = COPY %165
    %t9 = COPY %173
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %174 = LW %22, target-flags(<unknown>) @glVertex3dv, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glVertex3dv)
    %a0 = COPY %164
    %t9 = COPY %174
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %175 = LW %22, target-flags(<unknown>) @glNormal3dv, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glNormal3dv)
    %a0 = COPY %162
    %t9 = COPY %175
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %176 = LW %22, target-flags(<unknown>) @glVertex3dv, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glVertex3dv)
    %a0 = COPY %161
    %t9 = COPY %176
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %177 = LW %22, target-flags(<unknown>) @glNormal3dv, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glNormal3dv)
    %a0 = COPY %159
    %t9 = COPY %177
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %178 = LW %22, target-flags(<unknown>) @glVertex3dv, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glVertex3dv)
    %a0 = COPY %158
    %t9 = COPY %178
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %179 = LW %22, target-flags(<unknown>) @glEnd, <0x324b3a0> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @glEnd)
    %gp = COPY %22
    %t9 = COPY %179
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %10 = FADD_D32 %8, %32
    BEQ %14, %11, %bb.2..loopexit, implicit-def dead %at
    B %bb.4..lr.ph, implicit-def dead %at
  
  bb.5.._crit_edge (freq 12):
    liveouts:
  
    RetRA

...
