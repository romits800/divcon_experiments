--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            show_key
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           false
tracksRegLiveness: false
tracksSubRegLiveness: false
liveins:         
  - { reg: '%a0' }
  - { reg: '%a1' }
  - { reg: '%a2' }
  - { reg: '%t9' }
  - { reg: '%v0' }
calleeSavedRegisters: [ '%fp', '%ra', '%d10', '%d11', '%d12', '%d13', '%d14', 
                        '%d15', '%f20', '%f21', '%f22', '%f23', '%f24', 
                        '%f25', '%f26', '%f27', '%f28', '%f29', '%f30', 
                        '%f31', '%s0', '%s1', '%s2', '%s3', '%s4', '%s5', 
                        '%s6', '%s7' ]
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       1016
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    true
  hasCalls:        true
  maxCallFrameSize: 56
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
stack:           
  - { id: 0, name: buf.i, offset: -44, size: 3, alignment: 4 }
  - { id: 1, name: userid, offset: -300, size: 256, alignment: 4 }
  - { id: 2, name: n, offset: -556, size: 256, alignment: 4 }
  - { id: 3, name: e, offset: -812, size: 256, alignment: 4 }
  - { id: 4, name: sigkeyID, offset: -820, size: 8, alignment: 4 }
  - { id: 5, name: timestamp, offset: -824, size: 4, alignment: 4 }
  - { id: 6, name: ctb, offset: -828, size: 1, alignment: 4 }
  - { id: 7, name: keyctrl, offset: -832, size: 1, alignment: 4 }
  - { id: 8, name: savekeyID, offset: -840, size: 8, alignment: 4 }
  - { id: 9, name: hash, offset: -856, size: 16, alignment: 4 }
  - { id: 10, type: spill-slot, offset: -860, size: 4, alignment: 4 }
  - { id: 11, type: spill-slot, offset: -864, size: 4, alignment: 4 }
  - { id: 12, type: spill-slot, offset: -868, size: 4, alignment: 4 }
  - { id: 13, type: spill-slot, offset: -872, size: 4, alignment: 4 }
  - { id: 14, type: spill-slot, offset: -876, size: 4, alignment: 4 }
  - { id: 15, type: spill-slot, offset: -880, size: 4, alignment: 4 }
  - { id: 16, type: spill-slot, offset: -884, size: 4, alignment: 4 }
  - { id: 17, type: spill-slot, offset: -888, size: 4, alignment: 4 }
  - { id: 18, type: spill-slot, offset: -892, size: 4, alignment: 4 }
  - { id: 19, type: spill-slot, offset: -896, size: 4, alignment: 4 }
  - { id: 20, type: spill-slot, offset: -900, size: 4, alignment: 4 }
  - { id: 21, type: spill-slot, offset: -904, size: 4, alignment: 4 }
  - { id: 22, type: spill-slot, offset: -908, size: 4, alignment: 4 }
  - { id: 23, type: spill-slot, offset: -912, size: 4, alignment: 4 }
  - { id: 24, type: spill-slot, offset: -916, size: 4, alignment: 4 }
  - { id: 25, type: spill-slot, offset: -920, size: 4, alignment: 4 }
  - { id: 26, type: spill-slot, offset: -924, size: 4, alignment: 4 }
  - { id: 27, type: spill-slot, offset: -928, size: 4, alignment: 4 }
  - { id: 28, type: spill-slot, offset: -932, size: 4, alignment: 4 }
  - { id: 29, type: spill-slot, offset: -936, size: 4, alignment: 4 }
  - { id: 30, type: spill-slot, offset: -940, size: 4, alignment: 4 }
  - { id: 31, type: spill-slot, offset: -944, size: 4, alignment: 4 }
  - { id: 32, type: spill-slot, offset: -948, size: 4, alignment: 4 }
  - { id: 33, type: spill-slot, offset: -952, size: 4, alignment: 4 }
  - { id: 34, type: spill-slot, offset: -956, size: 4, alignment: 4 }
  - { id: 35, type: spill-slot, offset: -960, size: 4, alignment: 4 }
  - { id: 36, type: spill-slot, offset: -4, size: 4, alignment: 4, callee-saved-register: '%ra' }
  - { id: 37, type: spill-slot, offset: -8, size: 4, alignment: 4, callee-saved-register: '%fp' }
  - { id: 38, type: spill-slot, offset: -12, size: 4, alignment: 4, callee-saved-register: '%s7' }
  - { id: 39, type: spill-slot, offset: -16, size: 4, alignment: 4, callee-saved-register: '%s6' }
  - { id: 40, type: spill-slot, offset: -20, size: 4, alignment: 4, callee-saved-register: '%s5' }
  - { id: 41, type: spill-slot, offset: -24, size: 4, alignment: 4, callee-saved-register: '%s4' }
  - { id: 42, type: spill-slot, offset: -28, size: 4, alignment: 4, callee-saved-register: '%s3' }
  - { id: 43, type: spill-slot, offset: -32, size: 4, alignment: 4, callee-saved-register: '%s2' }
  - { id: 44, type: spill-slot, offset: -36, size: 4, alignment: 4, callee-saved-register: '%s1' }
  - { id: 45, type: spill-slot, offset: -40, size: 4, alignment: 4, callee-saved-register: '%s0' }
body:             |
  bb.0 (%ir-block.0, freq 3632):
    successors: %bb.2..thread(100)
    liveins: %a0, %a1, %a2, %t9, %ra, %fp, %s7, %s6, %s5, %s4, %s3, %s2, %s1, %s0
  
    %v0 = LUi target-flags(<unknown>) $_gp_disp
    %v0 = ADDiu %v0, target-flags(<unknown>) $_gp_disp
    %sp = ADDiu %sp, -1016
    CFI_INSTRUCTION .cfi_def_cfa_offset 1016
    SW killed %ra, %sp, 1012 :: (store 4 into stack)
    SW killed %fp, %sp, 1008 :: (store 4 into stack)
    SW killed %s7, %sp, 1004 :: (store 4 into stack)
    SW killed %s6, %sp, 1000 :: (store 4 into stack)
    SW killed %s5, %sp, 996 :: (store 4 into stack)
    SW killed %s4, %sp, 992 :: (store 4 into stack)
    SW killed %s3, %sp, 988 :: (store 4 into stack)
    SW killed %s2, %sp, 984 :: (store 4 into stack)
    SW killed %s1, %sp, 980 :: (store 4 into stack)
    SW killed %s0, %sp, 976 :: (store 4 into stack)
    CFI_INSTRUCTION .cfi_offset %ra_64, -4
    CFI_INSTRUCTION .cfi_offset %fp_64, -8
    CFI_INSTRUCTION .cfi_offset %s7_64, -12
    CFI_INSTRUCTION .cfi_offset %s6_64, -16
    CFI_INSTRUCTION .cfi_offset %s5_64, -20
    CFI_INSTRUCTION .cfi_offset %s4_64, -24
    CFI_INSTRUCTION .cfi_offset %s3_64, -28
    CFI_INSTRUCTION .cfi_offset %s2_64, -32
    CFI_INSTRUCTION .cfi_offset %s1_64, -36
    CFI_INSTRUCTION .cfi_offset %s0_64, -40
    %s0 = ADDu %v0, %t9
    %s3 = OR %a2, %zero
    SW %s3, %sp, 112 :: (store 4 into stack)
    %s2 = OR %a1, %zero
    %s1 = OR %a0, %zero
    SW %s1, %sp, 156 :: (store 4 into stack)
    %at = LW %s0, target-flags(<unknown>) @global_precision :: (load 4 from got)
    SW %at, %sp, 96 :: (store 4 into stack)
    %at = LHu killed %at, 0 :: (load 2 from @global_precision, !tbaa !34)
    SW killed %at, %sp, 92 :: (store 4 into stack)
    %t9 = LW %s0, target-flags(<unknown>) @ftell :: (load 4 from call-entry @ftell)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    SW %v0, %sp, 88 :: (store 4 into stack)
    %at = ADDiu %zero, 0
    SW killed %at, %sp, 128 :: (store 4 into stack)
    %t9 = LW %s0, target-flags(<unknown>) @fseek :: (load 4 from call-entry @fseek)
    %a0 = OR killed %s1, %zero
    %a1 = OR killed %s2, %zero
    %a2 = ADDiu %zero, 0
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    %at = ANDi %s3, 4
    SW killed %at, %sp, 132 :: (store 4 into stack)
    %at = ANDi %s3, 8
    SW killed %at, %sp, 84 :: (store 4 into stack)
    %at = ANDi %s3, 1
    SW killed %at, %sp, 108 :: (store 4 into stack)
    %at = ANDi %s3, 2
    SW killed %at, %sp, 100 :: (store 4 into stack)
    %at = ANDi killed %s3, 16
    SW killed %at, %sp, 104 :: (store 4 into stack)
    %at = ADDiu %zero, -1
    SW killed %at, %sp, 136 :: (store 4 into stack)
    %at = LEA_ADDiu %sp, 204
    SW killed %at, %sp, 152 :: (store 4 into stack)
    %at = LEA_ADDiu %sp, 196
    SW killed %at, %sp, 148 :: (store 4 into stack)
    %at = LEA_ADDiu %sp, 184
    SW killed %at, %sp, 144 :: (store 4 into stack)
    %s4 = LEA_ADDiu %sp, 460
    %s5 = LEA_ADDiu %sp, 716
    %at = LEA_ADDiu %sp, 188
    SW killed %at, %sp, 140 :: (store 4 into stack)
    %s7 = LEA_ADDiu %sp, 192
    %at = LW %s0, target-flags(<unknown>) @pgpout :: (load 4 from got)
    SW killed %at, %sp, 124 :: (store 4 into stack)
    %at = LW %s0, target-flags(<unknown>) @.str.25 :: (load 4 from got)
    %at = ADDiu killed %at, target-flags(<unknown>) @.str.25
    SW killed %at, %sp, 80 :: (store 4 into stack)
    %at = LW %s0, target-flags(<unknown>) @.str.26 :: (load 4 from got)
    %at = ADDiu killed %at, target-flags(<unknown>) @.str.26
    SW killed %at, %sp, 76 :: (store 4 into stack)
    %at = LW %s0, target-flags(<unknown>) @.str.28 :: (load 4 from got)
    %at = ADDiu killed %at, target-flags(<unknown>) @.str.28
    SW killed %at, %sp, 56 :: (store 4 into stack)
    %at = LW %s0, target-flags(<unknown>) @owntrust_msg :: (load 4 from got)
    %at = ADDiu killed %at, target-flags(<unknown>) @owntrust_msg
    SW killed %at, %sp, 60 :: (store 4 into stack)
    %at = LW %s0, target-flags(<unknown>) @.str.30 :: (load 4 from got)
    %at = ADDiu killed %at, target-flags(<unknown>) @.str.30
    SW killed %at, %sp, 68 :: (store 4 into stack)
    %at = LW %s0, target-flags(<unknown>) @.str.29 :: (load 4 from got)
    %at = ADDiu killed %at, target-flags(<unknown>) @.str.29
    SW killed %at, %sp, 64 :: (store 4 into stack)
    %s3 = ADDiu %zero, 0
    %s6 = ADDiu %zero, 0
    %v0 = ADDiu %zero, 0
    %at = ADDiu %zero, 0
    SW killed %at, %sp, 120 :: (store 4 into stack)
    %at = ADDiu %zero, 0
    B %bb.2..thread, implicit-def %at {
      SW killed %at, %sp, 116 :: (store 4 into stack)
    }
  
  bb.1 (%ir-block.37, freq 38836):
    successors: %bb.2..thread(100)
    liveins: %fp, %s0, %s2, %s3, %s4, %s5, %s7
  
    %s6 = ADDiu %zero, 1
    %at = LBu %sp, 188 :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    SW killed %at, %sp, 128 :: (store 4 into stack)
    SW killed %fp, %sp, 136 :: (store 4 into stack)
    %v0 = OR killed %s2, %zero
  
  bb.2..thread (freq 66211):
    successors: %bb.53(3), %bb.3(96)
    liveins: %s0, %s3, %s4, %s5, %s6, %s7, %v0
  
    %s2 = OR killed %v0, %zero
    %at = LW %sp, 144 :: (load 4 from stack)
    SW killed %at, %sp, 48 :: (store 4 into unknown)
    %at = LW %sp, 148 :: (load 4 from stack)
    SW killed %at, %sp, 44 :: (store 4 into unknown)
    %at = LW %sp, 152 :: (load 4 from stack)
    SW killed %at, %sp, 24 :: (store 4 into unknown)
    SW %s4, %sp, 20 :: (store 4 into unknown)
    SW %s5, %sp, 16 :: (store 4 into unknown)
    SW %zero, %sp, 40 :: (store 4 into unknown)
    SW %zero, %sp, 36 :: (store 4 into unknown)
    SW %zero, %sp, 32 :: (store 4 into unknown)
    SW %zero, %sp, 28 :: (store 4 into unknown)
    %t9 = LW %s0, target-flags(<unknown>) @readkeypacket :: (load 4 from call-entry @readkeypacket)
    %a0 = LW %sp, 156 :: (load 4 from stack)
    %a1 = ADDiu %zero, 0
    %a2 = LW %sp, 140 :: (load 4 from stack)
    %a3 = OR %s7, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %fp = OR %v0, %zero
    %s1 = ANDi %fp, 65535
    %at = ORi %zero, 65532
    %at = SLTu killed %at, %s1
    BNE %at, %zero, %bb.53, implicit-def %at {
      NOP
    }
  
  bb.3 (%ir-block.23, freq 64142):
    successors: %bb.7(37), %bb.4(62)
    liveins: %fp, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %a0 = LBu %sp, 188 :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    %t9 = LW %s0, target-flags(<unknown>) @is_key_ctb :: (load 4 from call-entry @is_key_ctb)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    BEQ %v0, %zero, %bb.7, implicit-def %at {
      NOP
    }
  
  bb.4 (%ir-block.27, freq 40088):
    successors: %bb.5(96), %bb.54(3)
    liveins: %fp, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    BNE %s6, %zero, %bb.54, implicit-def %at {
      NOP
    }
  
  bb.5 (%ir-block.29, freq 38836):
    successors: %bb.1(50), %bb.6(50)
    liveins: %fp, %s0, %s2, %s3, %s4, %s5, %s7
  
    %t9 = LW %s0, target-flags(<unknown>) @extract_keyID :: (load 4 from call-entry @extract_keyID)
    %a0 = LEA_ADDiu %sp, 176
    %a1 = LEA_ADDiu %sp, 460
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp {
      %gp = OR %s0, %zero
    }
    %at = LW %sp, 132 :: (load 4 from stack)
    BEQ %at, %zero, %bb.1, implicit-def %at {
      NOP
    }
  
  bb.6 (%ir-block.33, freq 19418):
    successors: %bb.1(100)
    liveins: %fp, %s0, %s2, %s3, %s4, %s5, %s7
  
    %t9 = LW %s0, target-flags(<unknown>) @getKeyHash :: (load 4 from call-entry @getKeyHash)
    %a0 = LEA_ADDiu %sp, 160
    %a1 = LEA_ADDiu %sp, 460
    %a2 = LEA_ADDiu %sp, 204
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp {
      %gp = OR %s0, %zero
    }
    B %bb.1, implicit-def %at {
      NOP
    }
  
  bb.7 (%ir-block.39, freq 24053):
    successors: %bb.13(33), %bb.8(66)
    liveins: %fp, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %v0 = LBu %sp, 188 :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    %at = ADDiu %zero, 180
    BEQ %v0, %at, %bb.13, implicit-def %at {
      NOP
    }
  
  bb.8 (%ir-block.39, freq 16035):
    successors: %bb.9(50), %bb.22(49)
    liveins: %fp, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %v0
  
    %at = ADDiu %zero, 176
    BNE %v0, %at, %bb.22, implicit-def %at {
      NOP
    }
  
  bb.9 (%ir-block.42, freq 8017):
    successors: %bb.12(25), %bb.10(75)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = LW %sp, 136 :: (load 4 from stack)
    BLTZ %at, %bb.12, implicit-def %at {
      NOP
    }
  
  bb.10 (%ir-block.42, freq 6013):
    successors: %bb.12(33), %bb.11(66)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    BNE %s3, %zero, %bb.12, implicit-def %at {
      NOP
    }
  
  bb.11 (%ir-block.45, freq 4008):
    successors: %bb.12(100)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = LBu %sp, 184 :: (load 1 from %ir.keyctrl, align 4, !tbaa !6)
    %at = ANDi killed %at, 32
    %v0 = ADDiu %zero, 1
    %v1 = LW %sp, 116 :: (load 4 from stack)
    %v0 = MOVZ_I_I killed %v1, killed %at, killed %v0
    SW killed %v0, %sp, 116 :: (store 4 into stack)
  
  bb.12 (%ir-block.49, freq 8017):
    successors: %bb.2..thread(100)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %v0 = ADDiu %zero, 1
    %at = LW %sp, 108 :: (load 4 from stack)
    B %bb.2..thread, implicit-def dead %at {
      %v0 = MOVZ_I_I killed %s2, killed %at, killed %v0
    }
  
  bb.13 (%ir-block.51, freq 8017):
    successors: %bb.30(37), %bb.14(62)
    liveins: %fp, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %t9 = LW %s0, target-flags(<unknown>) @PascalToC :: (load 4 from call-entry @PascalToC)
    %a0 = OR %s5, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp {
      %gp = OR %s0, %zero
    }
    BEQ %s3, %zero, %bb.30, implicit-def %at {
      NOP
    }
  
  bb.14 (%ir-block.154, freq 5011):
    successors: %bb.16(37), %bb.15(62)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = LW %sp, 112 :: (load 4 from stack)
    %s1 = LW %sp, 124 :: (load 4 from stack)
    BEQ %at, %zero, %bb.16, implicit-def %at {
      NOP
    }
  
  bb.15 (%ir-block.156, freq 3131):
    successors: %bb.16(100)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %a1 = LW %s1, 0 :: (load 4 from @pgpout, !tbaa !9)
    %t9 = LW %s0, target-flags(<unknown>) @fputc :: (load 4 from call-entry @fputc)
    %a0 = ADDiu %zero, 10
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
  
  bb.16 (%ir-block.158, freq 5011):
    successors: %bb.17(100)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %s1 = LW killed %s1, 0 :: (load 4 from @pgpout, !tbaa !9)
    %at = LW %s0, target-flags(<unknown>) @.str.32 :: (load 4 from got)
    %a0 = ADDiu killed %at, target-flags(<unknown>) @.str.32
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %a2 = LEA_ADDiu %sp, 716
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %s1, %zero
    %a1 = OR killed %v0, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
  
  bb.17 (%ir-block.163, freq 5892):
    successors: %bb.2..thread(50), %bb.18..thread14(50)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = ANDi %s2, 255
    BEQ %at, %zero, %bb.2..thread, implicit-def %at {
      %v0 = ADDiu %zero, 0
    }
  
  bb.18..thread14 (freq 3475):
    successors: %bb.19(50), %bb.47.read_trust.exit(50)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %t9 = LW %s0, target-flags(<unknown>) @fread :: (load 4 from call-entry @fread)
    %a0 = LEA_ADDiu %sp, 972
    %a1 = ADDiu %zero, 1
    %a2 = ADDiu %zero, 3
    %a3 = LW %sp, 156 :: (load 4 from stack)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %s1 = LW %sp, 124 :: (load 4 from stack)
    %at = ADDiu %zero, 3
    BNE %v0, %at, %bb.47.read_trust.exit, implicit-def %at {
      NOP
    }
  
  bb.19 (%ir-block.168, freq 1737):
    successors: %bb.20(50), %bb.45(50)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %v0 = LW %sp, 972 :: (load 4 from %ir.169)
    %v1 = SRL %v0, 24
    %at = ADDiu %zero, 176
    BNE %v1, %at, %bb.45, implicit-def %at {
      NOP
    }
  
  bb.20 (%ir-block.180, freq 868):
    successors: %bb.21(50), %bb.47.read_trust.exit(50)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %v0
  
    %at = LUi 255
    %at = AND %v0, killed %at
    %v1 = LUi 1
    BNE %at, %v1, %bb.47.read_trust.exit, implicit-def %at {
      NOP
    }
  
  bb.21 (%ir-block.183, freq 434):
    successors: %bb.47.read_trust.exit(100)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %v0
  
    %at = SRL killed %v0, 8
    B %bb.47.read_trust.exit, implicit-def %at {
      SB killed %at, %sp, 184 :: (store 1 into %ir.keyctrl, align 4, !tbaa !6)
    }
  
  bb.22 (%ir-block.194, freq 8017):
    successors: %bb.23(50), %bb.2..thread(50)
    liveins: %fp, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %v0
  
    %at = ANDi killed %v0, 124
    %v1 = ADDiu %zero, 8
    BNE %at, %v1, %bb.2..thread, implicit-def %at {
      %v0 = OR %s2, %zero
    }
  
  bb.23 (%ir-block.197, freq 4008):
    successors: %bb.24(96), %bb.59(3)
    liveins: %fp, %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = LW %sp, 120 :: (load 4 from stack)
    %v0 = ADDiu %zero, 1
    %at = MOVZ_I_I killed %v0, %s3, killed %at
    SW killed %at, %sp, 120 :: (store 4 into stack)
    %at = LW %sp, 104 :: (load 4 from stack)
    BNE %at, %zero, %bb.59, implicit-def %at {
      NOP
    }
  
  bb.24 (%ir-block.205, freq 3883):
    successors: %bb.2..thread(50), %bb.25(50)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = LW %sp, 100 :: (load 4 from stack)
    BEQ %at, %zero, %bb.2..thread, implicit-def %at {
      %v0 = OR %s2, %zero
    }
  
  bb.25 (%ir-block.207, freq 1941):
    successors: %bb.48(37), %bb.26(62)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = ANDi %s2, 255
    BEQ %at, %zero, %bb.48, implicit-def %at {
      NOP
    }
  
  bb.26 (%ir-block.209, freq 1213):
    successors: %bb.27(50), %bb.51.read_trust.exit13(50)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %t9 = LW %s0, target-flags(<unknown>) @fread :: (load 4 from call-entry @fread)
    %a0 = LEA_ADDiu %sp, 972
    %a1 = ADDiu %zero, 1
    %a2 = ADDiu %zero, 3
    %a3 = LW %sp, 156 :: (load 4 from stack)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %s1 = LW %sp, 124 :: (load 4 from stack)
    %at = ADDiu %zero, 3
    BNE %v0, %at, %bb.51.read_trust.exit13, implicit-def %at {
      NOP
    }
  
  bb.27 (%ir-block.213, freq 606):
    successors: %bb.28(50), %bb.49(50)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %v0 = LW %sp, 972 :: (load 4 from %ir.214)
    %v1 = SRL %v0, 24
    %at = ADDiu %zero, 176
    BNE %v1, %at, %bb.49, implicit-def %at {
      NOP
    }
  
  bb.28 (%ir-block.225, freq 303):
    successors: %bb.29(50), %bb.51.read_trust.exit13(50)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %v0
  
    %at = LUi 255
    %at = AND %v0, killed %at
    %v1 = LUi 1
    BNE %at, %v1, %bb.51.read_trust.exit13, implicit-def %at {
      NOP
    }
  
  bb.29 (%ir-block.228, freq 151):
    successors: %bb.51.read_trust.exit13(100)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %v0
  
    %at = SRL killed %v0, 8
    B %bb.51.read_trust.exit13, implicit-def %at {
      SB killed %at, %sp, 184 :: (store 1 into %ir.keyctrl, align 4, !tbaa !6)
    }
  
  bb.30 (%ir-block.54, freq 3006):
    successors: %bb.31(96), %bb.60(3)
    liveins: %fp, %s0, %s1, %s2, %s4, %s5, %s6, %s7
  
    %at = LW %sp, 104 :: (load 4 from stack)
    BNE %at, %zero, %bb.60, implicit-def %at {
      NOP
    }
  
  bb.31 (%ir-block.61, freq 2912):
    successors: %bb.32(96), %bb.61(3)
    liveins: %fp, %s0, %s1, %s2, %s4, %s5, %s6, %s7
  
    %at = LW %sp, 84 :: (load 4 from stack)
    BNE %at, %zero, %bb.61, implicit-def %at {
      NOP
    }
  
  bb.32 (%ir-block.104, freq 2821):
    successors: %bb.35(33), %bb.33(66)
    liveins: %s0, %s2, %s4, %s5, %s6, %s7
  
    %s1 = LW %sp, 124 :: (load 4 from stack)
    %fp = LW %s1, 0 :: (load 4 from @pgpout, !tbaa !9)
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    %a0 = LW %sp, 80 :: (load 4 from stack)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %fp, %zero
    %a1 = OR killed %v0, %zero
    %a2 = OR %s5, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    %at = LW killed %s1, 0 :: (load 4 from @pgpout, !tbaa !9)
    SW killed %at, %sp, 72 :: (store 4 into stack)
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    %a0 = LW %sp, 76 :: (load 4 from stack)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0 {
      NOP
    }
    %fp = OR %v0, %zero
    %t9 = LW %s0, target-flags(<unknown>) @countbits :: (load 4 from call-entry @countbits)
    %a0 = OR %s4, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %s3 = OR %v0, %zero
    %t9 = LW %s0, target-flags(<unknown>) @key2IDstring :: (load 4 from call-entry @key2IDstring)
    %a0 = OR %s4, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %s1 = OR %v0, %zero
    %t9 = LW %s0, target-flags(<unknown>) @cdate :: (load 4 from call-entry @cdate)
    %a0 = OR %s7, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    SW killed %v0, %sp, 16 :: (store 4 into unknown)
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = LW %sp, 72 :: (load 4 from stack)
    %a1 = OR killed %fp, %zero
    %a2 = OR killed %s3, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def dead %v0 {
      %a3 = OR killed %s1, %zero
    }
    %v0 = LW %sp, 136 :: (load 4 from stack)
    %at = ADDiu %zero, -6
    BEQ %v0, %at, %bb.35, implicit-def %at {
      NOP
    }
  
  bb.33 (%ir-block.104, freq 1881):
    successors: %bb.34(50), %bb.36(49)
    liveins: %s0, %s2, %s4, %s5, %s6, %s7, %v0
  
    %at = ADDiu %zero, -4
    BNE %v0, %at, %bb.36, implicit-def %at {
      NOP
    }
  
  bb.34 (%ir-block.116, freq 940):
    successors: %bb.38(100)
    liveins: %s0, %s2, %s4, %s5, %s6, %s7
  
    %s3 = LW %sp, 124 :: (load 4 from stack)
    %s1 = LW %s3, 0 :: (load 4 from @pgpout, !tbaa !9)
    %at = LW %s0, target-flags(<unknown>) @.str.27 :: (load 4 from got)
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0 {
      %a0 = ADDiu killed %at, target-flags(<unknown>) @.str.27
    }
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %s1, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def dead %v0 {
      %a1 = OR killed %v0, %zero
    }
    B %bb.38, implicit-def dead %at {
      NOP
    }
  
  bb.35 (%ir-block.120, freq 940):
    successors: %bb.38(100)
    liveins: %s0, %s2, %s4, %s5, %s6, %s7
  
    %s3 = LW %sp, 124 :: (load 4 from stack)
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    %a0 = LW %sp, 56 :: (load 4 from stack)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0 {
      %s1 = LW %s3, 0 :: (load 4 from @pgpout, !tbaa !9)
    }
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %s1, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def dead %v0 {
      %a1 = OR killed %v0, %zero
    }
    B %bb.38, implicit-def dead %at {
      NOP
    }
  
  bb.36 (%ir-block.124, freq 940):
    successors: %bb.38(50), %bb.37(50)
    liveins: %s0, %s2, %s4, %s5, %s6, %s7
  
    %s3 = LW %sp, 124 :: (load 4 from stack)
    %at = LW %sp, 132 :: (load 4 from stack)
    BEQ %at, %zero, %bb.38, implicit-def %at {
      NOP
    }
  
  bb.37 (%ir-block.126, freq 470):
    successors: %bb.38(100)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %t9 = LW %s0, target-flags(<unknown>) @printKeyHash :: (load 4 from call-entry @printKeyHash)
    %a0 = LEA_ADDiu %sp, 160
    %a1 = ADDiu %zero, 0
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp {
      %gp = OR %s0, %zero
    }
  
  bb.38 (%ir-block.128, freq 2821):
    successors: %bb.40(37), %bb.39(62)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = LW %sp, 120 :: (load 4 from stack)
    BEQ %at, %zero, %bb.40, implicit-def %at {
      NOP
    }
  
  bb.39 (%ir-block.130, freq 1763):
    successors: %bb.40(100)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    %a0 = LW %sp, 64 :: (load 4 from stack)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0 {
      %s1 = LW %s3, 0 :: (load 4 from @pgpout, !tbaa !9)
    }
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %s1, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def dead %v0 {
      %a1 = OR killed %v0, %zero
    }
  
  bb.40 (%ir-block.134, freq 2821):
    successors: %bb.42(37), %bb.41(62)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = LW %sp, 116 :: (load 4 from stack)
    BEQ %at, %zero, %bb.42, implicit-def %at {
      NOP
    }
  
  bb.41 (%ir-block.136, freq 1763):
    successors: %bb.42(100)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    %a0 = LW %sp, 68 :: (load 4 from stack)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0 {
      %s1 = LW %s3, 0 :: (load 4 from @pgpout, !tbaa !9)
    }
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %s1, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def dead %v0 {
      %a1 = OR killed %v0, %zero
    }
  
  bb.42 (%ir-block.140, freq 2821):
    successors: %bb.2..thread(50), %bb.43(50)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    SW killed %s3, %sp, 124 :: (store 4 into stack)
    %at = ANDi %s2, 255
    %v0 = ADDiu %zero, 0
    BEQ %at, %zero, %bb.2..thread, implicit-def %at {
      %s3 = ADDiu %zero, 1
    }
  
  bb.43 (%ir-block.142, freq 1410):
    successors: %bb.18..thread14(37), %bb.44(62)
    liveins: %s0, %s2, %s4, %s5, %s6, %s7
  
    %at = LBu %sp, 184 :: (load 1 from %ir.keyctrl, align 4, !tbaa !6)
    %at = ANDi killed %at, 7
    %at = SLL killed %at, 2
    %v0 = LW %sp, 60 :: (load 4 from stack)
    %at = ADDu killed %v0, killed %at
    %a0 = LW killed %at, 0 :: (load 4 from %ir.146, !tbaa !9)
    %at = LBu %a0, 0 :: (load 1 from %ir.147, !tbaa !6)
    BEQ %at, %zero, %bb.18..thread14, implicit-def %at {
      %s3 = ADDiu %zero, 1
    }
  
  bb.44 (%ir-block.150, freq 881):
    successors: %bb.17(100)
    liveins: %a0, %s0, %s2, %s4, %s5, %s6, %s7
  
    %at = LW %sp, 124 :: (load 4 from stack)
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0 {
      %s1 = LW killed %at, 0 :: (load 4 from @pgpout, !tbaa !9)
    }
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %s1, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def dead %v0 {
      %a1 = OR killed %v0, %zero
    }
    B %bb.17, implicit-def dead %at {
      %s3 = ADDiu %zero, 1
    }
  
  bb.45 (%ir-block.175, freq 868):
    successors: %bb.46(37), %bb.47.read_trust.exit(62)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %v1
  
    %at = SEB killed %v1
    BGEZ %at, %bb.47.read_trust.exit, implicit-def %at {
      NOP
    }
  
  bb.46 (%ir-block.178, freq 325):
    successors: %bb.47.read_trust.exit(100)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %t9 = LW %s0, target-flags(<unknown>) @fseek :: (load 4 from call-entry @fseek)
    %a0 = LW %sp, 156 :: (load 4 from stack)
    %a1 = ADDiu %zero, -3
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def dead %v0 {
      %a2 = ADDiu %zero, 1
    }
  
  bb.47.read_trust.exit (freq 3475):
    successors: %bb.2..thread(100)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = LW %s0, target-flags(<unknown>) @keylegit_msg :: (load 4 from got)
    %at = ADDiu killed %at, target-flags(<unknown>) @keylegit_msg
    %v0 = LBu %sp, 184 :: (load 1 from %ir.keyctrl, align 4, !tbaa !6)
    %v0 = ANDi killed %v0, 3
    %v0 = SLL killed %v0, 2
    %at = ADDu killed %at, killed %v0
    %a0 = LW killed %at, 0 :: (load 4 from %ir.190, !tbaa !9)
    %s1 = LW killed %s1, 0 :: (load 4 from @pgpout, !tbaa !9)
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %s1, %zero
    %a1 = OR killed %v0, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    B %bb.2..thread, implicit-def dead %at {
      %v0 = OR killed %s2, %zero
    }
  
  bb.48 (%ir-block.239, freq 728):
    successors: %bb.52(100)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = LW %sp, 124 :: (load 4 from stack)
    %s1 = LW killed %at, 0 :: (load 4 from @pgpout, !tbaa !9)
    %at = LW %s0, target-flags(<unknown>) @.str.33 :: (load 4 from got)
    %a0 = ADDiu killed %at, target-flags(<unknown>) @.str.33
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %s1, %zero
    %a1 = OR killed %v0, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    B %bb.52, implicit-def %at {
      NOP
    }
  
  bb.49 (%ir-block.220, freq 303):
    successors: %bb.50(37), %bb.51.read_trust.exit13(62)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7, %v1
  
    %at = SEB killed %v1
    BGEZ %at, %bb.51.read_trust.exit13, implicit-def %at {
      NOP
    }
  
  bb.50 (%ir-block.223, freq 113):
    successors: %bb.51.read_trust.exit13(100)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %t9 = LW %s0, target-flags(<unknown>) @fseek :: (load 4 from call-entry @fseek)
    %a0 = LW %sp, 156 :: (load 4 from stack)
    %a1 = ADDiu %zero, -3
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def dead %v0 {
      %a2 = ADDiu %zero, 1
    }
  
  bb.51.read_trust.exit13 (freq 1213):
    successors: %bb.52(100)
    liveins: %s0, %s1, %s2, %s3, %s4, %s5, %s6, %s7
  
    %at = LW %s0, target-flags(<unknown>) @sigtrust_msg :: (load 4 from got)
    %at = ADDiu killed %at, target-flags(<unknown>) @sigtrust_msg
    %v0 = LBu %sp, 184 :: (load 1 from %ir.keyctrl, align 4, !tbaa !6)
    %v0 = ANDi killed %v0, 7
    %v0 = SLL killed %v0, 2
    %at = ADDu killed %at, killed %v0
    %a0 = LW killed %at, 0 :: (load 4 from %ir.235, !tbaa !9)
    %s1 = LW killed %s1, 0 :: (load 4 from @pgpout, !tbaa !9)
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %s1, %zero
    %a1 = OR killed %v0, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
  
  bb.52 (%ir-block.243, freq 1941):
    successors: %bb.2..thread(100)
    liveins: %s0, %s2, %s3, %s4, %s5, %s6, %s7
  
    %t9 = LW %s0, target-flags(<unknown>) @show_userid :: (load 4 from call-entry @show_userid)
    %a1 = LEA_ADDiu %sp, 196
    %a0 = LW %sp, 156 :: (load 4 from stack)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp {
      %gp = OR %s0, %zero
    }
    B %bb.2..thread, implicit-def dead %at {
      %v0 = OR killed %s2, %zero
    }
  
  bb.53 (freq 2069):
    successors: %bb.55..loopexit(100)
    liveins: %fp, %s0, %s1, %s3
  
    %s5 = LW %sp, 96 :: (load 4 from stack)
    %s6 = LW %sp, 92 :: (load 4 from stack)
    %s7 = LW %sp, 88 :: (load 4 from stack)
    B %bb.55..loopexit, implicit-def %at {
      NOP
    }
  
  bb.54 (freq 1252):
    successors: %bb.55..loopexit(100)
    liveins: %fp, %s0, %s1, %s3
  
    %s5 = LW %sp, 96 :: (load 4 from stack)
    %s6 = LW %sp, 92 :: (load 4 from stack)
    %s7 = LW %sp, 88 :: (load 4 from stack)
  
  bb.55..loopexit (freq 3632):
    successors: %bb.56..loopexit(75), %bb.58(25)
    liveins: %fp, %s0, %s1, %s3, %s5, %s6, %s7
  
    %at = OR %fp, %zero
    %at = MOVN_I_I killed %zero, %s3, killed %at
    %v0 = XORi killed %s1, 65535
    %fp = MOVZ_I_I killed %at, killed %v0, killed %fp
    %at = ADDiu %zero, 16
    %v0 = LW %sp, 112 :: (load 4 from stack)
    BEQ %v0, %at, %bb.58, implicit-def %at {
      NOP
    }
  
  bb.56..loopexit (freq 2724):
    successors: %bb.57(66), %bb.58(33)
    liveins: %fp, %s0, %s3, %s5, %s6, %s7
  
    %at = LW %sp, 120 :: (load 4 from stack)
    %at = OR killed %at, killed %s3
    BNE %at, %zero, %bb.58, implicit-def %at {
      NOP
    }
  
  bb.57 (%ir-block.249, freq 1816):
    successors: %bb.58(100)
    liveins: %s0, %s5, %s6, %s7
  
    %at = LW %sp, 124 :: (load 4 from stack)
    %s1 = LW killed %at, 0 :: (load 4 from @pgpout, !tbaa !9)
    %at = LW %s0, target-flags(<unknown>) @.str.34 :: (load 4 from got)
    %a0 = ADDiu killed %at, target-flags(<unknown>) @.str.34
    %t9 = LW %s0, target-flags(<unknown>) @LANG :: (load 4 from call-entry @LANG)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %s2 = OR %v0, %zero
    %a0 = LEA_ADDiu %sp, 460
    %t9 = LW %s0, target-flags(<unknown>) @countbits :: (load 4 from call-entry @countbits)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %s3 = OR %v0, %zero
    %a0 = LEA_ADDiu %sp, 176
    %t9 = LW %s0, target-flags(<unknown>) @keyIDstring :: (load 4 from call-entry @keyIDstring)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %s4 = OR %v0, %zero
    %a0 = LEA_ADDiu %sp, 192
    %t9 = LW %s0, target-flags(<unknown>) @cdate :: (load 4 from call-entry @cdate)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    SW killed %v0, %sp, 16 :: (store 4 into unknown)
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %s1, %zero
    %a1 = OR killed %s2, %zero
    %a2 = OR killed %s3, %zero
    %a3 = OR killed %s4, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    %fp = ADDiu %zero, -1
  
  bb.58 (%ir-block.258, freq 3632):
    liveins: %fp, %s0, %s5, %s6, %s7
    liveouts:
  
    SH killed %s6, killed %s5, 0 :: (store 2 into @global_precision, !tbaa !34)
    %t9 = LW killed %s0, target-flags(<unknown>) @fseek :: (load 4 from call-entry @fseek)
    %a0 = LW %sp, 156 :: (load 4 from stack)
    %a1 = OR killed %s7, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def dead %v0 {
      %a2 = ADDiu %zero, 0
    }
    %v0 = OR killed %fp, %zero
    %s0 = LW %sp, 976 :: (load 4 from stack)
    %s1 = LW %sp, 980 :: (load 4 from stack)
    %s2 = LW %sp, 984 :: (load 4 from stack)
    %s3 = LW %sp, 988 :: (load 4 from stack)
    %s4 = LW %sp, 992 :: (load 4 from stack)
    %s5 = LW %sp, 996 :: (load 4 from stack)
    %s6 = LW %sp, 1000 :: (load 4 from stack)
    %s7 = LW %sp, 1004 :: (load 4 from stack)
    %fp = LW %sp, 1008 :: (load 4 from stack)
    %ra = LW %sp, 1012 :: (load 4 from stack)
    PseudoReturn %ra {
      %sp = ADDiu %sp, 1016
    }
  
  bb.59 (%ir-block.200, freq 125):
    successors: %bb.55..loopexit(100)
    liveins: %fp, %s0, %s1, %s3
  
    %t9 = LW %s0, target-flags(<unknown>) @key2IDstring :: (load 4 from call-entry @key2IDstring)
    %a0 = LEA_ADDiu %sp, 460
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %at = LW %sp, 124 :: (load 4 from stack)
    %a0 = LW killed %at, 0 :: (load 4 from @pgpout, !tbaa !9)
    %at = LW %s0, target-flags(<unknown>) @.str.35 :: (load 4 from got)
    %a1 = ADDiu killed %at, target-flags(<unknown>) @.str.35
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a2 = OR killed %v0, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    %s5 = LW %sp, 96 :: (load 4 from stack)
    %s6 = LW %sp, 92 :: (load 4 from stack)
    %s7 = LW %sp, 88 :: (load 4 from stack)
    B %bb.55..loopexit, implicit-def dead %at {
      NOP
    }
  
  bb.60 (%ir-block.56, freq 93):
    successors: %bb.55..loopexit(100)
    liveins: %fp, %s0, %s1
  
    %t9 = LW %s0, target-flags(<unknown>) @key2IDstring :: (load 4 from call-entry @key2IDstring)
    %a0 = LEA_ADDiu %sp, 460
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %at = LW %sp, 124 :: (load 4 from stack)
    %a0 = LW killed %at, 0 :: (load 4 from @pgpout, !tbaa !9)
    %at = LW %s0, target-flags(<unknown>) @.str.35 :: (load 4 from got)
    %a1 = ADDiu killed %at, target-flags(<unknown>) @.str.35
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a2 = OR killed %v0, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    %s5 = LW %sp, 96 :: (load 4 from stack)
    %s6 = LW %sp, 92 :: (load 4 from stack)
    %s7 = LW %sp, 88 :: (load 4 from stack)
    B %bb.55..loopexit, implicit-def %at {
      %s3 = ADDiu %zero, 1
    }
  
  bb.61 (%ir-block.63, freq 91):
    successors: %bb.62(50), %bb.63(50)
    liveins: %fp, %s0, %s1
  
    %at = LW %sp, 128 :: (load 4 from stack)
    %v0 = ANDi killed %at, 124
    %at = ADDiu %zero, 24
    %s6 = LW %sp, 92 :: (load 4 from stack)
    %s7 = LW %sp, 88 :: (load 4 from stack)
    BNE %v0, %at, %bb.63, implicit-def %at {
      NOP
    }
  
  bb.62 (%ir-block.67, freq 45):
    successors: %bb.66(100)
    liveins: %fp, %s0, %s1, %s6, %s7
  
    %at = LW %sp, 124 :: (load 4 from stack)
    %a3 = LW killed %at, 0 :: (load 4 from @pgpout, !tbaa !9)
    %at = LW %s0, target-flags(<unknown>) @.str.17 :: (load 4 from got)
    %a0 = ADDiu killed %at, target-flags(<unknown>) @.str.17
    %t9 = LW %s0, target-flags(<unknown>) @fwrite :: (load 4 from call-entry @fwrite)
    %a1 = ADDiu %zero, 3
    %a2 = ADDiu %zero, 1
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    %v0 = LW %sp, 136 :: (load 4 from stack)
    B %bb.66, implicit-def dead %at {
      NOP
    }
  
  bb.63 (%ir-block.70, freq 45):
    successors: %bb.64(50), %bb.65(50)
    liveins: %fp, %s0, %s1, %s6, %s7, %v0
  
    %at = LW %sp, 124 :: (load 4 from stack)
    %a3 = LW killed %at, 0 :: (load 4 from @pgpout, !tbaa !9)
    %at = ADDiu %zero, 20
    BNE %v0, %at, %bb.65, implicit-def %at {
      NOP
    }
  
  bb.64 (%ir-block.73, freq 22):
    successors: %bb.66(100)
    liveins: %fp, %a3, %s0, %s1, %s6, %s7
  
    %at = LW %s0, target-flags(<unknown>) @.str.18 :: (load 4 from got)
    %a0 = ADDiu killed %at, target-flags(<unknown>) @.str.18
    %t9 = LW %s0, target-flags(<unknown>) @fwrite :: (load 4 from call-entry @fwrite)
    %a1 = ADDiu %zero, 3
    %a2 = ADDiu %zero, 1
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    %v0 = LW %sp, 136 :: (load 4 from stack)
    B %bb.66, implicit-def dead %at {
      NOP
    }
  
  bb.65 (%ir-block.75, freq 22):
    successors: %bb.66(100)
    liveins: %fp, %a3, %s0, %s1, %s6, %s7
  
    %at = LW %s0, target-flags(<unknown>) @.str.19 :: (load 4 from got)
    %a0 = ADDiu killed %at, target-flags(<unknown>) @.str.19
    %t9 = LW %s0, target-flags(<unknown>) @fwrite :: (load 4 from call-entry @fwrite)
    %a1 = ADDiu %zero, 3
    %a2 = ADDiu %zero, 1
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    %v0 = LW %sp, 136 :: (load 4 from stack)
  
  bb.66 (%ir-block.77, freq 91):
    successors: %bb.69(37), %bb.67(62)
    liveins: %fp, %s0, %s1, %s6, %s7, %v0
  
    BLTZ %v0, %bb.69, implicit-def %at {
      NOP
    }
  
  bb.67 (%ir-block.82, freq 56):
    successors: %bb.70(37), %bb.68(62)
    liveins: %fp, %s0, %s1, %s6, %s7
  
    %at = LW %sp, 120 :: (load 4 from stack)
    BEQ %at, %zero, %bb.70, implicit-def %at {
      NOP
    }
  
  bb.68 (%ir-block.84, freq 35):
    successors: %bb.73(100)
    liveins: %fp, %s0, %s1, %s6, %s7
  
    %s3 = LW %sp, 124 :: (load 4 from stack)
    %a3 = LW %s3, 0 :: (load 4 from @pgpout, !tbaa !9)
    %at = LW %s0, target-flags(<unknown>) @.str.21 :: (load 4 from got)
    %a0 = ADDiu killed %at, target-flags(<unknown>) @.str.21
    %t9 = LW %s0, target-flags(<unknown>) @fwrite :: (load 4 from call-entry @fwrite)
    %a1 = ADDiu %zero, 2
    %a2 = ADDiu %zero, 1
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    B %bb.73, implicit-def dead %at {
      NOP
    }
  
  bb.69 (%ir-block.79, freq 34):
    successors: %bb.73(100)
    liveins: %fp, %s0, %s1, %s6, %s7
  
    %s3 = LW %sp, 124 :: (load 4 from stack)
    %a3 = LW %s3, 0 :: (load 4 from @pgpout, !tbaa !9)
    %at = LW %s0, target-flags(<unknown>) @.str.20 :: (load 4 from got)
    %a0 = ADDiu killed %at, target-flags(<unknown>) @.str.20
    %t9 = LW %s0, target-flags(<unknown>) @fwrite :: (load 4 from call-entry @fwrite)
    %a1 = ADDiu %zero, 2
    %a2 = ADDiu %zero, 1
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    B %bb.73, implicit-def dead %at {
      NOP
    }
  
  bb.70 (%ir-block.87, freq 21):
    successors: %bb.72(37), %bb.71(62)
    liveins: %fp, %s0, %s1, %s6, %s7
  
    %at = LW %sp, 124 :: (load 4 from stack)
    %a3 = LW killed %at, 0 :: (load 4 from @pgpout, !tbaa !9)
    %at = LW %sp, 116 :: (load 4 from stack)
    BEQ %at, %zero, %bb.72, implicit-def %at {
      NOP
    }
  
  bb.71 (%ir-block.90, freq 13):
    successors: %bb.73(100)
    liveins: %fp, %a3, %s0, %s1, %s6, %s7
  
    %at = LW %s0, target-flags(<unknown>) @.str.22 :: (load 4 from got)
    %a0 = ADDiu killed %at, target-flags(<unknown>) @.str.22
    %t9 = LW %s0, target-flags(<unknown>) @fwrite :: (load 4 from call-entry @fwrite)
    %a1 = ADDiu %zero, 2
    %a2 = ADDiu %zero, 1
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    %s3 = LW %sp, 124 :: (load 4 from stack)
    B %bb.73, implicit-def dead %at {
      NOP
    }
  
  bb.72 (%ir-block.92, freq 8):
    successors: %bb.73(100)
    liveins: %fp, %a3, %s0, %s1, %s6, %s7
  
    %at = LW %s0, target-flags(<unknown>) @.str.23 :: (load 4 from got)
    %a0 = ADDiu killed %at, target-flags(<unknown>) @.str.23
    %t9 = LW %s0, target-flags(<unknown>) @fwrite :: (load 4 from call-entry @fwrite)
    %a1 = ADDiu %zero, 2
    %a2 = ADDiu %zero, 1
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    %s3 = LW %sp, 124 :: (load 4 from stack)
  
  bb.73 (%ir-block.94, freq 91):
    successors: %bb.55..loopexit(100)
    liveins: %fp, %s0, %s1, %s3, %s6, %s7
  
    SW %s3, %sp, 124 :: (store 4 into stack)
    %s2 = LW %s3, 0 :: (load 4 from @pgpout, !tbaa !9)
    %t9 = LW %s0, target-flags(<unknown>) @countbits :: (load 4 from call-entry @countbits)
    %s4 = LEA_ADDiu %sp, 460
    %a0 = OR %s4, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %s5 = OR %v0, %zero
    %t9 = LW %s0, target-flags(<unknown>) @key2IDstring :: (load 4 from call-entry @key2IDstring)
    %a0 = OR killed %s4, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %s4 = OR %v0, %zero
    %a0 = LEA_ADDiu %sp, 192
    %t9 = LW %s0, target-flags(<unknown>) @cdate :: (load 4 from call-entry @cdate)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0 {
      %gp = OR %s0, %zero
    }
    %at = LW %s0, target-flags(<unknown>) @.str.24 :: (load 4 from got)
    %a1 = ADDiu killed %at, target-flags(<unknown>) @.str.24
    SW killed %v0, %sp, 16 :: (store 4 into unknown)
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    %a0 = OR killed %s2, %zero
    %a2 = OR killed %s5, %zero
    %a3 = OR killed %s4, %zero
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def dead %v0 {
      %gp = OR %s0, %zero
    }
    %at = LW %s0, target-flags(<unknown>) @.str.12 :: (load 4 from got)
    %a1 = ADDiu killed %at, target-flags(<unknown>) @.str.12
    %a2 = LEA_ADDiu %sp, 716
    %t9 = LW %s0, target-flags(<unknown>) @fprintf :: (load 4 from call-entry @fprintf)
    JALRPseudo %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def dead %v0 {
      %a0 = LW killed %s3, 0 :: (load 4 from @pgpout, !tbaa !9)
    }
    %s5 = LW %sp, 96 :: (load 4 from stack)
    B %bb.55..loopexit, implicit-def dead %at {
      %s3 = ADDiu %zero, 1
    }

...
