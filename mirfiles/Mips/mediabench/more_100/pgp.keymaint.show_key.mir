--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %e.i.i.i = alloca [128 x i16], align 2
    %n.i.i = alloca [128 x i16], align 2
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %1 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %2 = icmp sgt i32 %1, 8
    br i1 %2, label %3, label %4
  
  ; <label>:3                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %4
  
  ; <label>:4                                       ; preds = %3, %0
    %5 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %5, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %6 = icmp eq %struct._IO_FILE* %5, null
    br i1 %6, label %7, label %11
  
  ; <label>:7                                       ; preds = %4
    %8 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %9 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %10 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %8, i8* %9, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %11
  
  ; <label>:11                                      ; preds = %7, %4
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp slt i32 %12, 8
    br i1 %13, label %15, label %14
  
  ; <label>:14                                      ; preds = %11
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:15                                      ; preds = %11
    %16 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %16, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %17 = icmp sgt i32 %12, 0
    br i1 %17, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:18                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %19 = bitcast i8** %scevgep to [8 x i8*]*
    %20 = icmp slt i32 %24, %12
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %15, %18
    %lsr.iv = phi [8 x i8*]* [ %19, %18 ], [ @krnames, %15 ]
    %i.02.i = phi i32 [ %24, %18 ], [ 0, %15 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %21 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %22 = tail call i32 @strcmp(i8* %.keyring.i, i8* %21) #6
    %23 = icmp eq i32 %22, 0
    %24 = add nuw nsw i32 %i.02.i, 1
    br i1 %23, label %setkrent.exit, label %18
  
  ._crit_edge.i:                                    ; preds = %18, %15
    %25 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %26 = load i32, i32* @nkr, align 4, !tbaa !7
    %27 = add nsw i32 %26, 1
    store i32 %27, i32* @nkr, align 4, !tbaa !7
    %28 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %26
    store i8* %25, i8** %28, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %29 = load i32, i32* @marg_min, align 4, !tbaa !7
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %31, label %33
  
  ; <label>:31                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %32 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:33                                      ; preds = %setkrent.exit
    %34 = load i32, i32* @compl_min, align 4, !tbaa !7
    %35 = icmp slt i32 %29, %34
    br i1 %35, label %36, label %37
  
  ; <label>:36                                      ; preds = %33
    store i32 %34, i32* @marg_min, align 4, !tbaa !7
    br label %37
  
  ; <label>:37                                      ; preds = %36, %33
    %38 = phi i32 [ %34, %36 ], [ %29, %33 ]
    store i32 %34, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %38, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %39 = mul nsw i32 %38, %34
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %37, %31
    %storemerge.i = phi i32 [ %39, %37 ], [ %32, %31 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %40 = sdiv i32 %storemerge.i, 2
    store i32 %40, i32* @marginal_min, align 4, !tbaa !7
    %41 = tail call i8* @xmalloc(i32 signext 1028) #6
    %42 = load i32, i32* @totalsize, align 4, !tbaa !10
    %43 = add nsw i32 %42, 1024
    store i32 %43, i32* @totalsize, align 4, !tbaa !10
    %44 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %45 = bitcast i8* %41 to i32*
    store i32 %44, i32* %45, align 4, !tbaa !12
    store i8* %41, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %46 = getelementptr inbounds i8, i8* %41, i32 4
    store i8* %46, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %46, i8 0, i32 1024, i32 4, i1 false) #6
    %47 = load i8, i8* @mverbose, align 4, !tbaa !6
    %48 = load i8, i8* @verbose, align 1
    %49 = or i8 %48, %47
    %50 = icmp eq i8 %49, 0
    br i1 %50, label %55, label %51
  
  ; <label>:51                                      ; preds = %setup_trust.exit
    %52 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %53 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %54 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %52, i8* %53)
    br label %55
  
  ; <label>:55                                      ; preds = %51, %setup_trust.exit
    %56 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %56) #6
    %57 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %57) #6
    %58 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %58) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %59 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %60 = icmp eq %struct._IO_FILE* %59, null
    br i1 %60, label %61, label %.preheader.i
  
  .preheader.i:                                     ; preds = %55
    br label %.outer.i
  
  ; <label>:61                                      ; preds = %55
    %62 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %63 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %64 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %62, i8* %63, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:65                                      ; preds = %.outer29.i, %82
    %66 = bitcast i64* %sigkeyID.i to i8*
    %67 = bitcast i64* %keyID.i to i8*
    %68 = bitcast [256 x i8]* %userid.i to i8*
    %69 = call i32 @readkpacket(%struct._IO_FILE* nonnull %59, i8* nonnull %ctb.i, i8* %68, i8* %67, i8* %66) #6
    %70 = icmp eq i32 %69, -1
    br i1 %70, label %493, label %71
  
  ; <label>:71                                      ; preds = %65
    %.off.i = add i32 %69, 3
    %72 = icmp ult i32 %.off.i, 2
    br i1 %72, label %73, label %75
  
  ; <label>:73                                      ; preds = %71
    %74 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  ; <label>:75                                      ; preds = %71
    %76 = icmp slt i32 %69, 0
    br i1 %76, label %.outer29.i, label %77
  
  ; <label>:77                                      ; preds = %75
    %78 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %79 = zext i8 %78 to i32
    %80 = and i32 %79, 124
    %81 = icmp eq i32 %80, 20
    br i1 %81, label %.outer29.i, label %82
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %80, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %83
    br i1 %or.cond28.i, label %84, label %65
  
  ; <label>:84                                      ; preds = %82
    %85 = icmp eq i32 %80, 56
    %86 = icmp eq i8 %78, -80
    %or.cond.i = or i1 %86, %85
    br i1 %or.cond.i, label %.outer29.i, label %87
  
  .outer29.i:                                       ; preds = %75, %77, %84, %93, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %93 ], [ true, %84 ], [ false, %77 ], [ false, %75 ]
    br label %65
  
  ; <label>:87                                      ; preds = %84
    %88 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %89 = icmp eq i32 %80, 8
    %or.cond4.i = and i1 %88, %89
    br i1 %or.cond4.i, label %90, label %94
  
  ; <label>:90                                      ; preds = %87
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %91 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %92 = icmp eq %struct.userid* %91, null
    br i1 %92, label %93, label %94
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:94                                      ; preds = %90, %87
    %95 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %95) #6
    %96 = call i32 @fread(i8* %95, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %59) #6
    %97 = icmp eq i32 %96, 3
    br i1 %97, label %98, label %.loopexit.i
  
  ; <label>:98                                      ; preds = %94
    %99 = bitcast [3 x i8]* %buf.i.i to i32*
    %100 = load i32, i32* %99, align 4
    %101 = lshr i32 %100, 24
    %102 = trunc i32 %101 to i8
    %103 = icmp eq i8 %102, -80
    %104 = lshr i32 %100, 8
    br i1 %103, label %110, label %105
  
  ; <label>:105                                     ; preds = %98
    %106 = trunc i32 %101 to i8
    %107 = icmp slt i8 %106, 0
    br i1 %107, label %108, label %.loopexit.i
  
  ; <label>:108                                     ; preds = %105
    %109 = call i32 @fseek(%struct._IO_FILE* nonnull %59, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:110                                     ; preds = %98
    %111 = and i32 %100, 16711680
    %112 = icmp eq i32 %111, 65536
    br i1 %112, label %115, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %94, %110, %108, %105
    %113 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %113) #6
    %114 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  ; <label>:115                                     ; preds = %110
    %116 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %116) #6
    %117 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %118 = zext i8 %117 to i32
    %119 = lshr i32 %118, 2
    %120 = and i32 %119, 31
    switch i32 %120, label %491 [
      i32 6, label %121
      i32 13, label %359
      i32 2, label %410
    ]
  
  ; <label>:121                                     ; preds = %115
    %122 = bitcast i64* %keyID.i to i8*
    %123 = load i8, i8* %122, align 8, !tbaa !6
    %124 = zext i8 %123 to i32
    %125 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %126 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %125, i32 %124
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %126, align 4, !tbaa !9
    %127 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %127, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %121, %132
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %132 ], [ %pk.02.i.i, %121 ]
    %128 = bitcast i64* %keyID.i to i8*
    %129 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %130 = call i32 @memcmp(i8* %129, i8* %128, i32 signext 8) #7
    %131 = icmp eq i32 %130, 0
    br i1 %131, label %getpubkey.exit.i, label %132
  
  ; <label>:132                                     ; preds = %.lr.ph.i.i
    %133 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %133, align 4, !tbaa !9
    %134 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %134, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %132, %121
    %135 = load i32, i32* @nleft, align 4, !tbaa !7
    %136 = icmp slt i32 %135, 28
    br i1 %136, label %137, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:137                                     ; preds = %._crit_edge.i.i
    %138 = call i8* @xmalloc(i32 signext 4004) #6
    %139 = load i32, i32* @totalsize, align 4, !tbaa !10
    %140 = add nsw i32 %139, 4000
    store i32 %140, i32* @totalsize, align 4, !tbaa !10
    %141 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %142 = bitcast i8* %138 to i32*
    store i32 %141, i32* %142, align 4, !tbaa !12
    store i8* %138, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %143 = getelementptr inbounds i8, i8* %138, i32 4
    store i8* %143, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %137, %._crit_edge.i8.i
    %144 = phi %struct.pubkey** [ %.pre61.i, %137 ], [ %125, %._crit_edge.i8.i ]
    %145 = phi i8* [ %143, %137 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %146 = phi i32 [ 4000, %137 ], [ %135, %._crit_edge.i8.i ]
    %147 = bitcast i64* %keyID.i to i8*
    %148 = add nsw i32 %146, -28
    store i32 %148, i32* @nleft, align 4, !tbaa !7
    %149 = getelementptr inbounds i8, i8* %145, i32 28
    store i8* %149, i8** @allocn.ptr, align 4, !tbaa !9
    %150 = bitcast i8* %145 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %145, i8 0, i32 28, i32 4, i1 false) #6
    %151 = getelementptr inbounds i8, i8* %145, i32 16
    %152 = bitcast i8* %151 to i64*
    %153 = load i64, i64* %keyID.i, align 8
    store i64 %153, i64* %152, align 1
    %154 = load i8, i8* %147, align 8, !tbaa !6
    %155 = zext i8 %154 to i32
    %156 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %144, i32 %155
    %157 = bitcast %struct.pubkey** %156 to i32*
    %158 = load i32, i32* %157, align 4, !tbaa !9
    %159 = getelementptr inbounds i8, i8* %145, i32 4
    %160 = bitcast i8* %159 to i32*
    store i32 %158, i32* %160, align 4, !tbaa !17
    %161 = load i8, i8* %147, align 8, !tbaa !6
    %162 = zext i8 %161 to i32
    %163 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %144, i32 %162
    %164 = bitcast %struct.pubkey** %163 to i8**
    store i8* %145, i8** %164, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %150, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %165 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %165, label %166, label %168
  
  ; <label>:166                                     ; preds = %getpubkey.exit.i
    %167 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %167, align 4, !tbaa !18
    br label %169
  
  ; <label>:168                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %169
  
  ; <label>:169                                     ; preds = %168, %166
    %170 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %171 = load %struct.pubkey*, %struct.pubkey** %170, align 4, !tbaa !18
    %172 = icmp eq %struct.pubkey* %171, null
    br i1 %172, label %180, label %173
  
  ; <label>:173                                     ; preds = %169
    %174 = bitcast i64* %keyID.i to i8*
    %175 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %176 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %177 = call i8* @keyIDstring(i8* %174) #6
    %178 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %175, i8* %176, i8* %177) #6
    %179 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  ; <label>:180                                     ; preds = %169
    %181 = trunc i32 %104 to i8
    %182 = icmp slt i8 %181, 0
    br i1 %182, label %ismember_newkeys.exit.i, label %183
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %104 to i8
    %185 = icmp eq %struct.newkey* %nkeys, null
    br i1 %185, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %183, %190
    %.02.i.i = phi %struct.newkey* [ %193, %190 ], [ %nkeys, %183 ]
    %186 = bitcast i64* %keyID.i to i8*
    %187 = bitcast %struct.newkey* %.02.i.i to i8*
    %188 = call i32 @memcmp(i8* %186, i8* %187, i32 signext 8) #7
    %189 = icmp eq i32 %188, 0
    br i1 %189, label %ismember_newkeys.exit.i, label %190
  
  ; <label>:190                                     ; preds = %.lr.ph.i9.i
    %191 = trunc i32 %104 to i8
    %192 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %193 = load %struct.newkey*, %struct.newkey** %192, align 4, !tbaa !1
    %194 = icmp eq %struct.newkey* %193, null
    br i1 %194, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %180
    %195 = bitcast [8 x i8]* %keyID.i.i to i8*
    %196 = bitcast [256 x i8]* %userid.i.i to i8*
    %197 = bitcast [128 x i16]* %esec.i.i to i8*
    %198 = bitcast [128 x i16]* %nsec.i.i to i8*
    %199 = bitcast [128 x i16]* %e.i.i to i8*
    %200 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 256, i8* %198) #6
    call void @llvm.lifetime.start(i64 256, i8* %197) #6
    call void @llvm.lifetime.start(i64 256, i8* %196) #6
    call void @llvm.lifetime.start(i64 8, i8* %195) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %201 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %202 = icmp eq %struct._IO_FILE* %201, null
    br i1 %202, label %check_secretkey.exit.i, label %203
  
  ; <label>:203                                     ; preds = %ismember_newkeys.exit.i
    %204 = bitcast [128 x i16]* %e.i.i to i16*
    %205 = bitcast [128 x i16]* %n.i.i to i16*
    %206 = call i32 @ftell(%struct._IO_FILE* nonnull %59) #6
    %207 = call i32 @fseek(%struct._IO_FILE* nonnull %59, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %208 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %59, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %205, i16* %204, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %209 = icmp slt i16 %208, 0
    br i1 %209, label %.thread.i.i, label %210
  
  ; <label>:210                                     ; preds = %203
    %211 = bitcast [128 x i16]* %n.i.i to i16*
    %212 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %212, i16* %211) #6
    br label %213
  
  ; <label>:213                                     ; preds = %233, %210
    %214 = bitcast [128 x i16]* %e.i.i.i to i16*
    %215 = bitcast [128 x i16]* %n.i.i.i to i16*
    %216 = bitcast [128 x i16]* %e.i.i.i to i8*
    %217 = bitcast [128 x i16]* %n.i.i.i to i8*
    %218 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %217) #6
    call void @llvm.lifetime.start(i64 256, i8* %216) #6
    %219 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %59, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %218, i16* %215, i16* %214, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %220 = icmp slt i16 %219, 0
    br i1 %220, label %readkpacket.exit.i.i, label %221
  
  ; <label>:221                                     ; preds = %213
    %222 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %223 = icmp eq i8 %222, -76
    br i1 %223, label %224, label %readkpacket.exit.thread.i.i
  
  ; <label>:224                                     ; preds = %221
    %225 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %225) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %224, %221
    %226 = bitcast [128 x i16]* %e.i.i.i to i8*
    %227 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %226) #6
    call void @llvm.lifetime.end(i64 256, i8* %227) #6
    br label %233
  
  readkpacket.exit.i.i:                             ; preds = %213
    %228 = bitcast [128 x i16]* %e.i.i.i to i8*
    %229 = bitcast [128 x i16]* %n.i.i.i to i8*
    %230 = sext i16 %219 to i32
    call void @llvm.lifetime.end(i64 256, i8* %228) #6
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    %231 = or i32 %230, 2
    %232 = icmp eq i32 %231, -1
    br i1 %232, label %.thread.i.i, label %233
  
  ; <label>:233                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %234 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %235 = icmp eq i8 %234, -76
    br i1 %235, label %236, label %213
  
  ; <label>:236                                     ; preds = %233
    %237 = bitcast [8 x i8]* %keyID.i.i to i8*
    %238 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %239 = call i32 @lookup_by_keyID(%struct._IO_FILE* %238, i8* %237) #6
    %240 = icmp slt i32 %239, 0
    br i1 %240, label %.thread.i.i, label %241
  
  ; <label>:241                                     ; preds = %236
    %242 = bitcast [128 x i16]* %esec.i.i to i16*
    %243 = bitcast [128 x i16]* %nsec.i.i to i16*
    %244 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %245 = call i32 @ftell(%struct._IO_FILE* %244) #6
    %246 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %247 = call signext i16 @readkeypacket(%struct._IO_FILE* %246, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %243, i16* %242, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %248 = icmp slt i16 %247, 0
    br i1 %248, label %249, label %253
  
  ; <label>:249                                     ; preds = %241
    %250 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %251 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %252 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %250, i8* %251) #6
    br label %.thread.i.i
  
  ; <label>:253                                     ; preds = %241
    %254 = bitcast [128 x i16]* %nsec.i.i to i16*
    %255 = bitcast [128 x i16]* %n.i.i to i16*
    %256 = call signext i16 @mp_compare(i16* %255, i16* %254) #6
    %257 = icmp eq i16 %256, 0
    br i1 %257, label %258, label %263
  
  ; <label>:258                                     ; preds = %253
    %259 = bitcast [128 x i16]* %esec.i.i to i16*
    %260 = bitcast [128 x i16]* %e.i.i to i16*
    %261 = call signext i16 @mp_compare(i16* %260, i16* %259) #6
    %262 = icmp eq i16 %261, 0
    br i1 %262, label %271, label %263
  
  ; <label>:263                                     ; preds = %258, %253
    %264 = bitcast [256 x i8]* %userid.i.i to i8*
    %265 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %266 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %267 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %265, i8* %266, i8* %264) #6
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269) #6
    br label %271
  
  ; <label>:271                                     ; preds = %263, %258
    %status.0.i.i = phi i32 [ -2, %263 ], [ 0, %258 ]
    %272 = trunc i32 %104 to i8
    %273 = icmp slt i8 %272, 0
    br i1 %273, label %287, label %274
  
  ; <label>:274                                     ; preds = %271
    %275 = load i8, i8* @batchmode, align 1, !tbaa !6
    %276 = icmp eq i8 %275, 0
    br i1 %276, label %277, label %.thread.i.i
  
  ; <label>:277                                     ; preds = %274
    %278 = bitcast [256 x i8]* %userid.i.i to i8*
    %279 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %280 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %281 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %279, i8* %280, i8* %278) #6
    %282 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %283 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %284 = call i32 @fputs(i8* %282, %struct._IO_FILE* %283) #6
    %285 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %285, 0
    %286 = sext i1 %not..i.i to i32
    br label %287
  
  ; <label>:287                                     ; preds = %277, %271
    %status.1.i.i = phi i32 [ %status.0.i.i, %271 ], [ %286, %277 ]
    %288 = icmp eq i32 %status.1.i.i, 0
    %289 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %290 = icmp ne %struct._IO_FILE* %289, null
    %or.cond3.i.i = and i1 %288, %290
    br i1 %or.cond3.i.i, label %291, label %.thread.i.i
  
  ; <label>:291                                     ; preds = %287
    %292 = bitcast [8 x i8]* %keyID.i.i to i8*
    %293 = call i32 @lookup_by_keyID(%struct._IO_FILE* %289, i8* %292) #6
    %294 = icmp slt i32 %293, 0
    br i1 %294, label %295, label %300
  
  ; <label>:295                                     ; preds = %291
    %296 = bitcast [256 x i8]* %userid.i.i to i8*
    %297 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %298 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %299 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %297, i8* %298, i8* %296, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:300                                     ; preds = %291
    %301 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %302 = call i32 @ftell(%struct._IO_FILE* %301) #6
    %303 = sub nsw i32 %302, %245
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @fseek(%struct._IO_FILE* %304, i32 signext %245, i32 signext 0) #6
    br label %306
  
  ; <label>:306                                     ; preds = %308, %300
    %pktlen.0.i.i = phi i32 [ %303, %300 ], [ %309, %308 ]
    %307 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %307, label %308, label %.critedge.i.i
  
  ; <label>:308                                     ; preds = %306
    %309 = add nsw i32 %pktlen.0.i.i, -1
    %310 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %311 = call i32 @_IO_getc(%struct._IO_FILE* %310) #6
    %312 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %313 = call i32 @_IO_getc(%struct._IO_FILE* %312) #6
    %314 = icmp eq i32 %311, %313
    br i1 %314, label %306, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %306
    %315 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %315, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %308, %.critedge.i.i
    %316 = bitcast [256 x i8]* %userid.i.i to i8*
    %317 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %318 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %319 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %317, i8* %318, i8* %316, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %295, %287, %274, %249, %236, %203
    %status.4.i.i = phi i32 [ -1, %203 ], [ 1, %236 ], [ -3, %249 ], [ 0, %295 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %287 ], [ -1, %274 ], [ %230, %readkpacket.exit.i.i ]
    %323 = call i32 @fseek(%struct._IO_FILE* nonnull %59, i32 signext %206, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %324 = bitcast [8 x i8]* %keyID.i.i to i8*
    %325 = bitcast [256 x i8]* %userid.i.i to i8*
    %326 = bitcast [128 x i16]* %esec.i.i to i8*
    %327 = bitcast [128 x i16]* %nsec.i.i to i8*
    %328 = bitcast [128 x i16]* %e.i.i to i8*
    %329 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %324) #6
    call void @llvm.lifetime.end(i64 256, i8* %325) #6
    call void @llvm.lifetime.end(i64 256, i8* %326) #6
    call void @llvm.lifetime.end(i64 256, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    %330 = icmp eq i32 %.0.i11.i, 0
    br i1 %330, label %331, label %343
  
  ; <label>:331                                     ; preds = %check_secretkey.exit.i
    %332 = add nsw i32 %buckstopcount.0.ph.i, 1
    %333 = or i32 %104, 135
    %334 = trunc i32 %333 to i8
    %335 = load i8, i8* @mverbose, align 4, !tbaa !6
    %336 = icmp eq i8 %335, 0
    br i1 %336, label %355, label %337
  
  ; <label>:337                                     ; preds = %331
    %338 = trunc i32 %333 to i8
    %339 = bitcast i64* %keyID.i to i8*
    %340 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %341 = call i8* @keyIDstring(i8* %339) #6
    %342 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %340, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %341) #6
    br label %355
  
  ; <label>:343                                     ; preds = %check_secretkey.exit.i
    %344 = and i32 %104, 127
    %345 = trunc i32 %344 to i8
    %346 = and i32 %104, 7
    %347 = icmp eq i32 %346, 7
    %..i = select i1 %347, i8 6, i8 %345
    %348 = load i8, i8* @mverbose, align 4, !tbaa !6
    %349 = icmp eq i8 %348, 0
    br i1 %349, label %355, label %350
  
  ; <label>:350                                     ; preds = %343
    %351 = bitcast i64* %keyID.i to i8*
    %352 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %353 = call i8* @keyIDstring(i8* %351) #6
    %354 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %352, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %353) #6
    br label %355
  
  ; <label>:355                                     ; preds = %350, %343, %337, %331
    %keyctrl.2.i = phi i8 [ %334, %331 ], [ %338, %337 ], [ %..i, %343 ], [ %..i, %350 ]
    %buckstop.1.i = phi i8 [ 1, %331 ], [ 1, %337 ], [ %buckstop.0.ph.i, %343 ], [ %buckstop.0.ph.i, %350 ]
    %buckstopcount.1.i = phi i32 [ %332, %331 ], [ %332, %337 ], [ %buckstopcount.0.ph.i, %343 ], [ %buckstopcount.0.ph.i, %350 ]
    %356 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %190, %355, %183
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %355 ], [ %184, %183 ], [ %191, %190 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %355 ], [ 0, %183 ], [ 0, %190 ]
    %show_user.1.i = phi i8 [ %356, %355 ], [ 0, %183 ], [ 0, %190 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %355 ], [ %buckstopcount.0.ph.i, %183 ], [ %buckstopcount.0.ph.i, %190 ]
    %357 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %357, align 4, !tbaa !16
    %358 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %358, align 4, !tbaa !14
    br label %491
  
  ; <label>:359                                     ; preds = %115
    %360 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %360, label %361, label %491
  
  ; <label>:361                                     ; preds = %359
    %362 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %362, label %373, label %363
  
  ; <label>:363                                     ; preds = %361
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %364 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %365 = icmp eq %struct.userid* %364, null
    br i1 %365, label %369, label %366
  
  ; <label>:366                                     ; preds = %363
    %367 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %368 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %367) #6
    br label %369
  
  ; <label>:369                                     ; preds = %366, %363
    %370 = bitcast [256 x i8]* %userid.i to i8*
    %371 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %372 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %371, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %370) #6
    br label %373
  
  ; <label>:373                                     ; preds = %369, %361
    %374 = load i32, i32* @nleft, align 4, !tbaa !7
    %375 = icmp slt i32 %374, 20
    br i1 %375, label %376, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %373
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:376                                     ; preds = %373
    %377 = call i8* @xmalloc(i32 signext 4004) #6
    %378 = load i32, i32* @totalsize, align 4, !tbaa !10
    %379 = add nsw i32 %378, 4000
    store i32 %379, i32* @totalsize, align 4, !tbaa !10
    %380 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %381 = bitcast i8* %377 to i32*
    store i32 %380, i32* %381, align 4, !tbaa !12
    store i8* %377, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %382 = getelementptr inbounds i8, i8* %377, i32 4
    store i8* %382, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %376, %._crit_edge.i13.i
    %383 = phi i8* [ %382, %376 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %384 = phi i32 [ 4000, %376 ], [ %374, %._crit_edge.i13.i ]
    %385 = icmp eq %struct.userid* %id.0.ph.i, null
    %386 = add nsw i32 %384, -20
    store i32 %386, i32* @nleft, align 4, !tbaa !7
    %387 = getelementptr inbounds i8, i8* %383, i32 20
    store i8* %387, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %385, label %390, label %388
  
  ; <label>:388                                     ; preds = %allocn.exit14.i
    %389 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %383, i8** %389, align 4, !tbaa !19
    br label %391
  
  ; <label>:390                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %383, i8** %sunkaddr12, align 4, !tbaa !14
    br label %391
  
  ; <label>:391                                     ; preds = %390, %388
    %392 = load i8, i8* @mverbose, align 4, !tbaa !6
    %393 = icmp eq i8 %392, 0
    br i1 %393, label %399, label %394
  
  ; <label>:394                                     ; preds = %391
    %395 = bitcast [256 x i8]* %userid.i to i8*
    %396 = call fastcc i8* @store_str(i8* %395) #6
    %397 = getelementptr inbounds i8, i8* %383, i32 12
    %398 = bitcast i8* %397 to i8**
    store i8* %396, i8** %398, align 4, !tbaa !21
    br label %399
  
  ; <label>:399                                     ; preds = %394, %391
    %400 = bitcast i8* %383 to %struct.userid*
    %401 = and i32 %104, 252
    %402 = icmp eq i8 %buckstop.0.ph.i, 0
    %403 = or i32 %104, 3
    %storemerge.in.i = select i1 %402, i32 %401, i32 %403
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %404 = bitcast i8* %383 to %struct.userid**
    store %struct.userid* null, %struct.userid** %404, align 4, !tbaa !19
    %405 = getelementptr inbounds i8, i8* %383, i32 4
    %406 = bitcast i8* %405 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %406, align 4, !tbaa !22
    %407 = getelementptr inbounds i8, i8* %383, i32 16
    store i8 %storemerge.i4, i8* %407, align 4, !tbaa !23
    %408 = getelementptr inbounds i8, i8* %383, i32 8
    %409 = bitcast i8* %408 to %struct.signature**
    store %struct.signature* null, %struct.signature** %409, align 4, !tbaa !24
    br label %491
  
  ; <label>:410                                     ; preds = %115
    %411 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %412 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %411, %412
    br i1 %or.cond3.i, label %413, label %491
  
  ; <label>:413                                     ; preds = %410
    %414 = load i32, i32* @nleft, align 4, !tbaa !7
    %415 = icmp slt i32 %414, 20
    br i1 %415, label %416, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %413
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:416                                     ; preds = %413
    %417 = call i8* @xmalloc(i32 signext 4004) #6
    %418 = load i32, i32* @totalsize, align 4, !tbaa !10
    %419 = add nsw i32 %418, 4000
    store i32 %419, i32* @totalsize, align 4, !tbaa !10
    %420 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %421 = bitcast i8* %417 to i32*
    store i32 %420, i32* %421, align 4, !tbaa !12
    store i8* %417, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %422 = getelementptr inbounds i8, i8* %417, i32 4
    store i8* %422, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %416, %._crit_edge.i16.i
    %423 = phi i8* [ %422, %416 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %424 = phi i32 [ 4000, %416 ], [ %414, %._crit_edge.i16.i ]
    %425 = icmp eq %struct.signature* %sig.0.ph.i, null
    %426 = add nsw i32 %424, -20
    store i32 %426, i32* @nleft, align 4, !tbaa !7
    %427 = getelementptr inbounds i8, i8* %423, i32 20
    store i8* %427, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %425, label %430, label %428
  
  ; <label>:428                                     ; preds = %allocn.exit17.i
    %429 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %423, i8** %429, align 4, !tbaa !25
    br label %433
  
  ; <label>:430                                     ; preds = %allocn.exit17.i
    %431 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %432 = bitcast %struct.signature** %431 to i8**
    store i8* %423, i8** %432, align 4, !tbaa !24
    br label %433
  
  ; <label>:433                                     ; preds = %430, %428
    %434 = bitcast i64* %sigkeyID.i to i8*
    %435 = bitcast i8* %423 to %struct.signature**
    store %struct.signature* null, %struct.signature** %435, align 4, !tbaa !25
    %436 = getelementptr inbounds i8, i8* %423, i32 4
    %437 = bitcast i8* %436 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %437, align 4, !tbaa !27
    %438 = load i8, i8* %434, align 8, !tbaa !6
    %439 = zext i8 %438 to i32
    %440 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %441 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %440, i32 %439
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %441, align 4, !tbaa !9
    %442 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %442, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %433, %447
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %447 ], [ %pk.02.i18.i, %433 ]
    %443 = bitcast i64* %sigkeyID.i to i8*
    %444 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %445 = call i32 @memcmp(i8* %444, i8* %443, i32 signext 8) #7
    %446 = icmp eq i32 %445, 0
    br i1 %446, label %getpubkey.exit24.i, label %447
  
  ; <label>:447                                     ; preds = %.lr.ph.i20.i
    %448 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %448, align 4, !tbaa !9
    %449 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %449, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %447, %433
    %450 = icmp slt i32 %426, 28
    br i1 %450, label %451, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:451                                     ; preds = %._crit_edge.i22.i
    %452 = call i8* @xmalloc(i32 signext 4004) #6
    %453 = load i32, i32* @totalsize, align 4, !tbaa !10
    %454 = add nsw i32 %453, 4000
    store i32 %454, i32* @totalsize, align 4, !tbaa !10
    %455 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %456 = bitcast i8* %452 to i32*
    store i32 %455, i32* %456, align 4, !tbaa !12
    store i8* %452, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %457 = getelementptr inbounds i8, i8* %452, i32 4
    store i8* %457, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %451, %._crit_edge.i26.i
    %458 = phi %struct.pubkey** [ %.pre.i, %451 ], [ %440, %._crit_edge.i26.i ]
    %459 = phi i8* [ %457, %451 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %460 = phi i32 [ 4000, %451 ], [ %426, %._crit_edge.i26.i ]
    %461 = bitcast i64* %sigkeyID.i to i8*
    %462 = add nsw i32 %460, -28
    store i32 %462, i32* @nleft, align 4, !tbaa !7
    %463 = getelementptr inbounds i8, i8* %459, i32 28
    store i8* %463, i8** @allocn.ptr, align 4, !tbaa !9
    %464 = bitcast i8* %459 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %459, i8 0, i32 28, i32 4, i1 false) #6
    %465 = getelementptr inbounds i8, i8* %459, i32 16
    %466 = bitcast i8* %465 to i64*
    %467 = load i64, i64* %sigkeyID.i, align 8
    store i64 %467, i64* %466, align 1
    %468 = load i8, i8* %461, align 8, !tbaa !6
    %469 = zext i8 %468 to i32
    %470 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %458, i32 %469
    %471 = bitcast %struct.pubkey** %470 to i32*
    %472 = load i32, i32* %471, align 4, !tbaa !9
    %473 = getelementptr inbounds i8, i8* %459, i32 4
    %474 = bitcast i8* %473 to i32*
    store i32 %472, i32* %474, align 4, !tbaa !17
    %475 = load i8, i8* %461, align 8, !tbaa !6
    %476 = zext i8 %475 to i32
    %477 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %458, i32 %476
    %478 = bitcast %struct.pubkey** %477 to i8**
    store i8* %459, i8** %478, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %464, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %479 = bitcast i8* %423 to %struct.signature*
    %480 = getelementptr inbounds i8, i8* %423, i32 8
    %481 = bitcast i8* %480 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %481, align 4, !tbaa !28
    %482 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %483 = bitcast %struct.signature** %482 to i32*
    %484 = load i32, i32* %483, align 4, !tbaa !29
    %485 = getelementptr inbounds i8, i8* %423, i32 12
    %486 = bitcast i8* %485 to i32*
    store i32 %484, i32* %486, align 4, !tbaa !30
    %487 = bitcast %struct.signature** %482 to i8**
    store i8* %423, i8** %487, align 4, !tbaa !29
    %488 = and i32 %104, 64
    %489 = trunc i32 %488 to i8
    %490 = getelementptr inbounds i8, i8* %423, i32 16
    store i8 %489, i8* %490, align 4, !tbaa !31
    br label %491
  
  ; <label>:491                                     ; preds = %getpubkey.exit24.i, %410, %399, %359, %ismember_newkeys.exit.thread.i, %115
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %115 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %410 ], [ %buckstop.0.ph.i, %399 ], [ %buckstop.0.ph.i, %359 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %115 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %410 ], [ %show_user.0.ph.i, %399 ], [ %show_user.0.ph.i, %359 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %115 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %410 ], [ %buckstopcount.0.ph.i, %399 ], [ %buckstopcount.0.ph.i, %359 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %115 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %410 ], [ %pk.0.ph.i, %399 ], [ null, %359 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %115 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %410 ], [ %400, %399 ], [ %id.0.ph.i, %359 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %115 ], [ %479, %getpubkey.exit24.i ], [ %sig.0.ph.i, %410 ], [ null, %399 ], [ %sig.0.ph.i, %359 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %492 = call i32 @ftell(%struct._IO_FILE* nonnull %59) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %491, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %491 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %491 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %491 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %492, %491 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %491 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %491 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %491 ]
    br label %.outer29.i
  
  ; <label>:493                                     ; preds = %65
    %494 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %495 = load i8, i8* @mverbose, align 4
    %496 = icmp eq i8 %495, 0
    %or.cond6.i = or i1 %494, %496
    br i1 %or.cond6.i, label %501, label %497
  
  ; <label>:497                                     ; preds = %493
    %498 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %499 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %500 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %498, i8* %499) #6
    br label %501
  
  ; <label>:501                                     ; preds = %497, %493
    %502 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %501, %173, %.loopexit.i, %73, %61
    %.0.i = phi i32 [ -1, %61 ], [ %69, %73 ], [ -7, %.loopexit.i ], [ -1, %173 ], [ 0, %501 ]
    %503 = bitcast i64* %sigkeyID.i to i8*
    %504 = bitcast i64* %keyID.i to i8*
    %505 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %503) #6
    call void @llvm.lifetime.end(i64 8, i8* %504) #6
    call void @llvm.lifetime.end(i64 256, i8* %505) #6
    %506 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %507 = icmp eq %struct._IO_FILE* %506, null
    br i1 %507, label %510, label %508
  
  ; <label>:508                                     ; preds = %maint_read_data.exit
    %509 = call i32 @fclose(%struct._IO_FILE* nonnull %506)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %510
  
  ; <label>:510                                     ; preds = %508, %maint_read_data.exit
    %511 = icmp slt i32 %.0.i, 0
    br i1 %511, label %756, label %512
  
  ; <label>:512                                     ; preds = %510
    %513 = load i8, i8* @mverbose, align 4, !tbaa !6
    %514 = load i8, i8* @verbose, align 1
    %515 = or i8 %514, %513
    %516 = icmp eq i8 %515, 0
    br i1 %516, label %521, label %517
  
  ; <label>:517                                     ; preds = %512
    %518 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %519 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %520 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %518, i8* %519)
    br label %521
  
  ; <label>:521                                     ; preds = %517, %512
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %522 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %522, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %521, %550
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %550 ], [ %pk.01.i, %521 ]
    %523 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %524 = load i8, i8* %523, align 4, !tbaa !16
    %525 = icmp slt i8 %524, 0
    br i1 %525, label %526, label %550
  
  ; <label>:526                                     ; preds = %.lr.ph.i5
    %527 = load i8, i8* @mverbose, align 4, !tbaa !6
    %528 = icmp eq i8 %527, 0
    br i1 %528, label %536, label %529
  
  ; <label>:529                                     ; preds = %526
    %530 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %531 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %532 = load %struct.userid*, %struct.userid** %531, align 4, !tbaa !14
    %533 = getelementptr inbounds %struct.userid, %struct.userid* %532, i32 0, i32 3
    %534 = load i8*, i8** %533, align 4, !tbaa !21
    %535 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %530, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %534) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %536
  
  ; <label>:536                                     ; preds = %529, %526
    %537 = phi i8 [ %524, %526 ], [ %.pre.i6, %529 ]
    %538 = and i8 %537, 7
    %539 = icmp eq i8 %538, 0
    br i1 %539, label %540, label %549
  
  ; <label>:540                                     ; preds = %536
    %541 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %542 = call i8* @user_from_keyID(i8* %541) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %543 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %544 = zext i8 %543 to i32
    %545 = and i32 %544, 248
    %546 = call i32 @ask_owntrust(i8* %542, i8 zeroext %543) #6
    %547 = or i32 %545, %546
    %548 = trunc i32 %547 to i8
    store i8 %548, i8* %sunkaddr18, align 4, !tbaa !6
    br label %549
  
  ; <label>:549                                     ; preds = %540, %536
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %550
  
  ; <label>:550                                     ; preds = %549, %.lr.ph.i5
    %551 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %551, align 4, !tbaa !9
    %552 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %552, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %550, %521
    %553 = load i8, i8* @verbose, align 1, !tbaa !6
    %554 = icmp eq i8 %553, 0
    br i1 %554, label %559, label %555
  
  ; <label>:555                                     ; preds = %maint_trace_chain.exit
    %556 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %557 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %558 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %556, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %557)
    br label %559
  
  ; <label>:559                                     ; preds = %555, %maint_trace_chain.exit
    %560 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %560) #6
    %561 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %561) #6
    %562 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %562) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i12) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %563, label %565
  
  ; <label>:563                                     ; preds = %559
    %564 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %567
  
  ; <label>:565                                     ; preds = %559
    %566 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %567
  
  ; <label>:567                                     ; preds = %565, %563
    %f.0.i = phi %struct._IO_FILE* [ %564, %563 ], [ %566, %565 ]
    %568 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %568, label %569, label %573
  
  ; <label>:569                                     ; preds = %567
    %570 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %571 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %572 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %570, i8* %571, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:573                                     ; preds = %567
    %574 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %707, %573
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %573 ], [ %kc_orig.2.i, %707 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %573 ], [ %trust_pos.1.i, %707 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %573 ], [ %kc_new.1.i, %707 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %573 ], [ %708, %707 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %574, %573 ], [ %pk.1.i, %707 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %573 ], [ %id.1.i, %707 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %573 ], [ %sig.1.i, %707 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %697, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %697 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %697 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %697 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %697 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %697 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %697 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %614, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %594, %614 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %580, %582, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %582 ], [ false, %580 ]
    br label %575
  
  ; <label>:575                                     ; preds = %587, %.outer20.i
    %576 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    %577 = bitcast [8 x i8]* %keyID.i.i to i8*
    %578 = bitcast [256 x i8]* %userid.i.i to i8*
    %579 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %ctb.i12, i8* %578, i8* %577, i8* %576) #6
    %switch.i = icmp ugt i32 %579, -4
    br i1 %switch.i, label %709, label %580
  
  ; <label>:580                                     ; preds = %575
    %581 = icmp slt i32 %579, 0
    br i1 %581, label %.outer20.i, label %582
  
  ; <label>:582                                     ; preds = %580
    %583 = load i8, i8* %ctb.i12, align 4, !tbaa !6
    %584 = zext i8 %583 to i32
    %585 = and i32 %584, 124
    %586 = icmp eq i32 %585, 20
    br i1 %586, label %.outer20.i, label %587
  
  ; <label>:587                                     ; preds = %582
    %588 = icmp eq i32 %585, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %588
    br i1 %or.cond.i18, label %589, label %575
  
  ; <label>:589                                     ; preds = %587
    switch i32 %585, label %590 [
      i32 24, label %592
      i32 8, label %592
    ]
  
  ; <label>:590                                     ; preds = %589
    %591 = icmp eq i8 %583, -76
    br i1 %591, label %592, label %.loopexit.i20
  
  ; <label>:592                                     ; preds = %590, %589, %589
    %593 = bitcast [3 x i8]* %buf.i.i to i8*
    %594 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %593) #6
    %595 = call i32 @fread(i8* %593, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %596 = icmp eq i32 %595, 3
    br i1 %596, label %597, label %614
  
  ; <label>:597                                     ; preds = %592
    %598 = bitcast [3 x i8]* %buf.i.i to i32*
    %599 = load i32, i32* %598, align 4
    %600 = lshr i32 %599, 24
    %601 = trunc i32 %600 to i8
    %602 = icmp eq i8 %601, -80
    br i1 %602, label %608, label %603
  
  ; <label>:603                                     ; preds = %597
    %604 = trunc i32 %600 to i8
    %605 = icmp slt i8 %604, 0
    br i1 %605, label %606, label %614
  
  ; <label>:606                                     ; preds = %603
    %607 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %614
  
  ; <label>:608                                     ; preds = %597
    %609 = and i32 %599, 16711680
    %610 = icmp eq i32 %609, 65536
    br i1 %610, label %read_trust.exit.i, label %614
  
  read_trust.exit.i:                                ; preds = %608
    %611 = bitcast [3 x i8]* %buf.i.i to i8*
    %612 = lshr i32 %599, 8
    %613 = trunc i32 %612 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %611) #6
    %.pre.i19 = load i8, i8* %ctb.i12, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:614                                     ; preds = %608, %606, %603, %592
    %615 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %615) #6
    %616 = load i8, i8* %ctb.i12, align 4, !tbaa !6
    %617 = and i8 %616, 124
    %618 = icmp eq i8 %617, 8
    br i1 %618, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %614
    %619 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %590, %read_trust.exit.i
    %620 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %583, %590 ]
    %kc_orig.2.i = phi i8 [ %613, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %590 ]
    %trust_pos.1.i = phi i32 [ %594, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %590 ]
    %621 = zext i8 %620 to i32
    %622 = lshr i32 %621, 2
    %623 = and i32 %622, 31
    switch i32 %623, label %697 [
      i32 6, label %624
      i32 13, label %643
      i32 2, label %681
    ]
  
  ; <label>:624                                     ; preds = %.loopexit.i20
    %625 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %625, label %631, label %626
  
  ; <label>:626                                     ; preds = %624
    %627 = bitcast [8 x i8]* %keyID.i.i to i8*
    %628 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %629 = call i32 @memcmp(i8* %628, i8* %627, i32 signext 8) #7
    %630 = icmp eq i32 %629, 0
    br i1 %630, label %632, label %631
  
  ; <label>:631                                     ; preds = %626, %624
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:632                                     ; preds = %626
    %633 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %634 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %634, %633
    br i1 %or.cond3.i21, label %635, label %636
  
  ; <label>:635                                     ; preds = %632
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:636                                     ; preds = %632
    %637 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %638 = load %struct.userid*, %struct.userid** %637, align 4, !tbaa !14
    %639 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %640 = load i8, i8* %639, align 4, !tbaa !16
    %641 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %642 = load %struct.pubkey*, %struct.pubkey** %641, align 4, !tbaa !18
    br label %697
  
  ; <label>:643                                     ; preds = %.loopexit.i20
    %644 = icmp eq %struct.userid* %id.0.ph.i14, null
    %645 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %644, %645
    br i1 %or.cond5.i, label %646, label %647
  
  ; <label>:646                                     ; preds = %643
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:647                                     ; preds = %643
    %648 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %649 = load %struct.signature*, %struct.signature** %648, align 4, !tbaa !24
    %650 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %651 = load %struct.pubkey*, %struct.pubkey** %650, align 4, !tbaa !22
    %652 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %651, i32 0, i32 5
    %653 = load i8, i8* %652, align 4, !tbaa !16
    %654 = icmp slt i8 %653, 0
    br i1 %654, label %compute_legit.exit.i, label %655
  
  ; <label>:655                                     ; preds = %647
    %656 = icmp eq %struct.signature* %649, null
    br i1 %656, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %655, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %649, %655 ]
    %trust_count.02.i.i = phi i32 [ %663, %.lr.ph.i.i22 ], [ 0, %655 ]
    %657 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %658 = load i8, i8* %657, align 4, !tbaa !31
    %659 = zext i8 %658 to i32
    %660 = and i32 %659, 7
    %661 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %660
    %662 = load i32, i32* %661, align 4, !tbaa !7
    %663 = add nsw i32 %662, %trust_count.02.i.i
    %664 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %664, align 4, !tbaa !9
    %665 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %665, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %666 = icmp eq i32 %663, 0
    br i1 %666, label %compute_legit.exit.i, label %667
  
  ; <label>:667                                     ; preds = %._crit_edge.i.i23
    %668 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %669 = icmp slt i32 %663, %668
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %667
    %671 = load i32, i32* @complete_min, align 4, !tbaa !7
    %672 = icmp slt i32 %663, %671
    %..i.i = select i1 %672, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %670, %667, %._crit_edge.i.i23, %655, %647
    %legit.0.i.i = phi i32 [ 3, %647 ], [ 0, %._crit_edge.i.i23 ], [ 1, %667 ], [ %..i.i, %670 ], [ 0, %655 ]
    %673 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %674 = load i8, i8* %673, align 4, !tbaa !23
    %675 = zext i8 %674 to i32
    %676 = and i32 %675, 252
    %677 = or i32 %676, %legit.0.i.i
    %678 = trunc i32 %677 to i8
    store i8 %678, i8* %673, align 4, !tbaa !23
    %679 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %680 = load %struct.userid*, %struct.userid** %679, align 4, !tbaa !19
    br label %697
  
  ; <label>:681                                     ; preds = %.loopexit.i20
    %682 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %682, label %683, label %684
  
  ; <label>:683                                     ; preds = %681
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:684                                     ; preds = %681
    %685 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    %686 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %687 = load %struct.pubkey*, %struct.pubkey** %686, align 4, !tbaa !28
    %688 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %687, i32 0, i32 4, i32 0
    %689 = call i32 @memcmp(i8* %688, i8* %685, i32 signext 8) #7
    %690 = icmp eq i32 %689, 0
    br i1 %690, label %692, label %691
  
  ; <label>:691                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:692                                     ; preds = %684
    %693 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %694 = load i8, i8* %693, align 4, !tbaa !31
    %695 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %696 = load %struct.signature*, %struct.signature** %695, align 4, !tbaa !25
    br label %697
  
  ; <label>:697                                     ; preds = %692, %compute_legit.exit.i, %636, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %694, %692 ], [ %678, %compute_legit.exit.i ], [ %640, %636 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %692 ], [ 3, %compute_legit.exit.i ], [ 135, %636 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %692 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %642, %636 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %692 ], [ %680, %compute_legit.exit.i ], [ %638, %636 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %696, %692 ], [ %649, %compute_legit.exit.i ], [ null, %636 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %698 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %699 = zext i8 %698 to i32
    %700 = and i32 %699, %mask.0.i
    %701 = icmp eq i32 %700, 0
    br i1 %701, label %.outer.i16, label %702
  
  ; <label>:702                                     ; preds = %697
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %707, label %703
  
  ; <label>:703                                     ; preds = %702
    %704 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %705 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %706 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %704, i32 signext 0) #6
    br label %707
  
  ; <label>:707                                     ; preds = %703, %702
    %708 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:709                                     ; preds = %575
    %710 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %711 = icmp slt i32 %579, -1
    br i1 %711, label %maint_final.exit, label %712
  
  ; <label>:712                                     ; preds = %709
    %713 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %714 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %713, %714
    %715 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %715, %or.cond7.i
    br i1 %or.cond9.i, label %716, label %maint_final.exit
  
  ; <label>:716                                     ; preds = %712
    %717 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %718 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %717) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %716, %712, %709, %.thread.i, %569
    %.0.i24 = phi i32 [ -1, %569 ], [ -1, %716 ], [ %579, %709 ], [ %changed.0.ph.ph.i, %712 ], [ -7, %.thread.i ]
    %719 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    %720 = bitcast [8 x i8]* %keyID.i.i to i8*
    %721 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i12) #6
    call void @llvm.lifetime.end(i64 8, i8* %719) #6
    call void @llvm.lifetime.end(i64 8, i8* %720) #6
    call void @llvm.lifetime.end(i64 256, i8* %721) #6
    %722 = icmp slt i32 %.0.i24, 0
    br i1 %722, label %756, label %723
  
  ; <label>:723                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %724 = load i8, i8* @verbose, align 1, !tbaa !6
    %725 = icmp eq i8 %724, 0
    br i1 %725, label %731, label %726
  
  ; <label>:726                                     ; preds = %723
    %727 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %728 = load i32, i32* @totalsize, align 4, !tbaa !10
    %729 = sdiv i32 %728, 1024
    %730 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %727, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %729) #6
    br label %731
  
  ; <label>:731                                     ; preds = %726, %723
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %732 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %733 = icmp eq %struct.bufpool* %732, null
    br i1 %733, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %731, %.lr.ph.i.i25
    %734 = phi %struct.bufpool* [ %738, %.lr.ph.i.i25 ], [ %732, %731 ]
    %735 = bitcast %struct.bufpool* %734 to i32*
    %736 = load i32, i32* %735, align 4, !tbaa !12
    store i32 %736, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %737 = bitcast %struct.bufpool* %734 to i8*
    call void @free(i8* %737) #6
    %738 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %739 = icmp eq %struct.bufpool* %738, null
    br i1 %739, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %731
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %740 = load i8, i8* @verbose, align 1, !tbaa !6
    %741 = icmp eq i8 %740, 0
    br i1 %741, label %.thread164, label %742
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:742                                     ; preds = %endkrent.exit
    %743 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %744 = load i32, i32* @totalsize, align 4, !tbaa !10
    %745 = sdiv i32 %744, 1024
    %746 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %743, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %745) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %747 = icmp eq %struct.bufpool* %.pre, null
    br i1 %747, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %742, %.lr.ph.i.i26
    %748 = phi %struct.bufpool* [ %752, %.lr.ph.i.i26 ], [ %.pre, %742 ]
    %749 = bitcast %struct.bufpool* %748 to i32*
    %750 = load i32, i32* %749, align 4, !tbaa !12
    store i32 %750, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %751 = bitcast %struct.bufpool* %748 to i8*
    call void @free(i8* %751) #6
    %752 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %753 = icmp eq %struct.bufpool* %752, null
    br i1 %753, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %742, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %754 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %755 = add nsw i32 %754, %.0.i24
    br label %791
  
  ; <label>:756                                     ; preds = %maint_final.exit, %510
    %status.0 = phi i32 [ %.0.i, %510 ], [ %.0.i24, %maint_final.exit ]
    %757 = load i8, i8* @verbose, align 1, !tbaa !6
    %758 = icmp eq i8 %757, 0
    br i1 %758, label %.thread, label %759
  
  .thread:                                          ; preds = %756
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %768
  
  ; <label>:759                                     ; preds = %756
    %760 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %761 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %760, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %762 = icmp eq i8 %.pr, 0
    br i1 %762, label %768, label %763
  
  ; <label>:763                                     ; preds = %759
    %764 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %765 = load i32, i32* @totalsize, align 4, !tbaa !10
    %766 = sdiv i32 %765, 1024
    %767 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %764, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %766) #6
    br label %768
  
  ; <label>:768                                     ; preds = %763, %759, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %769 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %770 = icmp eq %struct.bufpool* %769, null
    br i1 %770, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %768, %.lr.ph.i.i27
    %771 = phi %struct.bufpool* [ %775, %.lr.ph.i.i27 ], [ %769, %768 ]
    %772 = bitcast %struct.bufpool* %771 to i32*
    %773 = load i32, i32* %772, align 4, !tbaa !12
    store i32 %773, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %774 = bitcast %struct.bufpool* %771 to i8*
    call void @free(i8* %774) #6
    %775 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %776 = icmp eq %struct.bufpool* %775, null
    br i1 %776, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %768
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %777 = load i8, i8* @verbose, align 1, !tbaa !6
    %778 = icmp eq i8 %777, 0
    br i1 %778, label %.thread165, label %779
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:779                                     ; preds = %endkrent.exit28
    %780 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %781 = load i32, i32* @totalsize, align 4, !tbaa !10
    %782 = sdiv i32 %781, 1024
    %783 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %780, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %782) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %784 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %784, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %779, %.lr.ph.i.i29
    %785 = phi %struct.bufpool* [ %789, %.lr.ph.i.i29 ], [ %.pre163, %779 ]
    %786 = bitcast %struct.bufpool* %785 to i32*
    %787 = load i32, i32* %786, align 4, !tbaa !12
    store i32 %787, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %788 = bitcast %struct.bufpool* %785 to i8*
    call void @free(i8* %788) #6
    %789 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %790 = icmp eq %struct.bufpool* %789, null
    br i1 %790, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %779, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %791
  
  ; <label>:791                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %755, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            free_newkeys
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%2' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 12):
    successors: %bb.2.._crit_edge(37), %bb.3(62)
    liveins: %a0, %t9, %v0
  
    %3 = ADDu %v0, %t9
    %2 = COPY %a0
    BEQ %2, %zero, %bb.2.._crit_edge, implicit-def %at
  
  bb.3 (freq 8):
    successors: %bb.1..lr.ph(100)
  
  
  bb.1..lr.ph (freq 255):
    successors: %bb.2.._crit_edge(3), %bb.1..lr.ph(96)
  
    %0 = PHI %2, %bb.3, %1, %bb.1..lr.ph
    %1 = LW %0, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.2, !tbaa !1)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %4 = LW %3, target-flags(<unknown>) @free, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @free)
    %a0 = COPY %0
    %gp = COPY %3
    %t9 = COPY %4
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    BNE %1, %zero, %bb.1..lr.ph, implicit-def dead %at
    B %bb.2.._crit_edge, implicit-def dead %at
  
  bb.2.._crit_edge (freq 12):
    liveouts:
  
    RetRA

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %e.i.i.i = alloca [128 x i16], align 2
    %n.i.i = alloca [128 x i16], align 2
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %1 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %2 = icmp sgt i32 %1, 8
    br i1 %2, label %3, label %4
  
  ; <label>:3                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %4
  
  ; <label>:4                                       ; preds = %3, %0
    %5 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %5, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %6 = icmp eq %struct._IO_FILE* %5, null
    br i1 %6, label %7, label %11
  
  ; <label>:7                                       ; preds = %4
    %8 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %9 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %10 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %8, i8* %9, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %11
  
  ; <label>:11                                      ; preds = %7, %4
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp slt i32 %12, 8
    br i1 %13, label %15, label %14
  
  ; <label>:14                                      ; preds = %11
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:15                                      ; preds = %11
    %16 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %16, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %17 = icmp sgt i32 %12, 0
    br i1 %17, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:18                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %19 = bitcast i8** %scevgep to [8 x i8*]*
    %20 = icmp slt i32 %24, %12
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %15, %18
    %lsr.iv = phi [8 x i8*]* [ %19, %18 ], [ @krnames, %15 ]
    %i.02.i = phi i32 [ %24, %18 ], [ 0, %15 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %21 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %22 = tail call i32 @strcmp(i8* %.keyring.i, i8* %21) #6
    %23 = icmp eq i32 %22, 0
    %24 = add nuw nsw i32 %i.02.i, 1
    br i1 %23, label %setkrent.exit, label %18
  
  ._crit_edge.i:                                    ; preds = %18, %15
    %25 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %26 = load i32, i32* @nkr, align 4, !tbaa !7
    %27 = add nsw i32 %26, 1
    store i32 %27, i32* @nkr, align 4, !tbaa !7
    %28 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %26
    store i8* %25, i8** %28, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %29 = load i32, i32* @marg_min, align 4, !tbaa !7
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %31, label %33
  
  ; <label>:31                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %32 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:33                                      ; preds = %setkrent.exit
    %34 = load i32, i32* @compl_min, align 4, !tbaa !7
    %35 = icmp slt i32 %29, %34
    br i1 %35, label %36, label %37
  
  ; <label>:36                                      ; preds = %33
    store i32 %34, i32* @marg_min, align 4, !tbaa !7
    br label %37
  
  ; <label>:37                                      ; preds = %36, %33
    %38 = phi i32 [ %34, %36 ], [ %29, %33 ]
    store i32 %34, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %38, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %39 = mul nsw i32 %38, %34
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %37, %31
    %storemerge.i = phi i32 [ %39, %37 ], [ %32, %31 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %40 = sdiv i32 %storemerge.i, 2
    store i32 %40, i32* @marginal_min, align 4, !tbaa !7
    %41 = tail call i8* @xmalloc(i32 signext 1028) #6
    %42 = load i32, i32* @totalsize, align 4, !tbaa !10
    %43 = add nsw i32 %42, 1024
    store i32 %43, i32* @totalsize, align 4, !tbaa !10
    %44 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %45 = bitcast i8* %41 to i32*
    store i32 %44, i32* %45, align 4, !tbaa !12
    store i8* %41, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %46 = getelementptr inbounds i8, i8* %41, i32 4
    store i8* %46, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %46, i8 0, i32 1024, i32 4, i1 false) #6
    %47 = load i8, i8* @mverbose, align 4, !tbaa !6
    %48 = load i8, i8* @verbose, align 1
    %49 = or i8 %48, %47
    %50 = icmp eq i8 %49, 0
    br i1 %50, label %55, label %51
  
  ; <label>:51                                      ; preds = %setup_trust.exit
    %52 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %53 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %54 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %52, i8* %53)
    br label %55
  
  ; <label>:55                                      ; preds = %51, %setup_trust.exit
    %56 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %56) #6
    %57 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %57) #6
    %58 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %58) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %59 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %60 = icmp eq %struct._IO_FILE* %59, null
    br i1 %60, label %61, label %.preheader.i
  
  .preheader.i:                                     ; preds = %55
    br label %.outer.i
  
  ; <label>:61                                      ; preds = %55
    %62 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %63 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %64 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %62, i8* %63, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:65                                      ; preds = %.outer29.i, %82
    %66 = bitcast i64* %sigkeyID.i to i8*
    %67 = bitcast i64* %keyID.i to i8*
    %68 = bitcast [256 x i8]* %userid.i to i8*
    %69 = call i32 @readkpacket(%struct._IO_FILE* nonnull %59, i8* nonnull %ctb.i, i8* %68, i8* %67, i8* %66) #6
    %70 = icmp eq i32 %69, -1
    br i1 %70, label %493, label %71
  
  ; <label>:71                                      ; preds = %65
    %.off.i = add i32 %69, 3
    %72 = icmp ult i32 %.off.i, 2
    br i1 %72, label %73, label %75
  
  ; <label>:73                                      ; preds = %71
    %74 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  ; <label>:75                                      ; preds = %71
    %76 = icmp slt i32 %69, 0
    br i1 %76, label %.outer29.i, label %77
  
  ; <label>:77                                      ; preds = %75
    %78 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %79 = zext i8 %78 to i32
    %80 = and i32 %79, 124
    %81 = icmp eq i32 %80, 20
    br i1 %81, label %.outer29.i, label %82
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %80, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %83
    br i1 %or.cond28.i, label %84, label %65
  
  ; <label>:84                                      ; preds = %82
    %85 = icmp eq i32 %80, 56
    %86 = icmp eq i8 %78, -80
    %or.cond.i = or i1 %86, %85
    br i1 %or.cond.i, label %.outer29.i, label %87
  
  .outer29.i:                                       ; preds = %75, %77, %84, %93, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %93 ], [ true, %84 ], [ false, %77 ], [ false, %75 ]
    br label %65
  
  ; <label>:87                                      ; preds = %84
    %88 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %89 = icmp eq i32 %80, 8
    %or.cond4.i = and i1 %88, %89
    br i1 %or.cond4.i, label %90, label %94
  
  ; <label>:90                                      ; preds = %87
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %91 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %92 = icmp eq %struct.userid* %91, null
    br i1 %92, label %93, label %94
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:94                                      ; preds = %90, %87
    %95 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %95) #6
    %96 = call i32 @fread(i8* %95, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %59) #6
    %97 = icmp eq i32 %96, 3
    br i1 %97, label %98, label %.loopexit.i
  
  ; <label>:98                                      ; preds = %94
    %99 = bitcast [3 x i8]* %buf.i.i to i32*
    %100 = load i32, i32* %99, align 4
    %101 = lshr i32 %100, 24
    %102 = trunc i32 %101 to i8
    %103 = icmp eq i8 %102, -80
    %104 = lshr i32 %100, 8
    br i1 %103, label %110, label %105
  
  ; <label>:105                                     ; preds = %98
    %106 = trunc i32 %101 to i8
    %107 = icmp slt i8 %106, 0
    br i1 %107, label %108, label %.loopexit.i
  
  ; <label>:108                                     ; preds = %105
    %109 = call i32 @fseek(%struct._IO_FILE* nonnull %59, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:110                                     ; preds = %98
    %111 = and i32 %100, 16711680
    %112 = icmp eq i32 %111, 65536
    br i1 %112, label %115, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %94, %110, %108, %105
    %113 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %113) #6
    %114 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  ; <label>:115                                     ; preds = %110
    %116 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %116) #6
    %117 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %118 = zext i8 %117 to i32
    %119 = lshr i32 %118, 2
    %120 = and i32 %119, 31
    switch i32 %120, label %491 [
      i32 6, label %121
      i32 13, label %359
      i32 2, label %410
    ]
  
  ; <label>:121                                     ; preds = %115
    %122 = bitcast i64* %keyID.i to i8*
    %123 = load i8, i8* %122, align 8, !tbaa !6
    %124 = zext i8 %123 to i32
    %125 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %126 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %125, i32 %124
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %126, align 4, !tbaa !9
    %127 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %127, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %121, %132
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %132 ], [ %pk.02.i.i, %121 ]
    %128 = bitcast i64* %keyID.i to i8*
    %129 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %130 = call i32 @memcmp(i8* %129, i8* %128, i32 signext 8) #7
    %131 = icmp eq i32 %130, 0
    br i1 %131, label %getpubkey.exit.i, label %132
  
  ; <label>:132                                     ; preds = %.lr.ph.i.i
    %133 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %133, align 4, !tbaa !9
    %134 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %134, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %132, %121
    %135 = load i32, i32* @nleft, align 4, !tbaa !7
    %136 = icmp slt i32 %135, 28
    br i1 %136, label %137, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:137                                     ; preds = %._crit_edge.i.i
    %138 = call i8* @xmalloc(i32 signext 4004) #6
    %139 = load i32, i32* @totalsize, align 4, !tbaa !10
    %140 = add nsw i32 %139, 4000
    store i32 %140, i32* @totalsize, align 4, !tbaa !10
    %141 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %142 = bitcast i8* %138 to i32*
    store i32 %141, i32* %142, align 4, !tbaa !12
    store i8* %138, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %143 = getelementptr inbounds i8, i8* %138, i32 4
    store i8* %143, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %137, %._crit_edge.i8.i
    %144 = phi %struct.pubkey** [ %.pre61.i, %137 ], [ %125, %._crit_edge.i8.i ]
    %145 = phi i8* [ %143, %137 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %146 = phi i32 [ 4000, %137 ], [ %135, %._crit_edge.i8.i ]
    %147 = bitcast i64* %keyID.i to i8*
    %148 = add nsw i32 %146, -28
    store i32 %148, i32* @nleft, align 4, !tbaa !7
    %149 = getelementptr inbounds i8, i8* %145, i32 28
    store i8* %149, i8** @allocn.ptr, align 4, !tbaa !9
    %150 = bitcast i8* %145 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %145, i8 0, i32 28, i32 4, i1 false) #6
    %151 = getelementptr inbounds i8, i8* %145, i32 16
    %152 = bitcast i8* %151 to i64*
    %153 = load i64, i64* %keyID.i, align 8
    store i64 %153, i64* %152, align 1
    %154 = load i8, i8* %147, align 8, !tbaa !6
    %155 = zext i8 %154 to i32
    %156 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %144, i32 %155
    %157 = bitcast %struct.pubkey** %156 to i32*
    %158 = load i32, i32* %157, align 4, !tbaa !9
    %159 = getelementptr inbounds i8, i8* %145, i32 4
    %160 = bitcast i8* %159 to i32*
    store i32 %158, i32* %160, align 4, !tbaa !17
    %161 = load i8, i8* %147, align 8, !tbaa !6
    %162 = zext i8 %161 to i32
    %163 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %144, i32 %162
    %164 = bitcast %struct.pubkey** %163 to i8**
    store i8* %145, i8** %164, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %150, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %165 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %165, label %166, label %168
  
  ; <label>:166                                     ; preds = %getpubkey.exit.i
    %167 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %167, align 4, !tbaa !18
    br label %169
  
  ; <label>:168                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %169
  
  ; <label>:169                                     ; preds = %168, %166
    %170 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %171 = load %struct.pubkey*, %struct.pubkey** %170, align 4, !tbaa !18
    %172 = icmp eq %struct.pubkey* %171, null
    br i1 %172, label %180, label %173
  
  ; <label>:173                                     ; preds = %169
    %174 = bitcast i64* %keyID.i to i8*
    %175 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %176 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %177 = call i8* @keyIDstring(i8* %174) #6
    %178 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %175, i8* %176, i8* %177) #6
    %179 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  ; <label>:180                                     ; preds = %169
    %181 = trunc i32 %104 to i8
    %182 = icmp slt i8 %181, 0
    br i1 %182, label %ismember_newkeys.exit.i, label %183
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %104 to i8
    %185 = icmp eq %struct.newkey* %nkeys, null
    br i1 %185, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %183, %190
    %.02.i.i = phi %struct.newkey* [ %193, %190 ], [ %nkeys, %183 ]
    %186 = bitcast i64* %keyID.i to i8*
    %187 = bitcast %struct.newkey* %.02.i.i to i8*
    %188 = call i32 @memcmp(i8* %186, i8* %187, i32 signext 8) #7
    %189 = icmp eq i32 %188, 0
    br i1 %189, label %ismember_newkeys.exit.i, label %190
  
  ; <label>:190                                     ; preds = %.lr.ph.i9.i
    %191 = trunc i32 %104 to i8
    %192 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %193 = load %struct.newkey*, %struct.newkey** %192, align 4, !tbaa !1
    %194 = icmp eq %struct.newkey* %193, null
    br i1 %194, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %180
    %195 = bitcast [8 x i8]* %keyID.i.i to i8*
    %196 = bitcast [256 x i8]* %userid.i.i to i8*
    %197 = bitcast [128 x i16]* %esec.i.i to i8*
    %198 = bitcast [128 x i16]* %nsec.i.i to i8*
    %199 = bitcast [128 x i16]* %e.i.i to i8*
    %200 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 256, i8* %198) #6
    call void @llvm.lifetime.start(i64 256, i8* %197) #6
    call void @llvm.lifetime.start(i64 256, i8* %196) #6
    call void @llvm.lifetime.start(i64 8, i8* %195) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %201 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %202 = icmp eq %struct._IO_FILE* %201, null
    br i1 %202, label %check_secretkey.exit.i, label %203
  
  ; <label>:203                                     ; preds = %ismember_newkeys.exit.i
    %204 = bitcast [128 x i16]* %e.i.i to i16*
    %205 = bitcast [128 x i16]* %n.i.i to i16*
    %206 = call i32 @ftell(%struct._IO_FILE* nonnull %59) #6
    %207 = call i32 @fseek(%struct._IO_FILE* nonnull %59, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %208 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %59, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %205, i16* %204, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %209 = icmp slt i16 %208, 0
    br i1 %209, label %.thread.i.i, label %210
  
  ; <label>:210                                     ; preds = %203
    %211 = bitcast [128 x i16]* %n.i.i to i16*
    %212 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %212, i16* %211) #6
    br label %213
  
  ; <label>:213                                     ; preds = %233, %210
    %214 = bitcast [128 x i16]* %e.i.i.i to i16*
    %215 = bitcast [128 x i16]* %n.i.i.i to i16*
    %216 = bitcast [128 x i16]* %e.i.i.i to i8*
    %217 = bitcast [128 x i16]* %n.i.i.i to i8*
    %218 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %217) #6
    call void @llvm.lifetime.start(i64 256, i8* %216) #6
    %219 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %59, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %218, i16* %215, i16* %214, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %220 = icmp slt i16 %219, 0
    br i1 %220, label %readkpacket.exit.i.i, label %221
  
  ; <label>:221                                     ; preds = %213
    %222 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %223 = icmp eq i8 %222, -76
    br i1 %223, label %224, label %readkpacket.exit.thread.i.i
  
  ; <label>:224                                     ; preds = %221
    %225 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %225) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %224, %221
    %226 = bitcast [128 x i16]* %e.i.i.i to i8*
    %227 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %226) #6
    call void @llvm.lifetime.end(i64 256, i8* %227) #6
    br label %233
  
  readkpacket.exit.i.i:                             ; preds = %213
    %228 = bitcast [128 x i16]* %e.i.i.i to i8*
    %229 = bitcast [128 x i16]* %n.i.i.i to i8*
    %230 = sext i16 %219 to i32
    call void @llvm.lifetime.end(i64 256, i8* %228) #6
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    %231 = or i32 %230, 2
    %232 = icmp eq i32 %231, -1
    br i1 %232, label %.thread.i.i, label %233
  
  ; <label>:233                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %234 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %235 = icmp eq i8 %234, -76
    br i1 %235, label %236, label %213
  
  ; <label>:236                                     ; preds = %233
    %237 = bitcast [8 x i8]* %keyID.i.i to i8*
    %238 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %239 = call i32 @lookup_by_keyID(%struct._IO_FILE* %238, i8* %237) #6
    %240 = icmp slt i32 %239, 0
    br i1 %240, label %.thread.i.i, label %241
  
  ; <label>:241                                     ; preds = %236
    %242 = bitcast [128 x i16]* %esec.i.i to i16*
    %243 = bitcast [128 x i16]* %nsec.i.i to i16*
    %244 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %245 = call i32 @ftell(%struct._IO_FILE* %244) #6
    %246 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %247 = call signext i16 @readkeypacket(%struct._IO_FILE* %246, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %243, i16* %242, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %248 = icmp slt i16 %247, 0
    br i1 %248, label %249, label %253
  
  ; <label>:249                                     ; preds = %241
    %250 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %251 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %252 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %250, i8* %251) #6
    br label %.thread.i.i
  
  ; <label>:253                                     ; preds = %241
    %254 = bitcast [128 x i16]* %nsec.i.i to i16*
    %255 = bitcast [128 x i16]* %n.i.i to i16*
    %256 = call signext i16 @mp_compare(i16* %255, i16* %254) #6
    %257 = icmp eq i16 %256, 0
    br i1 %257, label %258, label %263
  
  ; <label>:258                                     ; preds = %253
    %259 = bitcast [128 x i16]* %esec.i.i to i16*
    %260 = bitcast [128 x i16]* %e.i.i to i16*
    %261 = call signext i16 @mp_compare(i16* %260, i16* %259) #6
    %262 = icmp eq i16 %261, 0
    br i1 %262, label %271, label %263
  
  ; <label>:263                                     ; preds = %258, %253
    %264 = bitcast [256 x i8]* %userid.i.i to i8*
    %265 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %266 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %267 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %265, i8* %266, i8* %264) #6
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269) #6
    br label %271
  
  ; <label>:271                                     ; preds = %263, %258
    %status.0.i.i = phi i32 [ -2, %263 ], [ 0, %258 ]
    %272 = trunc i32 %104 to i8
    %273 = icmp slt i8 %272, 0
    br i1 %273, label %287, label %274
  
  ; <label>:274                                     ; preds = %271
    %275 = load i8, i8* @batchmode, align 1, !tbaa !6
    %276 = icmp eq i8 %275, 0
    br i1 %276, label %277, label %.thread.i.i
  
  ; <label>:277                                     ; preds = %274
    %278 = bitcast [256 x i8]* %userid.i.i to i8*
    %279 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %280 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %281 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %279, i8* %280, i8* %278) #6
    %282 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %283 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %284 = call i32 @fputs(i8* %282, %struct._IO_FILE* %283) #6
    %285 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %285, 0
    %286 = sext i1 %not..i.i to i32
    br label %287
  
  ; <label>:287                                     ; preds = %277, %271
    %status.1.i.i = phi i32 [ %status.0.i.i, %271 ], [ %286, %277 ]
    %288 = icmp eq i32 %status.1.i.i, 0
    %289 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %290 = icmp ne %struct._IO_FILE* %289, null
    %or.cond3.i.i = and i1 %288, %290
    br i1 %or.cond3.i.i, label %291, label %.thread.i.i
  
  ; <label>:291                                     ; preds = %287
    %292 = bitcast [8 x i8]* %keyID.i.i to i8*
    %293 = call i32 @lookup_by_keyID(%struct._IO_FILE* %289, i8* %292) #6
    %294 = icmp slt i32 %293, 0
    br i1 %294, label %295, label %300
  
  ; <label>:295                                     ; preds = %291
    %296 = bitcast [256 x i8]* %userid.i.i to i8*
    %297 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %298 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %299 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %297, i8* %298, i8* %296, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:300                                     ; preds = %291
    %301 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %302 = call i32 @ftell(%struct._IO_FILE* %301) #6
    %303 = sub nsw i32 %302, %245
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @fseek(%struct._IO_FILE* %304, i32 signext %245, i32 signext 0) #6
    br label %306
  
  ; <label>:306                                     ; preds = %308, %300
    %pktlen.0.i.i = phi i32 [ %303, %300 ], [ %309, %308 ]
    %307 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %307, label %308, label %.critedge.i.i
  
  ; <label>:308                                     ; preds = %306
    %309 = add nsw i32 %pktlen.0.i.i, -1
    %310 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %311 = call i32 @_IO_getc(%struct._IO_FILE* %310) #6
    %312 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %313 = call i32 @_IO_getc(%struct._IO_FILE* %312) #6
    %314 = icmp eq i32 %311, %313
    br i1 %314, label %306, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %306
    %315 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %315, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %308, %.critedge.i.i
    %316 = bitcast [256 x i8]* %userid.i.i to i8*
    %317 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %318 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %319 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %317, i8* %318, i8* %316, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %295, %287, %274, %249, %236, %203
    %status.4.i.i = phi i32 [ -1, %203 ], [ 1, %236 ], [ -3, %249 ], [ 0, %295 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %287 ], [ -1, %274 ], [ %230, %readkpacket.exit.i.i ]
    %323 = call i32 @fseek(%struct._IO_FILE* nonnull %59, i32 signext %206, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %324 = bitcast [8 x i8]* %keyID.i.i to i8*
    %325 = bitcast [256 x i8]* %userid.i.i to i8*
    %326 = bitcast [128 x i16]* %esec.i.i to i8*
    %327 = bitcast [128 x i16]* %nsec.i.i to i8*
    %328 = bitcast [128 x i16]* %e.i.i to i8*
    %329 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %324) #6
    call void @llvm.lifetime.end(i64 256, i8* %325) #6
    call void @llvm.lifetime.end(i64 256, i8* %326) #6
    call void @llvm.lifetime.end(i64 256, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    %330 = icmp eq i32 %.0.i11.i, 0
    br i1 %330, label %331, label %343
  
  ; <label>:331                                     ; preds = %check_secretkey.exit.i
    %332 = add nsw i32 %buckstopcount.0.ph.i, 1
    %333 = or i32 %104, 135
    %334 = trunc i32 %333 to i8
    %335 = load i8, i8* @mverbose, align 4, !tbaa !6
    %336 = icmp eq i8 %335, 0
    br i1 %336, label %355, label %337
  
  ; <label>:337                                     ; preds = %331
    %338 = trunc i32 %333 to i8
    %339 = bitcast i64* %keyID.i to i8*
    %340 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %341 = call i8* @keyIDstring(i8* %339) #6
    %342 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %340, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %341) #6
    br label %355
  
  ; <label>:343                                     ; preds = %check_secretkey.exit.i
    %344 = and i32 %104, 127
    %345 = trunc i32 %344 to i8
    %346 = and i32 %104, 7
    %347 = icmp eq i32 %346, 7
    %..i = select i1 %347, i8 6, i8 %345
    %348 = load i8, i8* @mverbose, align 4, !tbaa !6
    %349 = icmp eq i8 %348, 0
    br i1 %349, label %355, label %350
  
  ; <label>:350                                     ; preds = %343
    %351 = bitcast i64* %keyID.i to i8*
    %352 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %353 = call i8* @keyIDstring(i8* %351) #6
    %354 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %352, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %353) #6
    br label %355
  
  ; <label>:355                                     ; preds = %350, %343, %337, %331
    %keyctrl.2.i = phi i8 [ %334, %331 ], [ %338, %337 ], [ %..i, %343 ], [ %..i, %350 ]
    %buckstop.1.i = phi i8 [ 1, %331 ], [ 1, %337 ], [ %buckstop.0.ph.i, %343 ], [ %buckstop.0.ph.i, %350 ]
    %buckstopcount.1.i = phi i32 [ %332, %331 ], [ %332, %337 ], [ %buckstopcount.0.ph.i, %343 ], [ %buckstopcount.0.ph.i, %350 ]
    %356 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %190, %355, %183
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %355 ], [ %184, %183 ], [ %191, %190 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %355 ], [ 0, %183 ], [ 0, %190 ]
    %show_user.1.i = phi i8 [ %356, %355 ], [ 0, %183 ], [ 0, %190 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %355 ], [ %buckstopcount.0.ph.i, %183 ], [ %buckstopcount.0.ph.i, %190 ]
    %357 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %357, align 4, !tbaa !16
    %358 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %358, align 4, !tbaa !14
    br label %491
  
  ; <label>:359                                     ; preds = %115
    %360 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %360, label %361, label %491
  
  ; <label>:361                                     ; preds = %359
    %362 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %362, label %373, label %363
  
  ; <label>:363                                     ; preds = %361
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %364 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %365 = icmp eq %struct.userid* %364, null
    br i1 %365, label %369, label %366
  
  ; <label>:366                                     ; preds = %363
    %367 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %368 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %367) #6
    br label %369
  
  ; <label>:369                                     ; preds = %366, %363
    %370 = bitcast [256 x i8]* %userid.i to i8*
    %371 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %372 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %371, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %370) #6
    br label %373
  
  ; <label>:373                                     ; preds = %369, %361
    %374 = load i32, i32* @nleft, align 4, !tbaa !7
    %375 = icmp slt i32 %374, 20
    br i1 %375, label %376, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %373
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:376                                     ; preds = %373
    %377 = call i8* @xmalloc(i32 signext 4004) #6
    %378 = load i32, i32* @totalsize, align 4, !tbaa !10
    %379 = add nsw i32 %378, 4000
    store i32 %379, i32* @totalsize, align 4, !tbaa !10
    %380 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %381 = bitcast i8* %377 to i32*
    store i32 %380, i32* %381, align 4, !tbaa !12
    store i8* %377, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %382 = getelementptr inbounds i8, i8* %377, i32 4
    store i8* %382, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %376, %._crit_edge.i13.i
    %383 = phi i8* [ %382, %376 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %384 = phi i32 [ 4000, %376 ], [ %374, %._crit_edge.i13.i ]
    %385 = icmp eq %struct.userid* %id.0.ph.i, null
    %386 = add nsw i32 %384, -20
    store i32 %386, i32* @nleft, align 4, !tbaa !7
    %387 = getelementptr inbounds i8, i8* %383, i32 20
    store i8* %387, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %385, label %390, label %388
  
  ; <label>:388                                     ; preds = %allocn.exit14.i
    %389 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %383, i8** %389, align 4, !tbaa !19
    br label %391
  
  ; <label>:390                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %383, i8** %sunkaddr12, align 4, !tbaa !14
    br label %391
  
  ; <label>:391                                     ; preds = %390, %388
    %392 = load i8, i8* @mverbose, align 4, !tbaa !6
    %393 = icmp eq i8 %392, 0
    br i1 %393, label %399, label %394
  
  ; <label>:394                                     ; preds = %391
    %395 = bitcast [256 x i8]* %userid.i to i8*
    %396 = call fastcc i8* @store_str(i8* %395) #6
    %397 = getelementptr inbounds i8, i8* %383, i32 12
    %398 = bitcast i8* %397 to i8**
    store i8* %396, i8** %398, align 4, !tbaa !21
    br label %399
  
  ; <label>:399                                     ; preds = %394, %391
    %400 = bitcast i8* %383 to %struct.userid*
    %401 = and i32 %104, 252
    %402 = icmp eq i8 %buckstop.0.ph.i, 0
    %403 = or i32 %104, 3
    %storemerge.in.i = select i1 %402, i32 %401, i32 %403
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %404 = bitcast i8* %383 to %struct.userid**
    store %struct.userid* null, %struct.userid** %404, align 4, !tbaa !19
    %405 = getelementptr inbounds i8, i8* %383, i32 4
    %406 = bitcast i8* %405 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %406, align 4, !tbaa !22
    %407 = getelementptr inbounds i8, i8* %383, i32 16
    store i8 %storemerge.i4, i8* %407, align 4, !tbaa !23
    %408 = getelementptr inbounds i8, i8* %383, i32 8
    %409 = bitcast i8* %408 to %struct.signature**
    store %struct.signature* null, %struct.signature** %409, align 4, !tbaa !24
    br label %491
  
  ; <label>:410                                     ; preds = %115
    %411 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %412 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %411, %412
    br i1 %or.cond3.i, label %413, label %491
  
  ; <label>:413                                     ; preds = %410
    %414 = load i32, i32* @nleft, align 4, !tbaa !7
    %415 = icmp slt i32 %414, 20
    br i1 %415, label %416, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %413
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:416                                     ; preds = %413
    %417 = call i8* @xmalloc(i32 signext 4004) #6
    %418 = load i32, i32* @totalsize, align 4, !tbaa !10
    %419 = add nsw i32 %418, 4000
    store i32 %419, i32* @totalsize, align 4, !tbaa !10
    %420 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %421 = bitcast i8* %417 to i32*
    store i32 %420, i32* %421, align 4, !tbaa !12
    store i8* %417, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %422 = getelementptr inbounds i8, i8* %417, i32 4
    store i8* %422, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %416, %._crit_edge.i16.i
    %423 = phi i8* [ %422, %416 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %424 = phi i32 [ 4000, %416 ], [ %414, %._crit_edge.i16.i ]
    %425 = icmp eq %struct.signature* %sig.0.ph.i, null
    %426 = add nsw i32 %424, -20
    store i32 %426, i32* @nleft, align 4, !tbaa !7
    %427 = getelementptr inbounds i8, i8* %423, i32 20
    store i8* %427, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %425, label %430, label %428
  
  ; <label>:428                                     ; preds = %allocn.exit17.i
    %429 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %423, i8** %429, align 4, !tbaa !25
    br label %433
  
  ; <label>:430                                     ; preds = %allocn.exit17.i
    %431 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %432 = bitcast %struct.signature** %431 to i8**
    store i8* %423, i8** %432, align 4, !tbaa !24
    br label %433
  
  ; <label>:433                                     ; preds = %430, %428
    %434 = bitcast i64* %sigkeyID.i to i8*
    %435 = bitcast i8* %423 to %struct.signature**
    store %struct.signature* null, %struct.signature** %435, align 4, !tbaa !25
    %436 = getelementptr inbounds i8, i8* %423, i32 4
    %437 = bitcast i8* %436 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %437, align 4, !tbaa !27
    %438 = load i8, i8* %434, align 8, !tbaa !6
    %439 = zext i8 %438 to i32
    %440 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %441 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %440, i32 %439
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %441, align 4, !tbaa !9
    %442 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %442, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %433, %447
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %447 ], [ %pk.02.i18.i, %433 ]
    %443 = bitcast i64* %sigkeyID.i to i8*
    %444 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %445 = call i32 @memcmp(i8* %444, i8* %443, i32 signext 8) #7
    %446 = icmp eq i32 %445, 0
    br i1 %446, label %getpubkey.exit24.i, label %447
  
  ; <label>:447                                     ; preds = %.lr.ph.i20.i
    %448 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %448, align 4, !tbaa !9
    %449 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %449, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %447, %433
    %450 = icmp slt i32 %426, 28
    br i1 %450, label %451, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:451                                     ; preds = %._crit_edge.i22.i
    %452 = call i8* @xmalloc(i32 signext 4004) #6
    %453 = load i32, i32* @totalsize, align 4, !tbaa !10
    %454 = add nsw i32 %453, 4000
    store i32 %454, i32* @totalsize, align 4, !tbaa !10
    %455 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %456 = bitcast i8* %452 to i32*
    store i32 %455, i32* %456, align 4, !tbaa !12
    store i8* %452, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %457 = getelementptr inbounds i8, i8* %452, i32 4
    store i8* %457, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %451, %._crit_edge.i26.i
    %458 = phi %struct.pubkey** [ %.pre.i, %451 ], [ %440, %._crit_edge.i26.i ]
    %459 = phi i8* [ %457, %451 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %460 = phi i32 [ 4000, %451 ], [ %426, %._crit_edge.i26.i ]
    %461 = bitcast i64* %sigkeyID.i to i8*
    %462 = add nsw i32 %460, -28
    store i32 %462, i32* @nleft, align 4, !tbaa !7
    %463 = getelementptr inbounds i8, i8* %459, i32 28
    store i8* %463, i8** @allocn.ptr, align 4, !tbaa !9
    %464 = bitcast i8* %459 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %459, i8 0, i32 28, i32 4, i1 false) #6
    %465 = getelementptr inbounds i8, i8* %459, i32 16
    %466 = bitcast i8* %465 to i64*
    %467 = load i64, i64* %sigkeyID.i, align 8
    store i64 %467, i64* %466, align 1
    %468 = load i8, i8* %461, align 8, !tbaa !6
    %469 = zext i8 %468 to i32
    %470 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %458, i32 %469
    %471 = bitcast %struct.pubkey** %470 to i32*
    %472 = load i32, i32* %471, align 4, !tbaa !9
    %473 = getelementptr inbounds i8, i8* %459, i32 4
    %474 = bitcast i8* %473 to i32*
    store i32 %472, i32* %474, align 4, !tbaa !17
    %475 = load i8, i8* %461, align 8, !tbaa !6
    %476 = zext i8 %475 to i32
    %477 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %458, i32 %476
    %478 = bitcast %struct.pubkey** %477 to i8**
    store i8* %459, i8** %478, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %464, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %479 = bitcast i8* %423 to %struct.signature*
    %480 = getelementptr inbounds i8, i8* %423, i32 8
    %481 = bitcast i8* %480 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %481, align 4, !tbaa !28
    %482 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %483 = bitcast %struct.signature** %482 to i32*
    %484 = load i32, i32* %483, align 4, !tbaa !29
    %485 = getelementptr inbounds i8, i8* %423, i32 12
    %486 = bitcast i8* %485 to i32*
    store i32 %484, i32* %486, align 4, !tbaa !30
    %487 = bitcast %struct.signature** %482 to i8**
    store i8* %423, i8** %487, align 4, !tbaa !29
    %488 = and i32 %104, 64
    %489 = trunc i32 %488 to i8
    %490 = getelementptr inbounds i8, i8* %423, i32 16
    store i8 %489, i8* %490, align 4, !tbaa !31
    br label %491
  
  ; <label>:491                                     ; preds = %getpubkey.exit24.i, %410, %399, %359, %ismember_newkeys.exit.thread.i, %115
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %115 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %410 ], [ %buckstop.0.ph.i, %399 ], [ %buckstop.0.ph.i, %359 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %115 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %410 ], [ %show_user.0.ph.i, %399 ], [ %show_user.0.ph.i, %359 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %115 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %410 ], [ %buckstopcount.0.ph.i, %399 ], [ %buckstopcount.0.ph.i, %359 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %115 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %410 ], [ %pk.0.ph.i, %399 ], [ null, %359 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %115 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %410 ], [ %400, %399 ], [ %id.0.ph.i, %359 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %115 ], [ %479, %getpubkey.exit24.i ], [ %sig.0.ph.i, %410 ], [ null, %399 ], [ %sig.0.ph.i, %359 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %492 = call i32 @ftell(%struct._IO_FILE* nonnull %59) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %491, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %491 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %491 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %491 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %492, %491 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %491 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %491 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %491 ]
    br label %.outer29.i
  
  ; <label>:493                                     ; preds = %65
    %494 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %495 = load i8, i8* @mverbose, align 4
    %496 = icmp eq i8 %495, 0
    %or.cond6.i = or i1 %494, %496
    br i1 %or.cond6.i, label %501, label %497
  
  ; <label>:497                                     ; preds = %493
    %498 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %499 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %500 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %498, i8* %499) #6
    br label %501
  
  ; <label>:501                                     ; preds = %497, %493
    %502 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %501, %173, %.loopexit.i, %73, %61
    %.0.i = phi i32 [ -1, %61 ], [ %69, %73 ], [ -7, %.loopexit.i ], [ -1, %173 ], [ 0, %501 ]
    %503 = bitcast i64* %sigkeyID.i to i8*
    %504 = bitcast i64* %keyID.i to i8*
    %505 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %503) #6
    call void @llvm.lifetime.end(i64 8, i8* %504) #6
    call void @llvm.lifetime.end(i64 256, i8* %505) #6
    %506 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %507 = icmp eq %struct._IO_FILE* %506, null
    br i1 %507, label %510, label %508
  
  ; <label>:508                                     ; preds = %maint_read_data.exit
    %509 = call i32 @fclose(%struct._IO_FILE* nonnull %506)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %510
  
  ; <label>:510                                     ; preds = %508, %maint_read_data.exit
    %511 = icmp slt i32 %.0.i, 0
    br i1 %511, label %756, label %512
  
  ; <label>:512                                     ; preds = %510
    %513 = load i8, i8* @mverbose, align 4, !tbaa !6
    %514 = load i8, i8* @verbose, align 1
    %515 = or i8 %514, %513
    %516 = icmp eq i8 %515, 0
    br i1 %516, label %521, label %517
  
  ; <label>:517                                     ; preds = %512
    %518 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %519 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %520 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %518, i8* %519)
    br label %521
  
  ; <label>:521                                     ; preds = %517, %512
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %522 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %522, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %521, %550
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %550 ], [ %pk.01.i, %521 ]
    %523 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %524 = load i8, i8* %523, align 4, !tbaa !16
    %525 = icmp slt i8 %524, 0
    br i1 %525, label %526, label %550
  
  ; <label>:526                                     ; preds = %.lr.ph.i5
    %527 = load i8, i8* @mverbose, align 4, !tbaa !6
    %528 = icmp eq i8 %527, 0
    br i1 %528, label %536, label %529
  
  ; <label>:529                                     ; preds = %526
    %530 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %531 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %532 = load %struct.userid*, %struct.userid** %531, align 4, !tbaa !14
    %533 = getelementptr inbounds %struct.userid, %struct.userid* %532, i32 0, i32 3
    %534 = load i8*, i8** %533, align 4, !tbaa !21
    %535 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %530, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %534) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %536
  
  ; <label>:536                                     ; preds = %529, %526
    %537 = phi i8 [ %524, %526 ], [ %.pre.i6, %529 ]
    %538 = and i8 %537, 7
    %539 = icmp eq i8 %538, 0
    br i1 %539, label %540, label %549
  
  ; <label>:540                                     ; preds = %536
    %541 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %542 = call i8* @user_from_keyID(i8* %541) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %543 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %544 = zext i8 %543 to i32
    %545 = and i32 %544, 248
    %546 = call i32 @ask_owntrust(i8* %542, i8 zeroext %543) #6
    %547 = or i32 %545, %546
    %548 = trunc i32 %547 to i8
    store i8 %548, i8* %sunkaddr18, align 4, !tbaa !6
    br label %549
  
  ; <label>:549                                     ; preds = %540, %536
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %550
  
  ; <label>:550                                     ; preds = %549, %.lr.ph.i5
    %551 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %551, align 4, !tbaa !9
    %552 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %552, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %550, %521
    %553 = load i8, i8* @verbose, align 1, !tbaa !6
    %554 = icmp eq i8 %553, 0
    br i1 %554, label %559, label %555
  
  ; <label>:555                                     ; preds = %maint_trace_chain.exit
    %556 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %557 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %558 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %556, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %557)
    br label %559
  
  ; <label>:559                                     ; preds = %555, %maint_trace_chain.exit
    %560 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %560) #6
    %561 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %561) #6
    %562 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %562) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i12) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %563, label %565
  
  ; <label>:563                                     ; preds = %559
    %564 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %567
  
  ; <label>:565                                     ; preds = %559
    %566 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %567
  
  ; <label>:567                                     ; preds = %565, %563
    %f.0.i = phi %struct._IO_FILE* [ %564, %563 ], [ %566, %565 ]
    %568 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %568, label %569, label %573
  
  ; <label>:569                                     ; preds = %567
    %570 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %571 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %572 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %570, i8* %571, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:573                                     ; preds = %567
    %574 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %707, %573
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %573 ], [ %kc_orig.2.i, %707 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %573 ], [ %trust_pos.1.i, %707 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %573 ], [ %kc_new.1.i, %707 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %573 ], [ %708, %707 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %574, %573 ], [ %pk.1.i, %707 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %573 ], [ %id.1.i, %707 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %573 ], [ %sig.1.i, %707 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %697, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %697 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %697 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %697 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %697 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %697 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %697 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %614, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %594, %614 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %580, %582, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %582 ], [ false, %580 ]
    br label %575
  
  ; <label>:575                                     ; preds = %587, %.outer20.i
    %576 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    %577 = bitcast [8 x i8]* %keyID.i.i to i8*
    %578 = bitcast [256 x i8]* %userid.i.i to i8*
    %579 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %ctb.i12, i8* %578, i8* %577, i8* %576) #6
    %switch.i = icmp ugt i32 %579, -4
    br i1 %switch.i, label %709, label %580
  
  ; <label>:580                                     ; preds = %575
    %581 = icmp slt i32 %579, 0
    br i1 %581, label %.outer20.i, label %582
  
  ; <label>:582                                     ; preds = %580
    %583 = load i8, i8* %ctb.i12, align 4, !tbaa !6
    %584 = zext i8 %583 to i32
    %585 = and i32 %584, 124
    %586 = icmp eq i32 %585, 20
    br i1 %586, label %.outer20.i, label %587
  
  ; <label>:587                                     ; preds = %582
    %588 = icmp eq i32 %585, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %588
    br i1 %or.cond.i18, label %589, label %575
  
  ; <label>:589                                     ; preds = %587
    switch i32 %585, label %590 [
      i32 24, label %592
      i32 8, label %592
    ]
  
  ; <label>:590                                     ; preds = %589
    %591 = icmp eq i8 %583, -76
    br i1 %591, label %592, label %.loopexit.i20
  
  ; <label>:592                                     ; preds = %590, %589, %589
    %593 = bitcast [3 x i8]* %buf.i.i to i8*
    %594 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %593) #6
    %595 = call i32 @fread(i8* %593, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %596 = icmp eq i32 %595, 3
    br i1 %596, label %597, label %614
  
  ; <label>:597                                     ; preds = %592
    %598 = bitcast [3 x i8]* %buf.i.i to i32*
    %599 = load i32, i32* %598, align 4
    %600 = lshr i32 %599, 24
    %601 = trunc i32 %600 to i8
    %602 = icmp eq i8 %601, -80
    br i1 %602, label %608, label %603
  
  ; <label>:603                                     ; preds = %597
    %604 = trunc i32 %600 to i8
    %605 = icmp slt i8 %604, 0
    br i1 %605, label %606, label %614
  
  ; <label>:606                                     ; preds = %603
    %607 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %614
  
  ; <label>:608                                     ; preds = %597
    %609 = and i32 %599, 16711680
    %610 = icmp eq i32 %609, 65536
    br i1 %610, label %read_trust.exit.i, label %614
  
  read_trust.exit.i:                                ; preds = %608
    %611 = bitcast [3 x i8]* %buf.i.i to i8*
    %612 = lshr i32 %599, 8
    %613 = trunc i32 %612 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %611) #6
    %.pre.i19 = load i8, i8* %ctb.i12, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:614                                     ; preds = %608, %606, %603, %592
    %615 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %615) #6
    %616 = load i8, i8* %ctb.i12, align 4, !tbaa !6
    %617 = and i8 %616, 124
    %618 = icmp eq i8 %617, 8
    br i1 %618, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %614
    %619 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %590, %read_trust.exit.i
    %620 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %583, %590 ]
    %kc_orig.2.i = phi i8 [ %613, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %590 ]
    %trust_pos.1.i = phi i32 [ %594, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %590 ]
    %621 = zext i8 %620 to i32
    %622 = lshr i32 %621, 2
    %623 = and i32 %622, 31
    switch i32 %623, label %697 [
      i32 6, label %624
      i32 13, label %643
      i32 2, label %681
    ]
  
  ; <label>:624                                     ; preds = %.loopexit.i20
    %625 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %625, label %631, label %626
  
  ; <label>:626                                     ; preds = %624
    %627 = bitcast [8 x i8]* %keyID.i.i to i8*
    %628 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %629 = call i32 @memcmp(i8* %628, i8* %627, i32 signext 8) #7
    %630 = icmp eq i32 %629, 0
    br i1 %630, label %632, label %631
  
  ; <label>:631                                     ; preds = %626, %624
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:632                                     ; preds = %626
    %633 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %634 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %634, %633
    br i1 %or.cond3.i21, label %635, label %636
  
  ; <label>:635                                     ; preds = %632
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:636                                     ; preds = %632
    %637 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %638 = load %struct.userid*, %struct.userid** %637, align 4, !tbaa !14
    %639 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %640 = load i8, i8* %639, align 4, !tbaa !16
    %641 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %642 = load %struct.pubkey*, %struct.pubkey** %641, align 4, !tbaa !18
    br label %697
  
  ; <label>:643                                     ; preds = %.loopexit.i20
    %644 = icmp eq %struct.userid* %id.0.ph.i14, null
    %645 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %644, %645
    br i1 %or.cond5.i, label %646, label %647
  
  ; <label>:646                                     ; preds = %643
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:647                                     ; preds = %643
    %648 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %649 = load %struct.signature*, %struct.signature** %648, align 4, !tbaa !24
    %650 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %651 = load %struct.pubkey*, %struct.pubkey** %650, align 4, !tbaa !22
    %652 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %651, i32 0, i32 5
    %653 = load i8, i8* %652, align 4, !tbaa !16
    %654 = icmp slt i8 %653, 0
    br i1 %654, label %compute_legit.exit.i, label %655
  
  ; <label>:655                                     ; preds = %647
    %656 = icmp eq %struct.signature* %649, null
    br i1 %656, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %655, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %649, %655 ]
    %trust_count.02.i.i = phi i32 [ %663, %.lr.ph.i.i22 ], [ 0, %655 ]
    %657 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %658 = load i8, i8* %657, align 4, !tbaa !31
    %659 = zext i8 %658 to i32
    %660 = and i32 %659, 7
    %661 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %660
    %662 = load i32, i32* %661, align 4, !tbaa !7
    %663 = add nsw i32 %662, %trust_count.02.i.i
    %664 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %664, align 4, !tbaa !9
    %665 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %665, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %666 = icmp eq i32 %663, 0
    br i1 %666, label %compute_legit.exit.i, label %667
  
  ; <label>:667                                     ; preds = %._crit_edge.i.i23
    %668 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %669 = icmp slt i32 %663, %668
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %667
    %671 = load i32, i32* @complete_min, align 4, !tbaa !7
    %672 = icmp slt i32 %663, %671
    %..i.i = select i1 %672, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %670, %667, %._crit_edge.i.i23, %655, %647
    %legit.0.i.i = phi i32 [ 3, %647 ], [ 0, %._crit_edge.i.i23 ], [ 1, %667 ], [ %..i.i, %670 ], [ 0, %655 ]
    %673 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %674 = load i8, i8* %673, align 4, !tbaa !23
    %675 = zext i8 %674 to i32
    %676 = and i32 %675, 252
    %677 = or i32 %676, %legit.0.i.i
    %678 = trunc i32 %677 to i8
    store i8 %678, i8* %673, align 4, !tbaa !23
    %679 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %680 = load %struct.userid*, %struct.userid** %679, align 4, !tbaa !19
    br label %697
  
  ; <label>:681                                     ; preds = %.loopexit.i20
    %682 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %682, label %683, label %684
  
  ; <label>:683                                     ; preds = %681
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:684                                     ; preds = %681
    %685 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    %686 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %687 = load %struct.pubkey*, %struct.pubkey** %686, align 4, !tbaa !28
    %688 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %687, i32 0, i32 4, i32 0
    %689 = call i32 @memcmp(i8* %688, i8* %685, i32 signext 8) #7
    %690 = icmp eq i32 %689, 0
    br i1 %690, label %692, label %691
  
  ; <label>:691                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:692                                     ; preds = %684
    %693 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %694 = load i8, i8* %693, align 4, !tbaa !31
    %695 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %696 = load %struct.signature*, %struct.signature** %695, align 4, !tbaa !25
    br label %697
  
  ; <label>:697                                     ; preds = %692, %compute_legit.exit.i, %636, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %694, %692 ], [ %678, %compute_legit.exit.i ], [ %640, %636 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %692 ], [ 3, %compute_legit.exit.i ], [ 135, %636 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %692 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %642, %636 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %692 ], [ %680, %compute_legit.exit.i ], [ %638, %636 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %696, %692 ], [ %649, %compute_legit.exit.i ], [ null, %636 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %698 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %699 = zext i8 %698 to i32
    %700 = and i32 %699, %mask.0.i
    %701 = icmp eq i32 %700, 0
    br i1 %701, label %.outer.i16, label %702
  
  ; <label>:702                                     ; preds = %697
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %707, label %703
  
  ; <label>:703                                     ; preds = %702
    %704 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %705 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %706 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %704, i32 signext 0) #6
    br label %707
  
  ; <label>:707                                     ; preds = %703, %702
    %708 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:709                                     ; preds = %575
    %710 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %711 = icmp slt i32 %579, -1
    br i1 %711, label %maint_final.exit, label %712
  
  ; <label>:712                                     ; preds = %709
    %713 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %714 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %713, %714
    %715 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %715, %or.cond7.i
    br i1 %or.cond9.i, label %716, label %maint_final.exit
  
  ; <label>:716                                     ; preds = %712
    %717 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %718 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %717) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %716, %712, %709, %.thread.i, %569
    %.0.i24 = phi i32 [ -1, %569 ], [ -1, %716 ], [ %579, %709 ], [ %changed.0.ph.ph.i, %712 ], [ -7, %.thread.i ]
    %719 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    %720 = bitcast [8 x i8]* %keyID.i.i to i8*
    %721 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i12) #6
    call void @llvm.lifetime.end(i64 8, i8* %719) #6
    call void @llvm.lifetime.end(i64 8, i8* %720) #6
    call void @llvm.lifetime.end(i64 256, i8* %721) #6
    %722 = icmp slt i32 %.0.i24, 0
    br i1 %722, label %756, label %723
  
  ; <label>:723                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %724 = load i8, i8* @verbose, align 1, !tbaa !6
    %725 = icmp eq i8 %724, 0
    br i1 %725, label %731, label %726
  
  ; <label>:726                                     ; preds = %723
    %727 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %728 = load i32, i32* @totalsize, align 4, !tbaa !10
    %729 = sdiv i32 %728, 1024
    %730 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %727, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %729) #6
    br label %731
  
  ; <label>:731                                     ; preds = %726, %723
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %732 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %733 = icmp eq %struct.bufpool* %732, null
    br i1 %733, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %731, %.lr.ph.i.i25
    %734 = phi %struct.bufpool* [ %738, %.lr.ph.i.i25 ], [ %732, %731 ]
    %735 = bitcast %struct.bufpool* %734 to i32*
    %736 = load i32, i32* %735, align 4, !tbaa !12
    store i32 %736, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %737 = bitcast %struct.bufpool* %734 to i8*
    call void @free(i8* %737) #6
    %738 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %739 = icmp eq %struct.bufpool* %738, null
    br i1 %739, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %731
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %740 = load i8, i8* @verbose, align 1, !tbaa !6
    %741 = icmp eq i8 %740, 0
    br i1 %741, label %.thread164, label %742
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:742                                     ; preds = %endkrent.exit
    %743 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %744 = load i32, i32* @totalsize, align 4, !tbaa !10
    %745 = sdiv i32 %744, 1024
    %746 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %743, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %745) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %747 = icmp eq %struct.bufpool* %.pre, null
    br i1 %747, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %742, %.lr.ph.i.i26
    %748 = phi %struct.bufpool* [ %752, %.lr.ph.i.i26 ], [ %.pre, %742 ]
    %749 = bitcast %struct.bufpool* %748 to i32*
    %750 = load i32, i32* %749, align 4, !tbaa !12
    store i32 %750, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %751 = bitcast %struct.bufpool* %748 to i8*
    call void @free(i8* %751) #6
    %752 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %753 = icmp eq %struct.bufpool* %752, null
    br i1 %753, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %742, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %754 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %755 = add nsw i32 %754, %.0.i24
    br label %791
  
  ; <label>:756                                     ; preds = %maint_final.exit, %510
    %status.0 = phi i32 [ %.0.i, %510 ], [ %.0.i24, %maint_final.exit ]
    %757 = load i8, i8* @verbose, align 1, !tbaa !6
    %758 = icmp eq i8 %757, 0
    br i1 %758, label %.thread, label %759
  
  .thread:                                          ; preds = %756
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %768
  
  ; <label>:759                                     ; preds = %756
    %760 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %761 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %760, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %762 = icmp eq i8 %.pr, 0
    br i1 %762, label %768, label %763
  
  ; <label>:763                                     ; preds = %759
    %764 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %765 = load i32, i32* @totalsize, align 4, !tbaa !10
    %766 = sdiv i32 %765, 1024
    %767 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %764, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %766) #6
    br label %768
  
  ; <label>:768                                     ; preds = %763, %759, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %769 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %770 = icmp eq %struct.bufpool* %769, null
    br i1 %770, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %768, %.lr.ph.i.i27
    %771 = phi %struct.bufpool* [ %775, %.lr.ph.i.i27 ], [ %769, %768 ]
    %772 = bitcast %struct.bufpool* %771 to i32*
    %773 = load i32, i32* %772, align 4, !tbaa !12
    store i32 %773, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %774 = bitcast %struct.bufpool* %771 to i8*
    call void @free(i8* %774) #6
    %775 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %776 = icmp eq %struct.bufpool* %775, null
    br i1 %776, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %768
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %777 = load i8, i8* @verbose, align 1, !tbaa !6
    %778 = icmp eq i8 %777, 0
    br i1 %778, label %.thread165, label %779
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:779                                     ; preds = %endkrent.exit28
    %780 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %781 = load i32, i32* @totalsize, align 4, !tbaa !10
    %782 = sdiv i32 %781, 1024
    %783 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %780, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %782) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %784 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %784, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %779, %.lr.ph.i.i29
    %785 = phi %struct.bufpool* [ %789, %.lr.ph.i.i29 ], [ %.pre163, %779 ]
    %786 = bitcast %struct.bufpool* %785 to i32*
    %787 = load i32, i32* %786, align 4, !tbaa !12
    store i32 %787, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %788 = bitcast %struct.bufpool* %785 to i8*
    call void @free(i8* %788) #6
    %789 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %790 = icmp eq %struct.bufpool* %789, null
    br i1 %790, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %779, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %791
  
  ; <label>:791                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %755, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            ismember_newkeys
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%3' }
  - { reg: '%a1', virtual-reg: '%4' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 12):
    successors: %bb.3.._crit_edge(37), %bb.4(62)
    liveins: %a0, %a1, %t9, %v0
  
    %6 = ADDu %v0, %t9
    %4 = COPY %a1
    %3 = COPY %a0
    %5 = ADDiu %zero, 0
    BEQ %4, %zero, %bb.3.._crit_edge, implicit-def %at
  
  bb.4 (freq 8):
    successors: %bb.1..lr.ph(100)
  
    %9 = ADDiu %zero, 8
  
  bb.1..lr.ph (freq 130):
    successors: %bb.3.._crit_edge(3), %bb.2(96)
  
    %0 = PHI %4, %bb.4, %1, %bb.2
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %8 = LW %6, target-flags(<unknown>) @memcmp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @memcmp)
    %a0 = COPY %3
    %a1 = COPY %0
    %a2 = COPY %9
    %gp = COPY %6
    %t9 = COPY %8
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %10 = COPY %v0
    %7 = ADDiu %zero, 1
    BEQ %10, %zero, %bb.3.._crit_edge, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.5, freq 125):
    successors: %bb.3.._crit_edge(3), %bb.1..lr.ph(96)
  
    %1 = LW %0, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.6, !tbaa !1)
    BNE %1, %zero, %bb.1..lr.ph, implicit-def dead %at
    B %bb.3.._crit_edge, implicit-def dead %at
  
  bb.3.._crit_edge (freq 12):
    liveouts: %v0
  
    %2 = PHI %5, %bb.0, %7, %bb.1..lr.ph, %5, %bb.2
    %v0 = COPY %2
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %e.i.i.i = alloca [128 x i16], align 2
    %n.i.i = alloca [128 x i16], align 2
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %1 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %2 = icmp sgt i32 %1, 8
    br i1 %2, label %3, label %4
  
  ; <label>:3                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %4
  
  ; <label>:4                                       ; preds = %3, %0
    %5 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %5, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %6 = icmp eq %struct._IO_FILE* %5, null
    br i1 %6, label %7, label %11
  
  ; <label>:7                                       ; preds = %4
    %8 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %9 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %10 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %8, i8* %9, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %11
  
  ; <label>:11                                      ; preds = %7, %4
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp slt i32 %12, 8
    br i1 %13, label %15, label %14
  
  ; <label>:14                                      ; preds = %11
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:15                                      ; preds = %11
    %16 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %16, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %17 = icmp sgt i32 %12, 0
    br i1 %17, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:18                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %19 = bitcast i8** %scevgep to [8 x i8*]*
    %20 = icmp slt i32 %24, %12
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %15, %18
    %lsr.iv = phi [8 x i8*]* [ %19, %18 ], [ @krnames, %15 ]
    %i.02.i = phi i32 [ %24, %18 ], [ 0, %15 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %21 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %22 = tail call i32 @strcmp(i8* %.keyring.i, i8* %21) #6
    %23 = icmp eq i32 %22, 0
    %24 = add nuw nsw i32 %i.02.i, 1
    br i1 %23, label %setkrent.exit, label %18
  
  ._crit_edge.i:                                    ; preds = %18, %15
    %25 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %26 = load i32, i32* @nkr, align 4, !tbaa !7
    %27 = add nsw i32 %26, 1
    store i32 %27, i32* @nkr, align 4, !tbaa !7
    %28 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %26
    store i8* %25, i8** %28, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %29 = load i32, i32* @marg_min, align 4, !tbaa !7
    %30 = icmp eq i32 %29, 0
    br i1 %30, label %31, label %33
  
  ; <label>:31                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %32 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:33                                      ; preds = %setkrent.exit
    %34 = load i32, i32* @compl_min, align 4, !tbaa !7
    %35 = icmp slt i32 %29, %34
    br i1 %35, label %36, label %37
  
  ; <label>:36                                      ; preds = %33
    store i32 %34, i32* @marg_min, align 4, !tbaa !7
    br label %37
  
  ; <label>:37                                      ; preds = %36, %33
    %38 = phi i32 [ %34, %36 ], [ %29, %33 ]
    store i32 %34, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %38, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %39 = mul nsw i32 %38, %34
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %37, %31
    %storemerge.i = phi i32 [ %39, %37 ], [ %32, %31 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %40 = sdiv i32 %storemerge.i, 2
    store i32 %40, i32* @marginal_min, align 4, !tbaa !7
    %41 = tail call i8* @xmalloc(i32 signext 1028) #6
    %42 = load i32, i32* @totalsize, align 4, !tbaa !10
    %43 = add nsw i32 %42, 1024
    store i32 %43, i32* @totalsize, align 4, !tbaa !10
    %44 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %45 = bitcast i8* %41 to i32*
    store i32 %44, i32* %45, align 4, !tbaa !12
    store i8* %41, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %46 = getelementptr inbounds i8, i8* %41, i32 4
    store i8* %46, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %46, i8 0, i32 1024, i32 4, i1 false) #6
    %47 = load i8, i8* @mverbose, align 4, !tbaa !6
    %48 = load i8, i8* @verbose, align 1
    %49 = or i8 %48, %47
    %50 = icmp eq i8 %49, 0
    br i1 %50, label %55, label %51
  
  ; <label>:51                                      ; preds = %setup_trust.exit
    %52 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %53 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %54 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %52, i8* %53)
    br label %55
  
  ; <label>:55                                      ; preds = %51, %setup_trust.exit
    %56 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %56) #6
    %57 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %57) #6
    %58 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %58) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %59 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %60 = icmp eq %struct._IO_FILE* %59, null
    br i1 %60, label %61, label %.preheader.i
  
  .preheader.i:                                     ; preds = %55
    br label %.outer.i
  
  ; <label>:61                                      ; preds = %55
    %62 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %63 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %64 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %62, i8* %63, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:65                                      ; preds = %.outer29.i, %82
    %66 = bitcast i64* %sigkeyID.i to i8*
    %67 = bitcast i64* %keyID.i to i8*
    %68 = bitcast [256 x i8]* %userid.i to i8*
    %69 = call i32 @readkpacket(%struct._IO_FILE* nonnull %59, i8* nonnull %ctb.i, i8* %68, i8* %67, i8* %66) #6
    %70 = icmp eq i32 %69, -1
    br i1 %70, label %493, label %71
  
  ; <label>:71                                      ; preds = %65
    %.off.i = add i32 %69, 3
    %72 = icmp ult i32 %.off.i, 2
    br i1 %72, label %73, label %75
  
  ; <label>:73                                      ; preds = %71
    %74 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  ; <label>:75                                      ; preds = %71
    %76 = icmp slt i32 %69, 0
    br i1 %76, label %.outer29.i, label %77
  
  ; <label>:77                                      ; preds = %75
    %78 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %79 = zext i8 %78 to i32
    %80 = and i32 %79, 124
    %81 = icmp eq i32 %80, 20
    br i1 %81, label %.outer29.i, label %82
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %80, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %83
    br i1 %or.cond28.i, label %84, label %65
  
  ; <label>:84                                      ; preds = %82
    %85 = icmp eq i32 %80, 56
    %86 = icmp eq i8 %78, -80
    %or.cond.i = or i1 %86, %85
    br i1 %or.cond.i, label %.outer29.i, label %87
  
  .outer29.i:                                       ; preds = %75, %77, %84, %93, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %93 ], [ true, %84 ], [ false, %77 ], [ false, %75 ]
    br label %65
  
  ; <label>:87                                      ; preds = %84
    %88 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %89 = icmp eq i32 %80, 8
    %or.cond4.i = and i1 %88, %89
    br i1 %or.cond4.i, label %90, label %94
  
  ; <label>:90                                      ; preds = %87
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %91 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %92 = icmp eq %struct.userid* %91, null
    br i1 %92, label %93, label %94
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:94                                      ; preds = %90, %87
    %95 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %95) #6
    %96 = call i32 @fread(i8* %95, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %59) #6
    %97 = icmp eq i32 %96, 3
    br i1 %97, label %98, label %.loopexit.i
  
  ; <label>:98                                      ; preds = %94
    %99 = bitcast [3 x i8]* %buf.i.i to i32*
    %100 = load i32, i32* %99, align 4
    %101 = lshr i32 %100, 24
    %102 = trunc i32 %101 to i8
    %103 = icmp eq i8 %102, -80
    %104 = lshr i32 %100, 8
    br i1 %103, label %110, label %105
  
  ; <label>:105                                     ; preds = %98
    %106 = trunc i32 %101 to i8
    %107 = icmp slt i8 %106, 0
    br i1 %107, label %108, label %.loopexit.i
  
  ; <label>:108                                     ; preds = %105
    %109 = call i32 @fseek(%struct._IO_FILE* nonnull %59, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:110                                     ; preds = %98
    %111 = and i32 %100, 16711680
    %112 = icmp eq i32 %111, 65536
    br i1 %112, label %115, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %94, %110, %108, %105
    %113 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %113) #6
    %114 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  ; <label>:115                                     ; preds = %110
    %116 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %116) #6
    %117 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %118 = zext i8 %117 to i32
    %119 = lshr i32 %118, 2
    %120 = and i32 %119, 31
    switch i32 %120, label %491 [
      i32 6, label %121
      i32 13, label %359
      i32 2, label %410
    ]
  
  ; <label>:121                                     ; preds = %115
    %122 = bitcast i64* %keyID.i to i8*
    %123 = load i8, i8* %122, align 8, !tbaa !6
    %124 = zext i8 %123 to i32
    %125 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %126 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %125, i32 %124
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %126, align 4, !tbaa !9
    %127 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %127, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %121, %132
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %132 ], [ %pk.02.i.i, %121 ]
    %128 = bitcast i64* %keyID.i to i8*
    %129 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %130 = call i32 @memcmp(i8* %129, i8* %128, i32 signext 8) #7
    %131 = icmp eq i32 %130, 0
    br i1 %131, label %getpubkey.exit.i, label %132
  
  ; <label>:132                                     ; preds = %.lr.ph.i.i
    %133 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %133, align 4, !tbaa !9
    %134 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %134, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %132, %121
    %135 = load i32, i32* @nleft, align 4, !tbaa !7
    %136 = icmp slt i32 %135, 28
    br i1 %136, label %137, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:137                                     ; preds = %._crit_edge.i.i
    %138 = call i8* @xmalloc(i32 signext 4004) #6
    %139 = load i32, i32* @totalsize, align 4, !tbaa !10
    %140 = add nsw i32 %139, 4000
    store i32 %140, i32* @totalsize, align 4, !tbaa !10
    %141 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %142 = bitcast i8* %138 to i32*
    store i32 %141, i32* %142, align 4, !tbaa !12
    store i8* %138, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %143 = getelementptr inbounds i8, i8* %138, i32 4
    store i8* %143, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %137, %._crit_edge.i8.i
    %144 = phi %struct.pubkey** [ %.pre61.i, %137 ], [ %125, %._crit_edge.i8.i ]
    %145 = phi i8* [ %143, %137 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %146 = phi i32 [ 4000, %137 ], [ %135, %._crit_edge.i8.i ]
    %147 = bitcast i64* %keyID.i to i8*
    %148 = add nsw i32 %146, -28
    store i32 %148, i32* @nleft, align 4, !tbaa !7
    %149 = getelementptr inbounds i8, i8* %145, i32 28
    store i8* %149, i8** @allocn.ptr, align 4, !tbaa !9
    %150 = bitcast i8* %145 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %145, i8 0, i32 28, i32 4, i1 false) #6
    %151 = getelementptr inbounds i8, i8* %145, i32 16
    %152 = bitcast i8* %151 to i64*
    %153 = load i64, i64* %keyID.i, align 8
    store i64 %153, i64* %152, align 1
    %154 = load i8, i8* %147, align 8, !tbaa !6
    %155 = zext i8 %154 to i32
    %156 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %144, i32 %155
    %157 = bitcast %struct.pubkey** %156 to i32*
    %158 = load i32, i32* %157, align 4, !tbaa !9
    %159 = getelementptr inbounds i8, i8* %145, i32 4
    %160 = bitcast i8* %159 to i32*
    store i32 %158, i32* %160, align 4, !tbaa !17
    %161 = load i8, i8* %147, align 8, !tbaa !6
    %162 = zext i8 %161 to i32
    %163 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %144, i32 %162
    %164 = bitcast %struct.pubkey** %163 to i8**
    store i8* %145, i8** %164, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %150, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %165 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %165, label %166, label %168
  
  ; <label>:166                                     ; preds = %getpubkey.exit.i
    %167 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %167, align 4, !tbaa !18
    br label %169
  
  ; <label>:168                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %169
  
  ; <label>:169                                     ; preds = %168, %166
    %170 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %171 = load %struct.pubkey*, %struct.pubkey** %170, align 4, !tbaa !18
    %172 = icmp eq %struct.pubkey* %171, null
    br i1 %172, label %180, label %173
  
  ; <label>:173                                     ; preds = %169
    %174 = bitcast i64* %keyID.i to i8*
    %175 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %176 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %177 = call i8* @keyIDstring(i8* %174) #6
    %178 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %175, i8* %176, i8* %177) #6
    %179 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  ; <label>:180                                     ; preds = %169
    %181 = trunc i32 %104 to i8
    %182 = icmp slt i8 %181, 0
    br i1 %182, label %ismember_newkeys.exit.i, label %183
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %104 to i8
    %185 = icmp eq %struct.newkey* %nkeys, null
    br i1 %185, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %183, %190
    %.02.i.i = phi %struct.newkey* [ %193, %190 ], [ %nkeys, %183 ]
    %186 = bitcast i64* %keyID.i to i8*
    %187 = bitcast %struct.newkey* %.02.i.i to i8*
    %188 = call i32 @memcmp(i8* %186, i8* %187, i32 signext 8) #7
    %189 = icmp eq i32 %188, 0
    br i1 %189, label %ismember_newkeys.exit.i, label %190
  
  ; <label>:190                                     ; preds = %.lr.ph.i9.i
    %191 = trunc i32 %104 to i8
    %192 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %193 = load %struct.newkey*, %struct.newkey** %192, align 4, !tbaa !1
    %194 = icmp eq %struct.newkey* %193, null
    br i1 %194, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %180
    %195 = bitcast [8 x i8]* %keyID.i.i to i8*
    %196 = bitcast [256 x i8]* %userid.i.i to i8*
    %197 = bitcast [128 x i16]* %esec.i.i to i8*
    %198 = bitcast [128 x i16]* %nsec.i.i to i8*
    %199 = bitcast [128 x i16]* %e.i.i to i8*
    %200 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 256, i8* %198) #6
    call void @llvm.lifetime.start(i64 256, i8* %197) #6
    call void @llvm.lifetime.start(i64 256, i8* %196) #6
    call void @llvm.lifetime.start(i64 8, i8* %195) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %201 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %202 = icmp eq %struct._IO_FILE* %201, null
    br i1 %202, label %check_secretkey.exit.i, label %203
  
  ; <label>:203                                     ; preds = %ismember_newkeys.exit.i
    %204 = bitcast [128 x i16]* %e.i.i to i16*
    %205 = bitcast [128 x i16]* %n.i.i to i16*
    %206 = call i32 @ftell(%struct._IO_FILE* nonnull %59) #6
    %207 = call i32 @fseek(%struct._IO_FILE* nonnull %59, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %208 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %59, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %205, i16* %204, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %209 = icmp slt i16 %208, 0
    br i1 %209, label %.thread.i.i, label %210
  
  ; <label>:210                                     ; preds = %203
    %211 = bitcast [128 x i16]* %n.i.i to i16*
    %212 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %212, i16* %211) #6
    br label %213
  
  ; <label>:213                                     ; preds = %233, %210
    %214 = bitcast [128 x i16]* %e.i.i.i to i16*
    %215 = bitcast [128 x i16]* %n.i.i.i to i16*
    %216 = bitcast [128 x i16]* %e.i.i.i to i8*
    %217 = bitcast [128 x i16]* %n.i.i.i to i8*
    %218 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %217) #6
    call void @llvm.lifetime.start(i64 256, i8* %216) #6
    %219 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %59, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %218, i16* %215, i16* %214, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %220 = icmp slt i16 %219, 0
    br i1 %220, label %readkpacket.exit.i.i, label %221
  
  ; <label>:221                                     ; preds = %213
    %222 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %223 = icmp eq i8 %222, -76
    br i1 %223, label %224, label %readkpacket.exit.thread.i.i
  
  ; <label>:224                                     ; preds = %221
    %225 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %225) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %224, %221
    %226 = bitcast [128 x i16]* %e.i.i.i to i8*
    %227 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %226) #6
    call void @llvm.lifetime.end(i64 256, i8* %227) #6
    br label %233
  
  readkpacket.exit.i.i:                             ; preds = %213
    %228 = bitcast [128 x i16]* %e.i.i.i to i8*
    %229 = bitcast [128 x i16]* %n.i.i.i to i8*
    %230 = sext i16 %219 to i32
    call void @llvm.lifetime.end(i64 256, i8* %228) #6
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    %231 = or i32 %230, 2
    %232 = icmp eq i32 %231, -1
    br i1 %232, label %.thread.i.i, label %233
  
  ; <label>:233                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %234 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %235 = icmp eq i8 %234, -76
    br i1 %235, label %236, label %213
  
  ; <label>:236                                     ; preds = %233
    %237 = bitcast [8 x i8]* %keyID.i.i to i8*
    %238 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %239 = call i32 @lookup_by_keyID(%struct._IO_FILE* %238, i8* %237) #6
    %240 = icmp slt i32 %239, 0
    br i1 %240, label %.thread.i.i, label %241
  
  ; <label>:241                                     ; preds = %236
    %242 = bitcast [128 x i16]* %esec.i.i to i16*
    %243 = bitcast [128 x i16]* %nsec.i.i to i16*
    %244 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %245 = call i32 @ftell(%struct._IO_FILE* %244) #6
    %246 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %247 = call signext i16 @readkeypacket(%struct._IO_FILE* %246, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %243, i16* %242, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %248 = icmp slt i16 %247, 0
    br i1 %248, label %249, label %253
  
  ; <label>:249                                     ; preds = %241
    %250 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %251 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %252 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %250, i8* %251) #6
    br label %.thread.i.i
  
  ; <label>:253                                     ; preds = %241
    %254 = bitcast [128 x i16]* %nsec.i.i to i16*
    %255 = bitcast [128 x i16]* %n.i.i to i16*
    %256 = call signext i16 @mp_compare(i16* %255, i16* %254) #6
    %257 = icmp eq i16 %256, 0
    br i1 %257, label %258, label %263
  
  ; <label>:258                                     ; preds = %253
    %259 = bitcast [128 x i16]* %esec.i.i to i16*
    %260 = bitcast [128 x i16]* %e.i.i to i16*
    %261 = call signext i16 @mp_compare(i16* %260, i16* %259) #6
    %262 = icmp eq i16 %261, 0
    br i1 %262, label %271, label %263
  
  ; <label>:263                                     ; preds = %258, %253
    %264 = bitcast [256 x i8]* %userid.i.i to i8*
    %265 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %266 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %267 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %265, i8* %266, i8* %264) #6
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269) #6
    br label %271
  
  ; <label>:271                                     ; preds = %263, %258
    %status.0.i.i = phi i32 [ -2, %263 ], [ 0, %258 ]
    %272 = trunc i32 %104 to i8
    %273 = icmp slt i8 %272, 0
    br i1 %273, label %287, label %274
  
  ; <label>:274                                     ; preds = %271
    %275 = load i8, i8* @batchmode, align 1, !tbaa !6
    %276 = icmp eq i8 %275, 0
    br i1 %276, label %277, label %.thread.i.i
  
  ; <label>:277                                     ; preds = %274
    %278 = bitcast [256 x i8]* %userid.i.i to i8*
    %279 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %280 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %281 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %279, i8* %280, i8* %278) #6
    %282 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %283 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %284 = call i32 @fputs(i8* %282, %struct._IO_FILE* %283) #6
    %285 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %285, 0
    %286 = sext i1 %not..i.i to i32
    br label %287
  
  ; <label>:287                                     ; preds = %277, %271
    %status.1.i.i = phi i32 [ %status.0.i.i, %271 ], [ %286, %277 ]
    %288 = icmp eq i32 %status.1.i.i, 0
    %289 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %290 = icmp ne %struct._IO_FILE* %289, null
    %or.cond3.i.i = and i1 %288, %290
    br i1 %or.cond3.i.i, label %291, label %.thread.i.i
  
  ; <label>:291                                     ; preds = %287
    %292 = bitcast [8 x i8]* %keyID.i.i to i8*
    %293 = call i32 @lookup_by_keyID(%struct._IO_FILE* %289, i8* %292) #6
    %294 = icmp slt i32 %293, 0
    br i1 %294, label %295, label %300
  
  ; <label>:295                                     ; preds = %291
    %296 = bitcast [256 x i8]* %userid.i.i to i8*
    %297 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %298 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %299 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %297, i8* %298, i8* %296, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:300                                     ; preds = %291
    %301 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %302 = call i32 @ftell(%struct._IO_FILE* %301) #6
    %303 = sub nsw i32 %302, %245
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @fseek(%struct._IO_FILE* %304, i32 signext %245, i32 signext 0) #6
    br label %306
  
  ; <label>:306                                     ; preds = %308, %300
    %pktlen.0.i.i = phi i32 [ %303, %300 ], [ %309, %308 ]
    %307 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %307, label %308, label %.critedge.i.i
  
  ; <label>:308                                     ; preds = %306
    %309 = add nsw i32 %pktlen.0.i.i, -1
    %310 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %311 = call i32 @_IO_getc(%struct._IO_FILE* %310) #6
    %312 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %313 = call i32 @_IO_getc(%struct._IO_FILE* %312) #6
    %314 = icmp eq i32 %311, %313
    br i1 %314, label %306, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %306
    %315 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %315, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %308, %.critedge.i.i
    %316 = bitcast [256 x i8]* %userid.i.i to i8*
    %317 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %318 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %319 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %317, i8* %318, i8* %316, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %295, %287, %274, %249, %236, %203
    %status.4.i.i = phi i32 [ -1, %203 ], [ 1, %236 ], [ -3, %249 ], [ 0, %295 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %287 ], [ -1, %274 ], [ %230, %readkpacket.exit.i.i ]
    %323 = call i32 @fseek(%struct._IO_FILE* nonnull %59, i32 signext %206, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %324 = bitcast [8 x i8]* %keyID.i.i to i8*
    %325 = bitcast [256 x i8]* %userid.i.i to i8*
    %326 = bitcast [128 x i16]* %esec.i.i to i8*
    %327 = bitcast [128 x i16]* %nsec.i.i to i8*
    %328 = bitcast [128 x i16]* %e.i.i to i8*
    %329 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %324) #6
    call void @llvm.lifetime.end(i64 256, i8* %325) #6
    call void @llvm.lifetime.end(i64 256, i8* %326) #6
    call void @llvm.lifetime.end(i64 256, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    %330 = icmp eq i32 %.0.i11.i, 0
    br i1 %330, label %331, label %343
  
  ; <label>:331                                     ; preds = %check_secretkey.exit.i
    %332 = add nsw i32 %buckstopcount.0.ph.i, 1
    %333 = or i32 %104, 135
    %334 = trunc i32 %333 to i8
    %335 = load i8, i8* @mverbose, align 4, !tbaa !6
    %336 = icmp eq i8 %335, 0
    br i1 %336, label %355, label %337
  
  ; <label>:337                                     ; preds = %331
    %338 = trunc i32 %333 to i8
    %339 = bitcast i64* %keyID.i to i8*
    %340 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %341 = call i8* @keyIDstring(i8* %339) #6
    %342 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %340, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %341) #6
    br label %355
  
  ; <label>:343                                     ; preds = %check_secretkey.exit.i
    %344 = and i32 %104, 127
    %345 = trunc i32 %344 to i8
    %346 = and i32 %104, 7
    %347 = icmp eq i32 %346, 7
    %..i = select i1 %347, i8 6, i8 %345
    %348 = load i8, i8* @mverbose, align 4, !tbaa !6
    %349 = icmp eq i8 %348, 0
    br i1 %349, label %355, label %350
  
  ; <label>:350                                     ; preds = %343
    %351 = bitcast i64* %keyID.i to i8*
    %352 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %353 = call i8* @keyIDstring(i8* %351) #6
    %354 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %352, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %353) #6
    br label %355
  
  ; <label>:355                                     ; preds = %350, %343, %337, %331
    %keyctrl.2.i = phi i8 [ %334, %331 ], [ %338, %337 ], [ %..i, %343 ], [ %..i, %350 ]
    %buckstop.1.i = phi i8 [ 1, %331 ], [ 1, %337 ], [ %buckstop.0.ph.i, %343 ], [ %buckstop.0.ph.i, %350 ]
    %buckstopcount.1.i = phi i32 [ %332, %331 ], [ %332, %337 ], [ %buckstopcount.0.ph.i, %343 ], [ %buckstopcount.0.ph.i, %350 ]
    %356 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %190, %355, %183
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %355 ], [ %184, %183 ], [ %191, %190 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %355 ], [ 0, %183 ], [ 0, %190 ]
    %show_user.1.i = phi i8 [ %356, %355 ], [ 0, %183 ], [ 0, %190 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %355 ], [ %buckstopcount.0.ph.i, %183 ], [ %buckstopcount.0.ph.i, %190 ]
    %357 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %357, align 4, !tbaa !16
    %358 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %358, align 4, !tbaa !14
    br label %491
  
  ; <label>:359                                     ; preds = %115
    %360 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %360, label %361, label %491
  
  ; <label>:361                                     ; preds = %359
    %362 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %362, label %373, label %363
  
  ; <label>:363                                     ; preds = %361
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %364 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %365 = icmp eq %struct.userid* %364, null
    br i1 %365, label %369, label %366
  
  ; <label>:366                                     ; preds = %363
    %367 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %368 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %367) #6
    br label %369
  
  ; <label>:369                                     ; preds = %366, %363
    %370 = bitcast [256 x i8]* %userid.i to i8*
    %371 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %372 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %371, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %370) #6
    br label %373
  
  ; <label>:373                                     ; preds = %369, %361
    %374 = load i32, i32* @nleft, align 4, !tbaa !7
    %375 = icmp slt i32 %374, 20
    br i1 %375, label %376, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %373
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:376                                     ; preds = %373
    %377 = call i8* @xmalloc(i32 signext 4004) #6
    %378 = load i32, i32* @totalsize, align 4, !tbaa !10
    %379 = add nsw i32 %378, 4000
    store i32 %379, i32* @totalsize, align 4, !tbaa !10
    %380 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %381 = bitcast i8* %377 to i32*
    store i32 %380, i32* %381, align 4, !tbaa !12
    store i8* %377, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %382 = getelementptr inbounds i8, i8* %377, i32 4
    store i8* %382, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %376, %._crit_edge.i13.i
    %383 = phi i8* [ %382, %376 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %384 = phi i32 [ 4000, %376 ], [ %374, %._crit_edge.i13.i ]
    %385 = icmp eq %struct.userid* %id.0.ph.i, null
    %386 = add nsw i32 %384, -20
    store i32 %386, i32* @nleft, align 4, !tbaa !7
    %387 = getelementptr inbounds i8, i8* %383, i32 20
    store i8* %387, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %385, label %390, label %388
  
  ; <label>:388                                     ; preds = %allocn.exit14.i
    %389 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %383, i8** %389, align 4, !tbaa !19
    br label %391
  
  ; <label>:390                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %383, i8** %sunkaddr12, align 4, !tbaa !14
    br label %391
  
  ; <label>:391                                     ; preds = %390, %388
    %392 = load i8, i8* @mverbose, align 4, !tbaa !6
    %393 = icmp eq i8 %392, 0
    br i1 %393, label %399, label %394
  
  ; <label>:394                                     ; preds = %391
    %395 = bitcast [256 x i8]* %userid.i to i8*
    %396 = call fastcc i8* @store_str(i8* %395) #6
    %397 = getelementptr inbounds i8, i8* %383, i32 12
    %398 = bitcast i8* %397 to i8**
    store i8* %396, i8** %398, align 4, !tbaa !21
    br label %399
  
  ; <label>:399                                     ; preds = %394, %391
    %400 = bitcast i8* %383 to %struct.userid*
    %401 = and i32 %104, 252
    %402 = icmp eq i8 %buckstop.0.ph.i, 0
    %403 = or i32 %104, 3
    %storemerge.in.i = select i1 %402, i32 %401, i32 %403
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %404 = bitcast i8* %383 to %struct.userid**
    store %struct.userid* null, %struct.userid** %404, align 4, !tbaa !19
    %405 = getelementptr inbounds i8, i8* %383, i32 4
    %406 = bitcast i8* %405 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %406, align 4, !tbaa !22
    %407 = getelementptr inbounds i8, i8* %383, i32 16
    store i8 %storemerge.i4, i8* %407, align 4, !tbaa !23
    %408 = getelementptr inbounds i8, i8* %383, i32 8
    %409 = bitcast i8* %408 to %struct.signature**
    store %struct.signature* null, %struct.signature** %409, align 4, !tbaa !24
    br label %491
  
  ; <label>:410                                     ; preds = %115
    %411 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %412 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %411, %412
    br i1 %or.cond3.i, label %413, label %491
  
  ; <label>:413                                     ; preds = %410
    %414 = load i32, i32* @nleft, align 4, !tbaa !7
    %415 = icmp slt i32 %414, 20
    br i1 %415, label %416, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %413
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:416                                     ; preds = %413
    %417 = call i8* @xmalloc(i32 signext 4004) #6
    %418 = load i32, i32* @totalsize, align 4, !tbaa !10
    %419 = add nsw i32 %418, 4000
    store i32 %419, i32* @totalsize, align 4, !tbaa !10
    %420 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %421 = bitcast i8* %417 to i32*
    store i32 %420, i32* %421, align 4, !tbaa !12
    store i8* %417, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %422 = getelementptr inbounds i8, i8* %417, i32 4
    store i8* %422, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %416, %._crit_edge.i16.i
    %423 = phi i8* [ %422, %416 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %424 = phi i32 [ 4000, %416 ], [ %414, %._crit_edge.i16.i ]
    %425 = icmp eq %struct.signature* %sig.0.ph.i, null
    %426 = add nsw i32 %424, -20
    store i32 %426, i32* @nleft, align 4, !tbaa !7
    %427 = getelementptr inbounds i8, i8* %423, i32 20
    store i8* %427, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %425, label %430, label %428
  
  ; <label>:428                                     ; preds = %allocn.exit17.i
    %429 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %423, i8** %429, align 4, !tbaa !25
    br label %433
  
  ; <label>:430                                     ; preds = %allocn.exit17.i
    %431 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %432 = bitcast %struct.signature** %431 to i8**
    store i8* %423, i8** %432, align 4, !tbaa !24
    br label %433
  
  ; <label>:433                                     ; preds = %430, %428
    %434 = bitcast i64* %sigkeyID.i to i8*
    %435 = bitcast i8* %423 to %struct.signature**
    store %struct.signature* null, %struct.signature** %435, align 4, !tbaa !25
    %436 = getelementptr inbounds i8, i8* %423, i32 4
    %437 = bitcast i8* %436 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %437, align 4, !tbaa !27
    %438 = load i8, i8* %434, align 8, !tbaa !6
    %439 = zext i8 %438 to i32
    %440 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %441 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %440, i32 %439
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %441, align 4, !tbaa !9
    %442 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %442, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %433, %447
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %447 ], [ %pk.02.i18.i, %433 ]
    %443 = bitcast i64* %sigkeyID.i to i8*
    %444 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %445 = call i32 @memcmp(i8* %444, i8* %443, i32 signext 8) #7
    %446 = icmp eq i32 %445, 0
    br i1 %446, label %getpubkey.exit24.i, label %447
  
  ; <label>:447                                     ; preds = %.lr.ph.i20.i
    %448 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %448, align 4, !tbaa !9
    %449 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %449, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %447, %433
    %450 = icmp slt i32 %426, 28
    br i1 %450, label %451, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:451                                     ; preds = %._crit_edge.i22.i
    %452 = call i8* @xmalloc(i32 signext 4004) #6
    %453 = load i32, i32* @totalsize, align 4, !tbaa !10
    %454 = add nsw i32 %453, 4000
    store i32 %454, i32* @totalsize, align 4, !tbaa !10
    %455 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %456 = bitcast i8* %452 to i32*
    store i32 %455, i32* %456, align 4, !tbaa !12
    store i8* %452, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %457 = getelementptr inbounds i8, i8* %452, i32 4
    store i8* %457, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %451, %._crit_edge.i26.i
    %458 = phi %struct.pubkey** [ %.pre.i, %451 ], [ %440, %._crit_edge.i26.i ]
    %459 = phi i8* [ %457, %451 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %460 = phi i32 [ 4000, %451 ], [ %426, %._crit_edge.i26.i ]
    %461 = bitcast i64* %sigkeyID.i to i8*
    %462 = add nsw i32 %460, -28
    store i32 %462, i32* @nleft, align 4, !tbaa !7
    %463 = getelementptr inbounds i8, i8* %459, i32 28
    store i8* %463, i8** @allocn.ptr, align 4, !tbaa !9
    %464 = bitcast i8* %459 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %459, i8 0, i32 28, i32 4, i1 false) #6
    %465 = getelementptr inbounds i8, i8* %459, i32 16
    %466 = bitcast i8* %465 to i64*
    %467 = load i64, i64* %sigkeyID.i, align 8
    store i64 %467, i64* %466, align 1
    %468 = load i8, i8* %461, align 8, !tbaa !6
    %469 = zext i8 %468 to i32
    %470 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %458, i32 %469
    %471 = bitcast %struct.pubkey** %470 to i32*
    %472 = load i32, i32* %471, align 4, !tbaa !9
    %473 = getelementptr inbounds i8, i8* %459, i32 4
    %474 = bitcast i8* %473 to i32*
    store i32 %472, i32* %474, align 4, !tbaa !17
    %475 = load i8, i8* %461, align 8, !tbaa !6
    %476 = zext i8 %475 to i32
    %477 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %458, i32 %476
    %478 = bitcast %struct.pubkey** %477 to i8**
    store i8* %459, i8** %478, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %464, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %479 = bitcast i8* %423 to %struct.signature*
    %480 = getelementptr inbounds i8, i8* %423, i32 8
    %481 = bitcast i8* %480 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %481, align 4, !tbaa !28
    %482 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %483 = bitcast %struct.signature** %482 to i32*
    %484 = load i32, i32* %483, align 4, !tbaa !29
    %485 = getelementptr inbounds i8, i8* %423, i32 12
    %486 = bitcast i8* %485 to i32*
    store i32 %484, i32* %486, align 4, !tbaa !30
    %487 = bitcast %struct.signature** %482 to i8**
    store i8* %423, i8** %487, align 4, !tbaa !29
    %488 = and i32 %104, 64
    %489 = trunc i32 %488 to i8
    %490 = getelementptr inbounds i8, i8* %423, i32 16
    store i8 %489, i8* %490, align 4, !tbaa !31
    br label %491
  
  ; <label>:491                                     ; preds = %getpubkey.exit24.i, %410, %399, %359, %ismember_newkeys.exit.thread.i, %115
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %115 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %410 ], [ %buckstop.0.ph.i, %399 ], [ %buckstop.0.ph.i, %359 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %115 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %410 ], [ %show_user.0.ph.i, %399 ], [ %show_user.0.ph.i, %359 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %115 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %410 ], [ %buckstopcount.0.ph.i, %399 ], [ %buckstopcount.0.ph.i, %359 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %115 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %410 ], [ %pk.0.ph.i, %399 ], [ null, %359 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %115 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %410 ], [ %400, %399 ], [ %id.0.ph.i, %359 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %115 ], [ %479, %getpubkey.exit24.i ], [ %sig.0.ph.i, %410 ], [ null, %399 ], [ %sig.0.ph.i, %359 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %492 = call i32 @ftell(%struct._IO_FILE* nonnull %59) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %491, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %491 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %491 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %491 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %492, %491 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %491 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %491 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %491 ]
    br label %.outer29.i
  
  ; <label>:493                                     ; preds = %65
    %494 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %495 = load i8, i8* @mverbose, align 4
    %496 = icmp eq i8 %495, 0
    %or.cond6.i = or i1 %494, %496
    br i1 %or.cond6.i, label %501, label %497
  
  ; <label>:497                                     ; preds = %493
    %498 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %499 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %500 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %498, i8* %499) #6
    br label %501
  
  ; <label>:501                                     ; preds = %497, %493
    %502 = call i32 @fclose(%struct._IO_FILE* nonnull %59) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %501, %173, %.loopexit.i, %73, %61
    %.0.i = phi i32 [ -1, %61 ], [ %69, %73 ], [ -7, %.loopexit.i ], [ -1, %173 ], [ 0, %501 ]
    %503 = bitcast i64* %sigkeyID.i to i8*
    %504 = bitcast i64* %keyID.i to i8*
    %505 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %503) #6
    call void @llvm.lifetime.end(i64 8, i8* %504) #6
    call void @llvm.lifetime.end(i64 256, i8* %505) #6
    %506 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %507 = icmp eq %struct._IO_FILE* %506, null
    br i1 %507, label %510, label %508
  
  ; <label>:508                                     ; preds = %maint_read_data.exit
    %509 = call i32 @fclose(%struct._IO_FILE* nonnull %506)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %510
  
  ; <label>:510                                     ; preds = %508, %maint_read_data.exit
    %511 = icmp slt i32 %.0.i, 0
    br i1 %511, label %756, label %512
  
  ; <label>:512                                     ; preds = %510
    %513 = load i8, i8* @mverbose, align 4, !tbaa !6
    %514 = load i8, i8* @verbose, align 1
    %515 = or i8 %514, %513
    %516 = icmp eq i8 %515, 0
    br i1 %516, label %521, label %517
  
  ; <label>:517                                     ; preds = %512
    %518 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %519 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %520 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %518, i8* %519)
    br label %521
  
  ; <label>:521                                     ; preds = %517, %512
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %522 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %522, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %521, %550
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %550 ], [ %pk.01.i, %521 ]
    %523 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %524 = load i8, i8* %523, align 4, !tbaa !16
    %525 = icmp slt i8 %524, 0
    br i1 %525, label %526, label %550
  
  ; <label>:526                                     ; preds = %.lr.ph.i5
    %527 = load i8, i8* @mverbose, align 4, !tbaa !6
    %528 = icmp eq i8 %527, 0
    br i1 %528, label %536, label %529
  
  ; <label>:529                                     ; preds = %526
    %530 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %531 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %532 = load %struct.userid*, %struct.userid** %531, align 4, !tbaa !14
    %533 = getelementptr inbounds %struct.userid, %struct.userid* %532, i32 0, i32 3
    %534 = load i8*, i8** %533, align 4, !tbaa !21
    %535 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %530, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %534) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %536
  
  ; <label>:536                                     ; preds = %529, %526
    %537 = phi i8 [ %524, %526 ], [ %.pre.i6, %529 ]
    %538 = and i8 %537, 7
    %539 = icmp eq i8 %538, 0
    br i1 %539, label %540, label %549
  
  ; <label>:540                                     ; preds = %536
    %541 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %542 = call i8* @user_from_keyID(i8* %541) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %543 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %544 = zext i8 %543 to i32
    %545 = and i32 %544, 248
    %546 = call i32 @ask_owntrust(i8* %542, i8 zeroext %543) #6
    %547 = or i32 %545, %546
    %548 = trunc i32 %547 to i8
    store i8 %548, i8* %sunkaddr18, align 4, !tbaa !6
    br label %549
  
  ; <label>:549                                     ; preds = %540, %536
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %550
  
  ; <label>:550                                     ; preds = %549, %.lr.ph.i5
    %551 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %551, align 4, !tbaa !9
    %552 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %552, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %550, %521
    %553 = load i8, i8* @verbose, align 1, !tbaa !6
    %554 = icmp eq i8 %553, 0
    br i1 %554, label %559, label %555
  
  ; <label>:555                                     ; preds = %maint_trace_chain.exit
    %556 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %557 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %558 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %556, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %557)
    br label %559
  
  ; <label>:559                                     ; preds = %555, %maint_trace_chain.exit
    %560 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %560) #6
    %561 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %561) #6
    %562 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %562) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i12) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %563, label %565
  
  ; <label>:563                                     ; preds = %559
    %564 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %567
  
  ; <label>:565                                     ; preds = %559
    %566 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %567
  
  ; <label>:567                                     ; preds = %565, %563
    %f.0.i = phi %struct._IO_FILE* [ %564, %563 ], [ %566, %565 ]
    %568 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %568, label %569, label %573
  
  ; <label>:569                                     ; preds = %567
    %570 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %571 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %572 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %570, i8* %571, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:573                                     ; preds = %567
    %574 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %707, %573
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %573 ], [ %kc_orig.2.i, %707 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %573 ], [ %trust_pos.1.i, %707 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %573 ], [ %kc_new.1.i, %707 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %573 ], [ %708, %707 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %574, %573 ], [ %pk.1.i, %707 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %573 ], [ %id.1.i, %707 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %573 ], [ %sig.1.i, %707 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %697, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %697 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %697 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %697 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %697 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %697 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %697 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %614, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %594, %614 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %580, %582, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %582 ], [ false, %580 ]
    br label %575
  
  ; <label>:575                                     ; preds = %587, %.outer20.i
    %576 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    %577 = bitcast [8 x i8]* %keyID.i.i to i8*
    %578 = bitcast [256 x i8]* %userid.i.i to i8*
    %579 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %ctb.i12, i8* %578, i8* %577, i8* %576) #6
    %switch.i = icmp ugt i32 %579, -4
    br i1 %switch.i, label %709, label %580
  
  ; <label>:580                                     ; preds = %575
    %581 = icmp slt i32 %579, 0
    br i1 %581, label %.outer20.i, label %582
  
  ; <label>:582                                     ; preds = %580
    %583 = load i8, i8* %ctb.i12, align 4, !tbaa !6
    %584 = zext i8 %583 to i32
    %585 = and i32 %584, 124
    %586 = icmp eq i32 %585, 20
    br i1 %586, label %.outer20.i, label %587
  
  ; <label>:587                                     ; preds = %582
    %588 = icmp eq i32 %585, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %588
    br i1 %or.cond.i18, label %589, label %575
  
  ; <label>:589                                     ; preds = %587
    switch i32 %585, label %590 [
      i32 24, label %592
      i32 8, label %592
    ]
  
  ; <label>:590                                     ; preds = %589
    %591 = icmp eq i8 %583, -76
    br i1 %591, label %592, label %.loopexit.i20
  
  ; <label>:592                                     ; preds = %590, %589, %589
    %593 = bitcast [3 x i8]* %buf.i.i to i8*
    %594 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %593) #6
    %595 = call i32 @fread(i8* %593, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %596 = icmp eq i32 %595, 3
    br i1 %596, label %597, label %614
  
  ; <label>:597                                     ; preds = %592
    %598 = bitcast [3 x i8]* %buf.i.i to i32*
    %599 = load i32, i32* %598, align 4
    %600 = lshr i32 %599, 24
    %601 = trunc i32 %600 to i8
    %602 = icmp eq i8 %601, -80
    br i1 %602, label %608, label %603
  
  ; <label>:603                                     ; preds = %597
    %604 = trunc i32 %600 to i8
    %605 = icmp slt i8 %604, 0
    br i1 %605, label %606, label %614
  
  ; <label>:606                                     ; preds = %603
    %607 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %614
  
  ; <label>:608                                     ; preds = %597
    %609 = and i32 %599, 16711680
    %610 = icmp eq i32 %609, 65536
    br i1 %610, label %read_trust.exit.i, label %614
  
  read_trust.exit.i:                                ; preds = %608
    %611 = bitcast [3 x i8]* %buf.i.i to i8*
    %612 = lshr i32 %599, 8
    %613 = trunc i32 %612 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %611) #6
    %.pre.i19 = load i8, i8* %ctb.i12, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:614                                     ; preds = %608, %606, %603, %592
    %615 = bitcast [3 x i8]* %buf.i.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %615) #6
    %616 = load i8, i8* %ctb.i12, align 4, !tbaa !6
    %617 = and i8 %616, 124
    %618 = icmp eq i8 %617, 8
    br i1 %618, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %614
    %619 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %590, %read_trust.exit.i
    %620 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %583, %590 ]
    %kc_orig.2.i = phi i8 [ %613, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %590 ]
    %trust_pos.1.i = phi i32 [ %594, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %590 ]
    %621 = zext i8 %620 to i32
    %622 = lshr i32 %621, 2
    %623 = and i32 %622, 31
    switch i32 %623, label %697 [
      i32 6, label %624
      i32 13, label %643
      i32 2, label %681
    ]
  
  ; <label>:624                                     ; preds = %.loopexit.i20
    %625 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %625, label %631, label %626
  
  ; <label>:626                                     ; preds = %624
    %627 = bitcast [8 x i8]* %keyID.i.i to i8*
    %628 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %629 = call i32 @memcmp(i8* %628, i8* %627, i32 signext 8) #7
    %630 = icmp eq i32 %629, 0
    br i1 %630, label %632, label %631
  
  ; <label>:631                                     ; preds = %626, %624
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:632                                     ; preds = %626
    %633 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %634 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %634, %633
    br i1 %or.cond3.i21, label %635, label %636
  
  ; <label>:635                                     ; preds = %632
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:636                                     ; preds = %632
    %637 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %638 = load %struct.userid*, %struct.userid** %637, align 4, !tbaa !14
    %639 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %640 = load i8, i8* %639, align 4, !tbaa !16
    %641 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %642 = load %struct.pubkey*, %struct.pubkey** %641, align 4, !tbaa !18
    br label %697
  
  ; <label>:643                                     ; preds = %.loopexit.i20
    %644 = icmp eq %struct.userid* %id.0.ph.i14, null
    %645 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %644, %645
    br i1 %or.cond5.i, label %646, label %647
  
  ; <label>:646                                     ; preds = %643
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:647                                     ; preds = %643
    %648 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %649 = load %struct.signature*, %struct.signature** %648, align 4, !tbaa !24
    %650 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %651 = load %struct.pubkey*, %struct.pubkey** %650, align 4, !tbaa !22
    %652 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %651, i32 0, i32 5
    %653 = load i8, i8* %652, align 4, !tbaa !16
    %654 = icmp slt i8 %653, 0
    br i1 %654, label %compute_legit.exit.i, label %655
  
  ; <label>:655                                     ; preds = %647
    %656 = icmp eq %struct.signature* %649, null
    br i1 %656, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %655, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %649, %655 ]
    %trust_count.02.i.i = phi i32 [ %663, %.lr.ph.i.i22 ], [ 0, %655 ]
    %657 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %658 = load i8, i8* %657, align 4, !tbaa !31
    %659 = zext i8 %658 to i32
    %660 = and i32 %659, 7
    %661 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %660
    %662 = load i32, i32* %661, align 4, !tbaa !7
    %663 = add nsw i32 %662, %trust_count.02.i.i
    %664 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %664, align 4, !tbaa !9
    %665 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %665, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %666 = icmp eq i32 %663, 0
    br i1 %666, label %compute_legit.exit.i, label %667
  
  ; <label>:667                                     ; preds = %._crit_edge.i.i23
    %668 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %669 = icmp slt i32 %663, %668
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %667
    %671 = load i32, i32* @complete_min, align 4, !tbaa !7
    %672 = icmp slt i32 %663, %671
    %..i.i = select i1 %672, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %670, %667, %._crit_edge.i.i23, %655, %647
    %legit.0.i.i = phi i32 [ 3, %647 ], [ 0, %._crit_edge.i.i23 ], [ 1, %667 ], [ %..i.i, %670 ], [ 0, %655 ]
    %673 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %674 = load i8, i8* %673, align 4, !tbaa !23
    %675 = zext i8 %674 to i32
    %676 = and i32 %675, 252
    %677 = or i32 %676, %legit.0.i.i
    %678 = trunc i32 %677 to i8
    store i8 %678, i8* %673, align 4, !tbaa !23
    %679 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %680 = load %struct.userid*, %struct.userid** %679, align 4, !tbaa !19
    br label %697
  
  ; <label>:681                                     ; preds = %.loopexit.i20
    %682 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %682, label %683, label %684
  
  ; <label>:683                                     ; preds = %681
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:684                                     ; preds = %681
    %685 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    %686 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %687 = load %struct.pubkey*, %struct.pubkey** %686, align 4, !tbaa !28
    %688 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %687, i32 0, i32 4, i32 0
    %689 = call i32 @memcmp(i8* %688, i8* %685, i32 signext 8) #7
    %690 = icmp eq i32 %689, 0
    br i1 %690, label %692, label %691
  
  ; <label>:691                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:692                                     ; preds = %684
    %693 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %694 = load i8, i8* %693, align 4, !tbaa !31
    %695 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %696 = load %struct.signature*, %struct.signature** %695, align 4, !tbaa !25
    br label %697
  
  ; <label>:697                                     ; preds = %692, %compute_legit.exit.i, %636, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %694, %692 ], [ %678, %compute_legit.exit.i ], [ %640, %636 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %692 ], [ 3, %compute_legit.exit.i ], [ 135, %636 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %692 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %642, %636 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %692 ], [ %680, %compute_legit.exit.i ], [ %638, %636 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %696, %692 ], [ %649, %compute_legit.exit.i ], [ null, %636 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %698 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %699 = zext i8 %698 to i32
    %700 = and i32 %699, %mask.0.i
    %701 = icmp eq i32 %700, 0
    br i1 %701, label %.outer.i16, label %702
  
  ; <label>:702                                     ; preds = %697
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %707, label %703
  
  ; <label>:703                                     ; preds = %702
    %704 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %705 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %706 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %704, i32 signext 0) #6
    br label %707
  
  ; <label>:707                                     ; preds = %703, %702
    %708 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:709                                     ; preds = %575
    %710 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %711 = icmp slt i32 %579, -1
    br i1 %711, label %maint_final.exit, label %712
  
  ; <label>:712                                     ; preds = %709
    %713 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %714 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %713, %714
    %715 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %715, %or.cond7.i
    br i1 %or.cond9.i, label %716, label %maint_final.exit
  
  ; <label>:716                                     ; preds = %712
    %717 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %718 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %717) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %716, %712, %709, %.thread.i, %569
    %.0.i24 = phi i32 [ -1, %569 ], [ -1, %716 ], [ %579, %709 ], [ %changed.0.ph.ph.i, %712 ], [ -7, %.thread.i ]
    %719 = bitcast [8 x i8]* %sigkeyID.i11 to i8*
    %720 = bitcast [8 x i8]* %keyID.i.i to i8*
    %721 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i12) #6
    call void @llvm.lifetime.end(i64 8, i8* %719) #6
    call void @llvm.lifetime.end(i64 8, i8* %720) #6
    call void @llvm.lifetime.end(i64 256, i8* %721) #6
    %722 = icmp slt i32 %.0.i24, 0
    br i1 %722, label %756, label %723
  
  ; <label>:723                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %724 = load i8, i8* @verbose, align 1, !tbaa !6
    %725 = icmp eq i8 %724, 0
    br i1 %725, label %731, label %726
  
  ; <label>:726                                     ; preds = %723
    %727 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %728 = load i32, i32* @totalsize, align 4, !tbaa !10
    %729 = sdiv i32 %728, 1024
    %730 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %727, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %729) #6
    br label %731
  
  ; <label>:731                                     ; preds = %726, %723
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %732 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %733 = icmp eq %struct.bufpool* %732, null
    br i1 %733, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %731, %.lr.ph.i.i25
    %734 = phi %struct.bufpool* [ %738, %.lr.ph.i.i25 ], [ %732, %731 ]
    %735 = bitcast %struct.bufpool* %734 to i32*
    %736 = load i32, i32* %735, align 4, !tbaa !12
    store i32 %736, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %737 = bitcast %struct.bufpool* %734 to i8*
    call void @free(i8* %737) #6
    %738 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %739 = icmp eq %struct.bufpool* %738, null
    br i1 %739, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %731
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %740 = load i8, i8* @verbose, align 1, !tbaa !6
    %741 = icmp eq i8 %740, 0
    br i1 %741, label %.thread164, label %742
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:742                                     ; preds = %endkrent.exit
    %743 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %744 = load i32, i32* @totalsize, align 4, !tbaa !10
    %745 = sdiv i32 %744, 1024
    %746 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %743, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %745) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %747 = icmp eq %struct.bufpool* %.pre, null
    br i1 %747, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %742, %.lr.ph.i.i26
    %748 = phi %struct.bufpool* [ %752, %.lr.ph.i.i26 ], [ %.pre, %742 ]
    %749 = bitcast %struct.bufpool* %748 to i32*
    %750 = load i32, i32* %749, align 4, !tbaa !12
    store i32 %750, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %751 = bitcast %struct.bufpool* %748 to i8*
    call void @free(i8* %751) #6
    %752 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %753 = icmp eq %struct.bufpool* %752, null
    br i1 %753, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %742, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %754 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %755 = add nsw i32 %754, %.0.i24
    br label %791
  
  ; <label>:756                                     ; preds = %maint_final.exit, %510
    %status.0 = phi i32 [ %.0.i, %510 ], [ %.0.i24, %maint_final.exit ]
    %757 = load i8, i8* @verbose, align 1, !tbaa !6
    %758 = icmp eq i8 %757, 0
    br i1 %758, label %.thread, label %759
  
  .thread:                                          ; preds = %756
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %768
  
  ; <label>:759                                     ; preds = %756
    %760 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %761 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %760, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %762 = icmp eq i8 %.pr, 0
    br i1 %762, label %768, label %763
  
  ; <label>:763                                     ; preds = %759
    %764 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %765 = load i32, i32* @totalsize, align 4, !tbaa !10
    %766 = sdiv i32 %765, 1024
    %767 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %764, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %766) #6
    br label %768
  
  ; <label>:768                                     ; preds = %763, %759, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %769 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %770 = icmp eq %struct.bufpool* %769, null
    br i1 %770, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %768, %.lr.ph.i.i27
    %771 = phi %struct.bufpool* [ %775, %.lr.ph.i.i27 ], [ %769, %768 ]
    %772 = bitcast %struct.bufpool* %771 to i32*
    %773 = load i32, i32* %772, align 4, !tbaa !12
    store i32 %773, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %774 = bitcast %struct.bufpool* %771 to i8*
    call void @free(i8* %774) #6
    %775 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %776 = icmp eq %struct.bufpool* %775, null
    br i1 %776, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %768
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %777 = load i8, i8* @verbose, align 1, !tbaa !6
    %778 = icmp eq i8 %777, 0
    br i1 %778, label %.thread165, label %779
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:779                                     ; preds = %endkrent.exit28
    %780 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %781 = load i32, i32* @totalsize, align 4, !tbaa !10
    %782 = sdiv i32 %781, 1024
    %783 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %780, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %782) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %784 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %784, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %779, %.lr.ph.i.i29
    %785 = phi %struct.bufpool* [ %789, %.lr.ph.i.i29 ], [ %.pre163, %779 ]
    %786 = bitcast %struct.bufpool* %785 to i32*
    %787 = load i32, i32* %786, align 4, !tbaa !12
    store i32 %787, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %788 = bitcast %struct.bufpool* %785 to i8*
    call void @free(i8* %788) #6
    %789 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %790 = icmp eq %struct.bufpool* %789, null
    br i1 %790, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %779, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %791
  
  ; <label>:791                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %755, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            maint_update
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%0' }
  - { reg: '%a1', virtual-reg: '%1' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 8):
    liveins: %a0, %a1, %t9, %v0
    liveouts: %v0
  
    %2 = ADDu %v0, %t9
    %1 = COPY %a1
    %0 = COPY %a0
    %3 = LW %2, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SB %zero, killed %3, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into @mverbose, align 4, !tbaa !6)
    %5 = LW %2, target-flags(<unknown>) @check_only, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SB %zero, killed %5, target-flags(<unknown>) @check_only, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into @check_only)
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %6 = LW %2, target-flags(<unknown>) @maintenance, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %7 = ADDiu killed %6, target-flags(<unknown>) @maintenance
    %a0 = COPY %0
    %a1 = COPY %1
    %t9 = COPY %7
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %8 = COPY %v0
    %v0 = COPY %8
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            maintenance
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: gpr32 }
  - { id: 75, class: gpr32 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: gpr32 }
  - { id: 78, class: gpr32 }
  - { id: 79, class: gpr32 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: gpr32 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: gpr32 }
  - { id: 84, class: gpr32 }
  - { id: 85, class: gpr32 }
  - { id: 86, class: gpr32 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: gpr32 }
  - { id: 89, class: gpr32 }
  - { id: 90, class: gpr32 }
  - { id: 91, class: gpr32 }
  - { id: 92, class: gpr32 }
  - { id: 93, class: gpr32 }
  - { id: 94, class: gpr32 }
  - { id: 95, class: gpr32 }
  - { id: 96, class: gpr32 }
  - { id: 97, class: gpr32 }
  - { id: 98, class: gpr32 }
  - { id: 99, class: gpr32 }
  - { id: 100, class: gpr32 }
  - { id: 101, class: gpr32 }
  - { id: 102, class: gpr32 }
  - { id: 103, class: gpr32 }
  - { id: 104, class: gpr32 }
  - { id: 105, class: gpr32 }
  - { id: 106, class: gpr32 }
  - { id: 107, class: gpr32 }
  - { id: 108, class: gpr32 }
  - { id: 109, class: gpr32 }
  - { id: 110, class: gpr32 }
  - { id: 111, class: gpr32 }
  - { id: 112, class: gpr32 }
  - { id: 113, class: gpr32 }
  - { id: 114, class: gpr32 }
  - { id: 115, class: gpr32 }
  - { id: 116, class: gpr32 }
  - { id: 117, class: gpr32 }
  - { id: 118, class: gpr32 }
  - { id: 119, class: gpr32 }
  - { id: 120, class: gpr32 }
  - { id: 121, class: gpr32 }
  - { id: 122, class: gpr32 }
  - { id: 123, class: gpr32 }
  - { id: 124, class: gpr32 }
  - { id: 125, class: gpr32 }
  - { id: 126, class: gpr32 }
  - { id: 127, class: gpr32 }
  - { id: 128, class: gpr32 }
  - { id: 129, class: gpr32 }
  - { id: 130, class: gpr32 }
  - { id: 131, class: gpr32 }
  - { id: 132, class: gpr32 }
  - { id: 133, class: gpr32 }
  - { id: 134, class: gpr32 }
  - { id: 135, class: gpr32 }
  - { id: 136, class: gpr32 }
  - { id: 137, class: gpr32 }
  - { id: 138, class: gpr32 }
  - { id: 139, class: gpr32 }
  - { id: 140, class: gpr32 }
  - { id: 141, class: gpr32 }
  - { id: 142, class: gpr32 }
  - { id: 143, class: gpr32 }
  - { id: 144, class: gpr32 }
  - { id: 145, class: gpr32 }
  - { id: 146, class: gpr32 }
  - { id: 147, class: gpr32 }
  - { id: 148, class: gpr32 }
  - { id: 149, class: gpr32 }
  - { id: 150, class: gpr32 }
  - { id: 151, class: gpr32 }
  - { id: 152, class: gpr32 }
  - { id: 153, class: gpr32 }
  - { id: 154, class: gpr32 }
  - { id: 155, class: gpr32 }
  - { id: 156, class: gpr32 }
  - { id: 157, class: gpr32 }
  - { id: 158, class: gpr32 }
  - { id: 159, class: gpr32 }
  - { id: 160, class: gpr32 }
  - { id: 161, class: gpr32 }
  - { id: 162, class: gpr32 }
  - { id: 163, class: gpr32 }
  - { id: 164, class: gpr32 }
  - { id: 165, class: gpr32 }
  - { id: 166, class: gpr32 }
  - { id: 167, class: gpr32 }
  - { id: 168, class: gpr32 }
  - { id: 169, class: gpr32 }
  - { id: 170, class: gpr32 }
  - { id: 171, class: gpr32 }
  - { id: 172, class: gpr32 }
  - { id: 173, class: gpr32 }
  - { id: 174, class: gpr32 }
  - { id: 175, class: gpr32 }
  - { id: 176, class: gpr32 }
  - { id: 177, class: gpr32 }
  - { id: 178, class: gpr32 }
  - { id: 179, class: gpr32 }
  - { id: 180, class: gpr32 }
  - { id: 181, class: gpr32 }
  - { id: 182, class: gpr32 }
  - { id: 183, class: gpr32 }
  - { id: 184, class: gpr32 }
  - { id: 185, class: gpr32 }
  - { id: 186, class: gpr32 }
  - { id: 187, class: gpr32 }
  - { id: 188, class: gpr32 }
  - { id: 189, class: gpr32 }
  - { id: 190, class: gpr32 }
  - { id: 191, class: gpr32 }
  - { id: 192, class: gpr32 }
  - { id: 193, class: gpr32 }
  - { id: 194, class: gpr32 }
  - { id: 195, class: gpr32 }
  - { id: 196, class: gpr32 }
  - { id: 197, class: gpr32 }
  - { id: 198, class: gpr32 }
  - { id: 199, class: gpr32 }
  - { id: 200, class: gpr32 }
  - { id: 201, class: gpr32 }
  - { id: 202, class: gpr32 }
  - { id: 203, class: gpr32 }
  - { id: 204, class: gpr32 }
  - { id: 205, class: gpr32 }
  - { id: 206, class: gpr32 }
  - { id: 207, class: gpr32 }
  - { id: 208, class: gpr32 }
  - { id: 209, class: gpr32 }
  - { id: 210, class: gpr32 }
  - { id: 211, class: gpr32 }
  - { id: 212, class: gpr32 }
  - { id: 213, class: gpr32 }
  - { id: 214, class: gpr32 }
  - { id: 215, class: gpr32 }
  - { id: 216, class: gpr32 }
  - { id: 217, class: gpr32 }
  - { id: 218, class: gpr32 }
  - { id: 219, class: gpr32 }
  - { id: 220, class: gpr32 }
  - { id: 221, class: gpr32 }
  - { id: 222, class: gpr32 }
  - { id: 223, class: gpr32 }
  - { id: 224, class: gpr32 }
  - { id: 225, class: gpr32 }
  - { id: 226, class: gpr32 }
  - { id: 227, class: gpr32 }
  - { id: 228, class: gpr32 }
  - { id: 229, class: gpr32 }
  - { id: 230, class: gpr32 }
  - { id: 231, class: gpr32 }
  - { id: 232, class: gpr32 }
  - { id: 233, class: gpr32 }
  - { id: 234, class: gpr32 }
  - { id: 235, class: gpr32 }
  - { id: 236, class: gpr32 }
  - { id: 237, class: gpr32 }
  - { id: 238, class: gpr32 }
  - { id: 239, class: gpr32 }
  - { id: 240, class: gpr32 }
  - { id: 241, class: gpr32 }
  - { id: 242, class: gpr32 }
  - { id: 243, class: gpr32 }
  - { id: 244, class: gpr32 }
  - { id: 245, class: gpr32 }
  - { id: 246, class: gpr32 }
  - { id: 247, class: gpr32 }
  - { id: 248, class: gpr32 }
  - { id: 249, class: gpr32 }
  - { id: 250, class: gpr32 }
  - { id: 251, class: gpr32 }
  - { id: 252, class: gpr32 }
  - { id: 253, class: gpr32 }
  - { id: 254, class: gpr32 }
  - { id: 255, class: gpr32 }
  - { id: 256, class: gpr32 }
  - { id: 257, class: gpr32 }
  - { id: 258, class: gpr32 }
  - { id: 259, class: gpr32 }
  - { id: 260, class: gpr32 }
  - { id: 261, class: gpr32 }
  - { id: 262, class: gpr32 }
  - { id: 263, class: gpr32 }
  - { id: 264, class: gpr32 }
  - { id: 265, class: gpr32 }
  - { id: 266, class: gpr32 }
  - { id: 267, class: gpr32 }
  - { id: 268, class: gpr32 }
  - { id: 269, class: gpr32 }
  - { id: 270, class: gpr32 }
  - { id: 271, class: gpr32 }
  - { id: 272, class: gpr32 }
  - { id: 273, class: gpr32 }
  - { id: 274, class: gpr32 }
  - { id: 275, class: gpr32 }
  - { id: 276, class: gpr32 }
  - { id: 277, class: gpr32 }
  - { id: 278, class: gpr32 }
  - { id: 279, class: gpr32 }
  - { id: 280, class: gpr32 }
  - { id: 281, class: gpr32 }
  - { id: 282, class: gpr32 }
  - { id: 283, class: gpr32 }
  - { id: 284, class: gpr32 }
  - { id: 285, class: gpr32 }
  - { id: 286, class: gpr32 }
  - { id: 287, class: gpr32 }
  - { id: 288, class: gpr32 }
  - { id: 289, class: gpr32 }
  - { id: 290, class: gpr32 }
  - { id: 291, class: gpr32 }
  - { id: 292, class: gpr32 }
  - { id: 293, class: gpr32 }
  - { id: 294, class: gpr32 }
  - { id: 295, class: gpr32 }
  - { id: 296, class: gpr32 }
  - { id: 297, class: gpr32 }
  - { id: 298, class: gpr32 }
  - { id: 299, class: gpr32 }
  - { id: 300, class: gpr32 }
  - { id: 301, class: gpr32 }
  - { id: 302, class: gpr32 }
  - { id: 303, class: gpr32 }
  - { id: 304, class: gpr32 }
  - { id: 305, class: gpr32 }
  - { id: 306, class: gpr32 }
  - { id: 307, class: gpr32 }
  - { id: 308, class: gpr32 }
  - { id: 309, class: gpr32 }
  - { id: 310, class: gpr32 }
  - { id: 311, class: gpr32 }
  - { id: 312, class: gpr32 }
  - { id: 313, class: gpr32 }
  - { id: 314, class: gpr32 }
  - { id: 315, class: gpr32 }
  - { id: 316, class: gpr32 }
  - { id: 317, class: gpr32 }
  - { id: 318, class: gpr32 }
  - { id: 319, class: gpr32 }
  - { id: 320, class: gpr32 }
  - { id: 321, class: gpr32 }
  - { id: 322, class: gpr32 }
  - { id: 323, class: gpr32 }
  - { id: 324, class: gpr32 }
  - { id: 325, class: gpr32 }
  - { id: 326, class: gpr32 }
  - { id: 327, class: gpr32 }
  - { id: 328, class: gpr32 }
  - { id: 329, class: gpr32 }
  - { id: 330, class: gpr32 }
  - { id: 331, class: gpr32 }
  - { id: 332, class: gpr32 }
  - { id: 333, class: gpr32 }
  - { id: 334, class: gpr32 }
  - { id: 335, class: gpr32 }
  - { id: 336, class: gpr32 }
  - { id: 337, class: gpr32 }
  - { id: 338, class: gpr32 }
  - { id: 339, class: gpr32 }
  - { id: 340, class: gpr32 }
  - { id: 341, class: gpr32 }
  - { id: 342, class: gpr32 }
  - { id: 343, class: gpr32 }
  - { id: 344, class: gpr32 }
  - { id: 345, class: gpr32 }
  - { id: 346, class: gpr32 }
  - { id: 347, class: gpr32 }
  - { id: 348, class: gpr32 }
  - { id: 349, class: gpr32 }
  - { id: 350, class: gpr32 }
  - { id: 351, class: gpr32 }
  - { id: 352, class: gpr32 }
  - { id: 353, class: gpr32 }
  - { id: 354, class: gpr32 }
  - { id: 355, class: gpr32 }
  - { id: 356, class: gpr32 }
  - { id: 357, class: gpr32 }
  - { id: 358, class: gpr32 }
  - { id: 359, class: gpr32 }
  - { id: 360, class: gpr32 }
  - { id: 361, class: gpr32 }
  - { id: 362, class: gpr32 }
  - { id: 363, class: gpr32 }
  - { id: 364, class: gpr32 }
  - { id: 365, class: gpr32 }
  - { id: 366, class: gpr32 }
  - { id: 367, class: gpr32 }
  - { id: 368, class: gpr32 }
  - { id: 369, class: gpr32 }
  - { id: 370, class: gpr32 }
  - { id: 371, class: gpr32 }
  - { id: 372, class: gpr32 }
  - { id: 373, class: gpr32 }
  - { id: 374, class: gpr32 }
  - { id: 375, class: gpr32 }
  - { id: 376, class: gpr32 }
  - { id: 377, class: gpr32 }
  - { id: 378, class: gpr32 }
  - { id: 379, class: gpr32 }
  - { id: 380, class: gpr32 }
  - { id: 381, class: gpr32 }
  - { id: 382, class: gpr32 }
  - { id: 383, class: gpr32 }
  - { id: 384, class: gpr32 }
  - { id: 385, class: gpr32 }
  - { id: 386, class: gpr32 }
  - { id: 387, class: gpr32 }
  - { id: 388, class: gpr32 }
  - { id: 389, class: gpr32 }
  - { id: 390, class: gpr32 }
  - { id: 391, class: gpr32 }
  - { id: 392, class: gpr32 }
  - { id: 393, class: gpr32 }
  - { id: 394, class: gpr32 }
  - { id: 395, class: gpr32 }
  - { id: 396, class: gpr32 }
  - { id: 397, class: gpr32 }
  - { id: 398, class: gpr32 }
  - { id: 399, class: gpr32 }
  - { id: 400, class: gpr32 }
  - { id: 401, class: gpr32 }
  - { id: 402, class: gpr32 }
  - { id: 403, class: gpr32 }
  - { id: 404, class: gpr32 }
  - { id: 405, class: gpr32 }
  - { id: 406, class: gpr32 }
  - { id: 407, class: gpr32 }
  - { id: 408, class: gpr32 }
  - { id: 409, class: gpr32 }
  - { id: 410, class: gpr32 }
  - { id: 411, class: gpr32 }
  - { id: 412, class: gpr32 }
  - { id: 413, class: gpr32 }
  - { id: 414, class: gpr32 }
  - { id: 415, class: gpr32 }
  - { id: 416, class: gpr32 }
  - { id: 417, class: gpr32 }
  - { id: 418, class: gpr32 }
  - { id: 419, class: gpr32 }
  - { id: 420, class: gpr32 }
  - { id: 421, class: gpr32 }
  - { id: 422, class: gpr32 }
  - { id: 423, class: gpr32 }
  - { id: 424, class: gpr32 }
  - { id: 425, class: gpr32 }
  - { id: 426, class: gpr32 }
  - { id: 427, class: gpr32 }
  - { id: 428, class: gpr32 }
  - { id: 429, class: gpr32 }
  - { id: 430, class: gpr32 }
  - { id: 431, class: gpr32 }
  - { id: 432, class: gpr32 }
  - { id: 433, class: gpr32 }
  - { id: 434, class: gpr32 }
  - { id: 435, class: gpr32 }
  - { id: 436, class: gpr32 }
  - { id: 437, class: gpr32 }
  - { id: 438, class: gpr32 }
  - { id: 439, class: gpr32 }
  - { id: 440, class: gpr32 }
  - { id: 441, class: gpr32 }
  - { id: 442, class: gpr32 }
  - { id: 443, class: gpr32 }
  - { id: 444, class: gpr32 }
  - { id: 445, class: gpr32 }
  - { id: 446, class: gpr32 }
  - { id: 447, class: gpr32 }
  - { id: 448, class: gpr32 }
  - { id: 449, class: gpr32 }
  - { id: 450, class: gpr32 }
  - { id: 451, class: gpr32 }
  - { id: 452, class: gpr32 }
  - { id: 453, class: gpr32 }
  - { id: 454, class: gpr32 }
  - { id: 455, class: gpr32 }
  - { id: 456, class: gpr32 }
  - { id: 457, class: gpr32 }
  - { id: 458, class: gpr32 }
  - { id: 459, class: gpr32 }
  - { id: 460, class: gpr32 }
  - { id: 461, class: gpr32 }
  - { id: 462, class: gpr32 }
  - { id: 463, class: gpr32 }
  - { id: 464, class: gpr32 }
  - { id: 465, class: gpr32 }
  - { id: 466, class: gpr32 }
  - { id: 467, class: gpr32 }
  - { id: 468, class: gpr32 }
  - { id: 469, class: gpr32 }
  - { id: 470, class: gpr32 }
  - { id: 471, class: gpr32 }
  - { id: 472, class: gpr32 }
  - { id: 473, class: gpr32 }
  - { id: 474, class: gpr32 }
  - { id: 475, class: gpr32 }
  - { id: 476, class: gpr32 }
  - { id: 477, class: gpr32 }
  - { id: 478, class: gpr32 }
  - { id: 479, class: gpr32 }
  - { id: 480, class: gpr32 }
  - { id: 481, class: gpr32 }
  - { id: 482, class: gpr32 }
  - { id: 483, class: gpr32 }
  - { id: 484, class: gpr32 }
  - { id: 485, class: gpr32 }
  - { id: 486, class: gpr32 }
  - { id: 487, class: gpr32 }
  - { id: 488, class: gpr32 }
  - { id: 489, class: gpr32 }
  - { id: 490, class: gpr32 }
  - { id: 491, class: gpr32 }
  - { id: 492, class: gpr32 }
  - { id: 493, class: gpr32 }
  - { id: 494, class: gpr32 }
  - { id: 495, class: gpr32 }
  - { id: 496, class: gpr32 }
  - { id: 497, class: gpr32 }
  - { id: 498, class: gpr32 }
  - { id: 499, class: gpr32 }
  - { id: 500, class: gpr32 }
  - { id: 501, class: gpr32 }
  - { id: 502, class: gpr32 }
  - { id: 503, class: gpr32 }
  - { id: 504, class: gpr32 }
  - { id: 505, class: gpr32 }
  - { id: 506, class: gpr32 }
  - { id: 507, class: gpr32 }
  - { id: 508, class: gpr32 }
  - { id: 509, class: gpr32 }
  - { id: 510, class: gpr32 }
  - { id: 511, class: gpr32 }
  - { id: 512, class: gpr32 }
  - { id: 513, class: gpr32 }
  - { id: 514, class: gpr32 }
  - { id: 515, class: gpr32 }
  - { id: 516, class: gpr32 }
  - { id: 517, class: gpr32 }
  - { id: 518, class: gpr32 }
  - { id: 519, class: gpr32 }
  - { id: 520, class: gpr32 }
  - { id: 521, class: gpr32 }
  - { id: 522, class: gpr32 }
  - { id: 523, class: gpr32 }
  - { id: 524, class: gpr32 }
  - { id: 525, class: gpr32 }
  - { id: 526, class: gpr32 }
  - { id: 527, class: gpr32 }
  - { id: 528, class: gpr32 }
  - { id: 529, class: gpr32 }
  - { id: 530, class: gpr32 }
  - { id: 531, class: gpr32 }
  - { id: 532, class: gpr32 }
  - { id: 533, class: gpr32 }
  - { id: 534, class: gpr32 }
  - { id: 535, class: gpr32 }
  - { id: 536, class: gpr32 }
  - { id: 537, class: gpr32 }
  - { id: 538, class: gpr32 }
  - { id: 539, class: gpr32 }
  - { id: 540, class: gpr32 }
  - { id: 541, class: gpr32 }
  - { id: 542, class: gpr32 }
  - { id: 543, class: gpr32 }
  - { id: 544, class: gpr32 }
  - { id: 545, class: gpr32 }
  - { id: 546, class: gpr32 }
  - { id: 547, class: gpr32 }
  - { id: 548, class: gpr32 }
  - { id: 549, class: gpr32 }
  - { id: 550, class: gpr32 }
  - { id: 551, class: gpr32 }
  - { id: 552, class: gpr32 }
  - { id: 553, class: gpr32 }
  - { id: 554, class: gpr32 }
  - { id: 555, class: gpr32 }
  - { id: 556, class: gpr32 }
  - { id: 557, class: gpr32 }
  - { id: 558, class: gpr32 }
  - { id: 559, class: gpr32 }
  - { id: 560, class: gpr32 }
  - { id: 561, class: gpr32 }
  - { id: 562, class: gpr32 }
  - { id: 563, class: gpr32 }
  - { id: 564, class: gpr32 }
  - { id: 565, class: gpr32 }
  - { id: 566, class: gpr32 }
  - { id: 567, class: gpr32 }
  - { id: 568, class: gpr32 }
  - { id: 569, class: gpr32 }
  - { id: 570, class: gpr32 }
  - { id: 571, class: gpr32 }
  - { id: 572, class: gpr32 }
  - { id: 573, class: gpr32 }
  - { id: 574, class: gpr32 }
  - { id: 575, class: gpr32 }
  - { id: 576, class: gpr32 }
  - { id: 577, class: gpr32 }
  - { id: 578, class: gpr32 }
  - { id: 579, class: gpr32 }
  - { id: 580, class: gpr32 }
  - { id: 581, class: gpr32 }
  - { id: 582, class: gpr32 }
  - { id: 583, class: gpr32 }
  - { id: 584, class: gpr32 }
  - { id: 585, class: gpr32 }
  - { id: 586, class: gpr32 }
  - { id: 587, class: gpr32 }
  - { id: 588, class: gpr32 }
  - { id: 589, class: gpr32 }
  - { id: 590, class: gpr32 }
  - { id: 591, class: gpr32 }
  - { id: 592, class: gpr32 }
  - { id: 593, class: gpr32 }
  - { id: 594, class: gpr32 }
  - { id: 595, class: gpr32 }
  - { id: 596, class: gpr32 }
  - { id: 597, class: gpr32 }
  - { id: 598, class: gpr32 }
  - { id: 599, class: gpr32 }
  - { id: 600, class: gpr32 }
  - { id: 601, class: gpr32 }
  - { id: 602, class: gpr32 }
  - { id: 603, class: gpr32 }
  - { id: 604, class: gpr32 }
  - { id: 605, class: gpr32 }
  - { id: 606, class: gpr32 }
  - { id: 607, class: gpr32 }
  - { id: 608, class: gpr32 }
  - { id: 609, class: gpr32 }
  - { id: 610, class: gpr32 }
  - { id: 611, class: gpr32 }
  - { id: 612, class: gpr32 }
  - { id: 613, class: gpr32 }
  - { id: 614, class: gpr32 }
  - { id: 615, class: gpr32 }
  - { id: 616, class: gpr32 }
  - { id: 617, class: gpr32 }
  - { id: 618, class: gpr32 }
  - { id: 619, class: gpr32 }
  - { id: 620, class: gpr32 }
  - { id: 621, class: gpr32 }
  - { id: 622, class: gpr32 }
  - { id: 623, class: gpr32 }
  - { id: 624, class: gpr32 }
  - { id: 625, class: gpr32 }
  - { id: 626, class: gpr32 }
  - { id: 627, class: gpr32 }
  - { id: 628, class: gpr32 }
  - { id: 629, class: gpr32 }
  - { id: 630, class: gpr32 }
  - { id: 631, class: gpr32 }
  - { id: 632, class: gpr32 }
  - { id: 633, class: gpr32 }
  - { id: 634, class: gpr32 }
  - { id: 635, class: gpr32 }
  - { id: 636, class: gpr32 }
  - { id: 637, class: gpr32 }
  - { id: 638, class: gpr32 }
  - { id: 639, class: gpr32 }
  - { id: 640, class: gpr32 }
  - { id: 641, class: gpr32 }
  - { id: 642, class: gpr32 }
  - { id: 643, class: gpr32 }
  - { id: 644, class: gpr32 }
  - { id: 645, class: gpr32 }
  - { id: 646, class: gpr32 }
  - { id: 647, class: gpr32 }
  - { id: 648, class: gpr32 }
  - { id: 649, class: gpr32 }
  - { id: 650, class: gpr32 }
  - { id: 651, class: gpr32 }
  - { id: 652, class: gpr32 }
  - { id: 653, class: gpr32 }
  - { id: 654, class: gpr32 }
  - { id: 655, class: gpr32 }
  - { id: 656, class: gpr32 }
  - { id: 657, class: gpr32 }
  - { id: 658, class: gpr32 }
  - { id: 659, class: gpr32 }
  - { id: 660, class: gpr32 }
  - { id: 661, class: gpr32 }
  - { id: 662, class: gpr32 }
  - { id: 663, class: gpr32 }
  - { id: 664, class: gpr32 }
  - { id: 665, class: gpr32 }
  - { id: 666, class: gpr32 }
  - { id: 667, class: gpr32 }
  - { id: 668, class: gpr32 }
  - { id: 669, class: gpr32 }
  - { id: 670, class: gpr32 }
  - { id: 671, class: gpr32 }
  - { id: 672, class: gpr32 }
  - { id: 673, class: gpr32 }
  - { id: 674, class: gpr32 }
  - { id: 675, class: gpr32 }
  - { id: 676, class: gpr32 }
  - { id: 677, class: gpr32 }
  - { id: 678, class: gpr32 }
  - { id: 679, class: gpr32 }
  - { id: 680, class: gpr32 }
  - { id: 681, class: gpr32 }
  - { id: 682, class: gpr32 }
  - { id: 683, class: gpr32 }
  - { id: 684, class: gpr32 }
  - { id: 685, class: gpr32 }
  - { id: 686, class: gpr32 }
  - { id: 687, class: gpr32 }
  - { id: 688, class: gpr32 }
  - { id: 689, class: gpr32 }
  - { id: 690, class: gpr32 }
  - { id: 691, class: gpr32 }
  - { id: 692, class: gpr32 }
  - { id: 693, class: gpr32 }
  - { id: 694, class: gpr32 }
  - { id: 695, class: gpr32 }
  - { id: 696, class: gpr32 }
  - { id: 697, class: gpr32 }
  - { id: 698, class: gpr32 }
  - { id: 699, class: gpr32 }
  - { id: 700, class: gpr32 }
  - { id: 701, class: gpr32 }
  - { id: 702, class: gpr32 }
  - { id: 703, class: gpr32 }
  - { id: 704, class: gpr32 }
  - { id: 705, class: gpr32 }
  - { id: 706, class: gpr32 }
  - { id: 707, class: gpr32 }
  - { id: 708, class: gpr32 }
  - { id: 709, class: gpr32 }
  - { id: 710, class: gpr32 }
  - { id: 711, class: gpr32 }
  - { id: 712, class: gpr32 }
  - { id: 713, class: gpr32 }
  - { id: 714, class: gpr32 }
  - { id: 715, class: gpr32 }
  - { id: 716, class: gpr32 }
  - { id: 717, class: gpr32 }
  - { id: 718, class: gpr32 }
  - { id: 719, class: gpr32 }
  - { id: 720, class: gpr32 }
  - { id: 721, class: gpr32 }
  - { id: 722, class: gpr32 }
  - { id: 723, class: gpr32 }
  - { id: 724, class: gpr32 }
  - { id: 725, class: gpr32 }
  - { id: 726, class: gpr32 }
  - { id: 727, class: gpr32 }
  - { id: 728, class: gpr32 }
  - { id: 729, class: gpr32 }
  - { id: 730, class: gpr32 }
  - { id: 731, class: gpr32 }
  - { id: 732, class: gpr32 }
  - { id: 733, class: gpr32 }
  - { id: 734, class: gpr32 }
  - { id: 735, class: gpr32 }
  - { id: 736, class: gpr32 }
  - { id: 737, class: gpr32 }
  - { id: 738, class: gpr32 }
  - { id: 739, class: gpr32 }
  - { id: 740, class: gpr32 }
  - { id: 741, class: gpr32 }
  - { id: 742, class: gpr32 }
  - { id: 743, class: gpr32 }
  - { id: 744, class: gpr32 }
  - { id: 745, class: gpr32 }
  - { id: 746, class: gpr32 }
  - { id: 747, class: gpr32 }
  - { id: 748, class: gpr32 }
  - { id: 749, class: gpr32 }
  - { id: 750, class: gpr32 }
  - { id: 751, class: gpr32 }
  - { id: 752, class: gpr32 }
  - { id: 753, class: gpr32 }
  - { id: 754, class: gpr32 }
  - { id: 755, class: gpr32 }
  - { id: 756, class: gpr32 }
  - { id: 757, class: gpr32 }
  - { id: 758, class: gpr32 }
  - { id: 759, class: gpr32 }
  - { id: 760, class: gpr32 }
  - { id: 761, class: gpr32 }
  - { id: 762, class: gpr32 }
  - { id: 763, class: gpr32 }
  - { id: 764, class: gpr32 }
  - { id: 765, class: gpr32 }
  - { id: 766, class: gpr32 }
  - { id: 767, class: gpr32 }
  - { id: 768, class: gpr32 }
  - { id: 769, class: gpr32 }
  - { id: 770, class: gpr32 }
  - { id: 771, class: gpr32 }
  - { id: 772, class: gpr32 }
  - { id: 773, class: gpr32 }
  - { id: 774, class: gpr32 }
  - { id: 775, class: gpr32 }
  - { id: 776, class: gpr32 }
  - { id: 777, class: gpr32 }
  - { id: 778, class: gpr32 }
  - { id: 779, class: gpr32 }
  - { id: 780, class: gpr32 }
  - { id: 781, class: gpr32 }
  - { id: 782, class: gpr32 }
  - { id: 783, class: gpr32 }
  - { id: 784, class: gpr32 }
  - { id: 785, class: gpr32 }
  - { id: 786, class: gpr32 }
  - { id: 787, class: gpr32 }
  - { id: 788, class: gpr32 }
  - { id: 789, class: gpr32 }
  - { id: 790, class: gpr32 }
  - { id: 791, class: gpr32 }
  - { id: 792, class: gpr32 }
  - { id: 793, class: gpr32 }
  - { id: 794, class: gpr32 }
  - { id: 795, class: gpr32 }
  - { id: 796, class: gpr32 }
  - { id: 797, class: gpr32 }
  - { id: 798, class: gpr32 }
  - { id: 799, class: gpr32 }
  - { id: 800, class: gpr32 }
  - { id: 801, class: gpr32 }
  - { id: 802, class: gpr32 }
  - { id: 803, class: gpr32 }
  - { id: 804, class: gpr32 }
  - { id: 805, class: gpr32 }
  - { id: 806, class: gpr32 }
  - { id: 807, class: gpr32 }
  - { id: 808, class: gpr32 }
  - { id: 809, class: gpr32 }
  - { id: 810, class: gpr32 }
  - { id: 811, class: gpr32 }
  - { id: 812, class: gpr32 }
  - { id: 813, class: gpr32 }
  - { id: 814, class: gpr32 }
  - { id: 815, class: gpr32 }
  - { id: 816, class: gpr32 }
  - { id: 817, class: gpr32 }
  - { id: 818, class: gpr32 }
  - { id: 819, class: gpr32 }
  - { id: 820, class: gpr32 }
  - { id: 821, class: gpr32 }
  - { id: 822, class: gpr32 }
  - { id: 823, class: gpr32 }
  - { id: 824, class: gpr32 }
  - { id: 825, class: gpr32 }
  - { id: 826, class: gpr32 }
  - { id: 827, class: gpr32 }
  - { id: 828, class: gpr32 }
  - { id: 829, class: gpr32 }
  - { id: 830, class: gpr32 }
  - { id: 831, class: gpr32 }
  - { id: 832, class: gpr32 }
  - { id: 833, class: gpr32 }
  - { id: 834, class: gpr32 }
  - { id: 835, class: gpr32 }
  - { id: 836, class: gpr32 }
  - { id: 837, class: gpr32 }
  - { id: 838, class: gpr32 }
  - { id: 839, class: gpr32 }
  - { id: 840, class: gpr32 }
  - { id: 841, class: gpr32 }
  - { id: 842, class: gpr32 }
  - { id: 843, class: gpr32 }
  - { id: 844, class: gpr32 }
  - { id: 845, class: gpr32 }
  - { id: 846, class: gpr32 }
  - { id: 847, class: gpr32 }
  - { id: 848, class: gpr32 }
  - { id: 849, class: gpr32 }
  - { id: 850, class: gpr32 }
  - { id: 851, class: gpr32 }
  - { id: 852, class: gpr32 }
  - { id: 853, class: gpr32 }
  - { id: 854, class: gpr32 }
  - { id: 855, class: gpr32 }
  - { id: 856, class: gpr32 }
  - { id: 857, class: gpr32 }
  - { id: 858, class: gpr32 }
  - { id: 859, class: gpr32 }
  - { id: 860, class: gpr32 }
  - { id: 861, class: gpr32 }
  - { id: 862, class: gpr32 }
  - { id: 863, class: gpr32 }
  - { id: 864, class: gpr32 }
  - { id: 865, class: gpr32 }
  - { id: 866, class: gpr32 }
  - { id: 867, class: gpr32 }
  - { id: 868, class: gpr32 }
  - { id: 869, class: gpr32 }
  - { id: 870, class: gpr32 }
  - { id: 871, class: gpr32 }
  - { id: 872, class: gpr32 }
  - { id: 873, class: gpr32 }
  - { id: 874, class: gpr32 }
  - { id: 875, class: gpr32 }
  - { id: 876, class: gpr32 }
  - { id: 877, class: gpr32 }
  - { id: 878, class: gpr32 }
  - { id: 879, class: gpr32 }
  - { id: 880, class: gpr32 }
  - { id: 881, class: gpr32 }
  - { id: 882, class: gpr32 }
  - { id: 883, class: gpr32 }
  - { id: 884, class: gpr32 }
  - { id: 885, class: gpr32 }
  - { id: 886, class: gpr32 }
  - { id: 887, class: gpr32 }
  - { id: 888, class: gpr32 }
  - { id: 889, class: gpr32 }
  - { id: 890, class: gpr32 }
  - { id: 891, class: gpr32 }
  - { id: 892, class: gpr32 }
  - { id: 893, class: gpr32 }
  - { id: 894, class: gpr32 }
  - { id: 895, class: gpr32 }
  - { id: 896, class: gpr32 }
  - { id: 897, class: gpr32 }
  - { id: 898, class: gpr32 }
  - { id: 899, class: gpr32 }
  - { id: 900, class: gpr32 }
  - { id: 901, class: gpr32 }
  - { id: 902, class: gpr32 }
  - { id: 903, class: gpr32 }
  - { id: 904, class: gpr32 }
  - { id: 905, class: gpr32 }
  - { id: 906, class: gpr32 }
  - { id: 907, class: gpr32 }
  - { id: 908, class: gpr32 }
  - { id: 909, class: gpr32 }
  - { id: 910, class: gpr32 }
  - { id: 911, class: gpr32 }
  - { id: 912, class: gpr32 }
  - { id: 913, class: gpr32 }
  - { id: 914, class: gpr32 }
  - { id: 915, class: gpr32 }
  - { id: 916, class: gpr32 }
  - { id: 917, class: gpr32 }
  - { id: 918, class: gpr32 }
  - { id: 919, class: gpr32 }
  - { id: 920, class: gpr32 }
  - { id: 921, class: gpr32 }
  - { id: 922, class: gpr32 }
  - { id: 923, class: gpr32 }
  - { id: 924, class: gpr32 }
  - { id: 925, class: gpr32 }
  - { id: 926, class: gpr32 }
  - { id: 927, class: gpr32 }
  - { id: 928, class: gpr32 }
  - { id: 929, class: gpr32 }
  - { id: 930, class: gpr32 }
  - { id: 931, class: gpr32 }
  - { id: 932, class: gpr32 }
  - { id: 933, class: gpr32 }
  - { id: 934, class: gpr32 }
  - { id: 935, class: gpr32 }
  - { id: 936, class: gpr32 }
  - { id: 937, class: gpr32 }
  - { id: 938, class: gpr32 }
  - { id: 939, class: gpr32 }
  - { id: 940, class: gpr32 }
  - { id: 941, class: gpr32 }
  - { id: 942, class: gpr32 }
  - { id: 943, class: gpr32 }
  - { id: 944, class: gpr32 }
  - { id: 945, class: gpr32 }
  - { id: 946, class: gpr32 }
  - { id: 947, class: gpr32 }
  - { id: 948, class: gpr32 }
  - { id: 949, class: gpr32 }
  - { id: 950, class: gpr32 }
  - { id: 951, class: gpr32 }
  - { id: 952, class: gpr32 }
  - { id: 953, class: gpr32 }
  - { id: 954, class: gpr32 }
  - { id: 955, class: gpr32 }
  - { id: 956, class: gpr32 }
  - { id: 957, class: gpr32 }
  - { id: 958, class: gpr32 }
  - { id: 959, class: gpr32 }
  - { id: 960, class: gpr32 }
  - { id: 961, class: gpr32 }
  - { id: 962, class: gpr32 }
  - { id: 963, class: gpr32 }
  - { id: 964, class: gpr32 }
  - { id: 965, class: gpr32 }
  - { id: 966, class: gpr32 }
  - { id: 967, class: gpr32 }
  - { id: 968, class: gpr32 }
  - { id: 969, class: gpr32 }
  - { id: 970, class: gpr32 }
  - { id: 971, class: gpr32 }
  - { id: 972, class: gpr32 }
  - { id: 973, class: gpr32 }
  - { id: 974, class: gpr32 }
  - { id: 975, class: gpr32 }
  - { id: 976, class: gpr32 }
  - { id: 977, class: gpr32 }
  - { id: 978, class: gpr32 }
  - { id: 979, class: gpr32 }
  - { id: 980, class: gpr32 }
  - { id: 981, class: gpr32 }
  - { id: 982, class: gpr32 }
  - { id: 983, class: gpr32 }
  - { id: 984, class: gpr32 }
  - { id: 985, class: gpr32 }
  - { id: 986, class: gpr32 }
  - { id: 987, class: gpr32 }
  - { id: 988, class: gpr32 }
  - { id: 989, class: gpr32 }
  - { id: 990, class: gpr32 }
  - { id: 991, class: gpr32 }
  - { id: 992, class: gpr32 }
  - { id: 993, class: gpr32 }
  - { id: 994, class: gpr32 }
  - { id: 995, class: gpr32 }
  - { id: 996, class: gpr32 }
  - { id: 997, class: gpr32 }
  - { id: 998, class: gpr32 }
  - { id: 999, class: gpr32 }
  - { id: 1000, class: gpr32 }
  - { id: 1001, class: gpr32 }
  - { id: 1002, class: gpr32 }
  - { id: 1003, class: gpr32 }
  - { id: 1004, class: gpr32 }
  - { id: 1005, class: gpr32 }
  - { id: 1006, class: gpr32 }
  - { id: 1007, class: gpr32 }
  - { id: 1008, class: gpr32 }
  - { id: 1009, class: gpr32 }
  - { id: 1010, class: gpr32 }
  - { id: 1011, class: gpr32 }
  - { id: 1012, class: gpr32 }
  - { id: 1013, class: gpr32 }
  - { id: 1014, class: gpr32 }
  - { id: 1015, class: gpr32 }
  - { id: 1016, class: gpr32 }
  - { id: 1017, class: gpr32 }
  - { id: 1018, class: gpr32 }
  - { id: 1019, class: gpr32 }
  - { id: 1020, class: gpr32 }
  - { id: 1021, class: gpr32 }
  - { id: 1022, class: gpr32 }
  - { id: 1023, class: gpr32 }
  - { id: 1024, class: gpr32 }
  - { id: 1025, class: gpr32 }
  - { id: 1026, class: gpr32 }
  - { id: 1027, class: gpr32 }
  - { id: 1028, class: gpr32 }
  - { id: 1029, class: gpr32 }
  - { id: 1030, class: gpr32 }
  - { id: 1031, class: gpr32 }
  - { id: 1032, class: gpr32 }
  - { id: 1033, class: gpr32 }
  - { id: 1034, class: gpr32 }
  - { id: 1035, class: gpr32 }
  - { id: 1036, class: gpr32 }
  - { id: 1037, class: gpr32 }
  - { id: 1038, class: gpr32 }
  - { id: 1039, class: gpr32 }
  - { id: 1040, class: gpr32 }
  - { id: 1041, class: gpr32 }
  - { id: 1042, class: gpr32 }
  - { id: 1043, class: gpr32 }
  - { id: 1044, class: gpr32 }
  - { id: 1045, class: gpr32 }
  - { id: 1046, class: gpr32 }
  - { id: 1047, class: gpr32 }
  - { id: 1048, class: gpr32 }
  - { id: 1049, class: gpr32 }
  - { id: 1050, class: gpr32 }
  - { id: 1051, class: gpr32 }
  - { id: 1052, class: gpr32 }
  - { id: 1053, class: gpr32 }
  - { id: 1054, class: gpr32 }
  - { id: 1055, class: gpr32 }
  - { id: 1056, class: gpr32 }
  - { id: 1057, class: gpr32 }
  - { id: 1058, class: gpr32 }
  - { id: 1059, class: gpr32 }
  - { id: 1060, class: gpr32 }
  - { id: 1061, class: gpr32 }
  - { id: 1062, class: gpr32 }
  - { id: 1063, class: gpr32 }
  - { id: 1064, class: gpr32 }
  - { id: 1065, class: gpr32 }
  - { id: 1066, class: gpr32 }
  - { id: 1067, class: gpr32 }
  - { id: 1068, class: gpr32 }
  - { id: 1069, class: gpr32 }
  - { id: 1070, class: gpr32 }
  - { id: 1071, class: gpr32 }
  - { id: 1072, class: gpr32 }
  - { id: 1073, class: gpr32 }
  - { id: 1074, class: gpr32 }
  - { id: 1075, class: gpr32 }
  - { id: 1076, class: gpr32 }
  - { id: 1077, class: gpr32 }
  - { id: 1078, class: gpr32 }
  - { id: 1079, class: gpr32 }
  - { id: 1080, class: gpr32 }
  - { id: 1081, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%176' }
  - { reg: '%a1', virtual-reg: '%177' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    8
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
stack:           
  - { id: 0, name: n.i.i.i, offset: 0, size: 256, alignment: 4 }
  - { id: 1, name: e.i.i.i, offset: 0, size: 256, alignment: 4 }
  - { id: 2, name: n.i.i, offset: 0, size: 256, alignment: 4 }
  - { id: 3, name: e.i.i, offset: 0, size: 256, alignment: 4 }
  - { id: 4, name: nsec.i.i, offset: 0, size: 256, alignment: 4 }
  - { id: 5, name: esec.i.i, offset: 0, size: 256, alignment: 4 }
  - { id: 6, name: userid.i.i, offset: 0, size: 256, alignment: 4 }
  - { id: 7, name: keyID.i.i, offset: 0, size: 8, alignment: 4 }
  - { id: 8, name: ctb.i.i, offset: 0, size: 1, alignment: 4 }
  - { id: 9, name: userid.i, offset: 0, size: 256, alignment: 4 }
  - { id: 10, name: keyID.i, offset: 0, size: 8, alignment: 8 }
  - { id: 11, name: sigkeyID.i, offset: 0, size: 8, alignment: 8 }
  - { id: 12, name: ctb.i, offset: 0, size: 1, alignment: 4 }
body:             |
  bb.0 (%ir-block.0, freq 5650919756):
    successors: %bb.1(50), %bb.2(50)
    liveins: %a0, %a1, %t9, %v0
  
    %178 = ADDu %v0, %t9
    %177 = COPY %a1
    %176 = COPY %a0
    %179 = LW %178, target-flags(<unknown>) @undefined_trust, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, %179, target-flags(<unknown>) @undefined_trust, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @undefined_trust, !tbaa !7)
    %180 = LW %178, target-flags(<unknown>) @max_cert_depth, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %181 = LW %180, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @max_cert_depth, !tbaa !7)
    %182 = SLTi killed %181, 9
    BNE killed %182, %zero, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.6, freq 2825459878):
    successors: %bb.2(100)
  
    %184 = ADDiu %zero, 8
    SW killed %184, %180, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @max_cert_depth, !tbaa !7)
  
  bb.2 (%ir-block.7, freq 5650919756):
    successors: %bb.3(37), %bb.4(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %185 = LW %178, target-flags(<unknown>) @.str, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %186 = ADDiu %185, target-flags(<unknown>) @.str
    %187 = LW %178, target-flags(<unknown>) @globalSecringName, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %188 = LW %178, target-flags(<unknown>) @fopen, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fopen)
    %a0 = COPY %187
    %a1 = COPY %186
    %gp = COPY %178
    %t9 = COPY %188
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %189 = COPY %v0
    %190 = LW %178, target-flags(<unknown>) @sec_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %189, %190, target-flags(<unknown>) @sec_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @sec_fp, !tbaa !9)
    BNE %189, %zero, %bb.4, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.10, freq 2119094908):
    successors: %bb.4(100)
  
    %191 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %192 = LW killed %191, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %193 = LW %178, target-flags(<unknown>) @.str.38, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %194 = ADDiu killed %193, target-flags(<unknown>) @.str.38
    %195 = LW %178, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %194
    %gp = COPY %178
    %t9 = COPY %195
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %196 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %198 = LW %178, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %192
    %a1 = COPY %196
    %a2 = COPY %187
    %gp = COPY %178
    %t9 = COPY %198
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.4 (%ir-block.14, freq 5650919756):
    successors: %bb.6(99), %bb.5(0)
  
    %200 = LW %178, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %0 = LW %200, target-flags(<unknown>) @nkr, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @nkr, !tbaa !7)
    %201 = SLTi %0, 8
    BNE killed %201, %zero, %bb.6, implicit-def dead %at
    B %bb.5, implicit-def dead %at
  
  bb.5 (%ir-block.17, freq 5389):
    exit
  
    %202 = LW %178, target-flags(<unknown>) @__PRETTY_FUNCTION__.setkrent, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %203 = LW %178, target-flags(<unknown>) @.str.37, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %204 = LW %178, target-flags(<unknown>) @.str.36, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %205 = ADDiu killed %204, target-flags(<unknown>) @.str.36
    %206 = ADDiu killed %203, target-flags(<unknown>) @.str.37
    %207 = ADDiu killed %202, target-flags(<unknown>) @__PRETTY_FUNCTION__.setkrent
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %208 = LW %178, target-flags(<unknown>) @__assert_fail, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @__assert_fail)
    %209 = ADDiu %zero, 1447
    %a0 = COPY %205
    %a1 = COPY %206
    %a2 = COPY %209
    %a3 = COPY %207
    %gp = COPY %178
    %t9 = COPY %208
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.6 (%ir-block.18, freq 5650914367):
    successors: %bb.224(62), %bb.9.._crit_edge.i(37)
  
    %212 = LW %178, target-flags(<unknown>) @globalPubringName, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %1 = MOVZ_I_I killed %212, %176, %176
    %213 = LW %178, target-flags(<unknown>) @krnames, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    BLEZ %0, %bb.9.._crit_edge.i, implicit-def %at
  
  bb.224 (freq 3531821479):
    successors: %bb.8..lr.ph.i(100)
  
    %210 = ADDiu %213, target-flags(<unknown>) @krnames
    %211 = ADDiu %zero, 0
    B %bb.8..lr.ph.i, implicit-def %at
  
  bb.7 (%ir-block.21, freq 55612173142):
    successors: %bb.8..lr.ph.i(96), %bb.9.._crit_edge.i(3)
  
    %5 = ADDiu %4, 1
    %217 = SLT %5, %0
    %2 = ADDiu %3, 4
    BEQ killed %217, %zero, %bb.9.._crit_edge.i, implicit-def dead %at
    B %bb.8..lr.ph.i, implicit-def dead %at
  
  bb.8..lr.ph.i (freq 57406114211):
    successors: %bb.10.setkrent.exit(3), %bb.7(96)
  
    %3 = PHI %210, %bb.224, %2, %bb.7
    %4 = PHI %211, %bb.224, %5, %bb.7
    %214 = LW %3, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv1, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %215 = LW %178, target-flags(<unknown>) @strcmp, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %1
    %a1 = COPY %214
    %gp = COPY %178
    %t9 = COPY %215
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %216 = COPY %v0
    BEQ %216, %zero, %bb.10.setkrent.exit, implicit-def dead %at
    B %bb.7, implicit-def dead %at
  
  bb.9.._crit_edge.i (freq 3856973298):
    successors: %bb.10.setkrent.exit(100)
  
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %218 = LW %178, target-flags(<unknown>) @store_str, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %219 = ADDiu killed %218, target-flags(<unknown>) @store_str
    %a0 = COPY %1
    %t9 = COPY %219
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %220 = COPY %v0
    %222 = LW %200, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @nkr, !tbaa !7)
    %224 = ADDiu %222, 1
    SW killed %224, %200, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nkr, !tbaa !7)
    %225 = ADDiu %213, target-flags(<unknown>) @krnames
    %226 = SLL %222, 2
    %227 = ADDu killed %225, killed %226
    SW %220, killed %227, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.31, !tbaa !9)
  
  bb.10.setkrent.exit (freq 5650914367):
    successors: %bb.11(37), %bb.12(62)
  
    %228 = LW %178, target-flags(<unknown>) @marg_min, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %6 = LW %228, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @marg_min, !tbaa !7)
    BNE %6, %zero, %bb.12, implicit-def dead %at
    B %bb.11, implicit-def dead %at
  
  bb.11 (%ir-block.34, freq 2119092887):
    successors: %bb.15.setup_trust.exit(100)
  
    %234 = LW %178, target-flags(<unknown>) @trust_tbl, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %235 = ADDiu killed %234, target-flags(<unknown>) @trust_tbl
    SW %zero, %235, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5)`, !tbaa !7)
    %236 = ADDiu %zero, 1
    SW killed %236, %235, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6)`, !tbaa !7)
    %237 = LW %178, target-flags(<unknown>) @compl_min, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %7 = LW killed %237, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @compl_min, !tbaa !7)
    B %bb.15.setup_trust.exit, implicit-def dead %at
  
  bb.12 (%ir-block.36, freq 3531821479):
    successors: %bb.13(50), %bb.14(50)
  
    %229 = LW %178, target-flags(<unknown>) @compl_min, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %8 = LW killed %229, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @compl_min, !tbaa !7)
    %230 = SLT %6, %8
    BEQ killed %230, %zero, %bb.14, implicit-def dead %at
    B %bb.13, implicit-def dead %at
  
  bb.13 (%ir-block.39, freq 1765910739):
    successors: %bb.14(100)
  
    SW %8, %228, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @marg_min, !tbaa !7)
  
  bb.14 (%ir-block.40, freq 3531821479):
    successors: %bb.15.setup_trust.exit(100)
  
    %9 = PHI %6, %bb.12, %8, %bb.13
    %10 = MUL %9, %8, implicit-def dead %hi0, implicit-def dead %lo0
    %232 = LW %178, target-flags(<unknown>) @trust_tbl, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %233 = ADDiu killed %232, target-flags(<unknown>) @trust_tbl
    SW %8, %233, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5)`, !tbaa !7)
    SW %9, %233, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6)`, !tbaa !7)
  
  bb.15.setup_trust.exit (freq 5650914367):
    successors: %bb.17(37), %bb.16(62)
  
    %11 = PHI %10, %bb.14, %7, %bb.11
    %238 = LW %178, target-flags(<unknown>) @complete_min, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %11, %238, target-flags(<unknown>) @complete_min, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @complete_min, !tbaa !7)
    %239 = LW %178, target-flags(<unknown>) @trust_tbl, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %240 = ADDiu %239, target-flags(<unknown>) @trust_tbl
    SW %11, killed %240, 28, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7)`, !tbaa !7)
    %241 = SRL %11, 31
    %242 = ADDu %11, killed %241
    %243 = SRA killed %242, 1
    %244 = LW %178, target-flags(<unknown>) @marginal_min, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW killed %243, %244, target-flags(<unknown>) @marginal_min, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @marginal_min, !tbaa !7)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %245 = ADDiu %zero, 1028
    %246 = LW %178, target-flags(<unknown>) @xmalloc, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @xmalloc)
    %a0 = COPY %245
    %gp = COPY %178
    %t9 = COPY %246
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %247 = COPY %v0
    %248 = LW %178, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %249 = LW %178, target-flags(<unknown>) @totalsize, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %250 = LW %178, target-flags(<unknown>) @pkhash, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %251 = ADDiu %zero, 0
    %252 = ADDiu %zero, 1024
    %253 = LW %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @totalsize, !tbaa !10)
    %254 = ADDiu killed %253, 1024
    SW killed %254, %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @totalsize, !tbaa !10)
    %255 = ADDiu %247, 4
    %256 = LW %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast (%struct.bufpool** @bufpool to i32*)`, !tbaa !9)
    SW killed %256, %247, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.48, !tbaa !12)
    SW %247, %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.bufpool** @bufpool to i8**)`, !tbaa !9)
    SW %255, %250, target-flags(<unknown>) @pkhash, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.pubkey*** @pkhash to i8**)`, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %257 = LW %178, target-flags(<unknown>) $memset, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry $memset)
    %a0 = COPY %255
    %a1 = COPY %251
    %a2 = COPY %252
    %gp = COPY %178
    %t9 = COPY %257
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %258 = LW %178, target-flags(<unknown>) @verbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %259 = LW %178, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %260 = LBu %259, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @mverbose, align 4, !tbaa !6)
    %261 = LBu %258, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @verbose)
    %262 = OR killed %261, killed %260
    %263 = ANDi killed %262, 255
    BEQ killed %263, %zero, %bb.17, implicit-def dead %at
    B %bb.16, implicit-def dead %at
  
  bb.16 (%ir-block.54, freq 3531821479):
    successors: %bb.17(100)
  
    %264 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %265 = LW killed %264, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %266 = LW %178, target-flags(<unknown>) @.str.39, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %267 = ADDiu killed %266, target-flags(<unknown>) @.str.39
    %268 = LW %178, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %267
    %gp = COPY %178
    %t9 = COPY %268
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %269 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %270 = LW %178, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %265
    %a1 = COPY %269
    %gp = COPY %178
    %t9 = COPY %270
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.17 (%ir-block.58, freq 5650914367):
    successors: %bb.19(37), %bb.18..preheader.i(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %273 = ADDiu %185, target-flags(<unknown>) @.str
    %274 = LW %178, target-flags(<unknown>) @fopen, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fopen)
    %a0 = COPY %176
    %a1 = COPY %273
    %t9 = COPY %274
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %275 = COPY %v0
    BEQ %275, %zero, %bb.19, implicit-def dead %at
    B %bb.18..preheader.i, implicit-def dead %at
  
  bb.18..preheader.i (freq 3531821479):
    successors: %bb.27..outer29.i(100)
  
    %12 = COPY %275
    %280 = ADDiu %zero, 0
    %279 = COPY %280
    %1065 = ADDiu %zero, 1
    %1058 = COPY %279
    %282 = LEA_ADDiu %stack.11.sigkeyID.i, 0
    %285 = LEA_ADDiu %stack.12.ctb.i, 0
    %286 = LEA_ADDiu %stack.9.userid.i, 0
    %287 = LEA_ADDiu %stack.10.keyID.i, 0
    %289 = ADDiu %zero, -1
    %294 = ADDiu %zero, 20
    %295 = ADDiu %zero, 24
    %301 = ADDiu %zero, 176
    %302 = ADDiu %zero, 56
    %303 = ADDiu %zero, 8
    %688 = ADDiu %zero, 2
    %307 = ADDiu %zero, 3
    %308 = LEA_ADDiu %stack.1.e.i.i.i, 0
    %316 = LUi 255
    %318 = LUi 1
    %327 = LW %178, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %332 = ADDiu %zero, 4004
    %325 = ADDiu %zero, 13
    %326 = ADDiu %zero, 6
    %522 = ADDiu %zero, 180
    %589 = ADDiu %zero, 110
    B %bb.27..outer29.i, implicit-def dead %at
  
  bb.19 (%ir-block.64, freq 2119092887):
    successors: %bb.122.maint_read_data.exit(100)
  
    %706 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %707 = LW killed %706, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %708 = LW %178, target-flags(<unknown>) @.str.6, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %709 = ADDiu killed %708, target-flags(<unknown>) @.str.6
    %710 = LW %178, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %709
    %gp = COPY %178
    %t9 = COPY %710
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %711 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %712 = LW %178, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %707
    %a1 = COPY %711
    %a2 = COPY %176
    %gp = COPY %178
    %t9 = COPY %712
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %705 = ADDiu %zero, -1
    B %bb.122.maint_read_data.exit, implicit-def dead %at
  
  bb.20 (%ir-block.68, freq 57328835432):
    successors: %bb.119(3), %bb.21(96)
  
    ADJCALLSTACKDOWN 24, implicit-def dead %sp, implicit %sp
    %283 = COPY %sp
    SW %282, %283, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %284 = LW %178, target-flags(<unknown>) @readkpacket, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @readkpacket)
    %a0 = COPY %12
    %a1 = COPY %285
    %a2 = COPY %286
    %a3 = COPY %287
    %gp = COPY %178
    %t9 = COPY %284
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 24, 0, implicit-def dead %sp, implicit %sp
    %288 = COPY %v0
    BEQ %288, %289, %bb.119, implicit-def dead %at
    B %bb.21, implicit-def dead %at
  
  bb.21 (%ir-block.74, freq 55537309325):
    successors: %bb.22(3), %bb.23(96)
  
    %13 = COPY %288
    %290 = ADDiu %288, 3
    %291 = SLTiu killed %290, 2
    BEQ killed %291, %zero, %bb.23, implicit-def dead %at
    B %bb.22, implicit-def dead %at
  
  bb.22 (%ir-block.76, freq 1735540916):
    successors: %bb.122.maint_read_data.exit(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %689 = LW %178, target-flags(<unknown>) @fclose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fclose)
    %a0 = COPY %12
    %gp = COPY %178
    %t9 = COPY %689
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.122.maint_read_data.exit, implicit-def dead %at
  
  bb.23 (%ir-block.78, freq 53801768409):
    successors: %bb.27..outer29.i(3), %bb.24(96)
  
    %292 = ADDiu %zero, 0
    BLTZ %13, %bb.27..outer29.i, implicit-def dead %at
    B %bb.24, implicit-def dead %at
  
  bb.24 (%ir-block.80, freq 52120463146):
    successors: %bb.27..outer29.i(3), %bb.25(96)
  
    %14 = LBu %stack.12.ctb.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb.i, align 4, !tbaa !6)
    %15 = ANDi %14, 124
    BEQ %15, %294, %bb.27..outer29.i, implicit-def dead %at
    B %bb.25, implicit-def dead %at
  
  bb.25 (%ir-block.85, freq 50491698672):
    successors: %bb.26(3), %bb.20(96)
  
    %296 = XOR %15, %295
    %297 = SLTiu killed %296, 1
    %298 = OR %16, killed %297
    %299 = ANDi killed %298, 1
    BEQ killed %299, %zero, %bb.20, implicit-def dead %at
    B %bb.26, implicit-def dead %at
  
  bb.26 (%ir-block.87, freq 1577865585):
    successors: %bb.27..outer29.i(25), %bb.211(75)
  
    BEQ %14, %301, %bb.27..outer29.i, implicit-def dead %at
    B %bb.211, implicit-def dead %at
  
  bb.211 (%ir-block.87, freq 1183399188):
    successors: %bb.27..outer29.i(33), %bb.28(66)
  
    BNE %15, %302, %bb.28, implicit-def dead %at
    B %bb.27..outer29.i, implicit-def dead %at
  
  bb.27..outer29.i (freq 8415002343):
    successors: %bb.20(100)
  
    %1081 = PHI %1081, %bb.23, %1081, %bb.24, %1081, %bb.26, %1081, %bb.211, %1081, %bb.30, %279, %bb.18..preheader.i, %93, %bb.117
    %1080 = PHI %1080, %bb.23, %1080, %bb.24, %1080, %bb.26, %1080, %bb.211, %1080, %bb.30, %279, %bb.18..preheader.i, %92, %bb.117
    %1079 = PHI %1079, %bb.23, %1079, %bb.24, %1079, %bb.26, %1079, %bb.211, %1079, %bb.30, %279, %bb.18..preheader.i, %91, %bb.117
    %1078 = PHI %1078, %bb.23, %1078, %bb.24, %1078, %bb.26, %1078, %bb.211, %1078, %bb.30, %1058, %bb.18..preheader.i, %94, %bb.117
    %1076 = PHI %1076, %bb.23, %1076, %bb.24, %1076, %bb.26, %1076, %bb.211, %1076, %bb.30, %1058, %bb.18..preheader.i, %90, %bb.117
    %1075 = PHI %1075, %bb.23, %1075, %bb.24, %1075, %bb.26, %1075, %bb.211, %1075, %bb.30, %1058, %bb.18..preheader.i, %89, %bb.117
    %1074 = PHI %1074, %bb.23, %1074, %bb.24, %1074, %bb.26, %1074, %bb.211, %1074, %bb.30, %1058, %bb.18..preheader.i, %88, %bb.117
    %16 = PHI %1065, %bb.18..preheader.i, %292, %bb.23, %292, %bb.24, %1065, %bb.26, %1065, %bb.211, %1065, %bb.30, %1065, %bb.117
    B %bb.20, implicit-def dead %at
  
  bb.28 (%ir-block.90, freq 788932792):
    successors: %bb.212(98), %bb.31(1)
  
    BEQ %1079, %zero, %bb.31, implicit-def dead %at
    B %bb.212, implicit-def dead %at
  
  bb.212 (%ir-block.90, freq 776605717):
    successors: %bb.29(98), %bb.31(1)
  
    BNE %15, %303, %bb.31, implicit-def dead %at
    B %bb.29, implicit-def dead %at
  
  bb.29 (%ir-block.93, freq 764278642):
    successors: %bb.30(96), %bb.31(3)
  
    %304 = LW %1079, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.sunkaddr3, !tbaa !14)
    BNE killed %304, %zero, %bb.31, implicit-def dead %at
    B %bb.30, implicit-def dead %at
  
  bb.30 (%ir-block.96, freq 740394935):
    successors: %bb.27..outer29.i(100)
  
    SB %688, %1079, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.sunkaddr6, align 4, !tbaa !16)
    B %bb.27..outer29.i, implicit-def dead %at
  
  bb.31 (%ir-block.97, freq 48537857):
    successors: %bb.32(96), %bb.36..loopexit.i(3)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %305 = LW %178, target-flags(<unknown>) @fread, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fread)
    %a0 = COPY %308
    %a1 = COPY %1065
    %a2 = COPY %307
    %a3 = COPY %12
    %gp = COPY %178
    %t9 = COPY %305
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %309 = COPY %v0
    BNE %309, %307, %bb.36..loopexit.i, implicit-def dead %at
    B %bb.32, implicit-def dead %at
  
  bb.32 (%ir-block.101, freq 47021049):
    successors: %bb.35(96), %bb.33(3)
  
    %17 = LW %stack.1.e.i.i.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.102)
    %18 = SRL %17, 24
    BEQ %18, %301, %bb.35, implicit-def dead %at
    B %bb.33, implicit-def dead %at
  
  bb.33 (%ir-block.108, freq 1469408):
    successors: %bb.34(37), %bb.36..loopexit.i(62)
  
    %311 = SEB %18
    BGEZ killed %311, %bb.36..loopexit.i, implicit-def dead %at
    B %bb.34, implicit-def dead %at
  
  bb.34 (%ir-block.111, freq 551028):
    successors: %bb.36..loopexit.i(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %312 = LW %178, target-flags(<unknown>) @fseek, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fseek)
    %313 = ADDiu %zero, -3
    %314 = ADDiu %zero, 1
    %a0 = COPY %12
    %a1 = COPY %313
    %a2 = COPY %314
    %gp = COPY %178
    %t9 = COPY %312
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.36..loopexit.i, implicit-def dead %at
  
  bb.35 (%ir-block.113, freq 45551641):
    successors: %bb.37(96), %bb.36..loopexit.i(3)
  
    %317 = AND %17, %316
    BEQ killed %317, %318, %bb.37, implicit-def dead %at
    B %bb.36..loopexit.i, implicit-def dead %at
  
  bb.36..loopexit.i (freq 4409705):
    successors: %bb.122.maint_read_data.exit(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %320 = LW %178, target-flags(<unknown>) @fclose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fclose)
    %a0 = COPY %12
    %gp = COPY %178
    %t9 = COPY %320
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %319 = ADDiu %zero, -7
    B %bb.122.maint_read_data.exit, implicit-def dead %at
  
  bb.37 (%ir-block.118, freq 44128152):
    successors: %bb.102(25), %bb.213(75)
  
    %19 = SRL %17, 8
    %323 = LBu %stack.12.ctb.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb.i, align 4, !tbaa !6)
    %322 = EXT killed %323, 2, 5
    BEQ %322, %688, %bb.102, implicit-def dead %at
    B %bb.213, implicit-def dead %at
  
  bb.213 (%ir-block.118, freq 33096114):
    successors: %bb.88(33), %bb.214(66)
  
    BEQ %322, %325, %bb.88, implicit-def dead %at
    B %bb.214, implicit-def dead %at
  
  bb.214 (%ir-block.118, freq 22064076):
    successors: %bb.38(50), %bb.117(50)
  
    BNE %322, %326, %bb.117, implicit-def dead %at
    B %bb.38, implicit-def dead %at
  
  bb.38 (%ir-block.124, freq 11032038):
    successors: %bb.41.._crit_edge.i.i(37), %bb.39..lr.ph.i.i(62)
  
    %20 = LW %250, target-flags(<unknown>) @pkhash, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pkhash, !tbaa !9)
    %430 = LBu %stack.10.keyID.i, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from %ir.125, align 8, !tbaa !6)
    %431 = SLL killed %430, 2
    %432 = ADDu %20, killed %431
    %21 = LW killed %432, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.129, !tbaa !9)
    BEQ %21, %zero, %bb.41.._crit_edge.i.i, implicit-def dead %at
    B %bb.39..lr.ph.i.i, implicit-def dead %at
  
  bb.39..lr.ph.i.i (freq 112071498):
    successors: %bb.45.getpubkey.exit.i(3), %bb.40(96)
  
    %22 = PHI %21, %bb.38, %23, %bb.40
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %433 = ADDiu %22, 16
    %434 = LW %178, target-flags(<unknown>) @memcmp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @memcmp)
    %436 = LEA_ADDiu %stack.10.keyID.i, 0
    %a0 = COPY %433
    %a1 = COPY %436
    %a2 = COPY %303
    %gp = COPY %178
    %t9 = COPY %434
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %437 = COPY %v0
    BEQ %437, %zero, %bb.45.getpubkey.exit.i, implicit-def dead %at
    B %bb.40, implicit-def dead %at
  
  bb.40 (%ir-block.135, freq 108569264):
    successors: %bb.41.._crit_edge.i.i(3), %bb.39..lr.ph.i.i(96)
  
    %23 = LW %22, 4, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.136, !tbaa !9)
    BNE %23, %zero, %bb.39..lr.ph.i.i, implicit-def dead %at
    B %bb.41.._crit_edge.i.i, implicit-def dead %at
  
  bb.41.._crit_edge.i.i (freq 7529803):
    successors: %bb.43(50), %bb.42.._crit_edge.i8.i(50)
  
    %24 = LW %327, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @nleft, !tbaa !7)
    %439 = SLTi %24, 28
    BNE killed %439, %zero, %bb.43, implicit-def dead %at
    B %bb.42.._crit_edge.i8.i, implicit-def dead %at
  
  bb.42.._crit_edge.i8.i (freq 3764901):
    successors: %bb.44.allocn.exit.i(100)
  
    %440 = LW %178, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %25 = LW killed %440, target-flags(<unknown>) @allocn.ptr, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @allocn.ptr, !tbaa !9)
    B %bb.44.allocn.exit.i, implicit-def dead %at
  
  bb.43 (%ir-block.140, freq 3764901):
    successors: %bb.44.allocn.exit.i(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %442 = LW %178, target-flags(<unknown>) @xmalloc, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @xmalloc)
    %a0 = COPY %332
    %t9 = COPY %442
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %444 = COPY %v0
    %26 = ADDiu %444, 4
    %446 = LW %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @totalsize, !tbaa !10)
    %441 = ADDiu %zero, 4000
    %449 = LW %178, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %451 = ADDiu killed %446, 4000
    SW killed %451, %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @totalsize, !tbaa !10)
    %452 = LW %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast (%struct.bufpool** @bufpool to i32*)`, !tbaa !9)
    SW killed %452, %444, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.145, !tbaa !12)
    SW %444, %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.bufpool** @bufpool to i8**)`, !tbaa !9)
    SW %26, killed %449, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @allocn.ptr, !tbaa !9)
    SW %441, %327, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nleft, !tbaa !7)
    %27 = LW %250, target-flags(<unknown>) @pkhash, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pkhash, !tbaa !9)
  
  bb.44.allocn.exit.i (freq 7529803):
    successors: %bb.45.getpubkey.exit.i(100)
  
    %28 = PHI %20, %bb.42.._crit_edge.i8.i, %27, %bb.43
    %29 = PHI %25, %bb.42.._crit_edge.i8.i, %26, %bb.43
    %30 = PHI %24, %bb.42.._crit_edge.i8.i, %441, %bb.43
    %453 = ADDiu %30, -28
    SW killed %453, %327, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nleft, !tbaa !7)
    %455 = ADDiu %29, 28
    %456 = LW %178, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW killed %455, killed %456, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @allocn.ptr, !tbaa !9)
    SW %zero, %29, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.148 + 24)
    SW %zero, %29, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.148 + 20)
    SW %zero, %29, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.148 + 16)
    SW %zero, %29, 12, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.148 + 12)
    SW %zero, %29, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.148 + 8)
    SW %zero, %29, 4, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.148 + 4)
    SW %zero, %29, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.148)
    %457 = LW %stack.10.keyID.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.keyID.i, align 8)
    %458 = LW %stack.10.keyID.i, 4, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.keyID.i + 4)
    %31 = COPY %29
    SWL %458, %29, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.155 + 4, align 1)
    SWL %457, %29, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.155, align 1)
    SWR %458, %29, 23, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.155 + 4, align 1)
    SWR %457, %29, 19, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.155, align 1)
    %459 = LBu %stack.10.keyID.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.150, align 8, !tbaa !6)
    %460 = SLL killed %459, 2
    %461 = ADDu %28, killed %460
    %462 = LW killed %461, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.160, !tbaa !9)
    SW killed %462, %29, 4, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.163, !tbaa !17)
    %463 = LBu %stack.10.keyID.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.150, align 8, !tbaa !6)
    %464 = SLL killed %463, 2
    %465 = ADDu %28, killed %464
    SW %29, killed %465, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.167, !tbaa !9)
  
  bb.45.getpubkey.exit.i (freq 11032038):
    successors: %bb.46(62), %bb.47(37)
  
    %32 = PHI %22, %bb.39..lr.ph.i.i, %31, %bb.44.allocn.exit.i
    BEQ %1079, %zero, %bb.47, implicit-def dead %at
    B %bb.46, implicit-def dead %at
  
  bb.46 (%ir-block.169, freq 6895023):
    successors: %bb.48(100)
  
    SW %32, %1079, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.170, !tbaa !18)
    B %bb.48, implicit-def dead %at
  
  bb.47 (%ir-block.171, freq 4137014):
    successors: %bb.48(100)
  
    %466 = LW %178, target-flags(<unknown>) @pklist, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %32, killed %466, target-flags(<unknown>) @pklist, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @pklist, !tbaa !9)
  
  bb.48 (%ir-block.172, freq 11032038):
    successors: %bb.50(96), %bb.49(3)
  
    %467 = LW %32, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.173, !tbaa !18)
    BEQ killed %467, %zero, %bb.50, implicit-def dead %at
    B %bb.49, implicit-def dead %at
  
  bb.49 (%ir-block.176, freq 344751):
    successors: %bb.122.maint_read_data.exit(100)
  
    %469 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %470 = LW killed %469, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %471 = LW %178, target-flags(<unknown>) @.str.45, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %472 = ADDiu killed %471, target-flags(<unknown>) @.str.45
    %473 = LW %178, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %472
    %gp = COPY %178
    %t9 = COPY %473
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %474 = COPY %v0
    %475 = LEA_ADDiu %stack.10.keyID.i, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %476 = LW %178, target-flags(<unknown>) @keyIDstring, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @keyIDstring)
    %a0 = COPY %475
    %gp = COPY %178
    %t9 = COPY %476
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %477 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %478 = LW %178, target-flags(<unknown>) @fprintf, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %470
    %a1 = COPY %474
    %a2 = COPY %477
    %gp = COPY %178
    %t9 = COPY %478
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %480 = LW %178, target-flags(<unknown>) @fclose, <0x461f8d0> = !{!"unison-memory-partition", i32 6} :: (load 4 from call-entry @fclose)
    %a0 = COPY %12
    %gp = COPY %178
    %t9 = COPY %480
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %468 = ADDiu %zero, -1
    B %bb.122.maint_read_data.exit, implicit-def dead %at
  
  bb.50 (%ir-block.183, freq 10687286):
    successors: %bb.54.ismember_newkeys.exit.i(37), %bb.51(62)
  
    %482 = SEB %19
    BLTZ %482, %bb.54.ismember_newkeys.exit.i, implicit-def dead %at
    B %bb.51, implicit-def dead %at
  
  bb.51 (%ir-block.186, freq 6679554):
    successors: %bb.87.ismember_newkeys.exit.thread.i(37), %bb.52..lr.ph.i9.i(62)
  
    %33 = COPY %19
    %483 = ADDiu %zero, 0
    BEQ %177, %zero, %bb.87.ismember_newkeys.exit.thread.i, implicit-def dead %at
    B %bb.52..lr.ph.i9.i, implicit-def dead %at
  
  bb.52..lr.ph.i9.i (freq 67855790):
    successors: %bb.54.ismember_newkeys.exit.i(3), %bb.53(96)
  
    %34 = PHI %177, %bb.51, %36, %bb.53
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %484 = LW %178, target-flags(<unknown>) @memcmp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @memcmp)
    %486 = LEA_ADDiu %stack.10.keyID.i, 0
    %a0 = COPY %486
    %a1 = COPY %34
    %a2 = COPY %303
    %gp = COPY %178
    %t9 = COPY %484
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %487 = COPY %v0
    BEQ %487, %zero, %bb.54.ismember_newkeys.exit.i, implicit-def dead %at
    B %bb.53, implicit-def dead %at
  
  bb.53 (%ir-block.193, freq 65735296):
    successors: %bb.87.ismember_newkeys.exit.thread.i(3), %bb.52..lr.ph.i9.i(96)
  
    %36 = LW %34, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.195, !tbaa !1)
    %35 = COPY %19
    BEQ %36, %zero, %bb.87.ismember_newkeys.exit.thread.i, implicit-def dead %at
    B %bb.52..lr.ph.i9.i, implicit-def dead %at
  
  bb.54.ismember_newkeys.exit.i (freq 6128226):
    successors: %bb.81.check_secretkey.exit.i(37), %bb.55(62)
  
    %1077 = PHI %1076, %bb.50, %1076, %bb.52..lr.ph.i9.i
    %489 = ADDiu %zero, -1
    %491 = LW %190, target-flags(<unknown>) @sec_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @sec_fp, !tbaa !9)
    BEQ killed %491, %zero, %bb.81.check_secretkey.exit.i, implicit-def dead %at
    B %bb.55, implicit-def dead %at
  
  bb.55 (%ir-block.206, freq 3830141):
    successors: %bb.80..thread.i.i(37), %bb.56(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %493 = LW %178, target-flags(<unknown>) @ftell, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @ftell)
    %a0 = COPY %12
    %gp = COPY %178
    %t9 = COPY %493
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %494 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %495 = LW %178, target-flags(<unknown>) @fseek, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fseek)
    %a0 = COPY %12
    %a1 = COPY %1078
    %a2 = COPY %280
    %gp = COPY %178
    %t9 = COPY %495
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %498 = LEA_ADDiu %stack.2.n.i.i, 0
    %499 = LEA_ADDiu %stack.3.e.i.i, 0
    %500 = LEA_ADDiu %stack.8.ctb.i.i, 0
    ADJCALLSTACKDOWN 56, implicit-def dead %sp, implicit %sp
    %501 = COPY %sp
    SW killed %499, %501, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW killed %498, %501, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %501, 48, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %501, 44, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %501, 40, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %501, 36, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %501, 32, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %501, 28, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %501, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %502 = LW %178, target-flags(<unknown>) @readkeypacket, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @readkeypacket)
    %a0 = COPY %12
    %a1 = COPY %280
    %a2 = COPY %500
    %a3 = COPY %280
    %gp = COPY %178
    %t9 = COPY %502
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 56, 0, implicit-def dead %sp, implicit %sp
    %503 = COPY %v0
    %492 = ADDiu %zero, -1
    %37 = COPY %494
    BLTZ %503, %bb.80..thread.i.i, implicit-def dead %at
    B %bb.56, implicit-def dead %at
  
  bb.56 (%ir-block.213, freq 2393838):
    successors: %bb.57(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %504 = LW %178, target-flags(<unknown>) @extract_keyID, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @extract_keyID)
    %505 = LEA_ADDiu %stack.7.keyID.i.i, 0
    %506 = LEA_ADDiu %stack.2.n.i.i, 0
    %a0 = COPY %505
    %a1 = COPY %506
    %gp = COPY %178
    %t9 = COPY %504
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.57 (%ir-block.216, freq 56190038):
    successors: %bb.61.readkpacket.exit.i.i(37), %bb.58(62)
  
    ADJCALLSTACKDOWN 56, implicit-def dead %sp, implicit %sp
    %507 = LEA_ADDiu %stack.0.n.i.i.i, 0
    %509 = COPY %sp
    SW %308, %509, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW killed %507, %509, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %510 = LEA_ADDiu %stack.6.userid.i.i, 0
    SW killed %510, %509, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %509, 48, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %509, 44, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %509, 40, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %509, 36, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %509, 32, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %509, 28, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %511 = LW %178, target-flags(<unknown>) @readkeypacket, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @readkeypacket)
    %513 = LEA_ADDiu %stack.8.ctb.i.i, 0
    %a0 = COPY %12
    %a1 = COPY %280
    %a2 = COPY %513
    %a3 = COPY %280
    %t9 = COPY %511
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 56, 0, implicit-def dead %sp, implicit %sp
    %514 = COPY %v0
    BLTZ %514, %bb.61.readkpacket.exit.i.i, implicit-def dead %at
    B %bb.58, implicit-def dead %at
  
  bb.58 (%ir-block.224, freq 35118774):
    successors: %bb.59(50), %bb.60.readkpacket.exit.thread.i.i(50)
  
    %515 = LBu %stack.8.ctb.i.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb.i.i, align 4, !tbaa !6)
    BNE killed %515, %522, %bb.60.readkpacket.exit.thread.i.i, implicit-def dead %at
    B %bb.59, implicit-def dead %at
  
  bb.59 (%ir-block.227, freq 17559387):
    successors: %bb.60.readkpacket.exit.thread.i.i(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %517 = LW %178, target-flags(<unknown>) @PascalToC, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @PascalToC)
    %518 = LEA_ADDiu %stack.6.userid.i.i, 0
    %a0 = COPY %518
    %gp = COPY %178
    %t9 = COPY %517
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.60.readkpacket.exit.thread.i.i (freq 35118774):
    successors: %bb.62(100)
  
    B %bb.62, implicit-def dead %at
  
  bb.61.readkpacket.exit.i.i (freq 21071264):
    successors: %bb.230(3), %bb.62(96)
  
    %519 = ORi %514, 2
    BNE %519, %289, %bb.62, implicit-def %at
  
  bb.230 (freq 658477):
    successors: %bb.80..thread.i.i(100)
  
    %38 = COPY %514
    %39 = COPY %38
    B %bb.80..thread.i.i, implicit-def %at
  
  bb.62 (%ir-block.236, freq 55531561):
    successors: %bb.63(3), %bb.57(96)
  
    %521 = LBu %stack.8.ctb.i.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb.i.i, align 4, !tbaa !6)
    BNE killed %521, %522, %bb.57, implicit-def dead %at
    B %bb.63, implicit-def dead %at
  
  bb.63 (%ir-block.239, freq 1735361):
    successors: %bb.80..thread.i.i(37), %bb.64(62)
  
    %525 = LW %190, target-flags(<unknown>) @sec_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @sec_fp, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %526 = LW %178, target-flags(<unknown>) @lookup_by_keyID, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @lookup_by_keyID)
    %527 = LEA_ADDiu %stack.7.keyID.i.i, 0
    %a0 = COPY %525
    %a1 = COPY %527
    %gp = COPY %178
    %t9 = COPY %526
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %528 = COPY %v0
    %523 = ADDiu %zero, 1
    BLTZ %528, %bb.80..thread.i.i, implicit-def dead %at
    B %bb.64, implicit-def dead %at
  
  bb.64 (%ir-block.244, freq 1084600):
    successors: %bb.65(37), %bb.66(62)
  
    %530 = LW %190, target-flags(<unknown>) @sec_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @sec_fp, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %531 = LW %178, target-flags(<unknown>) @ftell, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @ftell)
    %a0 = COPY %530
    %t9 = COPY %531
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %532 = COPY %v0
    %533 = LEA_ADDiu %stack.4.nsec.i.i, 0
    %534 = LEA_ADDiu %stack.5.esec.i.i, 0
    %536 = LEA_ADDiu %stack.8.ctb.i.i, 0
    %537 = LW %190, target-flags(<unknown>) @sec_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @sec_fp, !tbaa !9)
    ADJCALLSTACKDOWN 56, implicit-def dead %sp, implicit %sp
    %538 = COPY %sp
    SW killed %534, %538, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW killed %533, %538, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %538, 48, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %538, 44, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %538, 40, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %538, 36, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %538, 32, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %538, 28, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %538, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %539 = LW %178, target-flags(<unknown>) @readkeypacket, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @readkeypacket)
    %a0 = COPY %537
    %a1 = COPY %280
    %a2 = COPY %536
    %a3 = COPY %280
    %t9 = COPY %539
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 56, 0, implicit-def dead %sp, implicit %sp
    %540 = COPY %v0
    BGEZ %540, %bb.66, implicit-def dead %at
    B %bb.65, implicit-def dead %at
  
  bb.65 (%ir-block.252, freq 406725):
    successors: %bb.80..thread.i.i(100)
  
    %644 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %645 = LW killed %644, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %646 = LW %178, target-flags(<unknown>) @.str.51, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %647 = ADDiu killed %646, target-flags(<unknown>) @.str.51
    %648 = LW %178, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %647
    %gp = COPY %178
    %t9 = COPY %648
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %649 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %650 = LW %178, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %645
    %a1 = COPY %649
    %gp = COPY %178
    %t9 = COPY %650
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %643 = ADDiu %zero, -3
    B %bb.80..thread.i.i, implicit-def dead %at
  
  bb.66 (%ir-block.256, freq 677875):
    successors: %bb.67(37), %bb.68(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %541 = LW %178, target-flags(<unknown>) @mp_compare, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @mp_compare)
    %542 = LEA_ADDiu %stack.2.n.i.i, 0
    %543 = LEA_ADDiu %stack.4.nsec.i.i, 0
    %a0 = COPY %542
    %a1 = COPY %543
    %gp = COPY %178
    %t9 = COPY %541
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %544 = COPY %v0
    %545 = ANDi %544, 65535
    BNE killed %545, %zero, %bb.68, implicit-def dead %at
    B %bb.67, implicit-def dead %at
  
  bb.67 (%ir-block.261, freq 254203):
    successors: %bb.69(37), %bb.68(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %547 = LW %178, target-flags(<unknown>) @mp_compare, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @mp_compare)
    %548 = LEA_ADDiu %stack.3.e.i.i, 0
    %549 = LEA_ADDiu %stack.5.esec.i.i, 0
    %a0 = COPY %548
    %a1 = COPY %549
    %t9 = COPY %547
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %550 = COPY %v0
    %551 = ANDi %550, 65535
    %546 = ADDiu %zero, 0
    BEQ killed %551, %zero, %bb.69, implicit-def dead %at
    B %bb.68, implicit-def dead %at
  
  bb.68 (%ir-block.266, freq 582549):
    successors: %bb.69(100)
  
    %553 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %554 = LW %553, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %555 = LW %178, target-flags(<unknown>) @.str.52, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %556 = ADDiu killed %555, target-flags(<unknown>) @.str.52
    %557 = LW %178, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %556
    %gp = COPY %178
    %t9 = COPY %557
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %558 = COPY %v0
    %559 = LEA_ADDiu %stack.6.userid.i.i, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %560 = LW %178, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %554
    %a1 = COPY %558
    %a2 = COPY %559
    %gp = COPY %178
    %t9 = COPY %560
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %562 = LW %178, target-flags(<unknown>) @.str.53, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from got)
    %563 = ADDiu killed %562, target-flags(<unknown>) @.str.53
    %564 = LW %553, 0, <0x461f8d0> = !{!"unison-memory-partition", i32 6} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %565 = LW %178, target-flags(<unknown>) @LANG, <0x4777c50> = !{!"unison-memory-partition", i32 7} :: (load 4 from call-entry @LANG)
    %a0 = COPY %563
    %t9 = COPY %565
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %566 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %567 = LW %178, target-flags(<unknown>) @fprintf, <0x4633c30> = !{!"unison-memory-partition", i32 8} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %564
    %a1 = COPY %566
    %t9 = COPY %567
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %552 = ADDiu %zero, -2
  
  bb.69 (%ir-block.274, freq 677875):
    successors: %bb.72(37), %bb.70(62)
  
    %41 = PHI %546, %bb.67, %552, %bb.68
    BLTZ %482, %bb.72, implicit-def dead %at
    B %bb.70, implicit-def dead %at
  
  bb.70 (%ir-block.277, freq 423672):
    successors: %bb.71(37), %bb.80..thread.i.i(62)
  
    %571 = LW %178, target-flags(<unknown>) @batchmode, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %572 = LBu killed %571, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from @batchmode, !tbaa !6)
    BNE killed %572, %zero, %bb.80..thread.i.i, implicit-def dead %at
    B %bb.71, implicit-def dead %at
  
  bb.71 (%ir-block.280, freq 158877):
    successors: %bb.72(100)
  
    %573 = LW %178, target-flags(<unknown>) @pgpout, <0x461f8d0> = !{!"unison-memory-partition", i32 6} :: (load 4 from got)
    %574 = LW %573, 0, <0x4777c50> = !{!"unison-memory-partition", i32 7} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %575 = LW %178, target-flags(<unknown>) @.str.54, <0x4633c30> = !{!"unison-memory-partition", i32 8} :: (load 4 from got)
    %576 = ADDiu killed %575, target-flags(<unknown>) @.str.54
    %577 = LW %178, target-flags(<unknown>) @LANG, <0x468acb0> = !{!"unison-memory-partition", i32 9} :: (load 4 from call-entry @LANG)
    %a0 = COPY %576
    %gp = COPY %178
    %t9 = COPY %577
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %578 = COPY %v0
    %579 = LEA_ADDiu %stack.6.userid.i.i, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %580 = LW %178, target-flags(<unknown>) @fprintf, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %574
    %a1 = COPY %578
    %a2 = COPY %579
    %gp = COPY %178
    %t9 = COPY %580
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %582 = LW %178, target-flags(<unknown>) @.str.55, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %583 = ADDiu killed %582, target-flags(<unknown>) @.str.55
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %584 = LW %178, target-flags(<unknown>) @LANG, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @LANG)
    %a0 = COPY %583
    %t9 = COPY %584
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %585 = COPY %v0
    %586 = LW %573, 0, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %587 = LW %178, target-flags(<unknown>) @fputs, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fputs)
    %a0 = COPY %585
    %a1 = COPY %586
    %gp = COPY %178
    %t9 = COPY %587
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %590 = LW %178, target-flags(<unknown>) @getyesno, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from call-entry @getyesno)
    %a0 = COPY %589
    %gp = COPY %178
    %t9 = COPY %590
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %591 = COPY %v0
    %592 = SLTu %zero, %591
    %42 = ADDiu killed %592, -1
  
  bb.72 (%ir-block.290, freq 413080):
    successors: %bb.216(75), %bb.80..thread.i.i(25)
  
    %43 = PHI %41, %bb.69, %42, %bb.71
    BNE %43, %zero, %bb.80..thread.i.i, implicit-def dead %at
    B %bb.216, implicit-def dead %at
  
  bb.216 (%ir-block.290, freq 309810):
    successors: %bb.73(66), %bb.80..thread.i.i(33)
  
    %593 = LW %178, target-flags(<unknown>) @floppy_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %44 = LW %593, target-flags(<unknown>) @floppy_fp, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @floppy_fp)
    BEQ %44, %zero, %bb.80..thread.i.i, implicit-def dead %at
    B %bb.73, implicit-def dead %at
  
  bb.73 (%ir-block.294, freq 206540):
    successors: %bb.74(37), %bb.75(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %594 = LW %178, target-flags(<unknown>) @lookup_by_keyID, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @lookup_by_keyID)
    %595 = LEA_ADDiu %stack.7.keyID.i.i, 0
    %a0 = COPY %44
    %a1 = COPY %595
    %t9 = COPY %594
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %596 = COPY %v0
    BGEZ %596, %bb.75, implicit-def dead %at
    B %bb.74, implicit-def dead %at
  
  bb.74 (%ir-block.298, freq 77452):
    successors: %bb.80..thread.i.i(100)
  
    %633 = LW %178, target-flags(<unknown>) @pgpout, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %634 = LW killed %633, 0, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %635 = LW %178, target-flags(<unknown>) @.str.56, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from got)
    %636 = ADDiu killed %635, target-flags(<unknown>) @.str.56
    %637 = LW %178, target-flags(<unknown>) @LANG, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from call-entry @LANG)
    %a0 = COPY %636
    %gp = COPY %178
    %t9 = COPY %637
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %638 = COPY %v0
    %639 = LW %178, target-flags(<unknown>) @floppyring, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %640 = LEA_ADDiu %stack.6.userid.i.i, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %641 = LW %178, target-flags(<unknown>) @fprintf, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %634
    %a1 = COPY %638
    %a2 = COPY %640
    %a3 = COPY %639
    %gp = COPY %178
    %t9 = COPY %641
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %632 = ADDiu %zero, 0
    B %bb.80..thread.i.i, implicit-def dead %at
  
  bb.75 (%ir-block.303, freq 129087):
    successors: %bb.76(100)
  
    %40 = COPY %532
    %598 = LW %190, target-flags(<unknown>) @sec_fp, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @sec_fp, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %599 = LW %178, target-flags(<unknown>) @ftell, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @ftell)
    %a0 = COPY %598
    %t9 = COPY %599
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %600 = COPY %v0
    %602 = LW %190, target-flags(<unknown>) @sec_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @sec_fp, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %603 = LW %178, target-flags(<unknown>) @fseek, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fseek)
    %a0 = COPY %602
    %a1 = COPY %40
    %a2 = COPY %280
    %t9 = COPY %603
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %45 = SUBu %600, %532
  
  bb.76 (%ir-block.309, freq 2098186):
    successors: %bb.77(96), %bb.78..critedge.i.i(3)
  
    %46 = PHI %45, %bb.75, %47, %bb.77
    BLEZ %46, %bb.78..critedge.i.i, implicit-def dead %at
    B %bb.77, implicit-def dead %at
  
  bb.77 (%ir-block.311, freq 2032617):
    successors: %bb.76(96), %bb.79..critedge.thread.i.i(3)
  
    %607 = LW %190, target-flags(<unknown>) @sec_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @sec_fp, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %608 = LW %178, target-flags(<unknown>) @_IO_getc, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @_IO_getc)
    %a0 = COPY %607
    %gp = COPY %178
    %t9 = COPY %608
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %609 = COPY %v0
    %611 = LW %593, target-flags(<unknown>) @floppy_fp, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @floppy_fp, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %612 = LW %178, target-flags(<unknown>) @_IO_getc, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @_IO_getc)
    %a0 = COPY %611
    %t9 = COPY %612
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %613 = COPY %v0
    %47 = ADDiu %46, -1
    BEQ %609, %613, %bb.76, implicit-def dead %at
    B %bb.79..critedge.thread.i.i, implicit-def dead %at
  
  bb.78..critedge.i.i (freq 65568):
    successors: %bb.80..thread.i.i(37), %bb.79..critedge.thread.i.i(62)
  
    %605 = ADDiu %zero, 0
    BEQ %46, %zero, %bb.80..thread.i.i, implicit-def dead %at
    B %bb.79..critedge.thread.i.i, implicit-def dead %at
  
  bb.79..critedge.thread.i.i (freq 104499):
    successors: %bb.80..thread.i.i(100)
  
    %615 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %616 = LW %615, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %617 = LW %178, target-flags(<unknown>) @.str.57, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %618 = ADDiu killed %617, target-flags(<unknown>) @.str.57
    %619 = LW %178, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %618
    %gp = COPY %178
    %t9 = COPY %619
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %620 = COPY %v0
    %621 = LW %178, target-flags(<unknown>) @floppyring, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from got)
    %622 = LEA_ADDiu %stack.6.userid.i.i, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %623 = LW %178, target-flags(<unknown>) @fprintf, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %616
    %a1 = COPY %620
    %a2 = COPY %622
    %a3 = COPY %621
    %gp = COPY %178
    %t9 = COPY %623
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %625 = LW %178, target-flags(<unknown>) @.str.53, <0x461f8d0> = !{!"unison-memory-partition", i32 6} :: (load 4 from got)
    %626 = ADDiu killed %625, target-flags(<unknown>) @.str.53
    %627 = LW %615, 0, <0x4777c50> = !{!"unison-memory-partition", i32 7} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %628 = LW %178, target-flags(<unknown>) @LANG, <0x4633c30> = !{!"unison-memory-partition", i32 8} :: (load 4 from call-entry @LANG)
    %a0 = COPY %626
    %t9 = COPY %628
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %629 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %630 = LW %178, target-flags(<unknown>) @fprintf, <0x468acb0> = !{!"unison-memory-partition", i32 9} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %627
    %a1 = COPY %629
    %t9 = COPY %630
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %614 = ADDiu %zero, -2
  
  bb.80..thread.i.i (freq 3830141):
    successors: %bb.81.check_secretkey.exit.i(100)
  
    %48 = PHI %492, %bb.55, %39, %bb.230, %523, %bb.63, %492, %bb.70, %43, %bb.72, %43, %bb.216, %605, %bb.78..critedge.i.i, %614, %bb.79..critedge.thread.i.i, %632, %bb.74, %643, %bb.65
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %652 = LW %178, target-flags(<unknown>) @fseek, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fseek)
    %a0 = COPY %12
    %a1 = COPY %37
    %a2 = COPY %280
    %t9 = COPY %652
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.81.check_secretkey.exit.i (freq 6128226):
    successors: %bb.82(37), %bb.84(62)
  
    %49 = PHI %489, %bb.54.ismember_newkeys.exit.i, %48, %bb.80..thread.i.i
    BNE %49, %zero, %bb.84, implicit-def dead %at
    B %bb.82, implicit-def dead %at
  
  bb.82 (%ir-block.334, freq 2298084):
    successors: %bb.86(37), %bb.83(62)
  
    %52 = ORi %19, 135
    %50 = ADDiu %1077, 1
    %672 = LBu %259, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @mverbose, align 4, !tbaa !6)
    %670 = ADDiu %zero, 1
    BEQ killed %672, %zero, %bb.86, implicit-def dead %at
    B %bb.83, implicit-def dead %at
  
  bb.83 (%ir-block.340, freq 1436302):
    successors: %bb.86(100)
  
    %51 = COPY %52
    %674 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %675 = LW killed %674, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %676 = LW %178, target-flags(<unknown>) @keyIDstring, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @keyIDstring)
    %677 = LEA_ADDiu %stack.10.keyID.i, 0
    %a0 = COPY %677
    %gp = COPY %178
    %t9 = COPY %676
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %678 = COPY %v0
    %679 = LW %178, target-flags(<unknown>) @.str.46, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %680 = ADDiu killed %679, target-flags(<unknown>) @.str.46
    %681 = LW %178, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %675
    %a1 = COPY %680
    %a2 = COPY %678
    %gp = COPY %178
    %t9 = COPY %681
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %53 = COPY %51
    B %bb.86, implicit-def dead %at
  
  bb.84 (%ir-block.346, freq 3830141):
    successors: %bb.86(37), %bb.85(62)
  
    %655 = ANDi %19, 127
    %656 = ANDi %19, 7
    %657 = XORi killed %656, 7
    %54 = MOVZ_I_I %326, killed %657, %655
    %660 = LBu %259, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @mverbose, align 4, !tbaa !6)
    BEQ killed %660, %zero, %bb.86, implicit-def dead %at
    B %bb.85, implicit-def dead %at
  
  bb.85 (%ir-block.353, freq 2393838):
    successors: %bb.86(100)
  
    %661 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %662 = LW killed %661, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %663 = LW %178, target-flags(<unknown>) @keyIDstring, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @keyIDstring)
    %664 = LEA_ADDiu %stack.10.keyID.i, 0
    %a0 = COPY %664
    %gp = COPY %178
    %t9 = COPY %663
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %665 = COPY %v0
    %666 = LW %178, target-flags(<unknown>) @.str.47, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    %667 = ADDiu killed %666, target-flags(<unknown>) @.str.47
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %668 = LW %178, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %662
    %a1 = COPY %667
    %a2 = COPY %665
    %gp = COPY %178
    %t9 = COPY %668
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.86 (%ir-block.358, freq 6128226):
    successors: %bb.87.ismember_newkeys.exit.thread.i(100)
  
    %55 = PHI %54, %bb.84, %54, %bb.85, %52, %bb.82, %53, %bb.83
    %56 = PHI %1074, %bb.84, %1074, %bb.85, %670, %bb.82, %670, %bb.83
    %57 = PHI %1077, %bb.84, %1077, %bb.85, %50, %bb.82, %50, %bb.83
    %58 = LBu %259, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @mverbose, align 4, !tbaa !6)
  
  bb.87.ismember_newkeys.exit.thread.i (freq 10687286):
    successors: %bb.117(100)
  
    %59 = PHI %33, %bb.51, %35, %bb.53, %55, %bb.86
    %60 = PHI %483, %bb.51, %483, %bb.53, %56, %bb.86
    %61 = PHI %483, %bb.51, %483, %bb.53, %58, %bb.86
    %62 = PHI %1076, %bb.51, %1076, %bb.53, %57, %bb.86
    SB %59, %32, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.360, align 4, !tbaa !16)
    SW %zero, %32, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.361, !tbaa !14)
    %684 = ADDiu %zero, 0
    B %bb.117, implicit-def dead %at
  
  bb.88 (%ir-block.362, freq 11032038):
    successors: %bb.89(62), %bb.117(37)
  
    %382 = ADDiu %zero, 0
    BEQ %1079, %zero, %bb.117, implicit-def dead %at
    B %bb.89, implicit-def dead %at
  
  bb.89 (%ir-block.364, freq 6895023):
    successors: %bb.93(37), %bb.90(62)
  
    %383 = ANDi %1075, 255
    BEQ killed %383, %zero, %bb.93, implicit-def dead %at
    B %bb.90, implicit-def dead %at
  
  bb.90 (%ir-block.366, freq 4309389):
    successors: %bb.92(37), %bb.91(62)
  
    %384 = LW %1079, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.sunkaddr9, !tbaa !14)
    BEQ killed %384, %zero, %bb.92, implicit-def dead %at
    B %bb.91, implicit-def dead %at
  
  bb.91 (%ir-block.369, freq 2693368):
    successors: %bb.92(100)
  
    %385 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %386 = LW killed %385, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    %387 = LW %178, target-flags(<unknown>) @.str.48, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %388 = ADDiu killed %387, target-flags(<unknown>) @.str.48
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %389 = LW %178, target-flags(<unknown>) @fwrite, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fwrite)
    %a0 = COPY %388
    %a1 = COPY %303
    %a2 = COPY %1065
    %a3 = COPY %386
    %gp = COPY %178
    %t9 = COPY %389
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.92 (%ir-block.372, freq 4309389):
    successors: %bb.93(100)
  
    %393 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %394 = LW killed %393, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    %395 = LW %178, target-flags(<unknown>) @.str.49, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %396 = ADDiu killed %395, target-flags(<unknown>) @.str.49
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %397 = LW %178, target-flags(<unknown>) @fprintf, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fprintf)
    %398 = LEA_ADDiu %stack.9.userid.i, 0
    %a0 = COPY %394
    %a1 = COPY %396
    %a2 = COPY %398
    %gp = COPY %178
    %t9 = COPY %397
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.93 (%ir-block.376, freq 6895023):
    successors: %bb.95(50), %bb.94.._crit_edge.i13.i(50)
  
    %63 = LW %327, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @nleft, !tbaa !7)
    %401 = SLTi %63, 20
    BNE killed %401, %zero, %bb.95, implicit-def dead %at
    B %bb.94.._crit_edge.i13.i, implicit-def dead %at
  
  bb.94.._crit_edge.i13.i (freq 3447511):
    successors: %bb.96.allocn.exit14.i(100)
  
    %402 = LW %178, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %64 = LW killed %402, target-flags(<unknown>) @allocn.ptr, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @allocn.ptr, !tbaa !9)
    B %bb.96.allocn.exit14.i, implicit-def dead %at
  
  bb.95 (%ir-block.379, freq 3447511):
    successors: %bb.96.allocn.exit14.i(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %404 = LW %178, target-flags(<unknown>) @xmalloc, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @xmalloc)
    %a0 = COPY %332
    %t9 = COPY %404
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %406 = COPY %v0
    %65 = ADDiu %406, 4
    %408 = LW %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @totalsize, !tbaa !10)
    %403 = ADDiu %zero, 4000
    %410 = LW %178, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %412 = ADDiu killed %408, 4000
    SW killed %412, %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @totalsize, !tbaa !10)
    %413 = LW %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast (%struct.bufpool** @bufpool to i32*)`, !tbaa !9)
    SW killed %413, %406, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.384, !tbaa !12)
    SW %406, %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.bufpool** @bufpool to i8**)`, !tbaa !9)
    SW %65, killed %410, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @allocn.ptr, !tbaa !9)
    SW %403, %327, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nleft, !tbaa !7)
  
  bb.96.allocn.exit14.i (freq 6895023):
    successors: %bb.98(37), %bb.97(62)
  
    %66 = PHI %64, %bb.94.._crit_edge.i13.i, %65, %bb.95
    %67 = PHI %63, %bb.94.._crit_edge.i13.i, %403, %bb.95
    %414 = ADDiu %67, -20
    SW killed %414, %327, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nleft, !tbaa !7)
    %416 = ADDiu %66, 20
    %417 = LW %178, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW killed %416, killed %417, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @allocn.ptr, !tbaa !9)
    BEQ %1080, %zero, %bb.98, implicit-def dead %at
    B %bb.97, implicit-def dead %at
  
  bb.97 (%ir-block.391, freq 4309389):
    successors: %bb.99(100)
  
    SW %66, %1080, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.392, !tbaa !19)
    B %bb.99, implicit-def dead %at
  
  bb.98 (%ir-block.393, freq 2585633):
    successors: %bb.99(100)
  
    SW %66, %1079, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.sunkaddr12, !tbaa !14)
  
  bb.99 (%ir-block.394, freq 6895023):
    successors: %bb.101(37), %bb.100(62)
  
    %419 = LBu %259, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @mverbose, align 4, !tbaa !6)
    BEQ killed %419, %zero, %bb.101, implicit-def dead %at
    B %bb.100, implicit-def dead %at
  
  bb.100 (%ir-block.397, freq 4309389):
    successors: %bb.101(100)
  
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %420 = LW %178, target-flags(<unknown>) @store_str, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %421 = ADDiu killed %420, target-flags(<unknown>) @store_str
    %422 = LEA_ADDiu %stack.9.userid.i, 0
    %a0 = COPY %422
    %t9 = COPY %421
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %423 = COPY %v0
    SW %423, %66, 12, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.401, !tbaa !21)
  
  bb.101 (%ir-block.402, freq 6895023):
    successors: %bb.117(100)
  
    SW %zero, %66, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.407, !tbaa !19)
    SW %1079, %66, 4, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.409, !tbaa !22)
    %425 = ORi %19, 3
    %426 = ANDi %1074, 255
    %427 = ANDi %19, 252
    %428 = MOVZ_I_I killed %427, killed %426, %425
    SB killed %428, %66, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.410, align 4, !tbaa !23)
    SW %zero, %66, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.412, !tbaa !24)
    %68 = COPY %66
    %424 = ADDiu %zero, 0
    B %bb.117, implicit-def dead %at
  
  bb.102 (%ir-block.413, freq 11032038):
    successors: %bb.215(75), %bb.117(25)
  
    BEQ %1079, %zero, %bb.117, implicit-def dead %at
    B %bb.215, implicit-def dead %at
  
  bb.215 (%ir-block.413, freq 8274028):
    successors: %bb.103(66), %bb.117(33)
  
    BEQ %1080, %zero, %bb.117, implicit-def dead %at
    B %bb.103, implicit-def dead %at
  
  bb.103 (%ir-block.416, freq 5516019):
    successors: %bb.105(50), %bb.104.._crit_edge.i16.i(50)
  
    %69 = LW %327, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @nleft, !tbaa !7)
    %328 = SLTi %69, 20
    BNE killed %328, %zero, %bb.105, implicit-def dead %at
    B %bb.104.._crit_edge.i16.i, implicit-def dead %at
  
  bb.104.._crit_edge.i16.i (freq 2758009):
    successors: %bb.106.allocn.exit17.i(100)
  
    %329 = LW %178, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %70 = LW killed %329, target-flags(<unknown>) @allocn.ptr, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @allocn.ptr, !tbaa !9)
    B %bb.106.allocn.exit17.i, implicit-def dead %at
  
  bb.105 (%ir-block.419, freq 2758009):
    successors: %bb.106.allocn.exit17.i(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %331 = LW %178, target-flags(<unknown>) @xmalloc, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @xmalloc)
    %a0 = COPY %332
    %t9 = COPY %331
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %333 = COPY %v0
    %71 = ADDiu %333, 4
    %335 = LW %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @totalsize, !tbaa !10)
    %330 = ADDiu %zero, 4000
    %337 = LW %178, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %339 = ADDiu killed %335, 4000
    SW killed %339, %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @totalsize, !tbaa !10)
    %340 = LW %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast (%struct.bufpool** @bufpool to i32*)`, !tbaa !9)
    SW killed %340, %333, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.424, !tbaa !12)
    SW %333, %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.bufpool** @bufpool to i8**)`, !tbaa !9)
    SW %71, killed %337, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @allocn.ptr, !tbaa !9)
    SW %330, %327, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nleft, !tbaa !7)
  
  bb.106.allocn.exit17.i (freq 5516019):
    successors: %bb.108(37), %bb.107(62)
  
    %72 = PHI %70, %bb.104.._crit_edge.i16.i, %71, %bb.105
    %73 = PHI %69, %bb.104.._crit_edge.i16.i, %330, %bb.105
    %74 = ADDiu %73, -20
    SW %74, %327, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nleft, !tbaa !7)
    %342 = ADDiu %72, 20
    %343 = LW %178, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW killed %342, %343, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @allocn.ptr, !tbaa !9)
    BEQ %1081, %zero, %bb.108, implicit-def dead %at
    B %bb.107, implicit-def dead %at
  
  bb.107 (%ir-block.431, freq 3447511):
    successors: %bb.109(100)
  
    SW %72, %1081, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.432, !tbaa !25)
    B %bb.109, implicit-def dead %at
  
  bb.108 (%ir-block.433, freq 2068507):
    successors: %bb.109(100)
  
    SW %72, %1080, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.435, !tbaa !24)
  
  bb.109 (%ir-block.436, freq 5516019):
    successors: %bb.112.._crit_edge.i22.i(37), %bb.110..lr.ph.i20.i(62)
  
    SW %zero, %72, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.438, !tbaa !25)
    SW %1080, %72, 4, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.440, !tbaa !27)
    %75 = LW %250, target-flags(<unknown>) @pkhash, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pkhash, !tbaa !9)
    %345 = LBu %stack.11.sigkeyID.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.437, align 8, !tbaa !6)
    %346 = SLL killed %345, 2
    %347 = ADDu %75, killed %346
    %76 = LW killed %347, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.444, !tbaa !9)
    BEQ %76, %zero, %bb.112.._crit_edge.i22.i, implicit-def dead %at
    B %bb.110..lr.ph.i20.i, implicit-def dead %at
  
  bb.110..lr.ph.i20.i (freq 56035749):
    successors: %bb.116.getpubkey.exit24.i(3), %bb.111(96)
  
    %77 = PHI %76, %bb.109, %78, %bb.111
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %348 = ADDiu %77, 16
    %349 = LW %178, target-flags(<unknown>) @memcmp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @memcmp)
    %351 = LEA_ADDiu %stack.11.sigkeyID.i, 0
    %a0 = COPY %348
    %a1 = COPY %351
    %a2 = COPY %303
    %gp = COPY %178
    %t9 = COPY %349
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %352 = COPY %v0
    BEQ %352, %zero, %bb.116.getpubkey.exit24.i, implicit-def dead %at
    B %bb.111, implicit-def dead %at
  
  bb.111 (%ir-block.450, freq 54284632):
    successors: %bb.112.._crit_edge.i22.i(3), %bb.110..lr.ph.i20.i(96)
  
    %78 = LW %77, 4, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.451, !tbaa !9)
    BNE %78, %zero, %bb.110..lr.ph.i20.i, implicit-def dead %at
    B %bb.112.._crit_edge.i22.i, implicit-def dead %at
  
  bb.112.._crit_edge.i22.i (freq 3764901):
    successors: %bb.114(50), %bb.113.._crit_edge.i26.i(50)
  
    %353 = SLTi %74, 28
    BNE killed %353, %zero, %bb.114, implicit-def dead %at
    B %bb.113.._crit_edge.i26.i, implicit-def dead %at
  
  bb.113.._crit_edge.i26.i (freq 1882450):
    successors: %bb.115.allocn.exit27.i(100)
  
    %79 = LW %343, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @allocn.ptr, !tbaa !9)
    B %bb.115.allocn.exit27.i, implicit-def dead %at
  
  bb.114 (%ir-block.454, freq 1882450):
    successors: %bb.115.allocn.exit27.i(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %356 = LW %178, target-flags(<unknown>) @xmalloc, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @xmalloc)
    %a0 = COPY %332
    %t9 = COPY %356
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %358 = COPY %v0
    %80 = ADDiu %358, 4
    %360 = LW %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @totalsize, !tbaa !10)
    %355 = ADDiu %zero, 4000
    %365 = ADDiu killed %360, 4000
    SW killed %365, %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @totalsize, !tbaa !10)
    %366 = LW %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from `i32* bitcast (%struct.bufpool** @bufpool to i32*)`, !tbaa !9)
    SW killed %366, %358, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.459, !tbaa !12)
    SW %358, %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i8** bitcast (%struct.bufpool** @bufpool to i8**)`, !tbaa !9)
    SW %80, %343, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @allocn.ptr, !tbaa !9)
    SW %355, %327, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nleft, !tbaa !7)
    %81 = LW %250, target-flags(<unknown>) @pkhash, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pkhash, !tbaa !9)
  
  bb.115.allocn.exit27.i (freq 3764901):
    successors: %bb.116.getpubkey.exit24.i(100)
  
    %82 = PHI %75, %bb.113.._crit_edge.i26.i, %81, %bb.114
    %83 = PHI %79, %bb.113.._crit_edge.i26.i, %80, %bb.114
    %84 = PHI %74, %bb.113.._crit_edge.i26.i, %355, %bb.114
    %367 = ADDiu %84, -28
    SW killed %367, %327, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nleft, !tbaa !7)
    %369 = ADDiu %83, 28
    SW killed %369, %343, target-flags(<unknown>) @allocn.ptr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @allocn.ptr, !tbaa !9)
    SW %zero, %83, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.462 + 24)
    SW %zero, %83, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.462 + 20)
    SW %zero, %83, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.462 + 16)
    SW %zero, %83, 12, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.462 + 12)
    SW %zero, %83, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.462 + 8)
    SW %zero, %83, 4, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.462 + 4)
    SW %zero, %83, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.462)
    %371 = LW %stack.11.sigkeyID.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.sigkeyID.i, align 8)
    %372 = LW %stack.11.sigkeyID.i, 4, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.sigkeyID.i + 4)
    %85 = COPY %83
    SWL %372, %83, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.469 + 4, align 1)
    SWL %371, %83, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.469, align 1)
    SWR %372, %83, 23, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.469 + 4, align 1)
    SWR %371, %83, 19, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.469, align 1)
    %373 = LBu %stack.11.sigkeyID.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.464, align 8, !tbaa !6)
    %374 = SLL killed %373, 2
    %375 = ADDu %82, killed %374
    %376 = LW killed %375, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.474, !tbaa !9)
    SW killed %376, %83, 4, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.477, !tbaa !17)
    %377 = LBu %stack.11.sigkeyID.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.464, align 8, !tbaa !6)
    %378 = SLL killed %377, 2
    %379 = ADDu %82, killed %378
    SW %83, killed %379, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.481, !tbaa !9)
  
  bb.116.getpubkey.exit24.i (freq 5516019):
    successors: %bb.117(100)
  
    %86 = PHI %77, %bb.110..lr.ph.i20.i, %85, %bb.115.allocn.exit27.i
    SW %86, %72, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.484, !tbaa !28)
    %380 = LW %86, 12, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.486, !tbaa !29)
    SW killed %380, %72, 12, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.489, !tbaa !30)
    SW %72, %86, 12, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.490, !tbaa !29)
    %381 = ANDi %19, 64
    SB killed %381, %72, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.493, align 4, !tbaa !31)
    %87 = COPY %72
  
  bb.117 (%ir-block.494, freq 43783401):
    successors: %bb.27..outer29.i(100)
  
    %88 = PHI %1074, %bb.214, %1074, %bb.102, %1074, %bb.215, %1074, %bb.116.getpubkey.exit24.i, %1074, %bb.88, %1074, %bb.101, %60, %bb.87.ismember_newkeys.exit.thread.i
    %89 = PHI %1075, %bb.214, %1075, %bb.102, %1075, %bb.215, %1075, %bb.116.getpubkey.exit24.i, %1075, %bb.88, %1075, %bb.101, %61, %bb.87.ismember_newkeys.exit.thread.i
    %90 = PHI %1076, %bb.214, %1076, %bb.102, %1076, %bb.215, %1076, %bb.116.getpubkey.exit24.i, %1076, %bb.88, %1076, %bb.101, %62, %bb.87.ismember_newkeys.exit.thread.i
    %91 = PHI %1079, %bb.214, %1079, %bb.102, %1079, %bb.215, %1079, %bb.116.getpubkey.exit24.i, %382, %bb.88, %1079, %bb.101, %32, %bb.87.ismember_newkeys.exit.thread.i
    %92 = PHI %1080, %bb.214, %1080, %bb.102, %1080, %bb.215, %1080, %bb.116.getpubkey.exit24.i, %1080, %bb.88, %68, %bb.101, %684, %bb.87.ismember_newkeys.exit.thread.i
    %93 = PHI %1081, %bb.214, %1081, %bb.102, %1081, %bb.215, %87, %bb.116.getpubkey.exit24.i, %1081, %bb.88, %424, %bb.101, %1081, %bb.87.ismember_newkeys.exit.thread.i
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %685 = LW %178, target-flags(<unknown>) @ftell, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @ftell)
    %a0 = COPY %12
    %gp = COPY %178
    %t9 = COPY %685
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %686 = COPY %v0
    %94 = COPY %686
    B %bb.27..outer29.i, implicit-def dead %at
  
  bb.119 (%ir-block.496, freq 1791526107):
    successors: %bb.121(25), %bb.217(75)
  
    BNE %1076, %zero, %bb.121, implicit-def dead %at
    B %bb.217, implicit-def dead %at
  
  bb.217 (%ir-block.496, freq 1343644580):
    successors: %bb.121(33), %bb.120(66)
  
    %691 = LBu %259, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @mverbose, align 4)
    %693 = ANDi %691, 255
    BEQ killed %693, %zero, %bb.121, implicit-def dead %at
    B %bb.120, implicit-def dead %at
  
  bb.120 (%ir-block.500, freq 895763053):
    successors: %bb.121(100)
  
    %694 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %695 = LW killed %694, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %696 = LW %178, target-flags(<unknown>) @.str.50, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %697 = ADDiu killed %696, target-flags(<unknown>) @.str.50
    %698 = LW %178, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %697
    %gp = COPY %178
    %t9 = COPY %698
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %699 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %700 = LW %178, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %695
    %a1 = COPY %699
    %gp = COPY %178
    %t9 = COPY %700
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.121 (%ir-block.504, freq 1791526107):
    successors: %bb.122.maint_read_data.exit(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %703 = LW %178, target-flags(<unknown>) @fclose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fclose)
    %a0 = COPY %12
    %gp = COPY %178
    %t9 = COPY %703
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %702 = ADDiu %zero, 0
  
  bb.122.maint_read_data.exit (freq 5650914367):
    successors: %bb.124(37), %bb.123(62)
  
    %102 = PHI %319, %bb.36..loopexit.i, %468, %bb.49, %13, %bb.22, %702, %bb.121, %705, %bb.19
    %103 = LW %190, target-flags(<unknown>) @sec_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @sec_fp, !tbaa !9)
    BEQ %103, %zero, %bb.124, implicit-def dead %at
    B %bb.123, implicit-def dead %at
  
  bb.123 (%ir-block.511, freq 3531821479):
    successors: %bb.124(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %715 = LW %178, target-flags(<unknown>) @fclose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fclose)
    %a0 = COPY %103
    %gp = COPY %178
    %t9 = COPY %715
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    SW %zero, %190, target-flags(<unknown>) @sec_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @sec_fp, !tbaa !9)
  
  bb.124 (%ir-block.513, freq 5650914367):
    successors: %bb.199(37), %bb.125(62)
  
    BLTZ %102, %bb.199, implicit-def dead %at
    B %bb.125, implicit-def dead %at
  
  bb.125 (%ir-block.515, freq 3531821479):
    successors: %bb.127(37), %bb.126(62)
  
    %719 = LBu %259, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @mverbose, align 4, !tbaa !6)
    %721 = LBu %258, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from @verbose)
    %722 = OR killed %721, killed %719
    %723 = ANDi killed %722, 255
    BEQ killed %723, %zero, %bb.127, implicit-def dead %at
    B %bb.126, implicit-def dead %at
  
  bb.126 (%ir-block.520, freq 2207388424):
    successors: %bb.127(100)
  
    %724 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %725 = LW killed %724, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %726 = LW %178, target-flags(<unknown>) @.str.40, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %727 = ADDiu killed %726, target-flags(<unknown>) @.str.40
    %728 = LW %178, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %727
    %gp = COPY %178
    %t9 = COPY %728
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %729 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %730 = LW %178, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %725
    %a1 = COPY %729
    %gp = COPY %178
    %t9 = COPY %730
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.127 (%ir-block.524, freq 3531821479):
    successors: %bb.135.maint_trace_chain.exit(37), %bb.225(62)
  
    %732 = LW %178, target-flags(<unknown>) @pklist, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %104 = LW %732, target-flags(<unknown>) @pklist, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pklist, !tbaa !9)
    BEQ %104, %zero, %bb.135.maint_trace_chain.exit, implicit-def %at
  
  bb.225 (freq 2207388424):
    successors: %bb.128..lr.ph.i5(100)
  
    %752 = LW %178, target-flags(<unknown>) @trace_sig_chain, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %753 = ADDiu %752, target-flags(<unknown>) @trace_sig_chain
    %754 = ADDiu %zero, 0
    %737 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %739 = LW %178, target-flags(<unknown>) @.str.59, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %740 = ADDiu %739, target-flags(<unknown>) @.str.59
  
  bb.128..lr.ph.i5 (freq 70636429595):
    successors: %bb.129(37), %bb.134(62)
  
    %105 = PHI %104, %bb.225, %109, %bb.134
    %106 = LB %105, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.526, align 4, !tbaa !16)
    BGEZ %106, %bb.134, implicit-def dead %at
    B %bb.129, implicit-def dead %at
  
  bb.129 (%ir-block.529, freq 26488661098):
    successors: %bb.131(37), %bb.130(62)
  
    %734 = LBu %259, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @mverbose, align 4, !tbaa !6)
    BEQ killed %734, %zero, %bb.131, implicit-def dead %at
    B %bb.130, implicit-def dead %at
  
  bb.130 (%ir-block.532, freq 16555413186):
    successors: %bb.131(100)
  
    %735 = LW %105, 8, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.534, !tbaa !14)
    %736 = LW killed %735, 12, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.536, !tbaa !21)
    %738 = LW %737, 0, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %741 = LW %178, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %738
    %a1 = COPY %740
    %a2 = COPY %736
    %gp = COPY %178
    %t9 = COPY %741
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %107 = LBu %105, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.sunkaddr15, align 4, !tbaa !16)
  
  bb.131 (%ir-block.539, freq 26488661098):
    successors: %bb.132(37), %bb.133(62)
  
    %108 = PHI %106, %bb.129, %107, %bb.130
    %743 = ANDi %108, 7
    BNE killed %743, %zero, %bb.133, implicit-def dead %at
    B %bb.132, implicit-def dead %at
  
  bb.132 (%ir-block.543, freq 9933247911):
    successors: %bb.133(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %744 = ADDiu %105, 16
    %745 = LW %178, target-flags(<unknown>) @user_from_keyID, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @user_from_keyID)
    %a0 = COPY %744
    %gp = COPY %178
    %t9 = COPY %745
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %746 = COPY %v0
    %747 = LBu %105, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.sunkaddr18, align 4, !tbaa !6)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %748 = LW %178, target-flags(<unknown>) @ask_owntrust, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @ask_owntrust)
    %a0 = COPY %746
    %a1 = COPY %747
    %gp = COPY %178
    %t9 = COPY %748
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %749 = COPY %v0
    %750 = ANDi %747, 248
    %751 = OR killed %750, %749
    SB killed %751, %105, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.sunkaddr18, align 4, !tbaa !6)
  
  bb.133 (%ir-block.552, freq 26488661098):
    successors: %bb.134(100)
  
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %a0 = COPY %105
    %a1 = COPY %754
    %t9 = COPY %753
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
  
  bb.134 (%ir-block.553, freq 70636429595):
    successors: %bb.135.maint_trace_chain.exit(3), %bb.128..lr.ph.i5(96)
  
    %109 = LW %105, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.554, !tbaa !9)
    BNE %109, %zero, %bb.128..lr.ph.i5, implicit-def dead %at
    B %bb.135.maint_trace_chain.exit, implicit-def dead %at
  
  bb.135.maint_trace_chain.exit (freq 3531821479):
    successors: %bb.137(37), %bb.136(62)
  
    %756 = LBu %258, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @verbose, !tbaa !6)
    BEQ killed %756, %zero, %bb.137, implicit-def dead %at
    B %bb.136, implicit-def dead %at
  
  bb.136 (%ir-block.558, freq 2207388424):
    successors: %bb.137(100)
  
    %757 = LW %178, target-flags(<unknown>) @.str.43, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %758 = LW %178, target-flags(<unknown>) @check_only, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %759 = LBu killed %758, target-flags(<unknown>) @check_only, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 1 from @check_only)
    %760 = ADDiu killed %757, target-flags(<unknown>) @.str.43
    %761 = LW %178, target-flags(<unknown>) @.str.42, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    %762 = ADDiu killed %761, target-flags(<unknown>) @.str.42
    %763 = LW %178, target-flags(<unknown>) @pgpout, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from got)
    %764 = MOVN_I_I killed %762, killed %759, %760
    %765 = LW killed %763, 0, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from @pgpout, !tbaa !9)
    %766 = LW %178, target-flags(<unknown>) @.str.41, <0x461f8d0> = !{!"unison-memory-partition", i32 6} :: (load 4 from got)
    %767 = ADDiu killed %766, target-flags(<unknown>) @.str.41
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %768 = LW %178, target-flags(<unknown>) @fprintf, <0x4777c50> = !{!"unison-memory-partition", i32 7} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %765
    %a1 = COPY %767
    %a2 = COPY %764
    %gp = COPY %178
    %t9 = COPY %768
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.137 (%ir-block.562, freq 3531821479):
    successors: %bb.138(50), %bb.139(50)
  
    %770 = LW %178, target-flags(<unknown>) @check_only, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %771 = LBu %770, target-flags(<unknown>) @check_only, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from @check_only)
    BEQ killed %771, %zero, %bb.139, implicit-def dead %at
    B %bb.138, implicit-def dead %at
  
  bb.138 (%ir-block.566, freq 1765910739):
    successors: %bb.140(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %777 = ADDiu %185, target-flags(<unknown>) @.str
    %778 = LW %178, target-flags(<unknown>) @fopen, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fopen)
    %a0 = COPY %176
    %a1 = COPY %777
    %t9 = COPY %778
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %779 = COPY %v0
    %110 = COPY %779
    B %bb.140, implicit-def dead %at
  
  bb.139 (%ir-block.568, freq 1765910739):
    successors: %bb.140(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %772 = LW %178, target-flags(<unknown>) @.str.63, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %773 = ADDiu killed %772, target-flags(<unknown>) @.str.63
    %774 = LW %178, target-flags(<unknown>) @fopen, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fopen)
    %a0 = COPY %176
    %a1 = COPY %773
    %t9 = COPY %774
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %775 = COPY %v0
    %111 = COPY %775
  
  bb.140 (%ir-block.570, freq 3531821479):
    successors: %bb.141(37), %bb.142(62)
  
    %112 = PHI %111, %bb.139, %110, %bb.138
    BNE %112, %zero, %bb.142, implicit-def dead %at
    B %bb.141, implicit-def dead %at
  
  bb.141 (%ir-block.572, freq 1324433054):
    successors: %bb.189.maint_final.exit(100)
  
    %936 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %937 = LW killed %936, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %938 = LW %178, target-flags(<unknown>) @.str.6, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %939 = ADDiu killed %938, target-flags(<unknown>) @.str.6
    %940 = LW %178, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %939
    %gp = COPY %178
    %t9 = COPY %940
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %941 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %942 = LW %178, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %937
    %a1 = COPY %941
    %a2 = COPY %176
    %gp = COPY %178
    %t9 = COPY %942
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %935 = ADDiu %zero, -1
    B %bb.189.maint_final.exit, implicit-def dead %at
  
  bb.142 (%ir-block.576, freq 2207388424):
    successors: %bb.143..outer.outer.i(100)
  
    %113 = LW %732, target-flags(<unknown>) @pklist, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pklist, !tbaa !9)
    %780 = IMPLICIT_DEF
    %784 = ADDiu %zero, 0
    %783 = COPY %784
    %787 = LEA_ADDiu %stack.0.n.i.i.i, 0
    %790 = LEA_ADDiu %stack.2.n.i.i, 0
    %791 = LEA_ADDiu %stack.6.userid.i.i, 0
    %792 = LEA_ADDiu %stack.7.keyID.i.i, 0
    %797 = ADDiu %zero, 20
    %798 = ADDiu %zero, 24
    %808 = ADDiu %zero, 1
    %809 = ADDiu %zero, 3
    %810 = LEA_ADDiu %stack.1.e.i.i.i, 0
    %813 = ADDiu %zero, 176
    %819 = LUi 255
    %821 = LUi 1
    %816 = ADDiu %zero, -3
    %824 = ADDiu %zero, 8
    %830 = ADDiu %zero, 2
    %831 = ADDiu %zero, 13
    %832 = ADDiu %zero, 6
    %805 = ADDiu %zero, 180
  
  bb.143..outer.outer.i (freq 2208495655):
    successors: %bb.144..outer.i16(100)
  
    %114 = PHI %780, %bb.142, %138, %bb.185
    %115 = PHI %783, %bb.142, %139, %bb.185
    %116 = PHI %783, %bb.142, %154, %bb.185
    %117 = PHI %783, %bb.142, %159, %bb.185
    %118 = PHI %113, %bb.142, %156, %bb.185
    %119 = PHI %783, %bb.142, %157, %bb.185
    %120 = PHI %784, %bb.142, %158, %bb.185
  
  bb.144..outer.i16 (freq 2242819802):
    successors: %bb.145..outer13.i(100)
  
    %121 = PHI %114, %bb.143..outer.outer.i, %138, %bb.182
    %122 = PHI %115, %bb.143..outer.outer.i, %139, %bb.182
    %123 = PHI %116, %bb.143..outer.outer.i, %154, %bb.182
    %124 = PHI %118, %bb.143..outer.outer.i, %156, %bb.182
    %125 = PHI %119, %bb.143..outer.outer.i, %157, %bb.182
    %126 = PHI %120, %bb.143..outer.outer.i, %158, %bb.182
  
  bb.145..outer13.i (freq 4099866601):
    successors: %bb.146..outer20.i(100)
  
    %127 = PHI %122, %bb.144..outer.i16, %132, %bb.159
    %786 = ADDiu %zero, 1
  
  bb.146..outer20.i (freq 8195604433):
    successors: %bb.147(100)
  
    %128 = PHI %786, %bb.145..outer13.i, %795, %bb.148, %795, %bb.149
  
  bb.147 (%ir-block.578, freq 68719476342):
    successors: %bb.186(3), %bb.148(96)
  
    ADJCALLSTACKDOWN 24, implicit-def dead %sp, implicit %sp
    %788 = COPY %sp
    SW %787, %788, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %789 = LW %178, target-flags(<unknown>) @readkpacket, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @readkpacket)
    %a0 = COPY %112
    %a1 = COPY %790
    %a2 = COPY %791
    %a3 = COPY %792
    %gp = COPY %178
    %t9 = COPY %789
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 24, 0, implicit-def dead %sp, implicit %sp
    %793 = COPY %v0
    %794 = SLTiu %793, -3
    %129 = COPY %793
    BEQ killed %794, %zero, %bb.186, implicit-def dead %at
    B %bb.148, implicit-def dead %at
  
  bb.148 (%ir-block.583, freq 66571992706):
    successors: %bb.146..outer20.i(3), %bb.149(96)
  
    %795 = ADDiu %zero, 0
    BLTZ %129, %bb.146..outer20.i, implicit-def dead %at
    B %bb.149, implicit-def dead %at
  
  bb.149 (%ir-block.585, freq 64491617934):
    successors: %bb.146..outer20.i(3), %bb.150(96)
  
    %130 = LBu %stack.2.n.i.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.n.i.i, align 4, !tbaa !6)
    %131 = ANDi %130, 124
    BEQ %131, %797, %bb.146..outer20.i, implicit-def dead %at
    B %bb.150, implicit-def dead %at
  
  bb.150 (%ir-block.590, freq 62476254874):
    successors: %bb.151(3), %bb.147(96)
  
    %799 = XOR %131, %798
    %800 = SLTiu killed %799, 1
    %801 = OR %128, killed %800
    %802 = ANDi killed %801, 1
    BEQ killed %802, %zero, %bb.147, implicit-def dead %at
    B %bb.151, implicit-def dead %at
  
  bb.151 (%ir-block.592, freq 1952382962):
    successors: %bb.153(66), %bb.152(33)
  
    %803 = ORi %131, 16
    BEQ killed %803, %798, %bb.153, implicit-def dead %at
    B %bb.152, implicit-def dead %at
  
  bb.152 (%ir-block.593, freq 650794321):
    successors: %bb.153(96), %bb.161..loopexit.i20(3)
  
    BNE %130, %805, %bb.161..loopexit.i20, implicit-def dead %at
    B %bb.153, implicit-def dead %at
  
  bb.153 (%ir-block.595, freq 1932045640):
    successors: %bb.154(50), %bb.159(50)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %806 = LW %178, target-flags(<unknown>) @ftell, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @ftell)
    %a0 = COPY %112
    %gp = COPY %178
    %t9 = COPY %806
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %807 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %811 = LW %178, target-flags(<unknown>) @fread, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fread)
    %a0 = COPY %810
    %a1 = COPY %808
    %a2 = COPY %809
    %a3 = COPY %112
    %gp = COPY %178
    %t9 = COPY %811
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %812 = COPY %v0
    %132 = COPY %807
    BNE %812, %809, %bb.159, implicit-def dead %at
    B %bb.154, implicit-def dead %at
  
  bb.154 (%ir-block.600, freq 966022820):
    successors: %bb.157(50), %bb.155(50)
  
    %133 = LW %stack.1.e.i.i.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.601)
    %134 = SRL %133, 24
    BEQ %134, %813, %bb.157, implicit-def dead %at
    B %bb.155, implicit-def dead %at
  
  bb.155 (%ir-block.606, freq 483011410):
    successors: %bb.156(37), %bb.159(62)
  
    %814 = SEB %134
    BGEZ killed %814, %bb.159, implicit-def dead %at
    B %bb.156, implicit-def dead %at
  
  bb.156 (%ir-block.609, freq 181129278):
    successors: %bb.159(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %815 = LW %178, target-flags(<unknown>) @fseek, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fseek)
    %a0 = COPY %112
    %a1 = COPY %816
    %a2 = COPY %808
    %gp = COPY %178
    %t9 = COPY %815
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.159, implicit-def dead %at
  
  bb.157 (%ir-block.611, freq 483011410):
    successors: %bb.158.read_trust.exit.i(3), %bb.159(96)
  
    %820 = AND %133, %819
    BNE killed %820, %821, %bb.159, implicit-def dead %at
    B %bb.158.read_trust.exit.i, implicit-def dead %at
  
  bb.158.read_trust.exit.i (freq 15094107):
    successors: %bb.161..loopexit.i20(100)
  
    %135 = SRL %133, 8
    %136 = LBu %stack.2.n.i.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.n.i.i, align 4, !tbaa !6)
    B %bb.161..loopexit.i20, implicit-def dead %at
  
  bb.159 (%ir-block.617, freq 1916951533):
    successors: %bb.145..outer13.i(96), %bb.160..thread.i(3)
  
    %822 = LBu %stack.2.n.i.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.n.i.i, align 4, !tbaa !6)
    %823 = ANDi killed %822, 124
    BEQ killed %823, %824, %bb.145..outer13.i, implicit-def dead %at
    B %bb.160..thread.i, implicit-def dead %at
  
  bb.160..thread.i (freq 59904735):
    successors: %bb.189.maint_final.exit(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %826 = LW %178, target-flags(<unknown>) @fclose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fclose)
    %a0 = COPY %112
    %gp = COPY %178
    %t9 = COPY %826
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %825 = ADDiu %zero, -7
    B %bb.189.maint_final.exit, implicit-def dead %at
  
  bb.161..loopexit.i20 (freq 35431428):
    successors: %bb.177(25), %bb.218..loopexit.i20(75)
  
    %137 = PHI %130, %bb.152, %136, %bb.158.read_trust.exit.i
    %138 = PHI %121, %bb.152, %135, %bb.158.read_trust.exit.i
    %139 = PHI %127, %bb.152, %132, %bb.158.read_trust.exit.i
    %829 = EXT %137, 2, 5
    BEQ %829, %830, %bb.177, implicit-def dead %at
    B %bb.218..loopexit.i20, implicit-def dead %at
  
  bb.218..loopexit.i20 (freq 26573571):
    successors: %bb.168(33), %bb.219..loopexit.i20(66)
  
    BEQ %829, %831, %bb.168, implicit-def dead %at
    B %bb.219..loopexit.i20, implicit-def dead %at
  
  bb.219..loopexit.i20 (freq 17715714):
    successors: %bb.162(50), %bb.182(50)
  
    %828 = ADDiu %zero, 0
    BNE %829, %832, %bb.182, implicit-def dead %at
    B %bb.162, implicit-def dead %at
  
  bb.162 (%ir-block.627, freq 8857857):
    successors: %bb.164(0), %bb.163(99)
  
    BEQ %124, %zero, %bb.164, implicit-def dead %at
    B %bb.163, implicit-def dead %at
  
  bb.163 (%ir-block.629, freq 8857848):
    successors: %bb.165(99), %bb.164(0)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %887 = ADDiu %124, 16
    %888 = LW %178, target-flags(<unknown>) @memcmp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @memcmp)
    %890 = LEA_ADDiu %stack.7.keyID.i.i, 0
    %a0 = COPY %887
    %a1 = COPY %890
    %a2 = COPY %824
    %gp = COPY %178
    %t9 = COPY %888
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %891 = COPY %v0
    BEQ %891, %zero, %bb.165, implicit-def dead %at
    B %bb.164, implicit-def dead %at
  
  bb.164 (%ir-block.634, freq 17):
    exit
  
    %902 = LW %178, target-flags(<unknown>) @__PRETTY_FUNCTION__.maint_final, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %903 = LW %178, target-flags(<unknown>) @.str.37, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %904 = LW %178, target-flags(<unknown>) @.str.64, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %905 = ADDiu killed %904, target-flags(<unknown>) @.str.64
    %906 = ADDiu killed %903, target-flags(<unknown>) @.str.37
    %907 = ADDiu killed %902, target-flags(<unknown>) @__PRETTY_FUNCTION__.maint_final
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %908 = LW %178, target-flags(<unknown>) @__assert_fail, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @__assert_fail)
    %909 = ADDiu %zero, 715
    %a0 = COPY %905
    %a1 = COPY %906
    %a2 = COPY %909
    %a3 = COPY %907
    %gp = COPY %178
    %t9 = COPY %908
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.165 (%ir-block.635, freq 8857840):
    successors: %bb.166(0), %bb.221(99)
  
    BNE %125, %zero, %bb.166, implicit-def dead %at
    B %bb.221, implicit-def dead %at
  
  bb.221 (%ir-block.635, freq 8857836):
    successors: %bb.166(0), %bb.167(99)
  
    BEQ %126, %zero, %bb.167, implicit-def dead %at
    B %bb.166, implicit-def dead %at
  
  bb.166 (%ir-block.638, freq 8):
    exit
  
    %894 = LW %178, target-flags(<unknown>) @__PRETTY_FUNCTION__.maint_final, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %895 = LW %178, target-flags(<unknown>) @.str.37, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %896 = LW %178, target-flags(<unknown>) @.str.65, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    %897 = ADDiu killed %896, target-flags(<unknown>) @.str.65
    %898 = ADDiu killed %895, target-flags(<unknown>) @.str.37
    %899 = ADDiu killed %894, target-flags(<unknown>) @__PRETTY_FUNCTION__.maint_final
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %900 = LW %178, target-flags(<unknown>) @__assert_fail, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @__assert_fail)
    %901 = ADDiu %zero, 716
    %a0 = COPY %897
    %a1 = COPY %898
    %a2 = COPY %901
    %a3 = COPY %899
    %gp = COPY %178
    %t9 = COPY %900
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.167 (%ir-block.639, freq 8857831):
    successors: %bb.182(100)
  
    %142 = LW %124, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.644, !tbaa !18)
    %141 = LBu %124, 24, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from %ir.642, align 4, !tbaa !16)
    %140 = LW %124, 8, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.640, !tbaa !14)
    %893 = ADDiu %zero, 0
    %892 = ADDiu %zero, 135
    B %bb.182, implicit-def dead %at
  
  bb.168 (%ir-block.646, freq 8857857):
    successors: %bb.169(0), %bb.220(99)
  
    BEQ %125, %zero, %bb.169, implicit-def dead %at
    B %bb.220, implicit-def dead %at
  
  bb.220 (%ir-block.646, freq 8857852):
    successors: %bb.169(0), %bb.170(99)
  
    BEQ %126, %zero, %bb.170, implicit-def dead %at
    B %bb.169, implicit-def dead %at
  
  bb.169 (%ir-block.649, freq 8):
    exit
  
    %879 = LW %178, target-flags(<unknown>) @__PRETTY_FUNCTION__.maint_final, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %880 = LW %178, target-flags(<unknown>) @.str.37, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %881 = LW %178, target-flags(<unknown>) @.str.66, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %882 = ADDiu killed %881, target-flags(<unknown>) @.str.66
    %883 = ADDiu killed %880, target-flags(<unknown>) @.str.37
    %884 = ADDiu killed %879, target-flags(<unknown>) @__PRETTY_FUNCTION__.maint_final
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %885 = LW %178, target-flags(<unknown>) @__assert_fail, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @__assert_fail)
    %886 = ADDiu %zero, 727
    %a0 = COPY %882
    %a1 = COPY %883
    %a2 = COPY %886
    %a3 = COPY %884
    %gp = COPY %178
    %t9 = COPY %885
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.170 (%ir-block.650, freq 8857848):
    successors: %bb.176.compute_legit.exit.i(37), %bb.171(62)
  
    %143 = LW %125, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.651, !tbaa !24)
    %857 = LW %125, 4, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.653, !tbaa !22)
    %858 = LB killed %857, 24, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 1 from %ir.655, align 4, !tbaa !16)
    %856 = ADDiu %zero, 3
    BLTZ killed %858, %bb.176.compute_legit.exit.i, implicit-def dead %at
    B %bb.171, implicit-def dead %at
  
  bb.171 (%ir-block.658, freq 5536155):
    successors: %bb.176.compute_legit.exit.i(37), %bb.172..lr.ph.i.i22(62)
  
    %859 = ADDiu %zero, 0
    BEQ %143, %zero, %bb.176.compute_legit.exit.i, implicit-def dead %at
    B %bb.172..lr.ph.i.i22, implicit-def dead %at
  
  bb.172..lr.ph.i.i22 (freq 110723109):
    successors: %bb.173.._crit_edge.i.i23(3), %bb.172..lr.ph.i.i22(96)
  
    %144 = PHI %143, %bb.171, %147, %bb.172..lr.ph.i.i22
    %145 = PHI %859, %bb.171, %146, %bb.172..lr.ph.i.i22
    %861 = ADDiu %239, target-flags(<unknown>) @trust_tbl
    %862 = LBu %144, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.660, align 4, !tbaa !31)
    %863 = ANDi killed %862, 7
    %864 = SLL killed %863, 2
    %865 = ADDu killed %861, killed %864
    %866 = LW killed %865, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.664, !tbaa !7)
    %147 = LW %144, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.667, !tbaa !9)
    %146 = ADDu killed %866, %145
    BNE %147, %zero, %bb.172..lr.ph.i.i22, implicit-def dead %at
    B %bb.173.._crit_edge.i.i23, implicit-def dead %at
  
  bb.173.._crit_edge.i.i23 (freq 3460097):
    successors: %bb.176.compute_legit.exit.i(37), %bb.174(62)
  
    BEQ %146, %zero, %bb.176.compute_legit.exit.i, implicit-def dead %at
    B %bb.174, implicit-def dead %at
  
  bb.174 (%ir-block.670, freq 2162560):
    successors: %bb.176.compute_legit.exit.i(50), %bb.175(50)
  
    %870 = LW %244, target-flags(<unknown>) @marginal_min, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @marginal_min, !tbaa !7)
    %871 = SLT %146, killed %870
    %868 = ADDiu %zero, 1
    BNE killed %871, %zero, %bb.176.compute_legit.exit.i, implicit-def dead %at
    B %bb.175, implicit-def dead %at
  
  bb.175 (%ir-block.673, freq 1081280):
    successors: %bb.176.compute_legit.exit.i(100)
  
    %873 = LW %238, target-flags(<unknown>) @complete_min, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @complete_min, !tbaa !7)
    %874 = SLT %146, killed %873
    %875 = XORi killed %874, 1
    %148 = ORi killed %875, 2
  
  bb.176.compute_legit.exit.i (freq 8857848):
    successors: %bb.182(100)
  
    %149 = PHI %856, %bb.170, %859, %bb.171, %859, %bb.173.._crit_edge.i.i23, %868, %bb.174, %148, %bb.175
    %877 = LBu %125, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.676, align 4, !tbaa !23)
    %878 = ANDi killed %877, 252
    %150 = OR killed %878, %149
    SB %150, %125, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.676, align 4, !tbaa !23)
    %151 = LW %125, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.682, !tbaa !19)
    B %bb.182, implicit-def dead %at
  
  bb.177 (%ir-block.684, freq 8857857):
    successors: %bb.178(0), %bb.179(99)
  
    BNE %126, %zero, %bb.179, implicit-def dead %at
    B %bb.178, implicit-def dead %at
  
  bb.178 (%ir-block.686, freq 7):
    exit
  
    %848 = LW %178, target-flags(<unknown>) @__PRETTY_FUNCTION__.maint_final, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %849 = LW %178, target-flags(<unknown>) @.str.37, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %850 = LW %178, target-flags(<unknown>) @.str.67, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %851 = ADDiu killed %850, target-flags(<unknown>) @.str.67
    %852 = ADDiu killed %849, target-flags(<unknown>) @.str.37
    %853 = ADDiu killed %848, target-flags(<unknown>) @__PRETTY_FUNCTION__.maint_final
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %854 = LW %178, target-flags(<unknown>) @__assert_fail, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @__assert_fail)
    %855 = ADDiu %zero, 741
    %a0 = COPY %851
    %a1 = COPY %852
    %a2 = COPY %855
    %a3 = COPY %853
    %gp = COPY %178
    %t9 = COPY %854
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.179 (%ir-block.687, freq 8857848):
    successors: %bb.181(99), %bb.180(0)
  
    %833 = LW %126, 8, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.689, !tbaa !28)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %834 = ADDiu killed %833, 16
    %835 = LW %178, target-flags(<unknown>) @memcmp, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @memcmp)
    %a0 = COPY %834
    %a1 = COPY %787
    %a2 = COPY %824
    %gp = COPY %178
    %t9 = COPY %835
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %838 = COPY %v0
    BEQ %838, %zero, %bb.181, implicit-def dead %at
    B %bb.180, implicit-def dead %at
  
  bb.180 (%ir-block.694, freq 8):
    exit
  
    %839 = LW %178, target-flags(<unknown>) @__PRETTY_FUNCTION__.maint_final, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %840 = LW %178, target-flags(<unknown>) @.str.37, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %841 = LW %178, target-flags(<unknown>) @.str.68, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %842 = ADDiu killed %841, target-flags(<unknown>) @.str.68
    %843 = ADDiu killed %840, target-flags(<unknown>) @.str.37
    %844 = ADDiu killed %839, target-flags(<unknown>) @__PRETTY_FUNCTION__.maint_final
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %845 = LW %178, target-flags(<unknown>) @__assert_fail, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @__assert_fail)
    %846 = ADDiu %zero, 742
    %a0 = COPY %842
    %a1 = COPY %843
    %a2 = COPY %846
    %a3 = COPY %844
    %gp = COPY %178
    %t9 = COPY %845
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.181 (%ir-block.695, freq 8857840):
    successors: %bb.182(100)
  
    %153 = LW %126, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.698, !tbaa !25)
    %152 = LBu %126, 16, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from %ir.696, align 4, !tbaa !31)
    %847 = ADDiu %zero, 135
  
  bb.182 (%ir-block.700, freq 35431378):
    successors: %bb.144..outer.i16(96), %bb.183(3)
  
    %154 = PHI %123, %bb.219..loopexit.i20, %152, %bb.181, %150, %bb.176.compute_legit.exit.i, %141, %bb.167
    %155 = PHI %828, %bb.219..loopexit.i20, %847, %bb.181, %856, %bb.176.compute_legit.exit.i, %892, %bb.167
    %156 = PHI %124, %bb.219..loopexit.i20, %124, %bb.181, %124, %bb.176.compute_legit.exit.i, %142, %bb.167
    %157 = PHI %125, %bb.219..loopexit.i20, %125, %bb.181, %151, %bb.176.compute_legit.exit.i, %140, %bb.167
    %158 = PHI %126, %bb.219..loopexit.i20, %153, %bb.181, %143, %bb.176.compute_legit.exit.i, %893, %bb.167
    %910 = XOR %154, %138
    %911 = AND killed %910, %155
    BEQ killed %911, %zero, %bb.144..outer.i16, implicit-def dead %at
    B %bb.183, implicit-def dead %at
  
  bb.183 (%ir-block.705, freq 1107230):
    successors: %bb.185(50), %bb.184(50)
  
    %913 = LBu %770, target-flags(<unknown>) @check_only, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @check_only)
    BNE killed %913, %zero, %bb.185, implicit-def dead %at
    B %bb.184, implicit-def dead %at
  
  bb.184 (%ir-block.706, freq 553615):
    successors: %bb.185(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %914 = LW %178, target-flags(<unknown>) @ftell, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @ftell)
    %a0 = COPY %112
    %gp = COPY %178
    %t9 = COPY %914
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %915 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %916 = LW %178, target-flags(<unknown>) @fseek, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fseek)
    %a0 = COPY %112
    %a1 = COPY %139
    %a2 = COPY %784
    %gp = COPY %178
    %t9 = COPY %916
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %919 = ANDi %154, 255
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %920 = LW %178, target-flags(<unknown>) @write_trust, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @write_trust)
    %a0 = COPY %112
    %a1 = COPY %919
    %gp = COPY %178
    %t9 = COPY %920
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %921 = LW %178, target-flags(<unknown>) @fseek, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fseek)
    %a0 = COPY %112
    %a1 = COPY %915
    %a2 = COPY %784
    %t9 = COPY %921
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.185 (%ir-block.710, freq 1107230):
    successors: %bb.143..outer.outer.i(100)
  
    %159 = ADDiu %117, 1
    B %bb.143..outer.outer.i, implicit-def dead %at
  
  bb.186 (%ir-block.712, freq 2147483639):
    successors: %bb.189.maint_final.exit(50), %bb.187(50)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %923 = LW %178, target-flags(<unknown>) @fclose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fclose)
    %a0 = COPY %112
    %gp = COPY %178
    %t9 = COPY %923
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %925 = SLTi %793, -1
    BNE killed %925, %zero, %bb.189.maint_final.exit, implicit-def dead %at
    B %bb.187, implicit-def dead %at
  
  bb.187 (%ir-block.715, freq 1073741819):
    successors: %bb.188(25), %bb.222(75)
  
    BNE %125, %zero, %bb.188, implicit-def dead %at
    B %bb.222, implicit-def dead %at
  
  bb.222 (%ir-block.715, freq 805306364):
    successors: %bb.188(16), %bb.223(83)
  
    BNE %124, %zero, %bb.188, implicit-def dead %at
    B %bb.223, implicit-def dead %at
  
  bb.223 (%ir-block.715, freq 671088637):
    successors: %bb.188(19), %bb.189.maint_final.exit(80)
  
    BEQ %126, %zero, %bb.189.maint_final.exit, implicit-def dead %at
    B %bb.188, implicit-def dead %at
  
  bb.188 (%ir-block.719, freq 536870909):
    successors: %bb.189.maint_final.exit(100)
  
    %927 = LW %178, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %928 = LW killed %927, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %929 = LW %178, target-flags(<unknown>) @.str.69, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %930 = ADDiu killed %929, target-flags(<unknown>) @.str.69
    %931 = LW %178, target-flags(<unknown>) @fwrite, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fwrite)
    %932 = ADDiu %zero, 28
    %933 = ADDiu %zero, 1
    %a0 = COPY %930
    %a1 = COPY %932
    %a2 = COPY %933
    %a3 = COPY %928
    %gp = COPY %178
    %t9 = COPY %931
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %926 = ADDiu %zero, -1
  
  bb.189.maint_final.exit (freq 3531821430):
    successors: %bb.199(37), %bb.190(62)
  
    %160 = PHI %825, %bb.160..thread.i, %129, %bb.186, %117, %bb.223, %926, %bb.188, %935, %bb.141
    BLTZ %160, %bb.199, implicit-def dead %at
    B %bb.190, implicit-def dead %at
  
  bb.190 (%ir-block.726, freq 2207388394):
    successors: %bb.192(37), %bb.191(62)
  
    %944 = LW %178, target-flags(<unknown>) @strleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, %944, target-flags(<unknown>) @strleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @strleft, !tbaa !7)
    %945 = LW %178, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, %945, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @hashleft, !tbaa !7)
    %946 = LW %178, target-flags(<unknown>) @hashtbl, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, killed %946, target-flags(<unknown>) @hashtbl, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @hashtbl, !tbaa !9)
    SW %zero, %200, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nkr, !tbaa !7)
    %949 = LBu %258, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from @verbose, !tbaa !6)
    BEQ killed %949, %zero, %bb.192, implicit-def dead %at
    B %bb.191, implicit-def dead %at
  
  bb.191 (%ir-block.729, freq 1379617746):
    successors: %bb.192(100)
  
    %951 = LW %249, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @totalsize, !tbaa !10)
    %952 = SRA %951, 31
    %953 = LW %178, target-flags(<unknown>) @pgpout, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %954 = SRL killed %952, 22
    %955 = ADDu %951, killed %954
    %956 = SRA killed %955, 10
    %957 = LW killed %953, 0, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from @pgpout, !tbaa !9)
    %958 = LW %178, target-flags(<unknown>) @.str.83, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from got)
    %959 = ADDiu killed %958, target-flags(<unknown>) @.str.83
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %960 = LW %178, target-flags(<unknown>) @fprintf, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %957
    %a1 = COPY %959
    %a2 = COPY %956
    %gp = COPY %178
    %t9 = COPY %960
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.192 (%ir-block.734, freq 2207388394):
    successors: %bb.194.endkrent.exit(37), %bb.226(62)
  
    SW %zero, %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @totalsize, !tbaa !10)
    %161 = LW %248, target-flags(<unknown>) @bufpool, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @bufpool, !tbaa !9)
    BEQ %161, %zero, %bb.194.endkrent.exit, implicit-def %at
  
  bb.226 (freq 1379617746):
    successors: %bb.193..lr.ph.i.i25(100)
  
  
  bb.193..lr.ph.i.i25 (freq 44147767884):
    successors: %bb.194.endkrent.exit(3), %bb.193..lr.ph.i.i25(96)
  
    %162 = PHI %161, %bb.226, %163, %bb.193..lr.ph.i.i25
    %964 = LW %162, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.738, !tbaa !12)
    SW killed %964, %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i32* bitcast (%struct.bufpool** @bufpool to i32*)`, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %966 = LW %178, target-flags(<unknown>) @free, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @free)
    %a0 = COPY %162
    %gp = COPY %178
    %t9 = COPY %966
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %163 = LW %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @bufpool, !tbaa !9)
    BNE %163, %zero, %bb.193..lr.ph.i.i25, implicit-def dead %at
    B %bb.194.endkrent.exit, implicit-def dead %at
  
  bb.194.endkrent.exit (freq 2207388394):
    successors: %bb.195..thread164(37), %bb.196(62)
  
    SW %zero, %945, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @hashleft, !tbaa !7)
    %968 = LW %178, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, %968, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nleft, !tbaa !7)
    SW %zero, %944, target-flags(<unknown>) @strleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @strleft, !tbaa !7)
    SW %zero, %250, target-flags(<unknown>) @pkhash, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @pkhash, !tbaa !9)
    %972 = LBu %258, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from @verbose, !tbaa !6)
    BNE killed %972, %zero, %bb.196, implicit-def dead %at
    B %bb.195..thread164, implicit-def dead %at
  
  bb.195..thread164 (freq 827770647):
    successors: %bb.198.maint_release_mem.exit(100)
  
    SW %zero, %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @totalsize, !tbaa !10)
    B %bb.198.maint_release_mem.exit, implicit-def dead %at
  
  bb.196 (%ir-block.745, freq 1379617746):
    successors: %bb.198.maint_release_mem.exit(37), %bb.227(62)
  
    %974 = LW %249, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @totalsize, !tbaa !10)
    %975 = SRA %974, 31
    %976 = LW %178, target-flags(<unknown>) @pgpout, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %977 = SRL killed %975, 22
    %978 = ADDu %974, killed %977
    %979 = LW killed %976, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @pgpout, !tbaa !9)
    %980 = SRA killed %978, 10
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %981 = LW %178, target-flags(<unknown>) @.str.83, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %982 = ADDiu killed %981, target-flags(<unknown>) @.str.83
    %983 = LW %178, target-flags(<unknown>) @fprintf, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %979
    %a1 = COPY %982
    %a2 = COPY %980
    %gp = COPY %178
    %t9 = COPY %983
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %164 = LW %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @bufpool, !tbaa !9)
    SW %zero, %249, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (store 4 into @totalsize, !tbaa !10)
    BEQ %164, %zero, %bb.198.maint_release_mem.exit, implicit-def %at
  
  bb.227 (freq 862261091):
    successors: %bb.197..lr.ph.i.i26(100)
  
  
  bb.197..lr.ph.i.i26 (freq 27592354928):
    successors: %bb.198.maint_release_mem.exit(3), %bb.197..lr.ph.i.i26(96)
  
    %165 = PHI %164, %bb.227, %166, %bb.197..lr.ph.i.i26
    %986 = LW %165, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.752, !tbaa !12)
    SW killed %986, %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i32* bitcast (%struct.bufpool** @bufpool to i32*)`, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %988 = LW %178, target-flags(<unknown>) @free, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @free)
    %a0 = COPY %165
    %gp = COPY %178
    %t9 = COPY %988
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %166 = LW %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @bufpool, !tbaa !9)
    BNE %166, %zero, %bb.197..lr.ph.i.i26, implicit-def dead %at
    B %bb.198.maint_release_mem.exit, implicit-def dead %at
  
  bb.198.maint_release_mem.exit (freq 2207388394):
    successors: %bb.210(100)
  
    SW %zero, %945, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @hashleft, !tbaa !7)
    SW %zero, %944, target-flags(<unknown>) @strleft, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (store 4 into @strleft, !tbaa !7)
    SW %zero, %968, target-flags(<unknown>) @nleft, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (store 4 into @nleft, !tbaa !7)
    %994 = LW %179, target-flags(<unknown>) @undefined_trust, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from @undefined_trust, !tbaa !7)
    %167 = ADDu killed %994, %160
    B %bb.210, implicit-def dead %at
  
  bb.199 (%ir-block.759, freq 3443525924):
    successors: %bb.200..thread(37), %bb.201(62)
  
    %168 = PHI %102, %bb.124, %160, %bb.189.maint_final.exit
    %996 = LBu %258, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from @verbose, !tbaa !6)
    BNE killed %996, %zero, %bb.201, implicit-def dead %at
    B %bb.200..thread, implicit-def dead %at
  
  bb.200..thread (freq 1291322221):
    successors: %bb.203(100)
  
    %1021 = LW %178, target-flags(<unknown>) @strleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, killed %1021, target-flags(<unknown>) @strleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @strleft, !tbaa !7)
    %1022 = LW %178, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, killed %1022, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @hashleft, !tbaa !7)
    %1023 = LW %178, target-flags(<unknown>) @hashtbl, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, killed %1023, target-flags(<unknown>) @hashtbl, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @hashtbl, !tbaa !9)
    SW %zero, %200, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nkr, !tbaa !7)
    B %bb.203, implicit-def dead %at
  
  bb.201 (%ir-block.762, freq 2152203702):
    successors: %bb.203(37), %bb.202(62)
  
    %997 = LW %178, target-flags(<unknown>) @pgpout, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %998 = LW %997, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %999 = LW %178, target-flags(<unknown>) @.str.44, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %1000 = ADDiu killed %999, target-flags(<unknown>) @.str.44
    %1001 = LW %178, target-flags(<unknown>) @fprintf, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %998
    %a1 = COPY %1000
    %a2 = COPY %168
    %gp = COPY %178
    %t9 = COPY %1001
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %1004 = LW %178, target-flags(<unknown>) @hashtbl, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %1005 = LW %178, target-flags(<unknown>) @hashleft, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %1006 = LW %178, target-flags(<unknown>) @strleft, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %1008 = LBu %258, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 1 from @verbose, !tbaa !6)
    SW %zero, killed %1006, target-flags(<unknown>) @strleft, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (store 4 into @strleft, !tbaa !7)
    SW %zero, killed %1005, target-flags(<unknown>) @hashleft, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (store 4 into @hashleft, !tbaa !7)
    SW %zero, killed %1004, target-flags(<unknown>) @hashtbl, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (store 4 into @hashtbl, !tbaa !9)
    SW %zero, %200, target-flags(<unknown>) @nkr, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (store 4 into @nkr, !tbaa !7)
    BEQ killed %1008, %zero, %bb.203, implicit-def dead %at
    B %bb.202, implicit-def dead %at
  
  bb.202 (%ir-block.766, freq 1345127314):
    successors: %bb.203(100)
  
    %1010 = LW %249, 0, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from @totalsize, !tbaa !10)
    %1011 = SRA %1010, 31
    %1013 = SRL killed %1011, 22
    %1014 = ADDu %1010, killed %1013
    %1015 = SRA killed %1014, 10
    %1016 = LW %997, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    %1017 = LW %178, target-flags(<unknown>) @.str.83, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %1018 = ADDiu killed %1017, target-flags(<unknown>) @.str.83
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %1019 = LW %178, target-flags(<unknown>) @fprintf, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %1016
    %a1 = COPY %1018
    %a2 = COPY %1015
    %t9 = COPY %1019
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.203 (%ir-block.771, freq 3443525924):
    successors: %bb.205.endkrent.exit28(37), %bb.228(62)
  
    SW %zero, %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @totalsize, !tbaa !10)
    %169 = LW %248, target-flags(<unknown>) @bufpool, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @bufpool, !tbaa !9)
    BEQ %169, %zero, %bb.205.endkrent.exit28, implicit-def %at
  
  bb.228 (freq 2152203702):
    successors: %bb.204..lr.ph.i.i27(100)
  
  
  bb.204..lr.ph.i.i27 (freq 68870518488):
    successors: %bb.205.endkrent.exit28(3), %bb.204..lr.ph.i.i27(96)
  
    %170 = PHI %169, %bb.228, %171, %bb.204..lr.ph.i.i27
    %1027 = LW %170, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.775, !tbaa !12)
    SW killed %1027, %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i32* bitcast (%struct.bufpool** @bufpool to i32*)`, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %1029 = LW %178, target-flags(<unknown>) @free, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @free)
    %a0 = COPY %170
    %gp = COPY %178
    %t9 = COPY %1029
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %171 = LW %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @bufpool, !tbaa !9)
    BNE %171, %zero, %bb.204..lr.ph.i.i27, implicit-def dead %at
    B %bb.205.endkrent.exit28, implicit-def dead %at
  
  bb.205.endkrent.exit28 (freq 3443525924):
    successors: %bb.206..thread165(37), %bb.207(62)
  
    %1030 = LW %178, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, %1030, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @hashleft, !tbaa !7)
    %1031 = LW %178, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, %1031, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nleft, !tbaa !7)
    %1032 = LW %178, target-flags(<unknown>) @strleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, %1032, target-flags(<unknown>) @strleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @strleft, !tbaa !7)
    SW %zero, %250, target-flags(<unknown>) @pkhash, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @pkhash, !tbaa !9)
    %1035 = LBu %258, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from @verbose, !tbaa !6)
    BNE killed %1035, %zero, %bb.207, implicit-def dead %at
    B %bb.206..thread165, implicit-def dead %at
  
  bb.206..thread165 (freq 1291322221):
    successors: %bb.209.maint_release_mem.exit30(100)
  
    SW %zero, %249, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @totalsize, !tbaa !10)
    B %bb.209.maint_release_mem.exit30, implicit-def dead %at
  
  bb.207 (%ir-block.782, freq 2152203702):
    successors: %bb.209.maint_release_mem.exit30(37), %bb.229(62)
  
    %1037 = LW %249, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @totalsize, !tbaa !10)
    %1038 = SRA %1037, 31
    %1039 = LW %178, target-flags(<unknown>) @pgpout, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %1040 = SRL killed %1038, 22
    %1041 = ADDu %1037, killed %1040
    %1042 = LW killed %1039, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    %1043 = SRA killed %1041, 10
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %1044 = LW %178, target-flags(<unknown>) @.str.83, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %1045 = ADDiu killed %1044, target-flags(<unknown>) @.str.83
    %1046 = LW %178, target-flags(<unknown>) @fprintf, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %1042
    %a1 = COPY %1045
    %a2 = COPY %1043
    %gp = COPY %178
    %t9 = COPY %1046
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %172 = LW %248, target-flags(<unknown>) @bufpool, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @bufpool, !tbaa !9)
    SW %zero, %249, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (store 4 into @totalsize, !tbaa !10)
    BEQ %172, %zero, %bb.209.maint_release_mem.exit30, implicit-def %at
  
  bb.229 (freq 1345127314):
    successors: %bb.208..lr.ph.i.i29(100)
  
  
  bb.208..lr.ph.i.i29 (freq 43044074055):
    successors: %bb.209.maint_release_mem.exit30(3), %bb.208..lr.ph.i.i29(96)
  
    %173 = PHI %172, %bb.229, %174, %bb.208..lr.ph.i.i29
    %1049 = LW %173, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.789, !tbaa !12)
    SW killed %1049, %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i32* bitcast (%struct.bufpool** @bufpool to i32*)`, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %1051 = LW %178, target-flags(<unknown>) @free, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @free)
    %a0 = COPY %173
    %gp = COPY %178
    %t9 = COPY %1051
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %174 = LW %248, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @bufpool, !tbaa !9)
    BNE %174, %zero, %bb.208..lr.ph.i.i29, implicit-def dead %at
    B %bb.209.maint_release_mem.exit30, implicit-def dead %at
  
  bb.209.maint_release_mem.exit30 (freq 3443525924):
    successors: %bb.210(100)
  
    SW %zero, %1030, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @hashleft, !tbaa !7)
    SW %zero, %1032, target-flags(<unknown>) @strleft, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (store 4 into @strleft, !tbaa !7)
    SW %zero, %1031, target-flags(<unknown>) @nleft, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (store 4 into @nleft, !tbaa !7)
  
  bb.210 (%ir-block.794, freq 5650914318):
    liveouts: %v0
  
    %175 = PHI %167, %bb.198.maint_release_mem.exit, %168, %bb.209.maint_release_mem.exit30
    %v0 = COPY %175
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            maint_check
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: gpr32 }
  - { id: 75, class: gpr32 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: gpr32 }
  - { id: 78, class: gpr32 }
  - { id: 79, class: gpr32 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: gpr32 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: gpr32 }
  - { id: 84, class: gpr32 }
  - { id: 85, class: gpr32 }
  - { id: 86, class: gpr32 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: gpr32 }
  - { id: 89, class: gpr32 }
  - { id: 90, class: gpr32 }
  - { id: 91, class: gpr32 }
  - { id: 92, class: gpr32 }
  - { id: 93, class: gpr32 }
  - { id: 94, class: gpr32 }
  - { id: 95, class: gpr32 }
  - { id: 96, class: gpr32 }
  - { id: 97, class: gpr32 }
  - { id: 98, class: gpr32 }
  - { id: 99, class: gpr32 }
  - { id: 100, class: gpr32 }
  - { id: 101, class: gpr32 }
  - { id: 102, class: gpr32 }
  - { id: 103, class: gpr32 }
  - { id: 104, class: gpr32 }
  - { id: 105, class: gpr32 }
  - { id: 106, class: gpr32 }
  - { id: 107, class: gpr32 }
  - { id: 108, class: gpr32 }
  - { id: 109, class: gpr32 }
  - { id: 110, class: gpr32 }
  - { id: 111, class: gpr32 }
  - { id: 112, class: gpr32 }
  - { id: 113, class: gpr32 }
  - { id: 114, class: gpr32 }
  - { id: 115, class: gpr32 }
  - { id: 116, class: gpr32 }
  - { id: 117, class: gpr32 }
  - { id: 118, class: gpr32 }
  - { id: 119, class: gpr32 }
  - { id: 120, class: gpr32 }
  - { id: 121, class: gpr32 }
  - { id: 122, class: gpr32 }
  - { id: 123, class: gpr32 }
  - { id: 124, class: gpr32 }
  - { id: 125, class: gpr32 }
  - { id: 126, class: gpr32 }
  - { id: 127, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%6' }
  - { reg: '%a1', virtual-reg: '%7' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 114):
    successors: %bb.2(37), %bb.1(62)
    liveins: %a0, %a1, %t9, %v0
  
    %8 = ADDu %v0, %t9
    %7 = COPY %a1
    %6 = COPY %a0
    %9 = EXT %7, 1, 1
    %10 = LW %8, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SB killed %9, %10, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into @mverbose, align 4, !tbaa !6)
    %11 = LW %8, target-flags(<unknown>) @moreflag, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %12 = LBu killed %11, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from @moreflag, !tbaa !6)
    BEQ killed %12, %zero, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.5, freq 71):
    successors: %bb.2(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %13 = LW %8, target-flags(<unknown>) @open_more, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @open_more)
    %gp = COPY %8
    %t9 = COPY %13
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.2 (%ir-block.7, freq 114):
    successors: %bb.5(37), %bb.3(62)
  
    %15 = LW %8, target-flags(<unknown>) @floppyring, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %16 = LBu %15, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from `i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)`, !tbaa !6)
    BEQ killed %16, %zero, %bb.5, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.10, freq 71):
    successors: %bb.4(37), %bb.5(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %17 = LW %8, target-flags(<unknown>) @.str, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %18 = ADDiu killed %17, target-flags(<unknown>) @.str
    %20 = LW %8, target-flags(<unknown>) @fopen, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fopen)
    %a0 = COPY %15
    %a1 = COPY %18
    %gp = COPY %8
    %t9 = COPY %20
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %21 = COPY %v0
    %22 = LW %8, target-flags(<unknown>) @floppy_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %21, killed %22, target-flags(<unknown>) @floppy_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @floppy_fp, !tbaa !9)
    BNE %21, %zero, %bb.5, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.13, freq 26):
    successors: %bb.5(100)
  
    %23 = LW %8, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %24 = LW killed %23, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %25 = LW %8, target-flags(<unknown>) @.str.1, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %26 = ADDiu killed %25, target-flags(<unknown>) @.str.1
    %27 = LW %8, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %26
    %gp = COPY %8
    %t9 = COPY %27
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %28 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %30 = LW %8, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %24
    %a1 = COPY %28
    %a2 = COPY %15
    %gp = COPY %8
    %t9 = COPY %30
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.5 (%ir-block.17, freq 114):
    successors: %bb.7(37), %bb.6(62)
  
    %32 = LW %8, target-flags(<unknown>) @check_only, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %33 = ADDiu %zero, 1
    SB killed %33, %32, target-flags(<unknown>) @check_only, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into @check_only)
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %34 = LW %8, target-flags(<unknown>) @maintenance, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %35 = ADDiu %34, target-flags(<unknown>) @maintenance
    %36 = ADDiu %zero, 0
    %a0 = COPY %6
    %a1 = COPY %36
    %t9 = COPY %35
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %37 = COPY %v0
    %38 = LW %8, target-flags(<unknown>) @floppy_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %1 = LW %38, target-flags(<unknown>) @floppy_fp, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @floppy_fp, !tbaa !9)
    %0 = COPY %37
    BEQ %1, %zero, %bb.7, implicit-def dead %at
    B %bb.6, implicit-def dead %at
  
  bb.6 (%ir-block.21, freq 71):
    successors: %bb.7(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %39 = LW %8, target-flags(<unknown>) @fclose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fclose)
    %a0 = COPY %1
    %gp = COPY %8
    %t9 = COPY %39
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    SW %zero, %38, target-flags(<unknown>) @floppy_fp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @floppy_fp, !tbaa !9)
  
  bb.7 (%ir-block.23, freq 114):
    successors: %bb.8(37), %bb.11(62)
  
    BGTZ %0, %bb.11, implicit-def dead %at
    B %bb.8, implicit-def dead %at
  
  bb.8 (%ir-block.25, freq 43):
    successors: %bb.9(37), %bb.10(62)
  
    BNE %0, %zero, %bb.10, implicit-def dead %at
    B %bb.9, implicit-def dead %at
  
  bb.9 (%ir-block.27, freq 16):
    successors: %bb.10(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %122 = LW %8, target-flags(<unknown>) @maint_list, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @maint_list)
    %a0 = COPY %6
    %gp = COPY %8
    %t9 = COPY %122
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.10 (%ir-block.29, freq 43):
    successors: %bb.24(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %124 = LW %8, target-flags(<unknown>) @close_more, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @close_more)
    %gp = COPY %8
    %t9 = COPY %124
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.24, implicit-def dead %at
  
  bb.11 (%ir-block.31, freq 71):
    successors: %bb.16(37), %bb.12(62)
  
    %42 = LW %8, target-flags(<unknown>) @undefined_trust, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %43 = LW %42, target-flags(<unknown>) @undefined_trust, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @undefined_trust, !tbaa !7)
    BEQ killed %43, %zero, %bb.16, implicit-def dead %at
    B %bb.12, implicit-def dead %at
  
  bb.12 (%ir-block.34, freq 44):
    successors: %bb.14..critedge(50), %bb.13(50)
  
    %44 = ANDi %7, 1
    BEQ killed %44, %zero, %bb.14..critedge, implicit-def dead %at
    B %bb.13, implicit-def dead %at
  
  bb.13 (%ir-block.37, freq 22):
    successors: %bb.24(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %45 = LW %8, target-flags(<unknown>) @maint_list, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @maint_list)
    %a0 = COPY %6
    %gp = COPY %8
    %t9 = COPY %45
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %47 = LW %8, target-flags(<unknown>) @pgpout, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %48 = LW killed %47, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %49 = LW %8, target-flags(<unknown>) @.str.2, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    %50 = ADDiu killed %49, target-flags(<unknown>) @.str.2
    %51 = LW %8, target-flags(<unknown>) @LANG, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @LANG)
    %a0 = COPY %50
    %gp = COPY %8
    %t9 = COPY %51
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %52 = COPY %v0
    %54 = LW %42, target-flags(<unknown>) @undefined_trust, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from @undefined_trust, !tbaa !7)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %55 = LW %8, target-flags(<unknown>) @fprintf, <0x461f8d0> = !{!"unison-memory-partition", i32 6} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %48
    %a1 = COPY %52
    %a2 = COPY %54
    %gp = COPY %8
    %t9 = COPY %55
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %57 = LW %8, target-flags(<unknown>) @close_more, <0x4777c50> = !{!"unison-memory-partition", i32 7} :: (load 4 from call-entry @close_more)
    %gp = COPY %8
    %t9 = COPY %57
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.24, implicit-def dead %at
  
  bb.14..critedge (freq 22):
    successors: %bb.15(37), %bb.16(62)
  
    %59 = LW %8, target-flags(<unknown>) @pgpout, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %60 = LW %59, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %61 = LW %8, target-flags(<unknown>) @.str.2, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    %62 = ADDiu killed %61, target-flags(<unknown>) @.str.2
    %63 = LW %8, target-flags(<unknown>) @LANG, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @LANG)
    %a0 = COPY %62
    %gp = COPY %8
    %t9 = COPY %63
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %64 = COPY %v0
    %66 = LW %42, target-flags(<unknown>) @undefined_trust, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from @undefined_trust, !tbaa !7)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %67 = LW %8, target-flags(<unknown>) @fprintf, <0x461f8d0> = !{!"unison-memory-partition", i32 6} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %60
    %a1 = COPY %64
    %a2 = COPY %66
    %gp = COPY %8
    %t9 = COPY %67
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %69 = LW %8, target-flags(<unknown>) @.str.3, <0x4777c50> = !{!"unison-memory-partition", i32 7} :: (load 4 from got)
    %70 = ADDiu killed %69, target-flags(<unknown>) @.str.3
    %71 = LW %59, 0, <0x4633c30> = !{!"unison-memory-partition", i32 8} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %72 = LW %8, target-flags(<unknown>) @LANG, <0x468acb0> = !{!"unison-memory-partition", i32 9} :: (load 4 from call-entry @LANG)
    %a0 = COPY %70
    %t9 = COPY %72
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %73 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %74 = LW %8, target-flags(<unknown>) @fprintf, <0x48723d0> = !{!"unison-memory-partition", i32 10} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %71
    %a1 = COPY %73
    %a2 = COPY %6
    %t9 = COPY %74
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %76 = ADDiu %zero, 121
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %77 = LW %8, target-flags(<unknown>) @getyesno, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @getyesno)
    %a0 = COPY %76
    %gp = COPY %8
    %t9 = COPY %77
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %78 = COPY %v0
    BNE %78, %zero, %bb.16, implicit-def dead %at
    B %bb.15, implicit-def dead %at
  
  bb.15 (%ir-block.53, freq 8):
    successors: %bb.24(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %79 = LW %8, target-flags(<unknown>) @close_more, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @close_more)
    %gp = COPY %8
    %t9 = COPY %79
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.24, implicit-def dead %at
  
  bb.16 (%ir-block.55, freq 40):
    successors: %bb.17(37), %bb.18(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %81 = LW %8, target-flags(<unknown>) @tempfile, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @tempfile)
    %82 = ADDiu %zero, 0
    %a0 = COPY %82
    %gp = COPY %8
    %t9 = COPY %81
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %83 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %84 = LW %8, target-flags(<unknown>) @copyfiles_by_name, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @copyfiles_by_name)
    %a0 = COPY %6
    %a1 = COPY %83
    %gp = COPY %8
    %t9 = COPY %84
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %85 = COPY %v0
    BGEZ %85, %bb.18, implicit-def dead %at
    B %bb.17, implicit-def dead %at
  
  bb.17 (%ir-block.59, freq 15):
    successors: %bb.24(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %120 = LW %8, target-flags(<unknown>) @close_more, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @close_more)
    %gp = COPY %8
    %t9 = COPY %120
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %119 = ADDiu %zero, -1
    B %bb.24, implicit-def dead %at
  
  bb.18 (%ir-block.61, freq 25):
    successors: %bb.19(62), %bb.20(37)
  
    %2 = COPY %83
    %87 = ADDiu %zero, 0
    SB %zero, %10, target-flags(<unknown>) @mverbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into @mverbose, align 4, !tbaa !6)
    SB %zero, %32, target-flags(<unknown>) @check_only, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (store 1 into @check_only)
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %90 = ADDiu %34, target-flags(<unknown>) @maintenance
    %a0 = COPY %2
    %a1 = COPY %87
    %t9 = COPY %90
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %91 = COPY %v0
    %3 = COPY %91
    BLTZ %91, %bb.20, implicit-def dead %at
    B %bb.19, implicit-def dead %at
  
  bb.19 (%ir-block.64, freq 16):
    successors: %bb.20(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %92 = LW %8, target-flags(<unknown>) @maint_list, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @maint_list)
    %a0 = COPY %2
    %gp = COPY %8
    %t9 = COPY %92
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %94 = LW %8, target-flags(<unknown>) @pgpout, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from got)
    %95 = LW killed %94, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %96 = LW %8, target-flags(<unknown>) @.str.4, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %97 = ADDiu killed %96, target-flags(<unknown>) @.str.4
    %98 = LW %8, target-flags(<unknown>) @LANG, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @LANG)
    %a0 = COPY %97
    %gp = COPY %8
    %t9 = COPY %98
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %99 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %100 = LW %8, target-flags(<unknown>) @fprintf, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %95
    %a1 = COPY %99
    %a2 = COPY %3
    %gp = COPY %8
    %t9 = COPY %100
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.20 (%ir-block.69, freq 25):
    successors: %bb.25(75), %bb.23(25)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %102 = LW %8, target-flags(<unknown>) @close_more, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @close_more)
    %gp = COPY %8
    %t9 = COPY %102
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %104 = ANDi %7, 1
    BNE killed %104, %zero, %bb.23, implicit-def dead %at
    B %bb.25, implicit-def dead %at
  
  bb.25 (%ir-block.69, freq 19):
    successors: %bb.21(66), %bb.23(33)
  
    BLEZ %3, %bb.23, implicit-def dead %at
    B %bb.21, implicit-def dead %at
  
  bb.21 (%ir-block.74, freq 12):
    successors: %bb.23(37), %bb.22(62)
  
    %105 = LW %8, target-flags(<unknown>) @pgpout, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %106 = LW killed %105, 0, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %107 = LW %8, target-flags(<unknown>) @.str.5, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from got)
    %108 = ADDiu killed %107, target-flags(<unknown>) @.str.5
    %109 = LW %8, target-flags(<unknown>) @LANG, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from call-entry @LANG)
    %a0 = COPY %108
    %gp = COPY %8
    %t9 = COPY %109
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %110 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %111 = LW %8, target-flags(<unknown>) @fprintf, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %106
    %a1 = COPY %110
    %a2 = COPY %6
    %gp = COPY %8
    %t9 = COPY %111
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %113 = ADDiu %zero, 121
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %114 = LW %8, target-flags(<unknown>) @getyesno, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @getyesno)
    %a0 = COPY %113
    %gp = COPY %8
    %t9 = COPY %114
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %115 = COPY %v0
    BEQ %115, %zero, %bb.23, implicit-def dead %at
    B %bb.22, implicit-def dead %at
  
  bb.22 (%ir-block.80, freq 8):
    successors: %bb.24(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %116 = LW %8, target-flags(<unknown>) @savetempbak, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @savetempbak)
    %a0 = COPY %2
    %a1 = COPY %6
    %gp = COPY %8
    %t9 = COPY %116
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %117 = COPY %v0
    %4 = COPY %117
    B %bb.24, implicit-def dead %at
  
  bb.23 (%ir-block.82, freq 17):
    successors: %bb.24(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %118 = LW %8, target-flags(<unknown>) @rmtemp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @rmtemp)
    %a0 = COPY %2
    %gp = COPY %8
    %t9 = COPY %118
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.24 (%ir-block.83, freq 114):
    liveouts: %v0
  
    %5 = PHI %0, %bb.13, %0, %bb.15, %4, %bb.22, %3, %bb.23, %119, %bb.17, %0, %bb.10
    %v0 = COPY %5
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            maint_list
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: gpr32 }
  - { id: 75, class: gpr32 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: gpr32 }
  - { id: 78, class: gpr32 }
  - { id: 79, class: gpr32 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: gpr32 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: gpr32 }
  - { id: 84, class: gpr32 }
  - { id: 85, class: gpr32 }
  - { id: 86, class: gpr32 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: gpr32 }
  - { id: 89, class: gpr32 }
  - { id: 90, class: gpr32 }
  - { id: 91, class: gpr32 }
  - { id: 92, class: gpr32 }
  - { id: 93, class: gpr32 }
  - { id: 94, class: gpr32 }
  - { id: 95, class: gpr32 }
  - { id: 96, class: gpr32 }
  - { id: 97, class: gpr32 }
  - { id: 98, class: gpr32 }
  - { id: 99, class: gpr32 }
  - { id: 100, class: gpr32 }
  - { id: 101, class: gpr32 }
  - { id: 102, class: gpr32 }
  - { id: 103, class: gpr32 }
  - { id: 104, class: gpr32 }
  - { id: 105, class: gpr32 }
  - { id: 106, class: gpr32 }
  - { id: 107, class: gpr32 }
  - { id: 108, class: gpr32 }
  - { id: 109, class: gpr32 }
  - { id: 110, class: gpr32 }
  - { id: 111, class: gpr32 }
  - { id: 112, class: gpr32 }
  - { id: 113, class: gpr32 }
  - { id: 114, class: gpr32 }
  - { id: 115, class: gpr32 }
  - { id: 116, class: gpr32 }
  - { id: 117, class: gpr32 }
  - { id: 118, class: gpr32 }
  - { id: 119, class: gpr32 }
  - { id: 120, class: gpr32 }
  - { id: 121, class: gpr32 }
  - { id: 122, class: gpr32 }
  - { id: 123, class: gpr32 }
  - { id: 124, class: gpr32 }
  - { id: 125, class: gpr32 }
  - { id: 126, class: gpr32 }
  - { id: 127, class: gpr32 }
  - { id: 128, class: gpr32 }
  - { id: 129, class: gpr32 }
  - { id: 130, class: gpr32 }
  - { id: 131, class: gpr32 }
  - { id: 132, class: gpr32 }
  - { id: 133, class: gpr32 }
  - { id: 134, class: gpr32 }
  - { id: 135, class: gpr32 }
  - { id: 136, class: gpr32 }
  - { id: 137, class: gpr32 }
  - { id: 138, class: gpr32 }
  - { id: 139, class: gpr32 }
  - { id: 140, class: gpr32 }
  - { id: 141, class: gpr32 }
  - { id: 142, class: gpr32 }
  - { id: 143, class: gpr32 }
  - { id: 144, class: gpr32 }
  - { id: 145, class: gpr32 }
  - { id: 146, class: gpr32 }
  - { id: 147, class: gpr32 }
  - { id: 148, class: gpr32 }
  - { id: 149, class: gpr32 }
  - { id: 150, class: gpr32 }
  - { id: 151, class: gpr32 }
  - { id: 152, class: gpr32 }
  - { id: 153, class: gpr32 }
  - { id: 154, class: gpr32 }
  - { id: 155, class: gpr32 }
  - { id: 156, class: gpr32 }
  - { id: 157, class: gpr32 }
  - { id: 158, class: gpr32 }
  - { id: 159, class: gpr32 }
  - { id: 160, class: gpr32 }
  - { id: 161, class: gpr32 }
  - { id: 162, class: gpr32 }
  - { id: 163, class: gpr32 }
  - { id: 164, class: gpr32 }
  - { id: 165, class: gpr32 }
  - { id: 166, class: gpr32 }
  - { id: 167, class: gpr32 }
  - { id: 168, class: gpr32 }
  - { id: 169, class: gpr32 }
  - { id: 170, class: gpr32 }
  - { id: 171, class: gpr32 }
  - { id: 172, class: gpr32 }
  - { id: 173, class: gpr32 }
  - { id: 174, class: gpr32 }
  - { id: 175, class: gpr32 }
  - { id: 176, class: gpr32 }
  - { id: 177, class: gpr32 }
  - { id: 178, class: gpr32 }
  - { id: 179, class: gpr32 }
  - { id: 180, class: gpr32 }
  - { id: 181, class: gpr32 }
  - { id: 182, class: gpr32 }
  - { id: 183, class: gpr32 }
  - { id: 184, class: gpr32 }
  - { id: 185, class: gpr32 }
  - { id: 186, class: gpr32 }
  - { id: 187, class: gpr32 }
  - { id: 188, class: gpr32 }
  - { id: 189, class: gpr32 }
  - { id: 190, class: gpr32 }
  - { id: 191, class: gpr32 }
  - { id: 192, class: gpr32 }
  - { id: 193, class: gpr32 }
  - { id: 194, class: gpr32 }
  - { id: 195, class: gpr32 }
  - { id: 196, class: gpr32 }
  - { id: 197, class: gpr32 }
  - { id: 198, class: gpr32 }
  - { id: 199, class: gpr32 }
  - { id: 200, class: gpr32 }
  - { id: 201, class: gpr32 }
  - { id: 202, class: gpr32 }
  - { id: 203, class: gpr32 }
  - { id: 204, class: gpr32 }
  - { id: 205, class: gpr32 }
  - { id: 206, class: gpr32 }
  - { id: 207, class: gpr32 }
  - { id: 208, class: gpr32 }
  - { id: 209, class: gpr32 }
  - { id: 210, class: gpr32 }
  - { id: 211, class: gpr32 }
  - { id: 212, class: gpr32 }
  - { id: 213, class: gpr32 }
  - { id: 214, class: gpr32 }
  - { id: 215, class: gpr32 }
  - { id: 216, class: gpr32 }
  - { id: 217, class: gpr32 }
  - { id: 218, class: gpr32 }
  - { id: 219, class: gpr32 }
  - { id: 220, class: gpr32 }
  - { id: 221, class: gpr32 }
  - { id: 222, class: gpr32 }
  - { id: 223, class: gpr32 }
  - { id: 224, class: gpr32 }
  - { id: 225, class: gpr32 }
  - { id: 226, class: gpr32 }
  - { id: 227, class: gpr32 }
  - { id: 228, class: gpr32 }
  - { id: 229, class: gpr32 }
  - { id: 230, class: gpr32 }
  - { id: 231, class: gpr32 }
  - { id: 232, class: gpr32 }
  - { id: 233, class: gpr32 }
  - { id: 234, class: gpr32 }
  - { id: 235, class: gpr32 }
  - { id: 236, class: gpr32 }
  - { id: 237, class: gpr32 }
  - { id: 238, class: gpr32 }
  - { id: 239, class: gpr32 }
  - { id: 240, class: gpr32 }
  - { id: 241, class: gpr32 }
  - { id: 242, class: gpr32 }
  - { id: 243, class: gpr32 }
  - { id: 244, class: gpr32 }
  - { id: 245, class: gpr32 }
  - { id: 246, class: gpr32 }
  - { id: 247, class: gpr32 }
  - { id: 248, class: gpr32 }
  - { id: 249, class: gpr32 }
  - { id: 250, class: gpr32 }
  - { id: 251, class: gpr32 }
  - { id: 252, class: gpr32 }
  - { id: 253, class: gpr32 }
  - { id: 254, class: gpr32 }
  - { id: 255, class: gpr32 }
  - { id: 256, class: gpr32 }
  - { id: 257, class: gpr32 }
  - { id: 258, class: gpr32 }
  - { id: 259, class: gpr32 }
  - { id: 260, class: gpr32 }
  - { id: 261, class: gpr32 }
  - { id: 262, class: gpr32 }
  - { id: 263, class: gpr32 }
  - { id: 264, class: gpr32 }
  - { id: 265, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%39' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
stack:           
  - { id: 0, name: buf.i, offset: 0, size: 3, alignment: 4 }
  - { id: 1, name: userid, offset: 0, size: 256, alignment: 4 }
  - { id: 2, name: keyID, offset: 0, size: 8, alignment: 4 }
  - { id: 3, name: sigkeyID, offset: 0, size: 8, alignment: 4 }
  - { id: 4, name: ctb, offset: 0, size: 1, alignment: 4 }
body:             |
  bb.0 (%ir-block.0, freq 13421772):
    successors: %bb.1(37), %bb.2(62)
    liveins: %a0, %t9, %v0
  
    %40 = ADDu %v0, %t9
    %39 = COPY %a0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %41 = LW %40, target-flags(<unknown>) @.str, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %42 = ADDiu killed %41, target-flags(<unknown>) @.str
    %43 = LW %40, target-flags(<unknown>) @fopen, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fopen)
    %a0 = COPY %39
    %a1 = COPY %42
    %gp = COPY %40
    %t9 = COPY %43
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %44 = COPY %v0
    BNE %44, %zero, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.6, freq 5033164):
    successors: %bb.41(100)
  
    %256 = LW %40, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %257 = LW killed %256, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %258 = LW %40, target-flags(<unknown>) @.str.6, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %259 = ADDiu killed %258, target-flags(<unknown>) @.str.6
    %260 = LW %40, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %259
    %gp = COPY %40
    %t9 = COPY %260
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %261 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %262 = LW %40, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %257
    %a1 = COPY %261
    %a2 = COPY %39
    %gp = COPY %40
    %t9 = COPY %262
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %255 = ADDiu %zero, -1
    B %bb.41, implicit-def dead %at
  
  bb.2 (%ir-block.10, freq 8388608):
    successors: %bb.4(99), %bb.3(0)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %45 = LW %40, target-flags(<unknown>) @init_trust_lst, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @init_trust_lst)
    %gp = COPY %40
    %t9 = COPY %45
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %46 = LW %40, target-flags(<unknown>) @nkr, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %1 = LW %46, target-flags(<unknown>) @nkr, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @nkr, !tbaa !7)
    %47 = SLTi %1, 8
    BNE killed %47, %zero, %bb.4, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.13, freq 8):
    exit
  
    %48 = LW %40, target-flags(<unknown>) @__PRETTY_FUNCTION__.setkrent, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %49 = LW %40, target-flags(<unknown>) @.str.37, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %50 = LW %40, target-flags(<unknown>) @.str.36, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %51 = ADDiu killed %50, target-flags(<unknown>) @.str.36
    %52 = ADDiu killed %49, target-flags(<unknown>) @.str.37
    %53 = ADDiu killed %48, target-flags(<unknown>) @__PRETTY_FUNCTION__.setkrent
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %54 = LW %40, target-flags(<unknown>) @__assert_fail, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @__assert_fail)
    %55 = ADDiu %zero, 1447
    %a0 = COPY %51
    %a1 = COPY %52
    %a2 = COPY %55
    %a3 = COPY %53
    %gp = COPY %40
    %t9 = COPY %54
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.4 (%ir-block.14, freq 8388600):
    successors: %bb.44(62), %bb.7.._crit_edge.i(37)
  
    %58 = LW %40, target-flags(<unknown>) @globalPubringName, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %2 = MOVZ_I_I killed %58, %39, %39
    %59 = LW %40, target-flags(<unknown>) @krnames, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    BLEZ %1, %bb.7.._crit_edge.i, implicit-def %at
  
  bb.44 (freq 5242875):
    successors: %bb.6..lr.ph.i(100)
  
    %56 = ADDiu %59, target-flags(<unknown>) @krnames
    %57 = ADDiu %zero, 0
    B %bb.6..lr.ph.i, implicit-def %at
  
  bb.5 (%ir-block.17, freq 82554476):
    successors: %bb.6..lr.ph.i(96), %bb.7.._crit_edge.i(3)
  
    %6 = ADDiu %5, 1
    %63 = SLT %6, %1
    %3 = ADDiu %4, 4
    BEQ killed %63, %zero, %bb.7.._crit_edge.i, implicit-def dead %at
    B %bb.6..lr.ph.i, implicit-def dead %at
  
  bb.6..lr.ph.i (freq 85217523):
    successors: %bb.8.setkrent.exit(3), %bb.5(96)
  
    %4 = PHI %56, %bb.44, %3, %bb.5
    %5 = PHI %57, %bb.44, %6, %bb.5
    %60 = LW %4, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv1, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %61 = LW %40, target-flags(<unknown>) @strcmp, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %2
    %a1 = COPY %60
    %gp = COPY %40
    %t9 = COPY %61
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %62 = COPY %v0
    BEQ %62, %zero, %bb.8.setkrent.exit, implicit-def dead %at
    B %bb.5, implicit-def dead %at
  
  bb.7.._crit_edge.i (freq 5725552):
    successors: %bb.8.setkrent.exit(100)
  
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %64 = LW %40, target-flags(<unknown>) @store_str, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %65 = ADDiu killed %64, target-flags(<unknown>) @store_str
    %a0 = COPY %2
    %t9 = COPY %65
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %66 = COPY %v0
    %68 = LW %46, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @nkr, !tbaa !7)
    %70 = ADDiu %68, 1
    SW killed %70, %46, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nkr, !tbaa !7)
    %71 = ADDiu %59, target-flags(<unknown>) @krnames
    %72 = SLL %68, 2
    %73 = ADDu killed %71, killed %72
    SW %66, killed %73, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.27, !tbaa !9)
  
  bb.8.setkrent.exit (freq 8388600):
    successors: %bb.9..outer.outer.outer(100)
  
    %0 = COPY %44
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %76 = LW %40, target-flags(<unknown>) @init_userhash, <0x473cdc0> = !{!"unison-memory-partition", i32 13} :: (load 4 from call-entry @init_userhash)
    %gp = COPY %40
    %t9 = COPY %76
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %78 = LW %40, target-flags(<unknown>) @pgpout, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    %79 = LW %78, 0, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %80 = LW %40, target-flags(<unknown>) @.str.7, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from got)
    %81 = ADDiu killed %80, target-flags(<unknown>) @.str.7
    %82 = LW %40, target-flags(<unknown>) @LANG, <0x461f8d0> = !{!"unison-memory-partition", i32 6} :: (load 4 from call-entry @LANG)
    %a0 = COPY %81
    %gp = COPY %40
    %t9 = COPY %82
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %83 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %84 = LW %40, target-flags(<unknown>) @fprintf, <0x4777c50> = !{!"unison-memory-partition", i32 7} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %79
    %a1 = COPY %83
    %gp = COPY %40
    %t9 = COPY %84
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %74 = IMPLICIT_DEF
    %75 = ADDiu %zero, 0
    %87 = LW %40, target-flags(<unknown>) @trust_lst, <0x4874140> = !{!"unison-memory-partition", i32 15} :: (load 4 from got)
    %89 = LEA_ADDiu %stack.3.sigkeyID, 0
    %92 = LEA_ADDiu %stack.4.ctb, 0
    %93 = LEA_ADDiu %stack.1.userid, 0
    %94 = LEA_ADDiu %stack.2.keyID, 0
    %99 = ADDiu %zero, 24
    %103 = ADDiu %zero, 1
    %104 = ADDiu %zero, 3
    %105 = LEA_ADDiu %stack.0.buf.i, 0
    %107 = ADDiu %zero, 176
    %113 = LUi 255
    %115 = LUi 1
    %110 = ADDiu %zero, -3
    %118 = ADDiu %zero, 8
    %120 = ADDiu %zero, 2
    %128 = ADDiu %zero, 32
    %129 = ADDiu %zero, 99
    %131 = LW %40, target-flags(<unknown>) @.str.8, <0x4633c30> = !{!"unison-memory-partition", i32 8} :: (load 4 from got)
    %132 = ADDiu %131, target-flags(<unknown>) @.str.8
    %133 = LW %40, target-flags(<unknown>) @blankkeyID, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %138 = LW %40, target-flags(<unknown>) @.str.9, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %139 = LW %40, target-flags(<unknown>) @trustlst_len, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %144 = ADDiu %138, target-flags(<unknown>) @.str.9
    %147 = LW %40, target-flags(<unknown>) @legitlst_len, <0x48723d0> = !{!"unison-memory-partition", i32 10} :: (load 4 from got)
    %148 = LW %40, target-flags(<unknown>) @.str.11, <0x47b0020> = !{!"unison-memory-partition", i32 11} :: (load 4 from got)
    %149 = LW %40, target-flags(<unknown>) @.str.13, <0x459b620> = !{!"unison-memory-partition", i32 12} :: (load 4 from got)
    %150 = ADDiu %149, target-flags(<unknown>) @.str.13
    %151 = ADDiu %148, target-flags(<unknown>) @.str.11
    %166 = LW %40, target-flags(<unknown>) @.str.14, <0x468acb0> = !{!"unison-memory-partition", i32 9} :: (load 4 from got)
    %167 = ADDiu %166, target-flags(<unknown>) @.str.14
    %159 = LW %40, target-flags(<unknown>) @.str.12, <0x486ef90> = !{!"unison-memory-partition", i32 14} :: (load 4 from got)
    %160 = ADDiu %159, target-flags(<unknown>) @.str.12
    %121 = ADDiu %zero, 13
    %122 = ADDiu %zero, 6
    %224 = ADDiu %zero, 42
    %101 = ADDiu %zero, 180
  
  bb.9..outer.outer.outer (freq 8450264):
    successors: %bb.10..outer.outer(100)
  
    %7 = PHI %74, %bb.8.setkrent.exit, %26, %bb.25
    %8 = PHI %75, %bb.8.setkrent.exit, %27, %bb.25
    %9 = PHI %75, %bb.8.setkrent.exit, %28, %bb.25
    %86 = SLL %9, 4
    %10 = ADDu %87, killed %86
  
  bb.10..outer.outer (freq 8569740):
    successors: %bb.11..outer.outer5(100)
  
    %11 = PHI %7, %bb.9..outer.outer.outer, %26, %bb.32
    %12 = PHI %8, %bb.9..outer.outer.outer, %123, %bb.32
    %13 = ANDi %12, 255
    %88 = ADDiu %zero, 0
  
  bb.11..outer.outer5 (freq 8631405):
    successors: %bb.12..outer(100)
  
    %14 = PHI %11, %bb.10..outer.outer, %26, %bb.31
    %15 = PHI %88, %bb.10..outer.outer, %30, %bb.31
  
  bb.12..outer (freq 16158370):
    successors: %bb.13(100)
  
    %16 = PHI %14, %bb.11..outer.outer5, %26, %bb.43, %26, %bb.35, %26, %bb.34
  
  bb.13 (%ir-block.34, freq 262637636):
    successors: %bb.36..loopexit(3), %bb.14(96)
  
    ADJCALLSTACKDOWN 24, implicit-def dead %sp, implicit %sp
    %90 = COPY %sp
    SW %89, %90, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %91 = LW %40, target-flags(<unknown>) @readkpacket, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @readkpacket)
    %a0 = COPY %0
    %a1 = COPY %92
    %a2 = COPY %93
    %a3 = COPY %94
    %gp = COPY %40
    %t9 = COPY %91
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 24, 0, implicit-def dead %sp, implicit %sp
    %95 = COPY %v0
    %96 = SLTiu %95, -3
    %17 = COPY %95
    BEQ killed %96, %zero, %bb.36..loopexit, implicit-def dead %at
    B %bb.14, implicit-def dead %at
  
  bb.14 (%ir-block.39, freq 254430210):
    successors: %bb.13(96), %bb.15(3)
  
    BLTZ %17, %bb.13, implicit-def dead %at
    B %bb.15, implicit-def dead %at
  
  bb.15 (%ir-block.41, freq 7950944):
    successors: %bb.17(66), %bb.16(33)
  
    %18 = LBu %stack.4.ctb, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    %97 = ORi %18, 16
    %98 = ANDi killed %97, 124
    BEQ killed %98, %99, %bb.17, implicit-def dead %at
    B %bb.16, implicit-def dead %at
  
  bb.16 (%ir-block.45, freq 2650314):
    successors: %bb.17(50), %bb.24(50)
  
    %100 = ANDi %18, 255
    BNE killed %100, %101, %bb.24, implicit-def dead %at
    B %bb.17, implicit-def dead %at
  
  bb.17 (%ir-block.47, freq 6625786):
    successors: %bb.18(50), %bb.23(50)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %102 = LW %40, target-flags(<unknown>) @fread, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fread)
    %a0 = COPY %105
    %a1 = COPY %103
    %a2 = COPY %104
    %a3 = COPY %0
    %gp = COPY %40
    %t9 = COPY %102
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %106 = COPY %v0
    BNE %106, %104, %bb.23, implicit-def dead %at
    B %bb.18, implicit-def dead %at
  
  bb.18 (%ir-block.51, freq 3312893):
    successors: %bb.21(50), %bb.19(50)
  
    %19 = LW %stack.0.buf.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.52)
    %20 = SRL %19, 24
    BEQ %20, %107, %bb.21, implicit-def dead %at
    B %bb.19, implicit-def dead %at
  
  bb.19 (%ir-block.58, freq 1656446):
    successors: %bb.20(37), %bb.23(62)
  
    %108 = SEB %20
    BGEZ killed %108, %bb.23, implicit-def dead %at
    B %bb.20, implicit-def dead %at
  
  bb.20 (%ir-block.61, freq 621167):
    successors: %bb.23(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %109 = LW %40, target-flags(<unknown>) @fseek, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fseek)
    %a0 = COPY %0
    %a1 = COPY %110
    %a2 = COPY %103
    %gp = COPY %40
    %t9 = COPY %109
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.23, implicit-def dead %at
  
  bb.21 (%ir-block.63, freq 1656446):
    successors: %bb.22.read_trust.exit(50), %bb.23(50)
  
    %114 = AND %19, %113
    BNE killed %114, %115, %bb.23, implicit-def dead %at
    B %bb.22.read_trust.exit, implicit-def dead %at
  
  bb.22.read_trust.exit (freq 828223):
    successors: %bb.24(100)
  
    %21 = SRL %19, 8
    %22 = COPY %21
    %23 = LBu %stack.4.ctb, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    B %bb.24, implicit-def dead %at
  
  bb.23 (%ir-block.68, freq 5797563):
    successors: %bb.24(96), %bb.36..loopexit(3)
  
    %24 = LBu %stack.4.ctb, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    %117 = ANDi %24, 124
    %116 = ADDiu %zero, -7
    BNE killed %117, %118, %bb.36..loopexit, implicit-def dead %at
    B %bb.24, implicit-def dead %at
  
  bb.24 (%ir-block.73, freq 7769770):
    successors: %bb.32(49), %bb.42(50)
  
    %25 = PHI %18, %bb.16, %24, %bb.23, %23, %bb.22.read_trust.exit
    %26 = PHI %16, %bb.16, %16, %bb.23, %22, %bb.22.read_trust.exit
    %119 = EXT %25, 2, 5
    BEQ %119, %120, %bb.32, implicit-def dead %at
    B %bb.42, implicit-def dead %at
  
  bb.42 (%ir-block.73, freq 3946549):
    successors: %bb.26(1), %bb.43(98)
  
    BEQ %119, %121, %bb.26, implicit-def dead %at
    B %bb.43, implicit-def dead %at
  
  bb.43 (%ir-block.73, freq 3884885):
    successors: %bb.25(1), %bb.12..outer(98)
  
    BNE %119, %122, %bb.12..outer, implicit-def dead %at
    B %bb.25, implicit-def dead %at
  
  bb.25 (%ir-block.78, freq 61664):
    successors: %bb.9..outer.outer.outer(100)
  
    %220 = ANDi %26, 128
    SB %zero, %stack.1.userid, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.79, align 4, !tbaa !6)
    %222 = SRL killed %220, 7
    %27 = MOVN_I_I %224, killed %222, %128
    %28 = ANDi %26, 7
    B %bb.9..outer.outer.outer, implicit-def dead %at
  
  bb.26 (%ir-block.85, freq 61664):
    successors: %bb.28(62), %bb.27(37)
  
    %29 = LW %78, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    BNE %15, %zero, %bb.28, implicit-def dead %at
    B %bb.27, implicit-def dead %at
  
  bb.27 (%ir-block.88, freq 23124):
    successors: %bb.29(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %171 = LW %40, target-flags(<unknown>) @keyIDstring, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @keyIDstring)
    %172 = LEA_ADDiu %stack.2.keyID, 0
    %a0 = COPY %172
    %gp = COPY %40
    %t9 = COPY %171
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %173 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %175 = ADDiu %131, target-flags(<unknown>) @.str.8
    %176 = LW %40, target-flags(<unknown>) @fprintf, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %29
    %a1 = COPY %175
    %a2 = COPY %13
    %a3 = COPY %173
    %t9 = COPY %176
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %181 = ADDiu %138, target-flags(<unknown>) @.str.9
    %182 = LW %139, target-flags(<unknown>) @trustlst_len, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @trustlst_len, !tbaa !7)
    %183 = LW %78, 0, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %184 = LW %40, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %183
    %a1 = COPY %181
    %a2 = COPY %182
    %a3 = COPY %10
    %t9 = COPY %184
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.29, implicit-def dead %at
  
  bb.28 (%ir-block.95, freq 38540):
    successors: %bb.29(100)
  
    %187 = LW %139, target-flags(<unknown>) @trustlst_len, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @trustlst_len, !tbaa !7)
    ADJCALLSTACKDOWN 24, implicit-def dead %sp, implicit %sp
    %189 = ADDiu %148, target-flags(<unknown>) @.str.11
    %190 = COPY %sp
    SW killed %189, %190, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %191 = LW %40, target-flags(<unknown>) @.str.10, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %192 = ADDiu killed %191, target-flags(<unknown>) @.str.10
    %194 = LW %40, target-flags(<unknown>) @fprintf, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %29
    %a1 = COPY %192
    %a2 = COPY %133
    %a3 = COPY %187
    %t9 = COPY %194
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 24, 0, implicit-def dead %sp, implicit %sp
  
  bb.29 (%ir-block.98, freq 61664):
    successors: %bb.30(62), %bb.31(37)
  
    %198 = LW %147, target-flags(<unknown>) @legitlst_len, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @legitlst_len, !tbaa !7)
    %199 = LW %78, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    %200 = ANDi %26, 3
    %201 = SLL killed %200, 4
    %202 = LW %40, target-flags(<unknown>) @legit_lst, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %203 = ADDu killed %202, killed %201
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %205 = ADDiu %138, target-flags(<unknown>) @.str.9
    %206 = LW %40, target-flags(<unknown>) @fprintf, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %199
    %a1 = COPY %205
    %a2 = COPY %198
    %a3 = COPY %203
    %t9 = COPY %206
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    BEQ %15, %zero, %bb.31, implicit-def dead %at
    B %bb.30, implicit-def dead %at
  
  bb.30 (%ir-block.106, freq 38540):
    successors: %bb.31(100)
  
    %209 = LW %78, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %210 = LW %40, target-flags(<unknown>) @_IO_putc, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @_IO_putc)
    %a0 = COPY %128
    %a1 = COPY %209
    %gp = COPY %40
    %t9 = COPY %210
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.31 (%ir-block.109, freq 61664):
    successors: %bb.11..outer.outer5(100)
  
    %214 = LW %78, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %216 = ADDiu %159, target-flags(<unknown>) @.str.12
    %217 = LW %40, target-flags(<unknown>) @fprintf, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fprintf)
    %218 = LEA_ADDiu %stack.1.userid, 0
    %a0 = COPY %214
    %a1 = COPY %216
    %a2 = COPY %218
    %t9 = COPY %217
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %30 = ADDiu %15, 1
    B %bb.11..outer.outer5, implicit-def dead %at
  
  bb.32 (%ir-block.114, freq 3823220):
    successors: %bb.10..outer.outer(3), %bb.33(96)
  
    %123 = ADDiu %zero, 35
    BEQ %15, %zero, %bb.10..outer.outer, implicit-def dead %at
    B %bb.33, implicit-def dead %at
  
  bb.33 (%ir-block.116, freq 3703744):
    successors: %bb.34(37), %bb.35(62)
  
    %125 = LW %78, 0, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from @pgpout, !tbaa !9)
    %126 = SEB %26
    %127 = SLTi killed %126, 0
    %130 = MOVN_I_I %129, killed %127, %128
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %134 = LW %40, target-flags(<unknown>) @fprintf, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %125
    %a1 = COPY %132
    %a2 = COPY %130
    %a3 = COPY %133
    %t9 = COPY %134
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %136 = ANDi %26, 7
    %137 = SLL killed %136, 4
    %141 = ADDu %87, killed %137
    %142 = LW %139, target-flags(<unknown>) @trustlst_len, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @trustlst_len, !tbaa !7)
    %143 = LW %78, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %145 = LW %40, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %143
    %a1 = COPY %144
    %a2 = COPY %142
    %a3 = COPY %141
    %t9 = COPY %145
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %152 = LW %147, target-flags(<unknown>) @legitlst_len, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from @legitlst_len, !tbaa !7)
    %153 = LW %78, 0, <0x461f8d0> = !{!"unison-memory-partition", i32 6} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %154 = LW %40, target-flags(<unknown>) @fprintf, <0x4777c50> = !{!"unison-memory-partition", i32 7} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %153
    %a1 = COPY %150
    %a2 = COPY %152
    %a3 = COPY %151
    %t9 = COPY %154
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %157 = LW %40, target-flags(<unknown>) @user_from_keyID, <0x4633c30> = !{!"unison-memory-partition", i32 8} :: (load 4 from call-entry @user_from_keyID)
    %a0 = COPY %89
    %gp = COPY %40
    %t9 = COPY %157
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %158 = COPY %v0
    %32 = LW %78, 0, <0x468acb0> = !{!"unison-memory-partition", i32 9} :: (load 4 from @pgpout, !tbaa !9)
    BNE %158, %zero, %bb.35, implicit-def dead %at
    B %bb.34, implicit-def dead %at
  
  bb.34 (%ir-block.134, freq 1388904):
    successors: %bb.12..outer(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %163 = LW %40, target-flags(<unknown>) @keyIDstring, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @keyIDstring)
    %a0 = COPY %89
    %gp = COPY %40
    %t9 = COPY %163
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %165 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %168 = LW %40, target-flags(<unknown>) @fprintf, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %32
    %a1 = COPY %167
    %a2 = COPY %165
    %t9 = COPY %168
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.12..outer, implicit-def dead %at
  
  bb.35 (%ir-block.138, freq 2314840):
    successors: %bb.12..outer(100)
  
    %31 = COPY %158
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %161 = LW %40, target-flags(<unknown>) @fprintf, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %32
    %a1 = COPY %160
    %a2 = COPY %31
    %t9 = COPY %161
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.12..outer, implicit-def dead %at
  
  bb.36..loopexit (freq 8388600):
    successors: %bb.38(37), %bb.37(62)
  
    %33 = PHI %17, %bb.13, %116, %bb.23
    %225 = LW %40, target-flags(<unknown>) @strleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, %225, target-flags(<unknown>) @strleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @strleft, !tbaa !7)
    %226 = LW %40, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, %226, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @hashleft, !tbaa !7)
    %227 = LW %40, target-flags(<unknown>) @hashtbl, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, killed %227, target-flags(<unknown>) @hashtbl, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @hashtbl, !tbaa !9)
    SW %zero, %46, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nkr, !tbaa !7)
    %229 = LW %40, target-flags(<unknown>) @verbose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %230 = LBu killed %229, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from @verbose, !tbaa !6)
    BEQ killed %230, %zero, %bb.38, implicit-def dead %at
    B %bb.37, implicit-def dead %at
  
  bb.37 (%ir-block.142, freq 5242875):
    successors: %bb.38(100)
  
    %231 = LW %40, target-flags(<unknown>) @totalsize, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %232 = LW killed %231, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @totalsize, !tbaa !10)
    %233 = SRA %232, 31
    %235 = SRL killed %233, 22
    %236 = ADDu %232, killed %235
    %237 = SRA killed %236, 10
    %238 = LW %78, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @pgpout, !tbaa !9)
    %239 = LW %40, target-flags(<unknown>) @.str.83, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    %240 = ADDiu killed %239, target-flags(<unknown>) @.str.83
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %241 = LW %40, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %238
    %a1 = COPY %240
    %a2 = COPY %237
    %t9 = COPY %241
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.38 (%ir-block.147, freq 8388600):
    successors: %bb.40.endkrent.exit(37), %bb.45(62)
  
    %243 = LW %40, target-flags(<unknown>) @totalsize, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, killed %243, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @totalsize, !tbaa !10)
    %244 = LW %40, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %34 = LW %244, target-flags(<unknown>) @bufpool, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @bufpool, !tbaa !9)
    BEQ %34, %zero, %bb.40.endkrent.exit, implicit-def %at
  
  bb.45 (freq 5242875):
    successors: %bb.39..lr.ph.i.i(100)
  
  
  bb.39..lr.ph.i.i (freq 167771999):
    successors: %bb.40.endkrent.exit(3), %bb.39..lr.ph.i.i(96)
  
    %35 = PHI %34, %bb.45, %36, %bb.39..lr.ph.i.i
    %245 = LW %35, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.151, !tbaa !12)
    SW killed %245, %244, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into `i32* bitcast (%struct.bufpool** @bufpool to i32*)`, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %247 = LW %40, target-flags(<unknown>) @free, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @free)
    %a0 = COPY %35
    %gp = COPY %40
    %t9 = COPY %247
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %36 = LW %244, target-flags(<unknown>) @bufpool, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @bufpool, !tbaa !9)
    BNE %36, %zero, %bb.39..lr.ph.i.i, implicit-def dead %at
    B %bb.40.endkrent.exit, implicit-def dead %at
  
  bb.40.endkrent.exit (freq 8388600):
    successors: %bb.41(100)
  
    SW %zero, %226, target-flags(<unknown>) @hashleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @hashleft, !tbaa !7)
    SW %zero, %225, target-flags(<unknown>) @strleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @strleft, !tbaa !7)
    %250 = LW %40, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    SW %zero, killed %250, target-flags(<unknown>) @nleft, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nleft, !tbaa !7)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %251 = LW %40, target-flags(<unknown>) @fclose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fclose)
    %a0 = COPY %0
    %gp = COPY %40
    %t9 = COPY %251
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %253 = SLTi %33, -1
    %37 = MOVZ_I_I %zero, killed %253, %33
  
  bb.41 (%ir-block.158, freq 13421764):
    liveouts: %v0
  
    %38 = PHI %37, %bb.40.endkrent.exit, %255, %bb.1
    %v0 = COPY %38
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            init_trust_lst
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: gpr32 }
  - { id: 75, class: gpr32 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: gpr32 }
  - { id: 78, class: gpr32 }
  - { id: 79, class: gpr32 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: gpr32 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: gpr32 }
  - { id: 84, class: gpr32 }
  - { id: 85, class: gpr32 }
  - { id: 86, class: gpr32 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: gpr32 }
  - { id: 89, class: gpr32 }
  - { id: 90, class: gpr32 }
  - { id: 91, class: gpr32 }
  - { id: 92, class: gpr32 }
liveins:         
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 32):
    successors: %bb.12(50), %bb.25(50)
    liveins: %t9, %v0
  
    %14 = ADDu %v0, %t9
    %15 = LW %14, target-flags(<unknown>) @init_trust_lst.initialized, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %16 = LBu %15, target-flags(<unknown>) @init_trust_lst.initialized, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from @init_trust_lst.initialized)
    BNE %16, %zero, %bb.12, implicit-def %at
  
  bb.25 (freq 16):
    successors: %bb.1..preheader1(100)
  
    %13 = ADDiu %zero, 0
    %17 = LW %14, target-flags(<unknown>) @trust_lst, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %30 = ADDiu %zero, 128
    %26 = LW %14, target-flags(<unknown>) @trustlst_len, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %22 = ADDiu %zero, 15
  
  bb.1..preheader1 (freq 511):
    successors: %bb.6(37), %bb.2(62)
  
    %0 = PHI %13, %bb.25, %4, %bb.6
    %1 = ADDu %17, %0
    %18 = LBu %1, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.scevgep, !tbaa !6)
    BEQ killed %18, %zero, %bb.6, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.3, freq 319):
    successors: %bb.4(37), %bb.3(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %19 = LW %14, target-flags(<unknown>) @LANG, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @LANG)
    %a0 = COPY %1
    %gp = COPY %14
    %t9 = COPY %19
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %20 = COPY %v0
    %2 = COPY %20
    BEQ %1, %20, %bb.4, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.6, freq 199):
    successors: %bb.4(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %21 = LW %14, target-flags(<unknown>) @strncpy, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @strncpy)
    %a0 = COPY %1
    %a1 = COPY %2
    %a2 = COPY %22
    %gp = COPY %14
    %t9 = COPY %21
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.4 (%ir-block.8, freq 319):
    successors: %bb.5(50), %bb.6(50)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %24 = LW %14, target-flags(<unknown>) @strlen, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @strlen)
    %a0 = COPY %2
    %gp = COPY %14
    %t9 = COPY %24
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %25 = COPY %v0
    %27 = LW %26, target-flags(<unknown>) @trustlst_len, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @trustlst_len, !tbaa !7)
    %28 = SLT killed %27, %25
    BEQ killed %28, %zero, %bb.6, implicit-def dead %at
    B %bb.5, implicit-def dead %at
  
  bb.5 (%ir-block.12, freq 159):
    successors: %bb.6(100)
  
    %3 = COPY %25
    SW %3, %26, target-flags(<unknown>) @trustlst_len, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @trustlst_len, !tbaa !7)
  
  bb.6 (%ir-block.13, freq 511):
    successors: %bb.7..preheader.preheader(3), %bb.1..preheader1(96)
  
    %4 = ADDiu %0, 16
    BNE %4, %30, %bb.1..preheader1, implicit-def dead %at
    B %bb.7..preheader.preheader, implicit-def dead %at
  
  bb.7..preheader.preheader (freq 16):
    successors: %bb.9(37), %bb.8(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %31 = LW %14, target-flags(<unknown>) @legit_lst, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %32 = LW %14, target-flags(<unknown>) @LANG, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @LANG)
    %a0 = COPY %31
    %gp = COPY %14
    %t9 = COPY %32
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %33 = COPY %v0
    %5 = COPY %33
    BEQ %33, %31, %bb.9, implicit-def dead %at
    B %bb.8, implicit-def dead %at
  
  bb.8 (%ir-block.16, freq 10):
    successors: %bb.9(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %35 = LW %14, target-flags(<unknown>) @strncpy, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @strncpy)
    %36 = ADDiu %zero, 15
    %a0 = COPY %31
    %a1 = COPY %5
    %a2 = COPY %36
    %gp = COPY %14
    %t9 = COPY %35
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.9 (%ir-block.18, freq 16):
    successors: %bb.10(50), %bb.11..preheader.15(50)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %38 = LW %14, target-flags(<unknown>) @strlen, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @strlen)
    %a0 = COPY %5
    %gp = COPY %14
    %t9 = COPY %38
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %39 = COPY %v0
    %40 = LW %14, target-flags(<unknown>) @legitlst_len, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %41 = LW %40, target-flags(<unknown>) @legitlst_len, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @legitlst_len, !tbaa !7)
    %42 = SLT killed %41, %39
    BEQ killed %42, %zero, %bb.11..preheader.15, implicit-def dead %at
    B %bb.10, implicit-def dead %at
  
  bb.10 (%ir-block.22, freq 8):
    successors: %bb.11..preheader.15(100)
  
    %6 = COPY %39
    SW %6, %40, target-flags(<unknown>) @legitlst_len, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @legitlst_len, !tbaa !7)
  
  bb.11..preheader.15 (freq 16):
    successors: %bb.14(37), %bb.13(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %45 = ADDiu %31, 16
    %46 = LW %14, target-flags(<unknown>) @LANG, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @LANG)
    %a0 = COPY %45
    %t9 = COPY %46
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %47 = COPY %v0
    %7 = COPY %47
    BEQ %47, %45, %bb.14, implicit-def dead %at
    B %bb.13, implicit-def dead %at
  
  bb.12 (%ir-block.25, freq 32):
    liveouts:
  
    RetRA
  
  bb.13 (%ir-block.26, freq 10):
    successors: %bb.14(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %50 = LW %14, target-flags(<unknown>) @strncpy, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @strncpy)
    %51 = ADDiu %zero, 15
    %a0 = COPY %45
    %a1 = COPY %7
    %a2 = COPY %51
    %gp = COPY %14
    %t9 = COPY %50
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.14 (%ir-block.28, freq 16):
    successors: %bb.15(50), %bb.16..preheader.26(50)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %53 = LW %14, target-flags(<unknown>) @strlen, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @strlen)
    %a0 = COPY %7
    %t9 = COPY %53
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %54 = COPY %v0
    %56 = LW %40, target-flags(<unknown>) @legitlst_len, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @legitlst_len, !tbaa !7)
    %57 = SLT killed %56, %54
    BEQ killed %57, %zero, %bb.16..preheader.26, implicit-def dead %at
    B %bb.15, implicit-def dead %at
  
  bb.15 (%ir-block.32, freq 8):
    successors: %bb.16..preheader.26(100)
  
    %8 = COPY %54
    SW %8, %40, target-flags(<unknown>) @legitlst_len, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @legitlst_len, !tbaa !7)
  
  bb.16..preheader.26 (freq 16):
    successors: %bb.18(37), %bb.17(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %60 = ADDiu %31, 32
    %61 = LW %14, target-flags(<unknown>) @LANG, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @LANG)
    %a0 = COPY %60
    %t9 = COPY %61
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %62 = COPY %v0
    %9 = COPY %62
    BEQ %62, %60, %bb.18, implicit-def dead %at
    B %bb.17, implicit-def dead %at
  
  bb.17 (%ir-block.35, freq 10):
    successors: %bb.18(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %65 = LW %14, target-flags(<unknown>) @strncpy, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @strncpy)
    %66 = ADDiu %zero, 15
    %a0 = COPY %60
    %a1 = COPY %9
    %a2 = COPY %66
    %gp = COPY %14
    %t9 = COPY %65
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.18 (%ir-block.37, freq 16):
    successors: %bb.19(50), %bb.20..preheader.37(50)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %68 = LW %14, target-flags(<unknown>) @strlen, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @strlen)
    %a0 = COPY %9
    %t9 = COPY %68
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %69 = COPY %v0
    %71 = LW %40, target-flags(<unknown>) @legitlst_len, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @legitlst_len, !tbaa !7)
    %72 = SLT killed %71, %69
    BEQ killed %72, %zero, %bb.20..preheader.37, implicit-def dead %at
    B %bb.19, implicit-def dead %at
  
  bb.19 (%ir-block.41, freq 8):
    successors: %bb.20..preheader.37(100)
  
    %10 = COPY %69
    SW %10, %40, target-flags(<unknown>) @legitlst_len, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @legitlst_len, !tbaa !7)
  
  bb.20..preheader.37 (freq 16):
    successors: %bb.22(37), %bb.21(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %75 = ADDiu %31, 48
    %76 = LW %14, target-flags(<unknown>) @LANG, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @LANG)
    %a0 = COPY %75
    %t9 = COPY %76
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %77 = COPY %v0
    %11 = COPY %77
    BEQ %77, %75, %bb.22, implicit-def dead %at
    B %bb.21, implicit-def dead %at
  
  bb.21 (%ir-block.44, freq 10):
    successors: %bb.22(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %80 = LW %14, target-flags(<unknown>) @strncpy, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @strncpy)
    %81 = ADDiu %zero, 15
    %a0 = COPY %75
    %a1 = COPY %11
    %a2 = COPY %81
    %gp = COPY %14
    %t9 = COPY %80
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.22 (%ir-block.46, freq 16):
    successors: %bb.23(50), %bb.24(50)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %83 = LW %14, target-flags(<unknown>) @strlen, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strlen)
    %a0 = COPY %11
    %t9 = COPY %83
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %84 = COPY %v0
    %86 = LW %40, target-flags(<unknown>) @legitlst_len, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @legitlst_len, !tbaa !7)
    %87 = SLT killed %86, %84
    BEQ killed %87, %zero, %bb.24, implicit-def dead %at
    B %bb.23, implicit-def dead %at
  
  bb.23 (%ir-block.50, freq 8):
    successors: %bb.24(100)
  
    %12 = COPY %84
    SW %12, %40, target-flags(<unknown>) @legitlst_len, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @legitlst_len, !tbaa !7)
  
  bb.24 (%ir-block.51, freq 16):
    successors: %bb.12(100)
  
    %90 = ADDiu %zero, 1
    SB killed %90, %15, target-flags(<unknown>) @init_trust_lst.initialized, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into @init_trust_lst.initialized)
    B %bb.12, implicit-def dead %at

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            setkrent
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%6' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0, freq 8388608):
    successors: %bb.2(99), %bb.1(0)
    liveins: %a0, %t9, %v0
  
    %7 = ADDu %v0, %t9
    %6 = COPY %a0
    %8 = LW %7, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %0 = LW %8, target-flags(<unknown>) @nkr, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @nkr, !tbaa !7)
    %9 = SLTi %0, 8
    BNE killed %9, %zero, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.3, freq 8):
    exit
  
    %10 = LW %7, target-flags(<unknown>) @__PRETTY_FUNCTION__.setkrent, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    %11 = LW %7, target-flags(<unknown>) @.str.37, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %12 = LW %7, target-flags(<unknown>) @.str.36, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %13 = ADDiu killed %12, target-flags(<unknown>) @.str.36
    %14 = ADDiu killed %11, target-flags(<unknown>) @.str.37
    %15 = ADDiu killed %10, target-flags(<unknown>) @__PRETTY_FUNCTION__.setkrent
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %16 = LW %7, target-flags(<unknown>) @__assert_fail, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @__assert_fail)
    %17 = ADDiu %zero, 1447
    %a0 = COPY %13
    %a1 = COPY %14
    %a2 = COPY %17
    %a3 = COPY %15
    %gp = COPY %7
    %t9 = COPY %16
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.2 (%ir-block.4, freq 8388600):
    successors: %bb.7(62), %bb.5.._crit_edge(37)
  
    %20 = LW %7, target-flags(<unknown>) @globalPubringName, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %1 = MOVZ_I_I killed %20, %6, %6
    %21 = LW %7, target-flags(<unknown>) @krnames, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    BLEZ %0, %bb.5.._crit_edge, implicit-def %at
  
  bb.7 (freq 5242875):
    successors: %bb.4..lr.ph(100)
  
    %18 = ADDiu %21, target-flags(<unknown>) @krnames
    %19 = ADDiu %zero, 0
    B %bb.4..lr.ph, implicit-def %at
  
  bb.3 (%ir-block.7, freq 82554476):
    successors: %bb.4..lr.ph(96), %bb.5.._crit_edge(3)
  
    %5 = ADDiu %4, 1
    %25 = SLT %5, %0
    %2 = ADDiu %3, 4
    BEQ killed %25, %zero, %bb.5.._crit_edge, implicit-def dead %at
    B %bb.4..lr.ph, implicit-def dead %at
  
  bb.4..lr.ph (freq 85217523):
    successors: %bb.6..loopexit(3), %bb.3(96)
  
    %3 = PHI %18, %bb.7, %2, %bb.3
    %4 = PHI %19, %bb.7, %5, %bb.3
    %22 = LW %3, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.lsr.iv1, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %23 = LW %7, target-flags(<unknown>) @strcmp, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @strcmp)
    %a0 = COPY %1
    %a1 = COPY %22
    %gp = COPY %7
    %t9 = COPY %23
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %24 = COPY %v0
    BEQ %24, %zero, %bb.6..loopexit, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.5.._crit_edge (freq 5725552):
    successors: %bb.6..loopexit(100)
  
    ADJCALLSTACKDOWN 0, implicit-def dead %sp, implicit %sp
    %26 = LW %7, target-flags(<unknown>) @store_str, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %27 = ADDiu killed %26, target-flags(<unknown>) @store_str
    %a0 = COPY %1
    %t9 = COPY %27
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 0, 0, implicit-def dead %sp, implicit %sp
    %28 = COPY %v0
    %30 = LW %8, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @nkr, !tbaa !7)
    %32 = ADDiu %30, 1
    SW killed %32, %8, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @nkr, !tbaa !7)
    %33 = ADDiu %21, target-flags(<unknown>) @krnames
    %34 = SLL %30, 2
    %35 = ADDu killed %33, killed %34
    SW %28, killed %35, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into %ir.17, !tbaa !9)
  
  bb.6..loopexit (freq 8388600):
    liveouts: %v0
  
    %36 = ADDiu %zero, 0
    %v0 = COPY %36
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            readkpacket
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%3' }
  - { reg: '%a1', virtual-reg: '%4' }
  - { reg: '%a2', virtual-reg: '%5' }
  - { reg: '%a3', virtual-reg: '%6' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
fixedStack:      
  - { id: 0, offset: 16, size: 4, alignment: 8, isImmutable: true, isAliased: false }
stack:           
  - { id: 0, name: n, offset: 0, size: 256, alignment: 4 }
  - { id: 1, name: e, offset: 0, size: 256, alignment: 4 }
body:             |
  bb.0 (%ir-block.0, freq 40):
    successors: %bb.1(37), %bb.2(62)
    liveins: %a0, %a1, %a2, %a3, %t9, %v0
  
    %7 = ADDu %v0, %t9
    %6 = COPY %a3
    %5 = COPY %a2
    %4 = COPY %a1
    %3 = COPY %a0
    %8 = LW %fixed-stack.0, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from stack, align 8)
    ADJCALLSTACKDOWN 56, implicit-def dead %sp, implicit %sp
    %9 = LEA_ADDiu %stack.0.n, 0
    %10 = LEA_ADDiu %stack.1.e, 0
    %11 = COPY %sp
    SW killed %8, %11, 44, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW killed %10, %11, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW killed %9, %11, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %5, %11, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %11, 48, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %11, 40, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %11, 36, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %11, 32, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %11, 28, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %12 = LW %7, target-flags(<unknown>) @readkeypacket, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @readkeypacket)
    %13 = ADDiu %zero, 0
    %a0 = COPY %3
    %a1 = COPY %13
    %a2 = COPY %4
    %a3 = COPY %13
    %gp = COPY %7
    %t9 = COPY %12
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 56, 0, implicit-def dead %sp, implicit %sp
    %14 = COPY %v0
    BGEZ %14, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.7, freq 15):
    successors: %bb.8(100)
  
    %0 = COPY %14
    %1 = COPY %0
    B %bb.8, implicit-def dead %at
  
  bb.2 (%ir-block.9, freq 25):
    successors: %bb.5(37), %bb.3(62)
  
    BEQ %6, %zero, %bb.5, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.11, freq 16):
    successors: %bb.5(37), %bb.4(62)
  
    %15 = LBu %4, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, !tbaa !6)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %16 = LW %7, target-flags(<unknown>) @is_key_ctb, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @is_key_ctb)
    %a0 = COPY %15
    %gp = COPY %7
    %t9 = COPY %16
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %17 = COPY %v0
    BEQ %17, %zero, %bb.5, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.15, freq 10):
    successors: %bb.5(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %18 = LW %7, target-flags(<unknown>) @extract_keyID, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @extract_keyID)
    %19 = LEA_ADDiu %stack.0.n, 0
    %a0 = COPY %6
    %a1 = COPY %19
    %gp = COPY %7
    %t9 = COPY %18
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.5 (%ir-block.17, freq 25):
    successors: %bb.8(37), %bb.6(62)
  
    %20 = ADDiu %zero, 0
    BEQ %5, %zero, %bb.8, implicit-def dead %at
    B %bb.6, implicit-def dead %at
  
  bb.6 (%ir-block.19, freq 16):
    successors: %bb.7(50), %bb.8(50)
  
    %22 = LBu %4, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, !tbaa !6)
    %23 = ADDiu %zero, 180
    BNE killed %22, killed %23, %bb.8, implicit-def dead %at
    B %bb.7, implicit-def dead %at
  
  bb.7 (%ir-block.22, freq 8):
    successors: %bb.8(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %25 = LW %7, target-flags(<unknown>) @PascalToC, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @PascalToC)
    %a0 = COPY %5
    %gp = COPY %7
    %t9 = COPY %25
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.8 (%ir-block.23, freq 40):
    liveouts: %v0
  
    %2 = PHI %20, %bb.5, %20, %bb.6, %20, %bb.7, %1, %bb.1
    %v0 = COPY %2
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            read_trust
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%4' }
  - { reg: '%a1', virtual-reg: '%5' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
stack:           
  - { id: 0, name: buf, offset: 0, size: 3, alignment: 4 }
body:             |
  bb.0 (%ir-block.0, freq 102):
    successors: %bb.1(50), %bb.7(50)
    liveins: %a0, %a1, %t9, %v0
  
    %6 = ADDu %v0, %t9
    %5 = COPY %a1
    %4 = COPY %a0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %8 = LW %6, target-flags(<unknown>) @fread, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fread)
    %9 = ADDiu %zero, 1
    %10 = ADDiu %zero, 3
    %11 = LEA_ADDiu %stack.0.buf, 0
    %a0 = COPY %11
    %a1 = COPY %9
    %a2 = COPY %10
    %a3 = COPY %4
    %gp = COPY %6
    %t9 = COPY %8
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %12 = COPY %v0
    %7 = ADDiu %zero, -1
    BNE %12, %10, %bb.7, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.4, freq 51):
    successors: %bb.4(50), %bb.2(50)
  
    %0 = LW %stack.0.buf, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.5)
    %1 = SRL %0, 24
    %13 = ADDiu %zero, 176
    BEQ %1, killed %13, %bb.4, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.11, freq 25):
    successors: %bb.3(37), %bb.7(62)
  
    %15 = SEB %1
    %14 = ADDiu %zero, -3
    BGEZ killed %15, %bb.7, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.14, freq 9):
    successors: %bb.7(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %17 = LW %6, target-flags(<unknown>) @fseek, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fseek)
    %18 = ADDiu %zero, -3
    %19 = ADDiu %zero, 1
    %a0 = COPY %4
    %a1 = COPY %18
    %a2 = COPY %19
    %gp = COPY %6
    %t9 = COPY %17
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %16 = ADDiu %zero, -7
    B %bb.7, implicit-def dead %at
  
  bb.4 (%ir-block.16, freq 25):
    successors: %bb.5(50), %bb.7(50)
  
    %22 = LUi 255
    %23 = AND %0, killed %22
    %21 = ADDiu %zero, -3
    %24 = LUi 1
    BNE killed %23, killed %24, %bb.7, implicit-def dead %at
    B %bb.5, implicit-def dead %at
  
  bb.5 (%ir-block.19, freq 12):
    successors: %bb.7(37), %bb.6(62)
  
    %25 = ADDiu %zero, 0
    BEQ %5, %zero, %bb.7, implicit-def dead %at
    B %bb.6, implicit-def dead %at
  
  bb.6 (%ir-block.21, freq 8):
    successors: %bb.7(100)
  
    %2 = SRL %0, 8
    SB %2, %5, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.keyctrl, !tbaa !6)
  
  bb.7 (%ir-block.23, freq 102):
    liveouts: %v0
  
    %3 = PHI %7, %bb.0, %14, %bb.2, %16, %bb.3, %21, %bb.4, %25, %bb.5, %25, %bb.6
    %v0 = COPY %3
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            user_from_keyID
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%17' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
stack:           
  - { id: 0, name: keyID.i, offset: 0, size: 8, alignment: 4 }
  - { id: 1, name: ctb.i, offset: 0, size: 1, alignment: 4 }
body:             |
  bb.0 (%ir-block.0, freq 40):
    successors: %bb.1(37), %bb.11(62)
    liveins: %a0, %t9, %v0
  
    %18 = ADDu %v0, %t9
    %17 = COPY %a0
    %19 = LW %18, target-flags(<unknown>) @hashtbl, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %0 = LW killed %19, target-flags(<unknown>) @hashtbl, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @hashtbl, !tbaa !9)
    BNE %0, %zero, %bb.11, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.3, freq 15):
    successors: %bb.19(62), %bb.10._user_from_keyID.exit(37)
  
    %31 = LW %18, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %32 = LW %31, target-flags(<unknown>) @nkr, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @nkr)
    %30 = ADDiu %zero, 0
    BLEZ %32, %bb.10._user_from_keyID.exit, implicit-def %at
  
  bb.19 (freq 9):
    successors: %bb.2..lr.ph.i(100)
  
    %29 = COPY %30
    %34 = LW %18, target-flags(<unknown>) @krnames, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %35 = ADDiu %34, target-flags(<unknown>) @krnames
    %38 = LW %18, target-flags(<unknown>) @.str, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %39 = ADDiu %38, target-flags(<unknown>) @.str
    %43 = LW %18, target-flags(<unknown>) @_user_from_keyID.userid, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %44 = ADDiu %43, target-flags(<unknown>) @_user_from_keyID.userid
    %46 = LEA_ADDiu %stack.1.ctb.i, 0
    %47 = LEA_ADDiu %stack.0.keyID.i, 0
    %60 = ADDiu %zero, 180
    %54 = ADDiu %zero, 8
    %57 = ADDiu %zero, 1
  
  bb.2..lr.ph.i (freq 302):
    successors: %bb.8(37), %bb.3..preheader.i(62)
  
    %1 = PHI %29, %bb.19, %8, %bb.17
    %2 = PHI %29, %bb.19, %9, %bb.17
    %33 = SLL %2, 2
    %36 = ADDu %35, killed %33
    %37 = LW killed %36, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.7, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %40 = LW %18, target-flags(<unknown>) @fopen, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fopen)
    %a0 = COPY %37
    %a1 = COPY %39
    %gp = COPY %18
    %t9 = COPY %40
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %41 = COPY %v0
    %3 = COPY %41
    BEQ %41, %zero, %bb.8, implicit-def dead %at
    B %bb.3..preheader.i, implicit-def dead %at
  
  bb.3..preheader.i (freq 3072):
    successors: %bb.7(3), %bb.4(96)
  
    %4 = PHI %1, %bb.2..lr.ph.i, %6, %bb.6, %6, %bb.16
    ADJCALLSTACKDOWN 24, implicit-def dead %sp, implicit %sp
    %42 = COPY %sp
    SW %zero, %42, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %45 = LW %18, target-flags(<unknown>) @readkpacket, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @readkpacket)
    %a0 = COPY %3
    %a1 = COPY %46
    %a2 = COPY %44
    %a3 = COPY %47
    %gp = COPY %18
    %t9 = COPY %45
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 24, 0, implicit-def dead %sp, implicit %sp
    %48 = COPY %v0
    %49 = SLTiu %48, -3
    BEQ killed %49, %zero, %bb.7, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.13, freq 2976):
    successors: %bb.6(37), %bb.5(62)
  
    %50 = LBu %stack.1.ctb.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb.i, align 4, !tbaa !6)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %51 = LW %18, target-flags(<unknown>) @is_key_ctb, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @is_key_ctb)
    %a0 = COPY %50
    %gp = COPY %18
    %t9 = COPY %51
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %52 = COPY %v0
    BEQ %52, %zero, %bb.6, implicit-def dead %at
    B %bb.5, implicit-def dead %at
  
  bb.5 (%ir-block.17, freq 1860):
    successors: %bb.6(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %53 = LW %18, target-flags(<unknown>) @memcmp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @memcmp)
    %a0 = COPY %47
    %a1 = COPY %17
    %a2 = COPY %54
    %gp = COPY %18
    %t9 = COPY %53
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %56 = COPY %v0
    %5 = MOVZ_I_I %57, %56, %4
  
  bb.6 (%ir-block.21, freq 2976):
    successors: %bb.16(51), %bb.3..preheader.i(48)
  
    %6 = PHI %4, %bb.4, %5, %bb.5
    BEQ %6, %zero, %bb.3..preheader.i, implicit-def dead %at
    B %bb.16, implicit-def dead %at
  
  bb.16 (%ir-block.21, freq 1534):
    successors: %bb.7(6), %bb.3..preheader.i(93)
  
    %58 = LBu %stack.1.ctb.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb.i, align 4)
    %59 = ANDi %58, 255
    BNE killed %59, %60, %bb.3..preheader.i, implicit-def dead %at
    B %bb.7, implicit-def dead %at
  
  bb.7 (%ir-block.25, freq 189):
    successors: %bb.8(100)
  
    %7 = PHI %4, %bb.3..preheader.i, %6, %bb.16
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %61 = LW %18, target-flags(<unknown>) @fclose, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fclose)
    %a0 = COPY %3
    %gp = COPY %18
    %t9 = COPY %61
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.8 (%ir-block.27, freq 302):
    successors: %bb.17(98), %bb.9..critedge.loopexit.i(1)
  
    %8 = PHI %1, %bb.2..lr.ph.i, %7, %bb.7
    %65 = LW %31, target-flags(<unknown>) @nkr, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @nkr)
    %9 = ADDiu %2, 1
    %66 = SLT %9, killed %65
    BEQ killed %66, %zero, %bb.9..critedge.loopexit.i, implicit-def dead %at
    B %bb.17, implicit-def dead %at
  
  bb.17 (%ir-block.27, freq 297):
    successors: %bb.2..lr.ph.i(98), %bb.9..critedge.loopexit.i(1)
  
    %63 = SLTiu %8, 1
    BNE %63, %zero, %bb.2..lr.ph.i, implicit-def dead %at
    B %bb.9..critedge.loopexit.i, implicit-def dead %at
  
  bb.9..critedge.loopexit.i (freq 9):
    successors: %bb.10._user_from_keyID.exit(100)
  
    %68 = ADDiu %43, target-flags(<unknown>) @_user_from_keyID.userid
    %10 = MOVZ_I_I killed %zero, %8, %68
  
  bb.10._user_from_keyID.exit (freq 15):
    successors: %bb.15..loopexit(100)
  
    %11 = PHI %30, %bb.1, %10, %bb.9..critedge.loopexit.i
    B %bb.15..loopexit, implicit-def dead %at
  
  bb.11 (%ir-block.34, freq 25):
    successors: %bb.15..loopexit(37), %bb.18(62)
  
    %21 = LBu %17, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.keyID, !tbaa !6)
    %22 = SLL killed %21, 2
    %23 = ADDu %0, killed %22
    %12 = LW killed %23, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.37, !tbaa !9)
    %20 = ADDiu %zero, 0
    BEQ %12, %zero, %bb.15..loopexit, implicit-def %at
  
  bb.18 (freq 15):
    successors: %bb.12..lr.ph(100)
  
    %26 = ADDiu %zero, 8
  
  bb.12..lr.ph (freq 256):
    successors: %bb.13(3), %bb.14(96)
  
    %13 = PHI %12, %bb.18, %15, %bb.14
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %24 = ADDiu %13, 4
    %25 = LW %18, target-flags(<unknown>) @memcmp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @memcmp)
    %a0 = COPY %17
    %a1 = COPY %24
    %a2 = COPY %26
    %gp = COPY %18
    %t9 = COPY %25
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %27 = COPY %v0
    BNE %27, %zero, %bb.14, implicit-def dead %at
    B %bb.13, implicit-def dead %at
  
  bb.13 (%ir-block.42, freq 7):
    successors: %bb.15..loopexit(100)
  
    %14 = LW %13, 12, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.43, !tbaa !32)
    B %bb.15..loopexit, implicit-def dead %at
  
  bb.14 (%ir-block.45, freq 248):
    successors: %bb.15..loopexit(3), %bb.12..lr.ph(96)
  
    %15 = LW %13, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.46, !tbaa !9)
    BNE %15, %zero, %bb.12..lr.ph, implicit-def dead %at
    B %bb.15..loopexit, implicit-def dead %at
  
  bb.15..loopexit (freq 40):
    liveouts: %v0
  
    %16 = PHI %20, %bb.11, %20, %bb.14, %14, %bb.13, %11, %bb.10._user_from_keyID.exit
    %v0 = COPY %16
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            ask_owntrust
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%4' }
  - { reg: '%a1', virtual-reg: '%5' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
stack:           
  - { id: 0, name: buf, offset: 0, size: 8, alignment: 4 }
body:             |
  bb.0 (%ir-block.0, freq 32):
    successors: %bb.6(75), %bb.1(25)
    liveins: %a0, %a1, %t9, %v0
  
    %8 = ADDu %v0, %t9
    %5 = COPY %a1
    %4 = COPY %a0
    %9 = LW %8, target-flags(<unknown>) @filter_mode, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %10 = LBu killed %9, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from @filter_mode)
    %11 = LW %8, target-flags(<unknown>) @batchmode, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %12 = LBu killed %11, 0, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 1 from @batchmode)
    %13 = OR killed %12, killed %10
    %15 = ANDi killed %13, 255
    BNE killed %15, %zero, %bb.1, implicit-def dead %at
    B %bb.6, implicit-def dead %at
  
  bb.6 (%ir-block.0, freq 24):
    successors: %bb.2(66), %bb.1(33)
  
    %14 = LW %8, target-flags(<unknown>) @check_only, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %16 = LBu %14, target-flags(<unknown>) @check_only, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from @check_only)
    %7 = XORi %16, 1
    %17 = ANDi %7, 1
    BNE killed %17, %zero, %bb.2, implicit-def dead %at
    B %bb.1, implicit-def dead %at
  
  bb.1 (%ir-block.7, freq 16):
    successors: %bb.5(100)
  
    %19 = LW %8, target-flags(<unknown>) @undefined_trust, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %20 = LW %19, target-flags(<unknown>) @undefined_trust, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @undefined_trust, !tbaa !7)
    %21 = ADDiu killed %20, 1
    %18 = ADDiu %zero, 0
    SW killed %21, %19, target-flags(<unknown>) @undefined_trust, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into @undefined_trust, !tbaa !7)
    B %bb.5, implicit-def dead %at
  
  bb.2 (%ir-block.10, freq 15):
    successors: %bb.4.switch.lookup(50), %bb.3(50)
  
    %22 = LW %8, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %23 = LW %22, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %24 = LW %8, target-flags(<unknown>) @.str.15, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %25 = ADDiu killed %24, target-flags(<unknown>) @.str.15
    %26 = LW %8, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %25
    %gp = COPY %8
    %t9 = COPY %26
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %27 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %28 = LW %8, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %23
    %a1 = COPY %27
    %gp = COPY %8
    %t9 = COPY %28
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %30 = LW %8, target-flags(<unknown>) @.str.16, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from got)
    %31 = ADDiu killed %30, target-flags(<unknown>) @.str.16
    %32 = LW %22, 0, <0x461f8d0> = !{!"unison-memory-partition", i32 6} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %33 = LW %8, target-flags(<unknown>) @LANG, <0x468acb0> = !{!"unison-memory-partition", i32 9} :: (load 4 from call-entry @LANG)
    %a0 = COPY %31
    %t9 = COPY %33
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %34 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %35 = LW %8, target-flags(<unknown>) @fprintf, <0x48723d0> = !{!"unison-memory-partition", i32 10} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %32
    %a1 = COPY %34
    %a2 = COPY %4
    %t9 = COPY %35
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %37 = LW %22, 0, <0x47b0020> = !{!"unison-memory-partition", i32 11} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %38 = LW %8, target-flags(<unknown>) @fflush, <0x459b620> = !{!"unison-memory-partition", i32 12} :: (load 4 from call-entry @fflush)
    %a0 = COPY %37
    %gp = COPY %8
    %t9 = COPY %38
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %40 = ADDiu %zero, 7
    %41 = ADDiu %zero, 1
    %42 = LEA_ADDiu %stack.0.buf, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %43 = LW %8, target-flags(<unknown>) @getstring, <0x4777c50> = !{!"unison-memory-partition", i32 7} :: (load 4 from call-entry @getstring)
    %a0 = COPY %42
    %a1 = COPY %40
    %a2 = COPY %41
    %gp = COPY %8
    %t9 = COPY %43
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %45 = LB %stack.0.buf, 0, <0x4633c30> = !{!"unison-memory-partition", i32 8} :: (load 1 from %ir.11, align 4, !tbaa !6)
    %0 = ADDiu killed %45, -49
    %46 = SLTiu %0, 4
    BNE killed %46, %zero, %bb.4.switch.lookup, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.24, freq 7):
    successors: %bb.5(100)
  
    %1 = ANDi %5, 7
    B %bb.5, implicit-def dead %at
  
  bb.4.switch.lookup (freq 7):
    successors: %bb.5(100)
  
    %47 = SLL %0, 2
    %48 = LW %8, target-flags(<unknown>) @switch.table, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %49 = ADDiu killed %48, target-flags(<unknown>) @switch.table
    %50 = ADDu killed %49, killed %47
    %2 = LW killed %50, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.switch.gep)
  
  bb.5 (%ir-block.27, freq 32):
    liveouts: %v0
  
    %3 = PHI %18, %bb.1, %1, %bb.3, %2, %bb.4.switch.lookup
    %v0 = COPY %3
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            lookup_by_keyID
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%5' }
  - { reg: '%a1', virtual-reg: '%6' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
stack:           
  - { id: 0, name: n.i, offset: 0, size: 256, alignment: 4 }
  - { id: 1, name: e.i, offset: 0, size: 256, alignment: 4 }
  - { id: 2, name: keyID, offset: 0, size: 8, alignment: 4 }
  - { id: 3, name: ctb, offset: 0, size: 1, alignment: 4 }
body:             |
  bb.0 (%ir-block.0, freq 404):
    successors: %bb.1..thread.outer(100)
    liveins: %a0, %a1, %t9, %v0
  
    %7 = ADDu %v0, %t9
    %6 = COPY %a1
    %5 = COPY %a0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %9 = LW %7, target-flags(<unknown>) @rewind, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @rewind)
    %a0 = COPY %5
    %gp = COPY %7
    %t9 = COPY %9
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %8 = ADDiu %zero, 0
    %10 = LEA_ADDiu %stack.0.n.i, 0
    %11 = LEA_ADDiu %stack.1.e.i, 0
    %15 = LEA_ADDiu %stack.3.ctb, 0
    %36 = ORi %zero, 65532
    %27 = ADDiu %zero, 8
    %28 = LEA_ADDiu %stack.2.keyID, 0
  
  bb.1..thread.outer (freq 806):
    successors: %bb.2..thread(100)
  
    %0 = PHI %8, %bb.0, %2, %bb.9
  
  bb.2..thread (freq 13107):
    successors: %bb.5.readkpacket.exit(96), %bb.3(3)
  
    ADJCALLSTACKDOWN 56, implicit-def dead %sp, implicit %sp
    %12 = COPY %sp
    SW %11, %12, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %10, %12, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %12, 48, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %12, 44, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %12, 40, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %12, 36, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %12, 32, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %12, 28, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %12, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %13 = LW %7, target-flags(<unknown>) @readkeypacket, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @readkeypacket)
    %a0 = COPY %5
    %a1 = COPY %8
    %a2 = COPY %15
    %a3 = COPY %8
    %gp = COPY %7
    %t9 = COPY %13
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 56, 0, implicit-def dead %sp, implicit %sp
    %16 = COPY %v0
    BLTZ %16, %bb.5.readkpacket.exit, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.8, freq 409):
    successors: %bb.6(37), %bb.4(62)
  
    %17 = LBu %stack.3.ctb, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %18 = LW %7, target-flags(<unknown>) @is_key_ctb, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @is_key_ctb)
    %a0 = COPY %17
    %gp = COPY %7
    %t9 = COPY %18
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %19 = COPY %v0
    BEQ %19, %zero, %bb.6, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.12, freq 256):
    successors: %bb.6(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %20 = LW %7, target-flags(<unknown>) @extract_keyID, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @extract_keyID)
    %a0 = COPY %28
    %a1 = COPY %10
    %gp = COPY %7
    %t9 = COPY %20
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.6, implicit-def dead %at
  
  bb.5.readkpacket.exit (freq 12697):
    successors: %bb.10..loopexit(3), %bb.2..thread(96)
  
    %35 = ANDi %16, 65535
    %37 = SLTu %36, killed %35
    BNE killed %37, %zero, %bb.10..loopexit, implicit-def dead %at
    B %bb.2..thread, implicit-def dead %at
  
  bb.6 (%ir-block.17, freq 409):
    successors: %bb.9(37), %bb.7(62)
  
    %23 = LBu %stack.3.ctb, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %24 = LW %7, target-flags(<unknown>) @is_key_ctb, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @is_key_ctb)
    %a0 = COPY %23
    %t9 = COPY %24
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %25 = COPY %v0
    BEQ %25, %zero, %bb.9, implicit-def dead %at
    B %bb.7, implicit-def dead %at
  
  bb.7 (%ir-block.23, freq 256):
    successors: %bb.8(3), %bb.9(96)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %26 = LW %7, target-flags(<unknown>) @memcmp, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @memcmp)
    %a0 = COPY %28
    %a1 = COPY %6
    %a2 = COPY %27
    %gp = COPY %7
    %t9 = COPY %26
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %29 = COPY %v0
    BNE %29, %zero, %bb.9, implicit-def dead %at
    B %bb.8, implicit-def dead %at
  
  bb.8 (%ir-block.27, freq 7):
    successors: %bb.11(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %30 = LW %7, target-flags(<unknown>) @fseek, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fseek)
    %31 = ADDiu %zero, 0
    %a0 = COPY %5
    %a1 = COPY %0
    %a2 = COPY %31
    %gp = COPY %7
    %t9 = COPY %30
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.11, implicit-def dead %at
  
  bb.9 (%ir-block.29, freq 401):
    successors: %bb.1..thread.outer(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %33 = LW %7, target-flags(<unknown>) @ftell, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @ftell)
    %a0 = COPY %5
    %gp = COPY %7
    %t9 = COPY %33
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %34 = COPY %v0
    %2 = COPY %34
    B %bb.1..thread.outer, implicit-def dead %at
  
  bb.10..loopexit (freq 396):
    successors: %bb.11(100)
  
    %1 = COPY %16
    %3 = COPY %1
  
  bb.11 (%ir-block.32, freq 404):
    liveouts: %v0
  
    %4 = PHI %0, %bb.8, %3, %bb.10..loopexit
    %v0 = COPY %4
    RetRA implicit %v0

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            show_userid
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%2' }
  - { reg: '%a1', virtual-reg: '%3' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
stack:           
  - { id: 0, name: n.i, offset: 0, size: 256, alignment: 4 }
  - { id: 1, name: e.i, offset: 0, size: 256, alignment: 4 }
  - { id: 2, name: userid, offset: 0, size: 256, alignment: 4 }
  - { id: 3, name: ctb, offset: 0, size: 1, alignment: 4 }
body:             |
  bb.0 (%ir-block.0, freq 17):
    successors: %bb.1..preheader(62), %bb.9..loopexit(37)
    liveins: %a0, %a1, %t9, %v0
  
    %4 = ADDu %v0, %t9
    %3 = COPY %a1
    %2 = COPY %a0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %5 = LW %4, target-flags(<unknown>) @ftell, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @ftell)
    %a0 = COPY %2
    %gp = COPY %4
    %t9 = COPY %5
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %6 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %7 = LW %4, target-flags(<unknown>) @lookup_by_keyID, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @lookup_by_keyID)
    %a0 = COPY %2
    %a1 = COPY %3
    %gp = COPY %4
    %t9 = COPY %7
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %8 = COPY %v0
    %0 = COPY %6
    BLTZ %8, %bb.9..loopexit, implicit-def dead %at
    B %bb.1..preheader, implicit-def dead %at
  
  bb.1..preheader (freq 11):
    successors: %bb.2(100)
  
    %9 = LEA_ADDiu %stack.0.n.i, 0
    %10 = LEA_ADDiu %stack.1.e.i, 0
    %12 = LEA_ADDiu %stack.2.userid, 0
    %14 = ADDiu %zero, 0
    %15 = LEA_ADDiu %stack.3.ctb, 0
    %22 = ADDiu %zero, -1
    %35 = ADDiu %zero, 180
  
  bb.2 (%ir-block.5, freq 259):
    successors: %bb.6.readkpacket.exit(37), %bb.3(62)
  
    ADJCALLSTACKDOWN 56, implicit-def dead %sp, implicit %sp
    %11 = COPY %sp
    SW %10, %11, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %9, %11, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %12, %11, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %11, 48, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %11, 44, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %11, 40, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %11, 36, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %11, 32, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %11, 28, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %13 = LW %4, target-flags(<unknown>) @readkeypacket, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @readkeypacket)
    %a0 = COPY %2
    %a1 = COPY %14
    %a2 = COPY %15
    %a3 = COPY %14
    %gp = COPY %4
    %t9 = COPY %13
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 56, 0, implicit-def dead %sp, implicit %sp
    %16 = COPY %v0
    BLTZ %16, %bb.6.readkpacket.exit, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.13, freq 161):
    successors: %bb.4(50), %bb.5.readkpacket.exit.thread(50)
  
    %17 = LBu %stack.3.ctb, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    BNE killed %17, %35, %bb.5.readkpacket.exit.thread, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.16, freq 80):
    successors: %bb.5.readkpacket.exit.thread(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %19 = LW %4, target-flags(<unknown>) @PascalToC, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @PascalToC)
    %a0 = COPY %12
    %gp = COPY %4
    %t9 = COPY %19
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.5.readkpacket.exit.thread (freq 161):
    successors: %bb.7(100)
  
    B %bb.7, implicit-def dead %at
  
  bb.6.readkpacket.exit (freq 97):
    successors: %bb.9..loopexit(3), %bb.7(96)
  
    %21 = ORi %16, 2
    BEQ killed %21, %22, %bb.9..loopexit, implicit-def dead %at
    B %bb.7, implicit-def dead %at
  
  bb.7 (%ir-block.23, freq 255):
    successors: %bb.8(3), %bb.2(96)
  
    %34 = LBu %stack.3.ctb, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    BNE killed %34, %35, %bb.2, implicit-def dead %at
    B %bb.8, implicit-def dead %at
  
  bb.8 (%ir-block.26, freq 8):
    successors: %bb.10(100)
  
    %36 = LW %4, target-flags(<unknown>) @pgpout, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from got)
    %37 = LW killed %36, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %38 = LW %4, target-flags(<unknown>) @.str.12, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %39 = ADDiu killed %38, target-flags(<unknown>) @.str.12
    %40 = LW %4, target-flags(<unknown>) @fprintf, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @fprintf)
    %41 = LEA_ADDiu %stack.2.userid, 0
    %a0 = COPY %37
    %a1 = COPY %39
    %a2 = COPY %41
    %gp = COPY %4
    %t9 = COPY %40
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %43 = ADDiu %zero, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %44 = LW %4, target-flags(<unknown>) @fseek, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fseek)
    %a0 = COPY %2
    %a1 = COPY %0
    %a2 = COPY %43
    %gp = COPY %4
    %t9 = COPY %44
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.10, implicit-def dead %at
  
  bb.9..loopexit (freq 9):
    successors: %bb.10(100)
  
    %23 = LW %4, target-flags(<unknown>) @pgpout, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %24 = LW killed %23, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %25 = LW %4, target-flags(<unknown>) @keyIDstring, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @keyIDstring)
    %a0 = COPY %3
    %gp = COPY %4
    %t9 = COPY %25
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %26 = COPY %v0
    %27 = LW %4, target-flags(<unknown>) @.str.14, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from got)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %28 = ADDiu killed %27, target-flags(<unknown>) @.str.14
    %29 = LW %4, target-flags(<unknown>) @fprintf, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %24
    %a1 = COPY %28
    %a2 = COPY %26
    %gp = COPY %4
    %t9 = COPY %29
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %31 = ADDiu %zero, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %32 = LW %4, target-flags(<unknown>) @fseek, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fseek)
    %a0 = COPY %2
    %a1 = COPY %0
    %a2 = COPY %31
    %gp = COPY %4
    %t9 = COPY %32
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.10 (%ir-block.35, freq 17):
    liveouts:
  
    RetRA

...
--- |
  ; ModuleID = '/home/romi/didaktoriko/unison/unison-experiments/experiments/test-input/c/mediabench/mips_zip/build-mips/pgp/pgp.keymaint.ll'
  target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mips--linux-gnu"
  
  %struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i32, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i32, i32, [40 x i8] }
  %struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
  %struct.hashent = type { %struct.hashent*, [8 x i8], i8* }
  %struct.pubkey = type { %struct.pubkey*, %struct.pubkey*, %struct.userid*, %struct.signature*, [8 x i8], i8, i8 }
  %struct.userid = type { %struct.userid*, %struct.pubkey*, %struct.signature*, i8*, i8 }
  %struct.signature = type { %struct.signature*, %struct.userid*, %struct.pubkey*, %struct.signature*, i8 }
  %struct.bufpool = type { %struct.bufpool*, [1 x i8] }
  %struct.newkey = type { [8 x i8], %struct.newkey* }
  %struct.IdeaCfbContext = type opaque
  
  @marg_min = global i32 2, align 4
  @compl_min = global i32 1, align 4
  @trust_lst = global [8 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"unknown\00\00\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"<3>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"<4>\00\00\00\00\00\00\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00", [16 x i8] c"ultimate\00\00\00\00\00\00\00\00"], align 1
  @legit_lst = global [4 x [16 x i8]] [[16 x i8] c"undefined\00\00\00\00\00\00\00", [16 x i8] c"untrusted\00\00\00\00\00\00\00", [16 x i8] c"marginal\00\00\00\00\00\00\00\00", [16 x i8] c"complete\00\00\00\00\00\00\00\00"], align 1
  @floppyring = global [256 x i8] zeroinitializer, align 1
  @max_cert_depth = global i32 4, align 4
  @mverbose = internal unnamed_addr global i8 0, align 4
  @check_only = internal unnamed_addr global i1 false
  @moreflag = external global i8, align 1
  @.str = private unnamed_addr constant [2 x i8] c"r\00", align 1
  @floppy_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @pgpout = external global %struct._IO_FILE*, align 4
  @.str.1 = private unnamed_addr constant [39 x i8] c"\0ACan't open backup key ring file '%s'\0A\00", align 1
  @undefined_trust = internal unnamed_addr global i32 0, align 4
  @.str.2 = private unnamed_addr constant [46 x i8] c"\0A%d \22trust parameter(s)\22 need to be changed.\0A\00", align 1
  @.str.3 = private unnamed_addr constant [27 x i8] c"Continue with '%s' (Y/n)? \00", align 1
  @.str.4 = private unnamed_addr constant [35 x i8] c"\0A%d \22trust parameter(s)\22 changed.\0A\00", align 1
  @.str.5 = private unnamed_addr constant [35 x i8] c"Update public keyring '%s' (Y/n)? \00", align 1
  @.str.6 = private unnamed_addr constant [33 x i8] c"\0A\07Can't open key ring file '%s'\0A\00", align 1
  @.str.7 = private unnamed_addr constant [40 x i8] c"  KeyID    Trust     Validity  User ID\0A\00", align 1
  @.str.8 = private unnamed_addr constant [7 x i8] c"%c %s \00", align 1
  @.str.9 = private unnamed_addr constant [6 x i8] c"%-*s \00", align 1
  @trustlst_len = internal unnamed_addr global i32 9, align 4
  @.str.10 = private unnamed_addr constant [10 x i8] c"  %s %*s \00", align 1
  @blankkeyID = external constant [0 x i8], align 1
  @.str.11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
  @legitlst_len = internal unnamed_addr global i32 9, align 4
  @.str.12 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
  @.str.13 = private unnamed_addr constant [6 x i8] c"%*s  \00", align 1
  @.str.14 = private unnamed_addr constant [13 x i8] c"(KeyID: %s)\0A\00", align 1
  @init_trust_lst.initialized = internal unnamed_addr global i1 false
  @filter_mode = external global i8, align 1
  @batchmode = external global i8, align 1
  @.str.15 = private unnamed_addr constant [290 x i8] c"\0AMake a determination in your own mind whether this key actually\0Abelongs to the person whom you think it belongs to, based on available\0Aevidence.  If you think it does, then based on your estimate of\0Athat person's integrity and competence in key management, answer\0Athe following question:\0A\00", align 1
  @.str.16 = private unnamed_addr constant [146 x i8] c"\0AWould you trust \22%s\22\0Ato act as an introducer and certify other people's public keys to you?\0A(1=I don't know. 2=No. 3=Usually. 4=Yes, always.) ? \00", align 1
  @global_precision = external global i16, align 2
  @.str.17 = private unnamed_addr constant [4 x i8] c"pub\00", align 1
  @.str.18 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
  @.str.19 = private unnamed_addr constant [4 x i8] c"???\00", align 1
  @.str.20 = private unnamed_addr constant [3 x i8] c"? \00", align 1
  @.str.21 = private unnamed_addr constant [3 x i8] c"# \00", align 1
  @.str.22 = private unnamed_addr constant [3 x i8] c"- \00", align 1
  @.str.23 = private unnamed_addr constant [3 x i8] c"  \00", align 1
  @.str.24 = private unnamed_addr constant [12 x i8] c"%4d/%s %s  \00", align 1
  @.str.25 = private unnamed_addr constant [22 x i8] c"\0AKey for user ID: %s\0A\00", align 1
  @.str.26 = private unnamed_addr constant [35 x i8] c"%d-bit key, Key ID %s, created %s\0A\00", align 1
  @.str.27 = private unnamed_addr constant [17 x i8] c"Bad key format.\0A\00", align 1
  @.str.28 = private unnamed_addr constant [23 x i8] c"Unrecognized version.\0A\00", align 1
  @.str.29 = private unnamed_addr constant [23 x i8] c"Key has been revoked.\0A\00", align 1
  @.str.30 = private unnamed_addr constant [18 x i8] c"Key is disabled.\0A\00", align 1
  @owntrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.71, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.73, i32 0, i32 0)], align 4
  @.str.32 = private unnamed_addr constant [19 x i8] c"Also known as: %s\0A\00", align 1
  @keylegit_msg = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.76, i32 0, i32 0)], align 4
  @sigtrust_msg = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.78, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.81, i32 0, i32 0)], align 4
  @.str.33 = private unnamed_addr constant [17 x i8] c"  Certified by: \00", align 1
  @.str.34 = private unnamed_addr constant [44 x i8] c"\0AWarning: keyid %4d/%s %s  has no user id!\0A\00", align 1
  @.str.35 = private unnamed_addr constant [21 x i8] c"Updated keyID: 0x%s\0A\00", align 1
  @hashtbl = internal unnamed_addr global %struct.hashent** null, align 4
  @nkr = internal unnamed_addr global i32 0, align 4
  @.str.36 = private unnamed_addr constant [8 x i8] c"nkr < 8\00", align 1
  @.str.37 = private unnamed_addr constant [11 x i8] c"keymaint.c\00", align 1
  @__PRETTY_FUNCTION__.setkrent = private unnamed_addr constant [21 x i8] c"int setkrent(char *)\00", align 1
  @globalPubringName = external global [256 x i8], align 1
  @krnames = internal unnamed_addr global [8 x i8*] zeroinitializer, align 4
  @strleft = internal unnamed_addr global i32 0, align 4
  @hashleft = internal unnamed_addr global i32 0, align 4
  @hashptr = internal unnamed_addr global %struct.hashent* null, align 4
  @totalsize = global i32 0, align 4
  @globalSecringName = external global [256 x i8], align 1
  @sec_fp = internal unnamed_addr global %struct._IO_FILE* null, align 4
  @.str.38 = private unnamed_addr constant [39 x i8] c"\0ACan't open secret key ring file '%s'\0A\00", align 1
  @verbose = external global i8, align 1
  @.str.39 = private unnamed_addr constant [55 x i8] c"\0APass 1: Looking for the \22ultimately-trusted\22 keys...\0A\00", align 1
  @.str.40 = private unnamed_addr constant [38 x i8] c"\0APass 2: Tracing signature chains...\0A\00", align 1
  @.str.41 = private unnamed_addr constant [24 x i8] c"\0APass 3: %s keyring...\0A\00", align 1
  @.str.42 = private unnamed_addr constant [14 x i8] c"Checking with\00", align 1
  @.str.43 = private unnamed_addr constant [9 x i8] c"Updating\00", align 1
  @.str.44 = private unnamed_addr constant [35 x i8] c"maintenance pass: error exit = %d\0A\00", align 1
  @trust_tbl = internal unnamed_addr global [8 x i32] zeroinitializer, align 4
  @complete_min = internal unnamed_addr global i32 0, align 4
  @marginal_min = internal unnamed_addr global i32 0, align 4
  @pkhash = internal unnamed_addr global %struct.pubkey** null, align 4
  @pklist = internal unnamed_addr global %struct.pubkey* null, align 4
  @.str.45 = private unnamed_addr constant [36 x i8] c"Keyring contains duplicate key: %s\0A\00", align 1
  @.str.46 = private unnamed_addr constant [5 x i8] c"* %s\00", align 1
  @.str.47 = private unnamed_addr constant [5 x i8] c". %s\00", align 1
  @.str.48 = private unnamed_addr constant [9 x i8] c"        \00", align 1
  @.str.49 = private unnamed_addr constant [6 x i8] c"  %s\0A\00", align 1
  @.str.50 = private unnamed_addr constant [29 x i8] c"No ultimately-trusted keys.\0A\00", align 1
  @.str.51 = private unnamed_addr constant [36 x i8] c"\0A\07Cannot read from secret keyring.\0A\00", align 1
  @.str.52 = private unnamed_addr constant [101 x i8] c"\0A\07WARNING: Public key for user ID: \22%s\22\0Adoes not match the corresponding key in the secret keyring.\0A\00", align 1
  @.str.53 = private unnamed_addr constant [69 x i8] c"This is a serious condition, indicating possible keyring tampering.\0A\00", align 1
  @.str.54 = private unnamed_addr constant [59 x i8] c"\0AKey for user ID \22%s\22\0Aalso appears in the secret key ring.\00", align 1
  @.str.55 = private unnamed_addr constant [58 x i8] c"\0AUse this key as an ultimately-trusted introducer (y/N)? \00", align 1
  @.str.56 = private unnamed_addr constant [65 x i8] c"Public key for: \22%s\22\0Ais not present in the backup keyring '%s'.\0A\00", align 1
  @.str.57 = private unnamed_addr constant [84 x i8] c"\0A\07WARNING: Secret key for: \22%s\22\0Adoes not match the key in the backup keyring '%s'.\0A\00", align 1
  @allocn.ptr = internal unnamed_addr global i8* null, align 4
  @nleft = internal unnamed_addr global i32 0, align 4
  @.str.59 = private unnamed_addr constant [6 x i8] c"* %s\0A\00", align 1
  @.str.60 = private unnamed_addr constant [24 x i8] c"depth <= max_cert_depth\00", align 1
  @__PRETTY_FUNCTION__.trace_sig_chain = private unnamed_addr constant [42 x i8] c"int trace_sig_chain(struct pubkey *, int)\00", align 1
  @.str.61 = private unnamed_addr constant [11 x i8] c"%*s  > %s\0A\00", align 1
  @.str.62 = private unnamed_addr constant [11 x i8] c"%*s  X %s\0A\00", align 1
  @.str.63 = private unnamed_addr constant [3 x i8] c"r+\00", align 1
  @.str.64 = private unnamed_addr constant [38 x i8] c"pk && !memcmp(pk->pk_keyid, keyID, 8)\00", align 1
  @__PRETTY_FUNCTION__.maint_final = private unnamed_addr constant [24 x i8] c"int maint_final(char *)\00", align 1
  @.str.65 = private unnamed_addr constant [12 x i8] c"!sig && !id\00", align 1
  @.str.66 = private unnamed_addr constant [11 x i8] c"id && !sig\00", align 1
  @.str.67 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
  @.str.68 = private unnamed_addr constant [46 x i8] c"!memcmp(sig->sig_from->pk_keyid, sigkeyID, 8)\00", align 1
  @.str.69 = private unnamed_addr constant [29 x i8] c"maint_final: internal error\0A\00", align 1
  @.str.70 = private unnamed_addr constant [47 x i8] c"This user is untrusted to certify other keys.\0A\00", align 1
  @.str.71 = private unnamed_addr constant [55 x i8] c"This user is generally trusted to certify other keys.\0A\00", align 1
  @.str.72 = private unnamed_addr constant [56 x i8] c"This user is completely trusted to certify other keys.\0A\00", align 1
  @.str.73 = private unnamed_addr constant [65 x i8] c"This axiomatic key is ultimately trusted to certify other keys.\0A\00", align 1
  @.str.74 = private unnamed_addr constant [47 x i8] c"This key/userID association is not certified.\0A\00", align 1
  @.str.75 = private unnamed_addr constant [54 x i8] c"This key/userID association is marginally certified.\0A\00", align 1
  @.str.76 = private unnamed_addr constant [49 x i8] c"This key/userID association is fully certified.\0A\00", align 1
  @.str.77 = private unnamed_addr constant [38 x i8] c"  Questionable certification from:\0A  \00", align 1
  @.str.78 = private unnamed_addr constant [35 x i8] c"  Untrusted certification from:\0A  \00", align 1
  @.str.79 = private unnamed_addr constant [43 x i8] c"  Generally trusted certification from:\0A  \00", align 1
  @.str.80 = private unnamed_addr constant [44 x i8] c"  Completely trusted certification from:\0A  \00", align 1
  @.str.81 = private unnamed_addr constant [47 x i8] c"  Axiomatically trusted certification from:\0A  \00", align 1
  @_user_from_keyID.userid = internal global [256 x i8] zeroinitializer, align 1
  @stderr = external global %struct._IO_FILE*, align 4
  @.str.82 = private unnamed_addr constant [28 x i8] c"store_str: string too long\0A\00", align 1
  @strptr = internal unnamed_addr global i8* null, align 4
  @bufpool = internal unnamed_addr global %struct.bufpool* null, align 4
  @.str.83 = private unnamed_addr constant [20 x i8] c"\0AMemory used: %ldk\0A\00", align 1
  @switch.table = private unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 5, i32 6]
  
  ; Function Attrs: nounwind
  define void @free_newkeys(%struct.newkey* %nkeys) #0 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %.lr.ph
    %.01 = phi %struct.newkey* [ %3, %.lr.ph ], [ %nkeys, %0 ]
    %2 = getelementptr inbounds %struct.newkey, %struct.newkey* %.01, i32 0, i32 1
    %3 = load %struct.newkey*, %struct.newkey** %2, align 4, !tbaa !1
    %4 = bitcast %struct.newkey* %.01 to i8*
    tail call void @free(i8* %4) #6
    %5 = icmp eq %struct.newkey* %3, null
    br i1 %5, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %0
    ret void
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.start(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind
  declare void @free(i8* nocapture) #0
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.lifetime.end(i64, i8* nocapture) #1
  
  ; Function Attrs: nounwind readonly
  define i32 @ismember_newkeys(i8* nocapture readonly %keyid, %struct.newkey* readonly %nkeys) #2 {
    %1 = icmp eq %struct.newkey* %nkeys, null
    br i1 %1, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %0, %5
    %.02 = phi %struct.newkey* [ %7, %5 ], [ %nkeys, %0 ]
    %2 = bitcast %struct.newkey* %.02 to i8*
    %3 = tail call i32 @memcmp(i8* %keyid, i8* %2, i32 signext 8) #7
    %4 = icmp eq i32 %3, 0
    br i1 %4, label %._crit_edge, label %5
  
  ; <label>:5                                       ; preds = %.lr.ph
    %6 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02, i32 0, i32 1
    %7 = load %struct.newkey*, %struct.newkey** %6, align 4, !tbaa !1
    %8 = icmp eq %struct.newkey* %7, null
    br i1 %8, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.lr.ph, %5, %0
    %.01 = phi i32 [ 0, %0 ], [ 0, %5 ], [ 1, %.lr.ph ]
    ret i32 %.01
  }
  
  ; Function Attrs: nounwind readonly
  declare i32 @memcmp(i8* nocapture, i8* nocapture, i32 signext) #2
  
  ; Function Attrs: nounwind
  define i32 @maint_update(i8* %ringfile, %struct.newkey* readonly %nkeys) #0 {
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %1 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* %nkeys)
    ret i32 %1
  }
  
  ; Function Attrs: nounwind
  define internal fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* readonly %nkeys) unnamed_addr #0 {
    %sigkeyID.i11 = alloca [8 x i8], align 1
    %ctb.i12 = alloca i8, align 4
    %n.i.i.i = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n.i.i.i to [8 x i8]*
    %e.i.i.i = alloca [128 x i16], align 2
    %2 = bitcast [128 x i16]* %e.i.i.i to [3 x i8]*
    %n.i.i = alloca [128 x i16], align 2
    %3 = bitcast [128 x i16]* %n.i.i to i8*
    %e.i.i = alloca [128 x i16], align 2
    %nsec.i.i = alloca [128 x i16], align 2
    %esec.i.i = alloca [128 x i16], align 2
    %userid.i.i = alloca [256 x i8], align 1
    %keyID.i.i = alloca [8 x i8], align 1
    %ctb.i.i = alloca i8, align 4
    %buf.i.i = alloca [3 x i8], align 4
    %userid.i = alloca [256 x i8], align 1
    %keyID.i = alloca i64, align 8
    %sigkeyID.i = alloca i64, align 8
    %ctb.i = alloca i8, align 4
    store i32 0, i32* @undefined_trust, align 4, !tbaa !7
    %4 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %5 = icmp sgt i32 %4, 8
    br i1 %5, label %6, label %7
  
  ; <label>:6                                       ; preds = %0
    store i32 8, i32* @max_cert_depth, align 4, !tbaa !7
    br label %7
  
  ; <label>:7                                       ; preds = %6, %0
    %8 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %8, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %9 = icmp eq %struct._IO_FILE* %8, null
    br i1 %9, label %10, label %14
  
  ; <label>:10                                      ; preds = %7
    %11 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %12 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #6
    %13 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* %12, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @globalSecringName, i32 0, i32 0))
    br label %14
  
  ; <label>:14                                      ; preds = %10, %7
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = icmp slt i32 %15, 8
    br i1 %16, label %18, label %17
  
  ; <label>:17                                      ; preds = %14
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:18                                      ; preds = %14
    %19 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %19, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %20 = icmp sgt i32 %15, 0
    br i1 %20, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:21                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %22 = bitcast i8** %scevgep to [8 x i8*]*
    %23 = icmp slt i32 %27, %15
    br i1 %23, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %18, %21
    %lsr.iv = phi [8 x i8*]* [ %22, %21 ], [ @krnames, %18 ]
    %i.02.i = phi i32 [ %27, %21 ], [ 0, %18 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %24 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %25 = tail call i32 @strcmp(i8* %.keyring.i, i8* %24) #6
    %26 = icmp eq i32 %25, 0
    %27 = add nuw nsw i32 %i.02.i, 1
    br i1 %26, label %setkrent.exit, label %21
  
  ._crit_edge.i:                                    ; preds = %21, %18
    %28 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %29 = load i32, i32* @nkr, align 4, !tbaa !7
    %30 = add nsw i32 %29, 1
    store i32 %30, i32* @nkr, align 4, !tbaa !7
    %31 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %29
    store i8* %28, i8** %31, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %32 = load i32, i32* @marg_min, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %34, label %36
  
  ; <label>:34                                      ; preds = %setkrent.exit
    store i32 0, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 1, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %35 = load i32, i32* @compl_min, align 4, !tbaa !7
    br label %setup_trust.exit
  
  ; <label>:36                                      ; preds = %setkrent.exit
    %37 = load i32, i32* @compl_min, align 4, !tbaa !7
    %38 = icmp slt i32 %32, %37
    br i1 %38, label %39, label %40
  
  ; <label>:39                                      ; preds = %36
    store i32 %37, i32* @marg_min, align 4, !tbaa !7
    br label %40
  
  ; <label>:40                                      ; preds = %39, %36
    %41 = phi i32 [ %37, %39 ], [ %32, %36 ]
    store i32 %37, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 5), align 4, !tbaa !7
    store i32 %41, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 6), align 4, !tbaa !7
    %42 = mul nsw i32 %41, %37
    br label %setup_trust.exit
  
  setup_trust.exit:                                 ; preds = %40, %34
    %storemerge.i = phi i32 [ %42, %40 ], [ %35, %34 ]
    store i32 %storemerge.i, i32* @complete_min, align 4, !tbaa !7
    store i32 %storemerge.i, i32* getelementptr inbounds ([8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 7), align 4, !tbaa !7
    %43 = sdiv i32 %storemerge.i, 2
    store i32 %43, i32* @marginal_min, align 4, !tbaa !7
    %44 = tail call i8* @xmalloc(i32 signext 1028) #6
    %45 = load i32, i32* @totalsize, align 4, !tbaa !10
    %46 = add nsw i32 %45, 1024
    store i32 %46, i32* @totalsize, align 4, !tbaa !10
    %47 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %48 = bitcast i8* %44 to i32*
    store i32 %47, i32* %48, align 4, !tbaa !12
    store i8* %44, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %49 = getelementptr inbounds i8, i8* %44, i32 4
    store i8* %49, i8** bitcast (%struct.pubkey*** @pkhash to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %49, i8 0, i32 1024, i32 4, i1 false) #6
    %50 = load i8, i8* @mverbose, align 4, !tbaa !6
    %51 = load i8, i8* @verbose, align 1
    %52 = or i8 %51, %50
    %53 = icmp eq i8 %52, 0
    br i1 %53, label %58, label %54
  
  ; <label>:54                                      ; preds = %setup_trust.exit
    %55 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %56 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.39, i32 0, i32 0)) #6
    %57 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %55, i8* %56)
    br label %58
  
  ; <label>:58                                      ; preds = %54, %setup_trust.exit
    %59 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %59) #6
    %60 = bitcast i64* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %60) #6
    %61 = bitcast i64* %sigkeyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %61) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %62 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %63 = icmp eq %struct._IO_FILE* %62, null
    br i1 %63, label %64, label %.preheader.i
  
  .preheader.i:                                     ; preds = %58
    br label %.outer.i
  
  ; <label>:64                                      ; preds = %58
    %65 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %66 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %67 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %65, i8* %66, i8* %ringfile) #6
    br label %maint_read_data.exit
  
  ; <label>:68                                      ; preds = %.outer29.i, %85
    %69 = bitcast i64* %sigkeyID.i to i8*
    %70 = bitcast i64* %keyID.i to i8*
    %71 = bitcast [256 x i8]* %userid.i to i8*
    %72 = call i32 @readkpacket(%struct._IO_FILE* nonnull %62, i8* nonnull %ctb.i, i8* %71, i8* %70, i8* %69) #6
    %73 = icmp eq i32 %72, -1
    br i1 %73, label %496, label %74
  
  ; <label>:74                                      ; preds = %68
    %.off.i = add i32 %72, 3
    %75 = icmp ult i32 %.off.i, 2
    br i1 %75, label %76, label %78
  
  ; <label>:76                                      ; preds = %74
    %77 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:78                                      ; preds = %74
    %79 = icmp slt i32 %72, 0
    br i1 %79, label %.outer29.i, label %80
  
  ; <label>:80                                      ; preds = %78
    %81 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %82 = zext i8 %81 to i32
    %83 = and i32 %82, 124
    %84 = icmp eq i32 %83, 20
    br i1 %84, label %.outer29.i, label %85
  
  ; <label>:85                                      ; preds = %80
    %86 = icmp eq i32 %83, 24
    %or.cond28.i = or i1 %skip.0.ph.i, %86
    br i1 %or.cond28.i, label %87, label %68
  
  ; <label>:87                                      ; preds = %85
    %88 = icmp eq i32 %83, 56
    %89 = icmp eq i8 %81, -80
    %or.cond.i = or i1 %89, %88
    br i1 %or.cond.i, label %.outer29.i, label %90
  
  .outer29.i:                                       ; preds = %78, %80, %87, %96, %.outer.i
    %skip.0.ph.i = phi i1 [ true, %.outer.i ], [ true, %96 ], [ true, %87 ], [ false, %80 ], [ false, %78 ]
    br label %68
  
  ; <label>:90                                      ; preds = %87
    %91 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %92 = icmp eq i32 %83, 8
    %or.cond4.i = and i1 %91, %92
    br i1 %or.cond4.i, label %93, label %97
  
  ; <label>:93                                      ; preds = %90
    %sunkaddr = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr2 = add i32 %sunkaddr, 8
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to %struct.userid**
    %94 = load %struct.userid*, %struct.userid** %sunkaddr3, align 4, !tbaa !14
    %95 = icmp eq %struct.userid* %94, null
    br i1 %95, label %96, label %97
  
  ; <label>:96                                      ; preds = %93
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    store i8 2, i8* %sunkaddr6, align 4, !tbaa !16
    br label %.outer29.i
  
  ; <label>:97                                      ; preds = %93, %90
    %98 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.start(i64 3, i8* %98) #6
    %99 = call i32 @fread(i8* %98, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %62) #6
    %100 = icmp eq i32 %99, 3
    br i1 %100, label %101, label %.loopexit.i
  
  ; <label>:101                                     ; preds = %97
    %102 = bitcast [3 x i8]* %2 to i32*
    %103 = load i32, i32* %102, align 4
    %104 = lshr i32 %103, 24
    %105 = trunc i32 %104 to i8
    %106 = icmp eq i8 %105, -80
    %107 = lshr i32 %103, 8
    br i1 %106, label %113, label %108
  
  ; <label>:108                                     ; preds = %101
    %109 = trunc i32 %104 to i8
    %110 = icmp slt i8 %109, 0
    br i1 %110, label %111, label %.loopexit.i
  
  ; <label>:111                                     ; preds = %108
    %112 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext -3, i32 signext 1) #6
    br label %.loopexit.i
  
  ; <label>:113                                     ; preds = %101
    %114 = and i32 %103, 16711680
    %115 = icmp eq i32 %114, 65536
    br i1 %115, label %118, label %.loopexit.i
  
  .loopexit.i:                                      ; preds = %97, %113, %111, %108
    %116 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %116) #6
    %117 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:118                                     ; preds = %113
    %119 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %119) #6
    %120 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %121 = zext i8 %120 to i32
    %122 = lshr i32 %121, 2
    %123 = and i32 %122, 31
    switch i32 %123, label %494 [
      i32 6, label %124
      i32 13, label %362
      i32 2, label %413
    ]
  
  ; <label>:124                                     ; preds = %118
    %125 = bitcast i64* %keyID.i to i8*
    %126 = load i8, i8* %125, align 8, !tbaa !6
    %127 = zext i8 %126 to i32
    %128 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %129 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %128, i32 %127
    %pk.02.i.i = load %struct.pubkey*, %struct.pubkey** %129, align 4, !tbaa !9
    %130 = icmp eq %struct.pubkey* %pk.02.i.i, null
    br i1 %130, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %124, %135
    %pk.03.i.i = phi %struct.pubkey* [ %pk.0.i.i, %135 ], [ %pk.02.i.i, %124 ]
    %131 = bitcast i64* %keyID.i to i8*
    %132 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 4, i32 0
    %133 = call i32 @memcmp(i8* %132, i8* %131, i32 signext 8) #7
    %134 = icmp eq i32 %133, 0
    br i1 %134, label %getpubkey.exit.i, label %135
  
  ; <label>:135                                     ; preds = %.lr.ph.i.i
    %136 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i.i, i32 0, i32 1
    %pk.0.i.i = load %struct.pubkey*, %struct.pubkey** %136, align 4, !tbaa !9
    %137 = icmp eq %struct.pubkey* %pk.0.i.i, null
    br i1 %137, label %._crit_edge.i.i, label %.lr.ph.i.i
  
  ._crit_edge.i.i:                                  ; preds = %135, %124
    %138 = load i32, i32* @nleft, align 4, !tbaa !7
    %139 = icmp slt i32 %138, 28
    br i1 %139, label %140, label %._crit_edge.i8.i
  
  ._crit_edge.i8.i:                                 ; preds = %._crit_edge.i.i
    %.pre.i.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit.i
  
  ; <label>:140                                     ; preds = %._crit_edge.i.i
    %141 = call i8* @xmalloc(i32 signext 4004) #6
    %142 = load i32, i32* @totalsize, align 4, !tbaa !10
    %143 = add nsw i32 %142, 4000
    store i32 %143, i32* @totalsize, align 4, !tbaa !10
    %144 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %145 = bitcast i8* %141 to i32*
    store i32 %144, i32* %145, align 4, !tbaa !12
    store i8* %141, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %146 = getelementptr inbounds i8, i8* %141, i32 4
    store i8* %146, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre61.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit.i
  
  allocn.exit.i:                                    ; preds = %140, %._crit_edge.i8.i
    %147 = phi %struct.pubkey** [ %.pre61.i, %140 ], [ %128, %._crit_edge.i8.i ]
    %148 = phi i8* [ %146, %140 ], [ %.pre.i.i, %._crit_edge.i8.i ]
    %149 = phi i32 [ 4000, %140 ], [ %138, %._crit_edge.i8.i ]
    %150 = bitcast i64* %keyID.i to i8*
    %151 = add nsw i32 %149, -28
    store i32 %151, i32* @nleft, align 4, !tbaa !7
    %152 = getelementptr inbounds i8, i8* %148, i32 28
    store i8* %152, i8** @allocn.ptr, align 4, !tbaa !9
    %153 = bitcast i8* %148 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %148, i8 0, i32 28, i32 4, i1 false) #6
    %154 = getelementptr inbounds i8, i8* %148, i32 16
    %155 = bitcast i8* %154 to i64*
    %156 = load i64, i64* %keyID.i, align 8
    store i64 %156, i64* %155, align 1
    %157 = load i8, i8* %150, align 8, !tbaa !6
    %158 = zext i8 %157 to i32
    %159 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %158
    %160 = bitcast %struct.pubkey** %159 to i32*
    %161 = load i32, i32* %160, align 4, !tbaa !9
    %162 = getelementptr inbounds i8, i8* %148, i32 4
    %163 = bitcast i8* %162 to i32*
    store i32 %161, i32* %163, align 4, !tbaa !17
    %164 = load i8, i8* %150, align 8, !tbaa !6
    %165 = zext i8 %164 to i32
    %166 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %147, i32 %165
    %167 = bitcast %struct.pubkey** %166 to i8**
    store i8* %148, i8** %167, align 4, !tbaa !9
    br label %getpubkey.exit.i
  
  getpubkey.exit.i:                                 ; preds = %.lr.ph.i.i, %allocn.exit.i
    %.0.i7.i = phi %struct.pubkey* [ %153, %allocn.exit.i ], [ %pk.03.i.i, %.lr.ph.i.i ]
    %168 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %168, label %169, label %171
  
  ; <label>:169                                     ; preds = %getpubkey.exit.i
    %170 = bitcast %struct.pubkey* %pk.0.ph.i to %struct.pubkey**
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** %170, align 4, !tbaa !18
    br label %172
  
  ; <label>:171                                     ; preds = %getpubkey.exit.i
    store %struct.pubkey* %.0.i7.i, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %172
  
  ; <label>:172                                     ; preds = %171, %169
    %173 = bitcast %struct.pubkey* %.0.i7.i to %struct.pubkey**
    %174 = load %struct.pubkey*, %struct.pubkey** %173, align 4, !tbaa !18
    %175 = icmp eq %struct.pubkey* %174, null
    br i1 %175, label %183, label %176
  
  ; <label>:176                                     ; preds = %172
    %177 = bitcast i64* %keyID.i to i8*
    %178 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %179 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.45, i32 0, i32 0)) #6
    %180 = call i8* @keyIDstring(i8* %177) #6
    %181 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %178, i8* %179, i8* %180) #6
    %182 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  ; <label>:183                                     ; preds = %172
    %184 = trunc i32 %107 to i8
    %185 = icmp slt i8 %184, 0
    br i1 %185, label %ismember_newkeys.exit.i, label %186
  
  ; <label>:186                                     ; preds = %183
    %187 = trunc i32 %107 to i8
    %188 = icmp eq %struct.newkey* %nkeys, null
    br i1 %188, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  .lr.ph.i9.i:                                      ; preds = %186, %193
    %.02.i.i = phi %struct.newkey* [ %196, %193 ], [ %nkeys, %186 ]
    %189 = bitcast i64* %keyID.i to i8*
    %190 = bitcast %struct.newkey* %.02.i.i to i8*
    %191 = call i32 @memcmp(i8* %189, i8* %190, i32 signext 8) #7
    %192 = icmp eq i32 %191, 0
    br i1 %192, label %ismember_newkeys.exit.i, label %193
  
  ; <label>:193                                     ; preds = %.lr.ph.i9.i
    %194 = trunc i32 %107 to i8
    %195 = getelementptr inbounds %struct.newkey, %struct.newkey* %.02.i.i, i32 0, i32 1
    %196 = load %struct.newkey*, %struct.newkey** %195, align 4, !tbaa !1
    %197 = icmp eq %struct.newkey* %196, null
    br i1 %197, label %ismember_newkeys.exit.thread.i, label %.lr.ph.i9.i
  
  ismember_newkeys.exit.i:                          ; preds = %.lr.ph.i9.i, %183
    %198 = bitcast [8 x i8]* %keyID.i.i to i8*
    %199 = bitcast [256 x i8]* %userid.i.i to i8*
    %200 = bitcast [128 x i16]* %esec.i.i to i8*
    %201 = bitcast [128 x i16]* %nsec.i.i to i8*
    %202 = bitcast [128 x i16]* %e.i.i to i8*
    %203 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %203) #6
    call void @llvm.lifetime.start(i64 256, i8* %202) #6
    call void @llvm.lifetime.start(i64 256, i8* %201) #6
    call void @llvm.lifetime.start(i64 256, i8* %200) #6
    call void @llvm.lifetime.start(i64 256, i8* %199) #6
    call void @llvm.lifetime.start(i64 8, i8* %198) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i.i) #6
    %204 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %205 = icmp eq %struct._IO_FILE* %204, null
    br i1 %205, label %check_secretkey.exit.i, label %206
  
  ; <label>:206                                     ; preds = %ismember_newkeys.exit.i
    %207 = bitcast [128 x i16]* %e.i.i to i16*
    %208 = bitcast [128 x i16]* %n.i.i to i16*
    %209 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    %210 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %keypos.0.ph.i, i32 signext 0) #6
    %211 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %208, i16* %207, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %212 = icmp slt i16 %211, 0
    br i1 %212, label %.thread.i.i, label %213
  
  ; <label>:213                                     ; preds = %206
    %214 = bitcast [128 x i16]* %n.i.i to i16*
    %215 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @extract_keyID(i8* %215, i16* %214) #6
    br label %216
  
  ; <label>:216                                     ; preds = %236, %213
    %217 = bitcast [128 x i16]* %e.i.i.i to i16*
    %218 = bitcast [128 x i16]* %n.i.i.i to i16*
    %219 = bitcast [128 x i16]* %e.i.i.i to i8*
    %220 = bitcast [128 x i16]* %n.i.i.i to i8*
    %221 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %220) #6
    call void @llvm.lifetime.start(i64 256, i8* %219) #6
    %222 = call signext i16 @readkeypacket(%struct._IO_FILE* nonnull %62, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* %221, i16* %218, i16* %217, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %223 = icmp slt i16 %222, 0
    br i1 %223, label %readkpacket.exit.i.i, label %224
  
  ; <label>:224                                     ; preds = %216
    %225 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %226 = icmp eq i8 %225, -76
    br i1 %226, label %227, label %readkpacket.exit.thread.i.i
  
  ; <label>:227                                     ; preds = %224
    %228 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @PascalToC(i8* nonnull %228) #6
    br label %readkpacket.exit.thread.i.i
  
  readkpacket.exit.thread.i.i:                      ; preds = %227, %224
    %229 = bitcast [128 x i16]* %e.i.i.i to i8*
    %230 = bitcast [128 x i16]* %n.i.i.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %229) #6
    call void @llvm.lifetime.end(i64 256, i8* %230) #6
    br label %236
  
  readkpacket.exit.i.i:                             ; preds = %216
    %231 = bitcast [128 x i16]* %e.i.i.i to i8*
    %232 = bitcast [128 x i16]* %n.i.i.i to i8*
    %233 = sext i16 %222 to i32
    call void @llvm.lifetime.end(i64 256, i8* %231) #6
    call void @llvm.lifetime.end(i64 256, i8* %232) #6
    %234 = or i32 %233, 2
    %235 = icmp eq i32 %234, -1
    br i1 %235, label %.thread.i.i, label %236
  
  ; <label>:236                                     ; preds = %readkpacket.exit.i.i, %readkpacket.exit.thread.i.i
    %237 = load i8, i8* %ctb.i.i, align 4, !tbaa !6
    %238 = icmp eq i8 %237, -76
    br i1 %238, label %239, label %216
  
  ; <label>:239                                     ; preds = %236
    %240 = bitcast [8 x i8]* %keyID.i.i to i8*
    %241 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %242 = call i32 @lookup_by_keyID(%struct._IO_FILE* %241, i8* %240) #6
    %243 = icmp slt i32 %242, 0
    br i1 %243, label %.thread.i.i, label %244
  
  ; <label>:244                                     ; preds = %239
    %245 = bitcast [128 x i16]* %esec.i.i to i16*
    %246 = bitcast [128 x i16]* %nsec.i.i to i16*
    %247 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %248 = call i32 @ftell(%struct._IO_FILE* %247) #6
    %249 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %250 = call signext i16 @readkeypacket(%struct._IO_FILE* %249, %struct.IdeaCfbContext* null, i8* nonnull %ctb.i.i, i8* null, i8* null, i16* %246, i16* %245, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %251 = icmp slt i16 %250, 0
    br i1 %251, label %252, label %256
  
  ; <label>:252                                     ; preds = %244
    %253 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %254 = call i8* @LANG(i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0)) #6
    %255 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %253, i8* %254) #6
    br label %.thread.i.i
  
  ; <label>:256                                     ; preds = %244
    %257 = bitcast [128 x i16]* %nsec.i.i to i16*
    %258 = bitcast [128 x i16]* %n.i.i to i16*
    %259 = call signext i16 @mp_compare(i16* %258, i16* %257) #6
    %260 = icmp eq i16 %259, 0
    br i1 %260, label %261, label %266
  
  ; <label>:261                                     ; preds = %256
    %262 = bitcast [128 x i16]* %esec.i.i to i16*
    %263 = bitcast [128 x i16]* %e.i.i to i16*
    %264 = call signext i16 @mp_compare(i16* %263, i16* %262) #6
    %265 = icmp eq i16 %264, 0
    br i1 %265, label %274, label %266
  
  ; <label>:266                                     ; preds = %261, %256
    %267 = bitcast [256 x i8]* %userid.i.i to i8*
    %268 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %269 = call i8* @LANG(i8* nonnull getelementptr inbounds ([101 x i8], [101 x i8]* @.str.52, i32 0, i32 0)) #6
    %270 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %268, i8* %269, i8* %267) #6
    %271 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %272 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %273 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %271, i8* %272) #6
    br label %274
  
  ; <label>:274                                     ; preds = %266, %261
    %status.0.i.i = phi i32 [ -2, %266 ], [ 0, %261 ]
    %275 = trunc i32 %107 to i8
    %276 = icmp slt i8 %275, 0
    br i1 %276, label %290, label %277
  
  ; <label>:277                                     ; preds = %274
    %278 = load i8, i8* @batchmode, align 1, !tbaa !6
    %279 = icmp eq i8 %278, 0
    br i1 %279, label %280, label %.thread.i.i
  
  ; <label>:280                                     ; preds = %277
    %281 = bitcast [256 x i8]* %userid.i.i to i8*
    %282 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %283 = call i8* @LANG(i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0)) #6
    %284 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %282, i8* %283, i8* %281) #6
    %285 = call i8* @LANG(i8* nonnull getelementptr inbounds ([58 x i8], [58 x i8]* @.str.55, i32 0, i32 0)) #6
    %286 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %287 = call i32 @fputs(i8* %285, %struct._IO_FILE* %286) #6
    %288 = call zeroext i8 @getyesno(i8 signext 110) #6
    %not..i.i = icmp eq i8 %288, 0
    %289 = sext i1 %not..i.i to i32
    br label %290
  
  ; <label>:290                                     ; preds = %280, %274
    %status.1.i.i = phi i32 [ %status.0.i.i, %274 ], [ %289, %280 ]
    %291 = icmp eq i32 %status.1.i.i, 0
    %292 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4
    %293 = icmp ne %struct._IO_FILE* %292, null
    %or.cond3.i.i = and i1 %291, %293
    br i1 %or.cond3.i.i, label %294, label %.thread.i.i
  
  ; <label>:294                                     ; preds = %290
    %295 = bitcast [8 x i8]* %keyID.i.i to i8*
    %296 = call i32 @lookup_by_keyID(%struct._IO_FILE* %292, i8* %295) #6
    %297 = icmp slt i32 %296, 0
    br i1 %297, label %298, label %303
  
  ; <label>:298                                     ; preds = %294
    %299 = bitcast [256 x i8]* %userid.i.i to i8*
    %300 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %301 = call i8* @LANG(i8* nonnull getelementptr inbounds ([65 x i8], [65 x i8]* @.str.56, i32 0, i32 0)) #6
    %302 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %300, i8* %301, i8* %299, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    br label %.thread.i.i
  
  ; <label>:303                                     ; preds = %294
    %304 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %305 = call i32 @ftell(%struct._IO_FILE* %304) #6
    %306 = sub nsw i32 %305, %248
    %307 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %308 = call i32 @fseek(%struct._IO_FILE* %307, i32 signext %248, i32 signext 0) #6
    br label %309
  
  ; <label>:309                                     ; preds = %311, %303
    %pktlen.0.i.i = phi i32 [ %306, %303 ], [ %312, %311 ]
    %310 = icmp sgt i32 %pktlen.0.i.i, 0
    br i1 %310, label %311, label %.critedge.i.i
  
  ; <label>:311                                     ; preds = %309
    %312 = add nsw i32 %pktlen.0.i.i, -1
    %313 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %314 = call i32 @_IO_getc(%struct._IO_FILE* %313) #6
    %315 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %316 = call i32 @_IO_getc(%struct._IO_FILE* %315) #6
    %317 = icmp eq i32 %314, %316
    br i1 %317, label %309, label %.critedge.thread.i.i
  
  .critedge.i.i:                                    ; preds = %309
    %318 = icmp eq i32 %pktlen.0.i.i, 0
    br i1 %318, label %.thread.i.i, label %.critedge.thread.i.i
  
  .critedge.thread.i.i:                             ; preds = %311, %.critedge.i.i
    %319 = bitcast [256 x i8]* %userid.i.i to i8*
    %320 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %321 = call i8* @LANG(i8* nonnull getelementptr inbounds ([84 x i8], [84 x i8]* @.str.57, i32 0, i32 0)) #6
    %322 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %320, i8* %321, i8* %319, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0)) #6
    %323 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %324 = call i8* @LANG(i8* nonnull getelementptr inbounds ([69 x i8], [69 x i8]* @.str.53, i32 0, i32 0)) #6
    %325 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %323, i8* %324) #6
    br label %.thread.i.i
  
  .thread.i.i:                                      ; preds = %readkpacket.exit.i.i, %.critedge.thread.i.i, %.critedge.i.i, %298, %290, %277, %252, %239, %206
    %status.4.i.i = phi i32 [ -1, %206 ], [ 1, %239 ], [ -3, %252 ], [ 0, %298 ], [ -2, %.critedge.thread.i.i ], [ 0, %.critedge.i.i ], [ %status.1.i.i, %290 ], [ -1, %277 ], [ %233, %readkpacket.exit.i.i ]
    %326 = call i32 @fseek(%struct._IO_FILE* nonnull %62, i32 signext %209, i32 signext 0) #6
    br label %check_secretkey.exit.i
  
  check_secretkey.exit.i:                           ; preds = %.thread.i.i, %ismember_newkeys.exit.i
    %.0.i11.i = phi i32 [ %status.4.i.i, %.thread.i.i ], [ -1, %ismember_newkeys.exit.i ]
    %327 = bitcast [8 x i8]* %keyID.i.i to i8*
    %328 = bitcast [256 x i8]* %userid.i.i to i8*
    %329 = bitcast [128 x i16]* %esec.i.i to i8*
    %330 = bitcast [128 x i16]* %nsec.i.i to i8*
    %331 = bitcast [128 x i16]* %e.i.i to i8*
    %332 = bitcast [128 x i16]* %n.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %327) #6
    call void @llvm.lifetime.end(i64 256, i8* %328) #6
    call void @llvm.lifetime.end(i64 256, i8* %329) #6
    call void @llvm.lifetime.end(i64 256, i8* %330) #6
    call void @llvm.lifetime.end(i64 256, i8* %331) #6
    call void @llvm.lifetime.end(i64 256, i8* %332) #6
    %333 = icmp eq i32 %.0.i11.i, 0
    br i1 %333, label %334, label %346
  
  ; <label>:334                                     ; preds = %check_secretkey.exit.i
    %335 = add nsw i32 %buckstopcount.0.ph.i, 1
    %336 = or i32 %107, 135
    %337 = trunc i32 %336 to i8
    %338 = load i8, i8* @mverbose, align 4, !tbaa !6
    %339 = icmp eq i8 %338, 0
    br i1 %339, label %358, label %340
  
  ; <label>:340                                     ; preds = %334
    %341 = trunc i32 %336 to i8
    %342 = bitcast i64* %keyID.i to i8*
    %343 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %344 = call i8* @keyIDstring(i8* %342) #6
    %345 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %343, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i8* %344) #6
    br label %358
  
  ; <label>:346                                     ; preds = %check_secretkey.exit.i
    %347 = and i32 %107, 127
    %348 = trunc i32 %347 to i8
    %349 = and i32 %107, 7
    %350 = icmp eq i32 %349, 7
    %..i = select i1 %350, i8 6, i8 %348
    %351 = load i8, i8* @mverbose, align 4, !tbaa !6
    %352 = icmp eq i8 %351, 0
    br i1 %352, label %358, label %353
  
  ; <label>:353                                     ; preds = %346
    %354 = bitcast i64* %keyID.i to i8*
    %355 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %356 = call i8* @keyIDstring(i8* %354) #6
    %357 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %355, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i8* %356) #6
    br label %358
  
  ; <label>:358                                     ; preds = %353, %346, %340, %334
    %keyctrl.2.i = phi i8 [ %337, %334 ], [ %341, %340 ], [ %..i, %346 ], [ %..i, %353 ]
    %buckstop.1.i = phi i8 [ 1, %334 ], [ 1, %340 ], [ %buckstop.0.ph.i, %346 ], [ %buckstop.0.ph.i, %353 ]
    %buckstopcount.1.i = phi i32 [ %335, %334 ], [ %335, %340 ], [ %buckstopcount.0.ph.i, %346 ], [ %buckstopcount.0.ph.i, %353 ]
    %359 = load i8, i8* @mverbose, align 4, !tbaa !6
    br label %ismember_newkeys.exit.thread.i
  
  ismember_newkeys.exit.thread.i:                   ; preds = %193, %358, %186
    %keyctrl.3.i = phi i8 [ %keyctrl.2.i, %358 ], [ %187, %186 ], [ %194, %193 ]
    %buckstop.2.i = phi i8 [ %buckstop.1.i, %358 ], [ 0, %186 ], [ 0, %193 ]
    %show_user.1.i = phi i8 [ %359, %358 ], [ 0, %186 ], [ 0, %193 ]
    %buckstopcount.2.i = phi i32 [ %buckstopcount.1.i, %358 ], [ %buckstopcount.0.ph.i, %186 ], [ %buckstopcount.0.ph.i, %193 ]
    %360 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 5
    store i8 %keyctrl.3.i, i8* %360, align 4, !tbaa !16
    %361 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i7.i, i32 0, i32 2
    store %struct.userid* null, %struct.userid** %361, align 4, !tbaa !14
    br label %494
  
  ; <label>:362                                     ; preds = %118
    %363 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    br i1 %363, label %364, label %494
  
  ; <label>:364                                     ; preds = %362
    %365 = icmp eq i8 %show_user.0.ph.i, 0
    br i1 %365, label %376, label %366
  
  ; <label>:366                                     ; preds = %364
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr8 = add i32 %sunkaddr7, 8
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to %struct.userid**
    %367 = load %struct.userid*, %struct.userid** %sunkaddr9, align 4, !tbaa !14
    %368 = icmp eq %struct.userid* %367, null
    br i1 %368, label %372, label %369
  
  ; <label>:369                                     ; preds = %366
    %370 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %371 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.48, i32 0, i32 0), i32 8, i32 1, %struct._IO_FILE* %370) #6
    br label %372
  
  ; <label>:372                                     ; preds = %369, %366
    %373 = bitcast [256 x i8]* %userid.i to i8*
    %374 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %375 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %374, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %373) #6
    br label %376
  
  ; <label>:376                                     ; preds = %372, %364
    %377 = load i32, i32* @nleft, align 4, !tbaa !7
    %378 = icmp slt i32 %377, 20
    br i1 %378, label %379, label %._crit_edge.i13.i
  
  ._crit_edge.i13.i:                                ; preds = %376
    %.pre.i12.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit14.i
  
  ; <label>:379                                     ; preds = %376
    %380 = call i8* @xmalloc(i32 signext 4004) #6
    %381 = load i32, i32* @totalsize, align 4, !tbaa !10
    %382 = add nsw i32 %381, 4000
    store i32 %382, i32* @totalsize, align 4, !tbaa !10
    %383 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %384 = bitcast i8* %380 to i32*
    store i32 %383, i32* %384, align 4, !tbaa !12
    store i8* %380, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %385 = getelementptr inbounds i8, i8* %380, i32 4
    store i8* %385, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit14.i
  
  allocn.exit14.i:                                  ; preds = %379, %._crit_edge.i13.i
    %386 = phi i8* [ %385, %379 ], [ %.pre.i12.i, %._crit_edge.i13.i ]
    %387 = phi i32 [ 4000, %379 ], [ %377, %._crit_edge.i13.i ]
    %388 = icmp eq %struct.userid* %id.0.ph.i, null
    %389 = add nsw i32 %387, -20
    store i32 %389, i32* @nleft, align 4, !tbaa !7
    %390 = getelementptr inbounds i8, i8* %386, i32 20
    store i8* %390, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %388, label %393, label %391
  
  ; <label>:391                                     ; preds = %allocn.exit14.i
    %392 = bitcast %struct.userid* %id.0.ph.i to i8**
    store i8* %386, i8** %392, align 4, !tbaa !19
    br label %394
  
  ; <label>:393                                     ; preds = %allocn.exit14.i
    %sunkaddr10 = ptrtoint %struct.pubkey* %pk.0.ph.i to i32
    %sunkaddr11 = add i32 %sunkaddr10, 8
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8**
    store i8* %386, i8** %sunkaddr12, align 4, !tbaa !14
    br label %394
  
  ; <label>:394                                     ; preds = %393, %391
    %395 = load i8, i8* @mverbose, align 4, !tbaa !6
    %396 = icmp eq i8 %395, 0
    br i1 %396, label %402, label %397
  
  ; <label>:397                                     ; preds = %394
    %398 = bitcast [256 x i8]* %userid.i to i8*
    %399 = call fastcc i8* @store_str(i8* %398) #6
    %400 = getelementptr inbounds i8, i8* %386, i32 12
    %401 = bitcast i8* %400 to i8**
    store i8* %399, i8** %401, align 4, !tbaa !21
    br label %402
  
  ; <label>:402                                     ; preds = %397, %394
    %403 = bitcast i8* %386 to %struct.userid*
    %404 = and i32 %107, 252
    %405 = icmp eq i8 %buckstop.0.ph.i, 0
    %406 = or i32 %107, 3
    %storemerge.in.i = select i1 %405, i32 %404, i32 %406
    %storemerge.i4 = trunc i32 %storemerge.in.i to i8
    %407 = bitcast i8* %386 to %struct.userid**
    store %struct.userid* null, %struct.userid** %407, align 4, !tbaa !19
    %408 = getelementptr inbounds i8, i8* %386, i32 4
    %409 = bitcast i8* %408 to %struct.pubkey**
    store %struct.pubkey* %pk.0.ph.i, %struct.pubkey** %409, align 4, !tbaa !22
    %410 = getelementptr inbounds i8, i8* %386, i32 16
    store i8 %storemerge.i4, i8* %410, align 4, !tbaa !23
    %411 = getelementptr inbounds i8, i8* %386, i32 8
    %412 = bitcast i8* %411 to %struct.signature**
    store %struct.signature* null, %struct.signature** %412, align 4, !tbaa !24
    br label %494
  
  ; <label>:413                                     ; preds = %118
    %414 = icmp ne %struct.pubkey* %pk.0.ph.i, null
    %415 = icmp ne %struct.userid* %id.0.ph.i, null
    %or.cond3.i = and i1 %414, %415
    br i1 %or.cond3.i, label %416, label %494
  
  ; <label>:416                                     ; preds = %413
    %417 = load i32, i32* @nleft, align 4, !tbaa !7
    %418 = icmp slt i32 %417, 20
    br i1 %418, label %419, label %._crit_edge.i16.i
  
  ._crit_edge.i16.i:                                ; preds = %416
    %.pre.i15.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit17.i
  
  ; <label>:419                                     ; preds = %416
    %420 = call i8* @xmalloc(i32 signext 4004) #6
    %421 = load i32, i32* @totalsize, align 4, !tbaa !10
    %422 = add nsw i32 %421, 4000
    store i32 %422, i32* @totalsize, align 4, !tbaa !10
    %423 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %424 = bitcast i8* %420 to i32*
    store i32 %423, i32* %424, align 4, !tbaa !12
    store i8* %420, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %425 = getelementptr inbounds i8, i8* %420, i32 4
    store i8* %425, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    br label %allocn.exit17.i
  
  allocn.exit17.i:                                  ; preds = %419, %._crit_edge.i16.i
    %426 = phi i8* [ %425, %419 ], [ %.pre.i15.i, %._crit_edge.i16.i ]
    %427 = phi i32 [ 4000, %419 ], [ %417, %._crit_edge.i16.i ]
    %428 = icmp eq %struct.signature* %sig.0.ph.i, null
    %429 = add nsw i32 %427, -20
    store i32 %429, i32* @nleft, align 4, !tbaa !7
    %430 = getelementptr inbounds i8, i8* %426, i32 20
    store i8* %430, i8** @allocn.ptr, align 4, !tbaa !9
    br i1 %428, label %433, label %431
  
  ; <label>:431                                     ; preds = %allocn.exit17.i
    %432 = bitcast %struct.signature* %sig.0.ph.i to i8**
    store i8* %426, i8** %432, align 4, !tbaa !25
    br label %436
  
  ; <label>:433                                     ; preds = %allocn.exit17.i
    %434 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i, i32 0, i32 2
    %435 = bitcast %struct.signature** %434 to i8**
    store i8* %426, i8** %435, align 4, !tbaa !24
    br label %436
  
  ; <label>:436                                     ; preds = %433, %431
    %437 = bitcast i64* %sigkeyID.i to i8*
    %438 = bitcast i8* %426 to %struct.signature**
    store %struct.signature* null, %struct.signature** %438, align 4, !tbaa !25
    %439 = getelementptr inbounds i8, i8* %426, i32 4
    %440 = bitcast i8* %439 to %struct.userid**
    store %struct.userid* %id.0.ph.i, %struct.userid** %440, align 4, !tbaa !27
    %441 = load i8, i8* %437, align 8, !tbaa !6
    %442 = zext i8 %441 to i32
    %443 = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %444 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %443, i32 %442
    %pk.02.i18.i = load %struct.pubkey*, %struct.pubkey** %444, align 4, !tbaa !9
    %445 = icmp eq %struct.pubkey* %pk.02.i18.i, null
    br i1 %445, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  .lr.ph.i20.i:                                     ; preds = %436, %450
    %pk.03.i19.i = phi %struct.pubkey* [ %pk.0.i21.i, %450 ], [ %pk.02.i18.i, %436 ]
    %446 = bitcast i64* %sigkeyID.i to i8*
    %447 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 4, i32 0
    %448 = call i32 @memcmp(i8* %447, i8* %446, i32 signext 8) #7
    %449 = icmp eq i32 %448, 0
    br i1 %449, label %getpubkey.exit24.i, label %450
  
  ; <label>:450                                     ; preds = %.lr.ph.i20.i
    %451 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.03.i19.i, i32 0, i32 1
    %pk.0.i21.i = load %struct.pubkey*, %struct.pubkey** %451, align 4, !tbaa !9
    %452 = icmp eq %struct.pubkey* %pk.0.i21.i, null
    br i1 %452, label %._crit_edge.i22.i, label %.lr.ph.i20.i
  
  ._crit_edge.i22.i:                                ; preds = %450, %436
    %453 = icmp slt i32 %429, 28
    br i1 %453, label %454, label %._crit_edge.i26.i
  
  ._crit_edge.i26.i:                                ; preds = %._crit_edge.i22.i
    %.pre.i25.i = load i8*, i8** @allocn.ptr, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  ; <label>:454                                     ; preds = %._crit_edge.i22.i
    %455 = call i8* @xmalloc(i32 signext 4004) #6
    %456 = load i32, i32* @totalsize, align 4, !tbaa !10
    %457 = add nsw i32 %456, 4000
    store i32 %457, i32* @totalsize, align 4, !tbaa !10
    %458 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %459 = bitcast i8* %455 to i32*
    store i32 %458, i32* %459, align 4, !tbaa !12
    store i8* %455, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %460 = getelementptr inbounds i8, i8* %455, i32 4
    store i8* %460, i8** @allocn.ptr, align 4, !tbaa !9
    store i32 4000, i32* @nleft, align 4, !tbaa !7
    %.pre.i = load %struct.pubkey**, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    br label %allocn.exit27.i
  
  allocn.exit27.i:                                  ; preds = %454, %._crit_edge.i26.i
    %461 = phi %struct.pubkey** [ %.pre.i, %454 ], [ %443, %._crit_edge.i26.i ]
    %462 = phi i8* [ %460, %454 ], [ %.pre.i25.i, %._crit_edge.i26.i ]
    %463 = phi i32 [ 4000, %454 ], [ %429, %._crit_edge.i26.i ]
    %464 = bitcast i64* %sigkeyID.i to i8*
    %465 = add nsw i32 %463, -28
    store i32 %465, i32* @nleft, align 4, !tbaa !7
    %466 = getelementptr inbounds i8, i8* %462, i32 28
    store i8* %466, i8** @allocn.ptr, align 4, !tbaa !9
    %467 = bitcast i8* %462 to %struct.pubkey*
    call void @llvm.memset.p0i8.i32(i8* %462, i8 0, i32 28, i32 4, i1 false) #6
    %468 = getelementptr inbounds i8, i8* %462, i32 16
    %469 = bitcast i8* %468 to i64*
    %470 = load i64, i64* %sigkeyID.i, align 8
    store i64 %470, i64* %469, align 1
    %471 = load i8, i8* %464, align 8, !tbaa !6
    %472 = zext i8 %471 to i32
    %473 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %472
    %474 = bitcast %struct.pubkey** %473 to i32*
    %475 = load i32, i32* %474, align 4, !tbaa !9
    %476 = getelementptr inbounds i8, i8* %462, i32 4
    %477 = bitcast i8* %476 to i32*
    store i32 %475, i32* %477, align 4, !tbaa !17
    %478 = load i8, i8* %464, align 8, !tbaa !6
    %479 = zext i8 %478 to i32
    %480 = getelementptr inbounds %struct.pubkey*, %struct.pubkey** %461, i32 %479
    %481 = bitcast %struct.pubkey** %480 to i8**
    store i8* %462, i8** %481, align 4, !tbaa !9
    br label %getpubkey.exit24.i
  
  getpubkey.exit24.i:                               ; preds = %.lr.ph.i20.i, %allocn.exit27.i
    %.0.i23.i = phi %struct.pubkey* [ %467, %allocn.exit27.i ], [ %pk.03.i19.i, %.lr.ph.i20.i ]
    %482 = bitcast i8* %426 to %struct.signature*
    %483 = getelementptr inbounds i8, i8* %426, i32 8
    %484 = bitcast i8* %483 to %struct.pubkey**
    store %struct.pubkey* %.0.i23.i, %struct.pubkey** %484, align 4, !tbaa !28
    %485 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %.0.i23.i, i32 0, i32 3
    %486 = bitcast %struct.signature** %485 to i32*
    %487 = load i32, i32* %486, align 4, !tbaa !29
    %488 = getelementptr inbounds i8, i8* %426, i32 12
    %489 = bitcast i8* %488 to i32*
    store i32 %487, i32* %489, align 4, !tbaa !30
    %490 = bitcast %struct.signature** %485 to i8**
    store i8* %426, i8** %490, align 4, !tbaa !29
    %491 = and i32 %107, 64
    %492 = trunc i32 %491 to i8
    %493 = getelementptr inbounds i8, i8* %426, i32 16
    store i8 %492, i8* %493, align 4, !tbaa !31
    br label %494
  
  ; <label>:494                                     ; preds = %getpubkey.exit24.i, %413, %402, %362, %ismember_newkeys.exit.thread.i, %118
    %buckstop.3.i = phi i8 [ %buckstop.0.ph.i, %118 ], [ %buckstop.0.ph.i, %getpubkey.exit24.i ], [ %buckstop.0.ph.i, %413 ], [ %buckstop.0.ph.i, %402 ], [ %buckstop.0.ph.i, %362 ], [ %buckstop.2.i, %ismember_newkeys.exit.thread.i ]
    %show_user.2.i = phi i8 [ %show_user.0.ph.i, %118 ], [ %show_user.0.ph.i, %getpubkey.exit24.i ], [ %show_user.0.ph.i, %413 ], [ %show_user.0.ph.i, %402 ], [ %show_user.0.ph.i, %362 ], [ %show_user.1.i, %ismember_newkeys.exit.thread.i ]
    %buckstopcount.3.i = phi i32 [ %buckstopcount.0.ph.i, %118 ], [ %buckstopcount.0.ph.i, %getpubkey.exit24.i ], [ %buckstopcount.0.ph.i, %413 ], [ %buckstopcount.0.ph.i, %402 ], [ %buckstopcount.0.ph.i, %362 ], [ %buckstopcount.2.i, %ismember_newkeys.exit.thread.i ]
    %pk.2.i = phi %struct.pubkey* [ %pk.0.ph.i, %118 ], [ %pk.0.ph.i, %getpubkey.exit24.i ], [ %pk.0.ph.i, %413 ], [ %pk.0.ph.i, %402 ], [ null, %362 ], [ %.0.i7.i, %ismember_newkeys.exit.thread.i ]
    %id.2.i = phi %struct.userid* [ %id.0.ph.i, %118 ], [ %id.0.ph.i, %getpubkey.exit24.i ], [ %id.0.ph.i, %413 ], [ %403, %402 ], [ %id.0.ph.i, %362 ], [ null, %ismember_newkeys.exit.thread.i ]
    %sig.2.i = phi %struct.signature* [ %sig.0.ph.i, %118 ], [ %482, %getpubkey.exit24.i ], [ %sig.0.ph.i, %413 ], [ null, %402 ], [ %sig.0.ph.i, %362 ], [ %sig.0.ph.i, %ismember_newkeys.exit.thread.i ]
    %495 = call i32 @ftell(%struct._IO_FILE* nonnull %62) #6
    br label %.outer.i
  
  .outer.i:                                         ; preds = %494, %.preheader.i
    %buckstop.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %buckstop.3.i, %494 ]
    %show_user.0.ph.i = phi i8 [ 0, %.preheader.i ], [ %show_user.2.i, %494 ]
    %buckstopcount.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %buckstopcount.3.i, %494 ]
    %keypos.0.ph.i = phi i32 [ 0, %.preheader.i ], [ %495, %494 ]
    %pk.0.ph.i = phi %struct.pubkey* [ null, %.preheader.i ], [ %pk.2.i, %494 ]
    %id.0.ph.i = phi %struct.userid* [ null, %.preheader.i ], [ %id.2.i, %494 ]
    %sig.0.ph.i = phi %struct.signature* [ null, %.preheader.i ], [ %sig.2.i, %494 ]
    br label %.outer29.i
  
  ; <label>:496                                     ; preds = %68
    %497 = icmp ne i32 %buckstopcount.0.ph.i, 0
    %498 = load i8, i8* @mverbose, align 4
    %499 = icmp eq i8 %498, 0
    %or.cond6.i = or i1 %497, %499
    br i1 %or.cond6.i, label %504, label %500
  
  ; <label>:500                                     ; preds = %496
    %501 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %502 = call i8* @LANG(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50, i32 0, i32 0)) #6
    %503 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %501, i8* %502) #6
    br label %504
  
  ; <label>:504                                     ; preds = %500, %496
    %505 = call i32 @fclose(%struct._IO_FILE* nonnull %62) #6
    br label %maint_read_data.exit
  
  maint_read_data.exit:                             ; preds = %504, %176, %.loopexit.i, %76, %64
    %.0.i = phi i32 [ -1, %64 ], [ %72, %76 ], [ -7, %.loopexit.i ], [ -1, %176 ], [ 0, %504 ]
    %506 = bitcast i64* %sigkeyID.i to i8*
    %507 = bitcast i64* %keyID.i to i8*
    %508 = bitcast [256 x i8]* %userid.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %506) #6
    call void @llvm.lifetime.end(i64 8, i8* %507) #6
    call void @llvm.lifetime.end(i64 256, i8* %508) #6
    %509 = load %struct._IO_FILE*, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    %510 = icmp eq %struct._IO_FILE* %509, null
    br i1 %510, label %513, label %511
  
  ; <label>:511                                     ; preds = %maint_read_data.exit
    %512 = call i32 @fclose(%struct._IO_FILE* nonnull %509)
    store %struct._IO_FILE* null, %struct._IO_FILE** @sec_fp, align 4, !tbaa !9
    br label %513
  
  ; <label>:513                                     ; preds = %511, %maint_read_data.exit
    %514 = icmp slt i32 %.0.i, 0
    br i1 %514, label %759, label %515
  
  ; <label>:515                                     ; preds = %513
    %516 = load i8, i8* @mverbose, align 4, !tbaa !6
    %517 = load i8, i8* @verbose, align 1
    %518 = or i8 %517, %516
    %519 = icmp eq i8 %518, 0
    br i1 %519, label %524, label %520
  
  ; <label>:520                                     ; preds = %515
    %521 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %522 = call i8* @LANG(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.40, i32 0, i32 0)) #6
    %523 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %521, i8* %522)
    br label %524
  
  ; <label>:524                                     ; preds = %520, %515
    %pk.01.i = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    %525 = icmp eq %struct.pubkey* %pk.01.i, null
    br i1 %525, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  .lr.ph.i5:                                        ; preds = %524, %553
    %pk.02.i = phi %struct.pubkey* [ %pk.0.i, %553 ], [ %pk.01.i, %524 ]
    %526 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 5
    %527 = load i8, i8* %526, align 4, !tbaa !16
    %528 = icmp slt i8 %527, 0
    br i1 %528, label %529, label %553
  
  ; <label>:529                                     ; preds = %.lr.ph.i5
    %530 = load i8, i8* @mverbose, align 4, !tbaa !6
    %531 = icmp eq i8 %530, 0
    br i1 %531, label %539, label %532
  
  ; <label>:532                                     ; preds = %529
    %533 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %534 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 2
    %535 = load %struct.userid*, %struct.userid** %534, align 4, !tbaa !14
    %536 = getelementptr inbounds %struct.userid, %struct.userid* %535, i32 0, i32 3
    %537 = load i8*, i8** %536, align 4, !tbaa !21
    %538 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %533, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* %537) #6
    %sunkaddr13 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr14 = add i32 %sunkaddr13, 24
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    %.pre.i6 = load i8, i8* %sunkaddr15, align 4, !tbaa !16
    br label %539
  
  ; <label>:539                                     ; preds = %532, %529
    %540 = phi i8 [ %527, %529 ], [ %.pre.i6, %532 ]
    %541 = and i8 %540, 7
    %542 = icmp eq i8 %541, 0
    br i1 %542, label %543, label %552
  
  ; <label>:543                                     ; preds = %539
    %544 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.02.i, i32 0, i32 4, i32 0
    %545 = call i8* @user_from_keyID(i8* %544) #6
    %sunkaddr16 = ptrtoint %struct.pubkey* %pk.02.i to i32
    %sunkaddr17 = add i32 %sunkaddr16, 24
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %546 = load i8, i8* %sunkaddr18, align 4, !tbaa !6
    %547 = zext i8 %546 to i32
    %548 = and i32 %547, 248
    %549 = call i32 @ask_owntrust(i8* %545, i8 zeroext %546) #6
    %550 = or i32 %548, %549
    %551 = trunc i32 %550 to i8
    store i8 %551, i8* %sunkaddr18, align 4, !tbaa !6
    br label %552
  
  ; <label>:552                                     ; preds = %543, %539
    call fastcc void @trace_sig_chain(%struct.pubkey* nonnull %pk.02.i, i32 signext 0) #6
    br label %553
  
  ; <label>:553                                     ; preds = %552, %.lr.ph.i5
    %554 = bitcast %struct.pubkey* %pk.02.i to %struct.pubkey**
    %pk.0.i = load %struct.pubkey*, %struct.pubkey** %554, align 4, !tbaa !9
    %555 = icmp eq %struct.pubkey* %pk.0.i, null
    br i1 %555, label %maint_trace_chain.exit, label %.lr.ph.i5
  
  maint_trace_chain.exit:                           ; preds = %553, %524
    %556 = load i8, i8* @verbose, align 1, !tbaa !6
    %557 = icmp eq i8 %556, 0
    br i1 %557, label %562, label %558
  
  ; <label>:558                                     ; preds = %maint_trace_chain.exit
    %559 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %.b = load i1, i1* @check_only, align 1
    %560 = select i1 %.b, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0)
    %561 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %559, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.41, i32 0, i32 0), i8* %560)
    br label %562
  
  ; <label>:562                                     ; preds = %558, %maint_trace_chain.exit
    %563 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %563) #6
    %564 = bitcast [8 x i8]* %keyID.i.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %564) #6
    %565 = bitcast [8 x i8]* %1 to i8*
    call void @llvm.lifetime.start(i64 8, i8* %565) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %3) #6
    %.b10.i = load i1, i1* @check_only, align 1
    br i1 %.b10.i, label %566, label %568
  
  ; <label>:566                                     ; preds = %562
    %567 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:568                                     ; preds = %562
    %569 = call %struct._IO_FILE* @fopen(i8* %ringfile, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0)) #6
    br label %570
  
  ; <label>:570                                     ; preds = %568, %566
    %f.0.i = phi %struct._IO_FILE* [ %567, %566 ], [ %569, %568 ]
    %571 = icmp eq %struct._IO_FILE* %f.0.i, null
    br i1 %571, label %572, label %576
  
  ; <label>:572                                     ; preds = %570
    %573 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %574 = call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %575 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %573, i8* %574, i8* %ringfile) #6
    br label %maint_final.exit
  
  ; <label>:576                                     ; preds = %570
    %577 = load %struct.pubkey*, %struct.pubkey** @pklist, align 4, !tbaa !9
    br label %.outer.outer.i
  
  .outer.outer.i:                                   ; preds = %710, %576
    %kc_orig.0.ph.ph.i = phi i8 [ undef, %576 ], [ %kc_orig.2.i, %710 ]
    %trust_pos.0.ph.ph.i = phi i32 [ 0, %576 ], [ %trust_pos.1.i, %710 ]
    %kc_new.0.ph.ph.i = phi i8 [ 0, %576 ], [ %kc_new.1.i, %710 ]
    %changed.0.ph.ph.i = phi i32 [ 0, %576 ], [ %711, %710 ]
    %pk.0.ph.ph.i = phi %struct.pubkey* [ %577, %576 ], [ %pk.1.i, %710 ]
    %id.0.ph.ph.i = phi %struct.userid* [ null, %576 ], [ %id.1.i, %710 ]
    %sig.0.ph.ph.i = phi %struct.signature* [ null, %576 ], [ %sig.1.i, %710 ]
    br label %.outer.i16
  
  .outer.i16:                                       ; preds = %700, %.outer.outer.i
    %kc_orig.0.ph.i = phi i8 [ %kc_orig.2.i, %700 ], [ %kc_orig.0.ph.ph.i, %.outer.outer.i ]
    %trust_pos.0.ph.i = phi i32 [ %trust_pos.1.i, %700 ], [ %trust_pos.0.ph.ph.i, %.outer.outer.i ]
    %kc_new.0.ph.i = phi i8 [ %kc_new.1.i, %700 ], [ %kc_new.0.ph.ph.i, %.outer.outer.i ]
    %pk.0.ph.i13 = phi %struct.pubkey* [ %pk.1.i, %700 ], [ %pk.0.ph.ph.i, %.outer.outer.i ]
    %id.0.ph.i14 = phi %struct.userid* [ %id.1.i, %700 ], [ %id.0.ph.ph.i, %.outer.outer.i ]
    %sig.0.ph.i15 = phi %struct.signature* [ %sig.1.i, %700 ], [ %sig.0.ph.ph.i, %.outer.outer.i ]
    br label %.outer13.i
  
  .outer13.i:                                       ; preds = %617, %.outer.i16
    %trust_pos.0.ph14.i = phi i32 [ %trust_pos.0.ph.i, %.outer.i16 ], [ %597, %617 ]
    br label %.outer20.i
  
  .outer20.i:                                       ; preds = %583, %585, %.outer13.i
    %skip.0.ph.i17 = phi i1 [ true, %.outer13.i ], [ false, %585 ], [ false, %583 ]
    br label %578
  
  ; <label>:578                                     ; preds = %590, %.outer20.i
    %579 = bitcast [8 x i8]* %1 to i8*
    %580 = bitcast [8 x i8]* %keyID.i.i to i8*
    %581 = bitcast [256 x i8]* %userid.i.i to i8*
    %582 = call i32 @readkpacket(%struct._IO_FILE* nonnull %f.0.i, i8* nonnull %3, i8* %581, i8* %580, i8* %579) #6
    %switch.i = icmp ugt i32 %582, -4
    br i1 %switch.i, label %712, label %583
  
  ; <label>:583                                     ; preds = %578
    %584 = icmp slt i32 %582, 0
    br i1 %584, label %.outer20.i, label %585
  
  ; <label>:585                                     ; preds = %583
    %586 = load i8, i8* %3, align 4, !tbaa !6
    %587 = zext i8 %586 to i32
    %588 = and i32 %587, 124
    %589 = icmp eq i32 %588, 20
    br i1 %589, label %.outer20.i, label %590
  
  ; <label>:590                                     ; preds = %585
    %591 = icmp eq i32 %588, 24
    %or.cond.i18 = or i1 %skip.0.ph.i17, %591
    br i1 %or.cond.i18, label %592, label %578
  
  ; <label>:592                                     ; preds = %590
    switch i32 %588, label %593 [
      i32 24, label %595
      i32 8, label %595
    ]
  
  ; <label>:593                                     ; preds = %592
    %594 = icmp eq i8 %586, -76
    br i1 %594, label %595, label %.loopexit.i20
  
  ; <label>:595                                     ; preds = %593, %592, %592
    %596 = bitcast [3 x i8]* %2 to i8*
    %597 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    call void @llvm.lifetime.start(i64 3, i8* %596) #6
    %598 = call i32 @fread(i8* %596, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %f.0.i) #6
    %599 = icmp eq i32 %598, 3
    br i1 %599, label %600, label %617
  
  ; <label>:600                                     ; preds = %595
    %601 = bitcast [3 x i8]* %2 to i32*
    %602 = load i32, i32* %601, align 4
    %603 = lshr i32 %602, 24
    %604 = trunc i32 %603 to i8
    %605 = icmp eq i8 %604, -80
    br i1 %605, label %611, label %606
  
  ; <label>:606                                     ; preds = %600
    %607 = trunc i32 %603 to i8
    %608 = icmp slt i8 %607, 0
    br i1 %608, label %609, label %617
  
  ; <label>:609                                     ; preds = %606
    %610 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext -3, i32 signext 1) #6
    br label %617
  
  ; <label>:611                                     ; preds = %600
    %612 = and i32 %602, 16711680
    %613 = icmp eq i32 %612, 65536
    br i1 %613, label %read_trust.exit.i, label %617
  
  read_trust.exit.i:                                ; preds = %611
    %614 = bitcast [3 x i8]* %2 to i8*
    %615 = lshr i32 %602, 8
    %616 = trunc i32 %615 to i8
    call void @llvm.lifetime.end(i64 3, i8* nonnull %614) #6
    %.pre.i19 = load i8, i8* %3, align 4, !tbaa !6
    br label %.loopexit.i20
  
  ; <label>:617                                     ; preds = %611, %609, %606, %595
    %618 = bitcast [3 x i8]* %2 to i8*
    call void @llvm.lifetime.end(i64 3, i8* %618) #6
    %619 = load i8, i8* %3, align 4, !tbaa !6
    %620 = and i8 %619, 124
    %621 = icmp eq i8 %620, 8
    br i1 %621, label %.outer13.i, label %.thread.i
  
  .thread.i:                                        ; preds = %617
    %622 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    br label %maint_final.exit
  
  .loopexit.i20:                                    ; preds = %593, %read_trust.exit.i
    %623 = phi i8 [ %.pre.i19, %read_trust.exit.i ], [ %586, %593 ]
    %kc_orig.2.i = phi i8 [ %616, %read_trust.exit.i ], [ %kc_orig.0.ph.i, %593 ]
    %trust_pos.1.i = phi i32 [ %597, %read_trust.exit.i ], [ %trust_pos.0.ph14.i, %593 ]
    %624 = zext i8 %623 to i32
    %625 = lshr i32 %624, 2
    %626 = and i32 %625, 31
    switch i32 %626, label %700 [
      i32 6, label %627
      i32 13, label %646
      i32 2, label %684
    ]
  
  ; <label>:627                                     ; preds = %.loopexit.i20
    %628 = icmp eq %struct.pubkey* %pk.0.ph.i13, null
    br i1 %628, label %634, label %629
  
  ; <label>:629                                     ; preds = %627
    %630 = bitcast [8 x i8]* %keyID.i.i to i8*
    %631 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 4, i32 0
    %632 = call i32 @memcmp(i8* %631, i8* %630, i32 signext 8) #7
    %633 = icmp eq i32 %632, 0
    br i1 %633, label %635, label %634
  
  ; <label>:634                                     ; preds = %629, %627
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.64, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 715, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:635                                     ; preds = %629
    %636 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %637 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond3.i21 = or i1 %637, %636
    br i1 %or.cond3.i21, label %638, label %639
  
  ; <label>:638                                     ; preds = %635
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 716, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:639                                     ; preds = %635
    %640 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 2
    %641 = load %struct.userid*, %struct.userid** %640, align 4, !tbaa !14
    %642 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk.0.ph.i13, i32 0, i32 5
    %643 = load i8, i8* %642, align 4, !tbaa !16
    %644 = bitcast %struct.pubkey* %pk.0.ph.i13 to %struct.pubkey**
    %645 = load %struct.pubkey*, %struct.pubkey** %644, align 4, !tbaa !18
    br label %700
  
  ; <label>:646                                     ; preds = %.loopexit.i20
    %647 = icmp eq %struct.userid* %id.0.ph.i14, null
    %648 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond5.i = or i1 %647, %648
    br i1 %or.cond5.i, label %649, label %650
  
  ; <label>:649                                     ; preds = %646
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 727, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:650                                     ; preds = %646
    %651 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 2
    %652 = load %struct.signature*, %struct.signature** %651, align 4, !tbaa !24
    %653 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 1
    %654 = load %struct.pubkey*, %struct.pubkey** %653, align 4, !tbaa !22
    %655 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %654, i32 0, i32 5
    %656 = load i8, i8* %655, align 4, !tbaa !16
    %657 = icmp slt i8 %656, 0
    br i1 %657, label %compute_legit.exit.i, label %658
  
  ; <label>:658                                     ; preds = %650
    %659 = icmp eq %struct.signature* %652, null
    br i1 %659, label %compute_legit.exit.i, label %.lr.ph.i.i22
  
  .lr.ph.i.i22:                                     ; preds = %658, %.lr.ph.i.i22
    %s.03.i.i = phi %struct.signature* [ %s.0.i.i, %.lr.ph.i.i22 ], [ %652, %658 ]
    %trust_count.02.i.i = phi i32 [ %666, %.lr.ph.i.i22 ], [ 0, %658 ]
    %660 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i.i, i32 0, i32 4
    %661 = load i8, i8* %660, align 4, !tbaa !31
    %662 = zext i8 %661 to i32
    %663 = and i32 %662, 7
    %664 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %663
    %665 = load i32, i32* %664, align 4, !tbaa !7
    %666 = add nsw i32 %665, %trust_count.02.i.i
    %667 = bitcast %struct.signature* %s.03.i.i to %struct.signature**
    %s.0.i.i = load %struct.signature*, %struct.signature** %667, align 4, !tbaa !9
    %668 = icmp eq %struct.signature* %s.0.i.i, null
    br i1 %668, label %._crit_edge.i.i23, label %.lr.ph.i.i22
  
  ._crit_edge.i.i23:                                ; preds = %.lr.ph.i.i22
    %669 = icmp eq i32 %666, 0
    br i1 %669, label %compute_legit.exit.i, label %670
  
  ; <label>:670                                     ; preds = %._crit_edge.i.i23
    %671 = load i32, i32* @marginal_min, align 4, !tbaa !7
    %672 = icmp slt i32 %666, %671
    br i1 %672, label %compute_legit.exit.i, label %673
  
  ; <label>:673                                     ; preds = %670
    %674 = load i32, i32* @complete_min, align 4, !tbaa !7
    %675 = icmp slt i32 %666, %674
    %..i.i = select i1 %675, i32 2, i32 3
    br label %compute_legit.exit.i
  
  compute_legit.exit.i:                             ; preds = %673, %670, %._crit_edge.i.i23, %658, %650
    %legit.0.i.i = phi i32 [ 3, %650 ], [ 0, %._crit_edge.i.i23 ], [ 1, %670 ], [ %..i.i, %673 ], [ 0, %658 ]
    %676 = getelementptr inbounds %struct.userid, %struct.userid* %id.0.ph.i14, i32 0, i32 4
    %677 = load i8, i8* %676, align 4, !tbaa !23
    %678 = zext i8 %677 to i32
    %679 = and i32 %678, 252
    %680 = or i32 %679, %legit.0.i.i
    %681 = trunc i32 %680 to i8
    store i8 %681, i8* %676, align 4, !tbaa !23
    %682 = bitcast %struct.userid* %id.0.ph.i14 to %struct.userid**
    %683 = load %struct.userid*, %struct.userid** %682, align 4, !tbaa !19
    br label %700
  
  ; <label>:684                                     ; preds = %.loopexit.i20
    %685 = icmp eq %struct.signature* %sig.0.ph.i15, null
    br i1 %685, label %686, label %687
  
  ; <label>:686                                     ; preds = %684
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.67, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 741, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:687                                     ; preds = %684
    %688 = bitcast [8 x i8]* %1 to i8*
    %689 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 2
    %690 = load %struct.pubkey*, %struct.pubkey** %689, align 4, !tbaa !28
    %691 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %690, i32 0, i32 4, i32 0
    %692 = call i32 @memcmp(i8* %691, i8* %688, i32 signext 8) #7
    %693 = icmp eq i32 %692, 0
    br i1 %693, label %695, label %694
  
  ; <label>:694                                     ; preds = %687
    call void @__assert_fail(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.68, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 742, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.maint_final, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:695                                     ; preds = %687
    %696 = getelementptr inbounds %struct.signature, %struct.signature* %sig.0.ph.i15, i32 0, i32 4
    %697 = load i8, i8* %696, align 4, !tbaa !31
    %698 = bitcast %struct.signature* %sig.0.ph.i15 to %struct.signature**
    %699 = load %struct.signature*, %struct.signature** %698, align 4, !tbaa !25
    br label %700
  
  ; <label>:700                                     ; preds = %695, %compute_legit.exit.i, %639, %.loopexit.i20
    %kc_new.1.i = phi i8 [ %697, %695 ], [ %681, %compute_legit.exit.i ], [ %643, %639 ], [ %kc_new.0.ph.i, %.loopexit.i20 ]
    %mask.0.i = phi i32 [ 135, %695 ], [ 3, %compute_legit.exit.i ], [ 135, %639 ], [ 0, %.loopexit.i20 ]
    %pk.1.i = phi %struct.pubkey* [ %pk.0.ph.i13, %695 ], [ %pk.0.ph.i13, %compute_legit.exit.i ], [ %645, %639 ], [ %pk.0.ph.i13, %.loopexit.i20 ]
    %id.1.i = phi %struct.userid* [ %id.0.ph.i14, %695 ], [ %683, %compute_legit.exit.i ], [ %641, %639 ], [ %id.0.ph.i14, %.loopexit.i20 ]
    %sig.1.i = phi %struct.signature* [ %699, %695 ], [ %652, %compute_legit.exit.i ], [ null, %639 ], [ %sig.0.ph.i15, %.loopexit.i20 ]
    %701 = xor i8 %kc_new.1.i, %kc_orig.2.i
    %702 = zext i8 %701 to i32
    %703 = and i32 %702, %mask.0.i
    %704 = icmp eq i32 %703, 0
    br i1 %704, label %.outer.i16, label %705
  
  ; <label>:705                                     ; preds = %700
    %.b.i = load i1, i1* @check_only, align 1
    br i1 %.b.i, label %710, label %706
  
  ; <label>:706                                     ; preds = %705
    %707 = call i32 @ftell(%struct._IO_FILE* nonnull %f.0.i) #6
    %708 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %trust_pos.1.i, i32 signext 0) #6
    call void @write_trust(%struct._IO_FILE* nonnull %f.0.i, i8 zeroext %kc_new.1.i) #6
    %709 = call i32 @fseek(%struct._IO_FILE* nonnull %f.0.i, i32 signext %707, i32 signext 0) #6
    br label %710
  
  ; <label>:710                                     ; preds = %706, %705
    %711 = add nuw nsw i32 %changed.0.ph.ph.i, 1
    br label %.outer.outer.i
  
  ; <label>:712                                     ; preds = %578
    %713 = call i32 @fclose(%struct._IO_FILE* nonnull %f.0.i) #6
    %714 = icmp slt i32 %582, -1
    br i1 %714, label %maint_final.exit, label %715
  
  ; <label>:715                                     ; preds = %712
    %716 = icmp ne %struct.pubkey* %pk.0.ph.i13, null
    %717 = icmp ne %struct.signature* %sig.0.ph.i15, null
    %or.cond7.i = or i1 %716, %717
    %718 = icmp ne %struct.userid* %id.0.ph.i14, null
    %or.cond9.i = or i1 %718, %or.cond7.i
    br i1 %or.cond9.i, label %719, label %maint_final.exit
  
  ; <label>:719                                     ; preds = %715
    %720 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %721 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.69, i32 0, i32 0), i32 28, i32 1, %struct._IO_FILE* %720) #6
    br label %maint_final.exit
  
  maint_final.exit:                                 ; preds = %719, %715, %712, %.thread.i, %572
    %.0.i24 = phi i32 [ -1, %572 ], [ -1, %719 ], [ %582, %712 ], [ %changed.0.ph.ph.i, %715 ], [ -7, %.thread.i ]
    %722 = bitcast [8 x i8]* %1 to i8*
    %723 = bitcast [8 x i8]* %keyID.i.i to i8*
    %724 = bitcast [256 x i8]* %userid.i.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %3) #6
    call void @llvm.lifetime.end(i64 8, i8* %722) #6
    call void @llvm.lifetime.end(i64 8, i8* %723) #6
    call void @llvm.lifetime.end(i64 256, i8* %724) #6
    %725 = icmp slt i32 %.0.i24, 0
    br i1 %725, label %759, label %726
  
  ; <label>:726                                     ; preds = %maint_final.exit
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %727 = load i8, i8* @verbose, align 1, !tbaa !6
    %728 = icmp eq i8 %727, 0
    br i1 %728, label %734, label %729
  
  ; <label>:729                                     ; preds = %726
    %730 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %731 = load i32, i32* @totalsize, align 4, !tbaa !10
    %732 = sdiv i32 %731, 1024
    %733 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %730, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %732) #6
    br label %734
  
  ; <label>:734                                     ; preds = %729, %726
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %735 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %736 = icmp eq %struct.bufpool* %735, null
    br i1 %736, label %endkrent.exit, label %.lr.ph.i.i25
  
  .lr.ph.i.i25:                                     ; preds = %734, %.lr.ph.i.i25
    %737 = phi %struct.bufpool* [ %741, %.lr.ph.i.i25 ], [ %735, %734 ]
    %738 = bitcast %struct.bufpool* %737 to i32*
    %739 = load i32, i32* %738, align 4, !tbaa !12
    store i32 %739, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %740 = bitcast %struct.bufpool* %737 to i8*
    call void @free(i8* %740) #6
    %741 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %742 = icmp eq %struct.bufpool* %741, null
    br i1 %742, label %endkrent.exit, label %.lr.ph.i.i25
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i25, %734
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %743 = load i8, i8* @verbose, align 1, !tbaa !6
    %744 = icmp eq i8 %743, 0
    br i1 %744, label %.thread164, label %745
  
  .thread164:                                       ; preds = %endkrent.exit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit
  
  ; <label>:745                                     ; preds = %endkrent.exit
    %746 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %747 = load i32, i32* @totalsize, align 4, !tbaa !10
    %748 = sdiv i32 %747, 1024
    %749 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %746, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %748) #6
    %.pre = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %750 = icmp eq %struct.bufpool* %.pre, null
    br i1 %750, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  .lr.ph.i.i26:                                     ; preds = %745, %.lr.ph.i.i26
    %751 = phi %struct.bufpool* [ %755, %.lr.ph.i.i26 ], [ %.pre, %745 ]
    %752 = bitcast %struct.bufpool* %751 to i32*
    %753 = load i32, i32* %752, align 4, !tbaa !12
    store i32 %753, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %754 = bitcast %struct.bufpool* %751 to i8*
    call void @free(i8* %754) #6
    %755 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %756 = icmp eq %struct.bufpool* %755, null
    br i1 %756, label %maint_release_mem.exit, label %.lr.ph.i.i26
  
  maint_release_mem.exit:                           ; preds = %.lr.ph.i.i26, %745, %.thread164
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %757 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %758 = add nsw i32 %757, %.0.i24
    br label %794
  
  ; <label>:759                                     ; preds = %maint_final.exit, %513
    %status.0 = phi i32 [ %.0.i, %513 ], [ %.0.i24, %maint_final.exit ]
    %760 = load i8, i8* @verbose, align 1, !tbaa !6
    %761 = icmp eq i8 %760, 0
    br i1 %761, label %.thread, label %762
  
  .thread:                                          ; preds = %759
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    br label %771
  
  ; <label>:762                                     ; preds = %759
    %763 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %764 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %763, i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.44, i32 0, i32 0), i32 signext %status.0)
    %.pr = load i8, i8* @verbose, align 1, !tbaa !6
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %765 = icmp eq i8 %.pr, 0
    br i1 %765, label %771, label %766
  
  ; <label>:766                                     ; preds = %762
    %767 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %768 = load i32, i32* @totalsize, align 4, !tbaa !10
    %769 = sdiv i32 %768, 1024
    %770 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %767, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %769) #6
    br label %771
  
  ; <label>:771                                     ; preds = %766, %762, %.thread
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %772 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %773 = icmp eq %struct.bufpool* %772, null
    br i1 %773, label %endkrent.exit28, label %.lr.ph.i.i27
  
  .lr.ph.i.i27:                                     ; preds = %771, %.lr.ph.i.i27
    %774 = phi %struct.bufpool* [ %778, %.lr.ph.i.i27 ], [ %772, %771 ]
    %775 = bitcast %struct.bufpool* %774 to i32*
    %776 = load i32, i32* %775, align 4, !tbaa !12
    store i32 %776, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %777 = bitcast %struct.bufpool* %774 to i8*
    call void @free(i8* %777) #6
    %778 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %779 = icmp eq %struct.bufpool* %778, null
    br i1 %779, label %endkrent.exit28, label %.lr.ph.i.i27
  
  endkrent.exit28:                                  ; preds = %.lr.ph.i.i27, %771
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store %struct.pubkey** null, %struct.pubkey*** @pkhash, align 4, !tbaa !9
    %780 = load i8, i8* @verbose, align 1, !tbaa !6
    %781 = icmp eq i8 %780, 0
    br i1 %781, label %.thread165, label %782
  
  .thread165:                                       ; preds = %endkrent.exit28
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    br label %maint_release_mem.exit30
  
  ; <label>:782                                     ; preds = %endkrent.exit28
    %783 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %784 = load i32, i32* @totalsize, align 4, !tbaa !10
    %785 = sdiv i32 %784, 1024
    %786 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %783, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %785) #6
    %.pre163 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %787 = icmp eq %struct.bufpool* %.pre163, null
    br i1 %787, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  .lr.ph.i.i29:                                     ; preds = %782, %.lr.ph.i.i29
    %788 = phi %struct.bufpool* [ %792, %.lr.ph.i.i29 ], [ %.pre163, %782 ]
    %789 = bitcast %struct.bufpool* %788 to i32*
    %790 = load i32, i32* %789, align 4, !tbaa !12
    store i32 %790, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %791 = bitcast %struct.bufpool* %788 to i8*
    call void @free(i8* %791) #6
    %792 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %793 = icmp eq %struct.bufpool* %792, null
    br i1 %793, label %maint_release_mem.exit30, label %.lr.ph.i.i29
  
  maint_release_mem.exit30:                         ; preds = %.lr.ph.i.i29, %782, %.thread165
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    br label %794
  
  ; <label>:794                                     ; preds = %maint_release_mem.exit30, %maint_release_mem.exit
    %.0 = phi i32 [ %status.0, %maint_release_mem.exit30 ], [ %758, %maint_release_mem.exit ]
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @maint_check(i8* %ringfile, i32 signext %options) #0 {
    %1 = lshr i32 %options, 1
    %.lobit = and i32 %1, 1
    %2 = trunc i32 %.lobit to i8
    store i8 %2, i8* @mverbose, align 4, !tbaa !6
    %3 = load i8, i8* @moreflag, align 1, !tbaa !6
    %4 = icmp eq i8 %3, 0
    br i1 %4, label %7, label %5
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i32 @open_more() #6
    br label %7
  
  ; <label>:7                                       ; preds = %5, %0
    %8 = load i8, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), align 1, !tbaa !6
    %9 = icmp eq i8 %8, 0
    br i1 %9, label %17, label %10
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call %struct._IO_FILE* @fopen(i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0), i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    store %struct._IO_FILE* %11, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %12 = icmp eq %struct._IO_FILE* %11, null
    br i1 %12, label %13, label %17
  
  ; <label>:13                                      ; preds = %10
    %14 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %15 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1, i32 0, i32 0)) #6
    %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %14, i8* %15, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @floppyring, i32 0, i32 0))
    br label %17
  
  ; <label>:17                                      ; preds = %13, %10, %7
    store i1 true, i1* @check_only, align 1
    %18 = tail call fastcc i32 @maintenance(i8* %ringfile, %struct.newkey* null)
    %19 = load %struct._IO_FILE*, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    %20 = icmp eq %struct._IO_FILE* %19, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %17
    %22 = tail call i32 @fclose(%struct._IO_FILE* nonnull %19)
    store %struct._IO_FILE* null, %struct._IO_FILE** @floppy_fp, align 4, !tbaa !9
    br label %23
  
  ; <label>:23                                      ; preds = %21, %17
    %24 = icmp slt i32 %18, 1
    br i1 %24, label %25, label %31
  
  ; <label>:25                                      ; preds = %23
    %26 = icmp eq i32 %18, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %25
    %28 = tail call i32 @maint_list(i8* %ringfile)
    br label %29
  
  ; <label>:29                                      ; preds = %27, %25
    %30 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:31                                      ; preds = %23
    %32 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %33 = icmp eq i32 %32, 0
    br i1 %33, label %55, label %34
  
  ; <label>:34                                      ; preds = %31
    %35 = and i32 %options, 1
    %36 = icmp eq i32 %35, 0
    br i1 %36, label %.critedge, label %37
  
  ; <label>:37                                      ; preds = %34
    %38 = tail call i32 @maint_list(i8* %ringfile)
    %39 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %40 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %41 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %42 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* %40, i32 signext %41)
    %43 = tail call i32 @close_more() #6
    br label %83
  
  .critedge:                                        ; preds = %34
    %44 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %45 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2, i32 0, i32 0)) #6
    %46 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %47 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %44, i8* %45, i32 signext %46)
    %48 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %49 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3, i32 0, i32 0)) #6
    %50 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %48, i8* %49, i8* %ringfile)
    %51 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %52 = icmp eq i8 %51, 0
    br i1 %52, label %53, label %55
  
  ; <label>:53                                      ; preds = %.critedge
    %54 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:55                                      ; preds = %.critedge, %31
    %56 = tail call i8* @tempfile(i32 signext 0) #6
    %57 = tail call i32 @copyfiles_by_name(i8* %ringfile, i8* %56) #6
    %58 = icmp slt i32 %57, 0
    br i1 %58, label %59, label %61
  
  ; <label>:59                                      ; preds = %55
    %60 = tail call i32 @close_more() #6
    br label %83
  
  ; <label>:61                                      ; preds = %55
    store i8 0, i8* @mverbose, align 4, !tbaa !6
    store i1 false, i1* @check_only, align 1
    %62 = tail call fastcc i32 @maintenance(i8* %56, %struct.newkey* null)
    %63 = icmp sgt i32 %62, -1
    br i1 %63, label %64, label %69
  
  ; <label>:64                                      ; preds = %61
    %65 = tail call i32 @maint_list(i8* %56)
    %66 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %67 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0)) #6
    %68 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %66, i8* %67, i32 signext %62)
    br label %69
  
  ; <label>:69                                      ; preds = %64, %61
    %70 = tail call i32 @close_more() #6
    %71 = icmp sgt i32 %62, 0
    %72 = and i32 %options, 1
    %73 = icmp eq i32 %72, 0
    %or.cond = and i1 %73, %71
    br i1 %or.cond, label %74, label %82
  
  ; <label>:74                                      ; preds = %69
    %75 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %76 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.5, i32 0, i32 0)) #6
    %77 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %75, i8* %76, i8* %ringfile)
    %78 = tail call zeroext i8 @getyesno(i8 signext 121) #6
    %79 = icmp eq i8 %78, 0
    br i1 %79, label %82, label %80
  
  ; <label>:80                                      ; preds = %74
    %81 = tail call i32 @savetempbak(i8* %56, i8* %ringfile) #6
    br label %83
  
  ; <label>:82                                      ; preds = %74, %69
    tail call void @rmtemp(i8* %56) #6
    br label %83
  
  ; <label>:83                                      ; preds = %82, %80, %59, %53, %37, %29
    %.0 = phi i32 [ %18, %29 ], [ %18, %37 ], [ -1, %59 ], [ %62, %82 ], [ %81, %80 ], [ %18, %53 ]
    ret i32 %.0
  }
  
  declare i32 @open_more() #3
  
  ; Function Attrs: nounwind
  declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) #0
  
  ; Function Attrs: nounwind
  declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) #0
  
  declare i8* @LANG(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fclose(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i32 @maint_list(i8* %ringfile) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 4
    %keyID = alloca [8 x i8], align 1
    %sigkeyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %2) #6
    %3 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %3) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %4 = tail call %struct._IO_FILE* @fopen(i8* %ringfile, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %5 = icmp eq %struct._IO_FILE* %4, null
    br i1 %5, label %6, label %10
  
  ; <label>:6                                       ; preds = %0
    %7 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %8 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6, i32 0, i32 0)) #6
    %9 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* %8, i8* %ringfile)
    br label %158
  
  ; <label>:10                                      ; preds = %0
    tail call void @init_trust_lst()
    %11 = load i32, i32* @nkr, align 4, !tbaa !7
    %12 = icmp slt i32 %11, 8
    br i1 %12, label %14, label %13
  
  ; <label>:13                                      ; preds = %10
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:14                                      ; preds = %10
    %15 = icmp eq i8* %ringfile, null
    %.keyring.i = select i1 %15, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %ringfile
    %16 = icmp sgt i32 %11, 0
    br i1 %16, label %.lr.ph.i, label %._crit_edge.i
  
  ; <label>:17                                      ; preds = %.lr.ph.i
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %18 = bitcast i8** %scevgep to [8 x i8*]*
    %19 = icmp slt i32 %23, %11
    br i1 %19, label %.lr.ph.i, label %._crit_edge.i
  
  .lr.ph.i:                                         ; preds = %14, %17
    %lsr.iv = phi [8 x i8*]* [ %18, %17 ], [ @krnames, %14 ]
    %i.02.i = phi i32 [ %23, %17 ], [ 0, %14 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %20 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %21 = tail call i32 @strcmp(i8* %.keyring.i, i8* %20) #6
    %22 = icmp eq i32 %21, 0
    %23 = add nuw nsw i32 %i.02.i, 1
    br i1 %22, label %setkrent.exit, label %17
  
  ._crit_edge.i:                                    ; preds = %17, %14
    %24 = tail call fastcc i8* @store_str(i8* %.keyring.i) #6
    %25 = load i32, i32* @nkr, align 4, !tbaa !7
    %26 = add nsw i32 %25, 1
    store i32 %26, i32* @nkr, align 4, !tbaa !7
    %27 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %25
    store i8* %24, i8** %27, align 4, !tbaa !9
    br label %setkrent.exit
  
  setkrent.exit:                                    ; preds = %.lr.ph.i, %._crit_edge.i
    %28 = tail call i32 @init_userhash()
    %29 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %30 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7, i32 0, i32 0)) #6
    %31 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %29, i8* %30)
    br label %.outer.outer.outer
  
  .outer.outer.outer:                               ; preds = %78, %setkrent.exit
    %kc.0.ph.ph.ph = phi i8 [ %kc.2, %78 ], [ undef, %setkrent.exit ]
    %tchar.0.ph.ph.ph = phi i32 [ %83, %78 ], [ 0, %setkrent.exit ]
    %owntrust.0.ph.ph.ph = phi i32 [ %84, %78 ], [ 0, %setkrent.exit ]
    %32 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %owntrust.0.ph.ph.ph, i32 0
    br label %.outer.outer
  
  .outer.outer:                                     ; preds = %114, %.outer.outer.outer
    %kc.0.ph.ph = phi i8 [ %kc.0.ph.ph.ph, %.outer.outer.outer ], [ %kc.2, %114 ]
    %tchar.0.ph.ph = phi i32 [ %tchar.0.ph.ph.ph, %.outer.outer.outer ], [ 35, %114 ]
    %33 = and i32 %tchar.0.ph.ph, 255
    br label %.outer.outer5
  
  .outer.outer5:                                    ; preds = %109, %.outer.outer
    %kc.0.ph.ph6 = phi i8 [ %kc.0.ph.ph, %.outer.outer ], [ %kc.2, %109 ]
    %usercount.0.ph.ph = phi i32 [ 0, %.outer.outer ], [ %111, %109 ]
    br label %.outer
  
  .outer:                                           ; preds = %73, %134, %138, %.outer.outer5
    %kc.0.ph = phi i8 [ %kc.0.ph.ph6, %.outer.outer5 ], [ %kc.2, %138 ], [ %kc.2, %134 ], [ %kc.2, %73 ]
    br label %34
  
  ; <label>:34                                      ; preds = %39, %.outer
    %35 = bitcast [8 x i8]* %sigkeyID to i8*
    %36 = bitcast [8 x i8]* %keyID to i8*
    %37 = bitcast [256 x i8]* %userid to i8*
    %38 = call i32 @readkpacket(%struct._IO_FILE* nonnull %4, i8* nonnull %ctb, i8* %37, i8* %36, i8* %35)
    %switch = icmp ugt i32 %38, -4
    br i1 %switch, label %.loopexit, label %39
  
  ; <label>:39                                      ; preds = %34
    %40 = icmp slt i32 %38, 0
    br i1 %40, label %34, label %41
  
  ; <label>:41                                      ; preds = %39
    %42 = load i8, i8* %ctb, align 4, !tbaa !6
    %43 = zext i8 %42 to i32
    %44 = and i32 %43, 124
    switch i32 %44, label %45 [
      i32 24, label %47
      i32 8, label %47
    ]
  
  ; <label>:45                                      ; preds = %41
    %46 = icmp eq i8 %42, -76
    br i1 %46, label %47, label %73
  
  ; <label>:47                                      ; preds = %45, %41, %41
    %48 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %48) #6
    %49 = call i32 @fread(i8* %48, i32 signext 1, i32 signext 3, %struct._IO_FILE* nonnull %4) #6
    %50 = icmp eq i32 %49, 3
    br i1 %50, label %51, label %68
  
  ; <label>:51                                      ; preds = %47
    %52 = bitcast [3 x i8]* %buf.i to i32*
    %53 = load i32, i32* %52, align 4
    %54 = lshr i32 %53, 24
    %55 = trunc i32 %54 to i8
    %56 = icmp eq i8 %55, -80
    %57 = lshr i32 %53, 8
    br i1 %56, label %63, label %58
  
  ; <label>:58                                      ; preds = %51
    %59 = trunc i32 %54 to i8
    %60 = icmp slt i8 %59, 0
    br i1 %60, label %61, label %68
  
  ; <label>:61                                      ; preds = %58
    %62 = call i32 @fseek(%struct._IO_FILE* nonnull %4, i32 signext -3, i32 signext 1) #6
    br label %68
  
  ; <label>:63                                      ; preds = %51
    %64 = and i32 %53, 16711680
    %65 = icmp eq i32 %64, 65536
    br i1 %65, label %read_trust.exit, label %68
  
  read_trust.exit:                                  ; preds = %63
    %66 = trunc i32 %57 to i8
    %67 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* nonnull %67) #6
    %.pre = load i8, i8* %ctb, align 4, !tbaa !6
    br label %73
  
  ; <label>:68                                      ; preds = %63, %61, %58, %47
    %69 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %69) #6
    %70 = load i8, i8* %ctb, align 4, !tbaa !6
    %71 = and i8 %70, 124
    %72 = icmp eq i8 %71, 8
    br i1 %72, label %73, label %.loopexit
  
  ; <label>:73                                      ; preds = %68, %read_trust.exit, %45
    %74 = phi i8 [ %70, %68 ], [ %.pre, %read_trust.exit ], [ %42, %45 ]
    %kc.2 = phi i8 [ %kc.0.ph, %68 ], [ %66, %read_trust.exit ], [ %kc.0.ph, %45 ]
    %75 = zext i8 %74 to i32
    %76 = lshr i32 %75, 2
    %77 = and i32 %76, 31
    switch i32 %77, label %.outer [
      i32 6, label %78
      i32 13, label %85
      i32 2, label %114
    ]
  
  ; <label>:78                                      ; preds = %73
    %79 = bitcast [256 x i8]* %userid to i8*
    %80 = zext i8 %kc.2 to i32
    %81 = and i32 %80, 128
    %82 = icmp ne i32 %81, 0
    %83 = select i1 %82, i32 42, i32 32
    %84 = and i32 %80, 7
    store i8 0, i8* %79, align 4, !tbaa !6
    br label %.outer.outer.outer
  
  ; <label>:85                                      ; preds = %73
    %86 = icmp ne i32 %usercount.0.ph.ph, 0
    %87 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %86, label %95, label %88
  
  ; <label>:88                                      ; preds = %85
    %89 = bitcast [8 x i8]* %keyID to i8*
    %90 = call i8* @keyIDstring(i8* %89) #6
    %91 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %33, i8* %90)
    %92 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %93 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %94 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %92, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %93, i8* %32)
    br label %98
  
  ; <label>:95                                      ; preds = %85
    %96 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %97 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %87, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0), i32 signext %96, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    br label %98
  
  ; <label>:98                                      ; preds = %95, %88
    %99 = icmp ne i32 %usercount.0.ph.ph, 0
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %102 = zext i8 %kc.2 to i32
    %103 = and i32 %102, 3
    %104 = getelementptr inbounds [4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 %103, i32 0
    %105 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %101, i8* %104)
    br i1 %99, label %106, label %109
  
  ; <label>:106                                     ; preds = %98
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i32 @_IO_putc(i32 signext 32, %struct._IO_FILE* %107)
    br label %109
  
  ; <label>:109                                     ; preds = %106, %98
    %110 = bitcast [256 x i8]* %userid to i8*
    %111 = add nuw nsw i32 %usercount.0.ph.ph, 1
    %112 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %112, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %110)
    br label %.outer.outer5
  
  ; <label>:114                                     ; preds = %73
    %115 = icmp eq i32 %usercount.0.ph.ph, 0
    br i1 %115, label %.outer.outer, label %116
  
  ; <label>:116                                     ; preds = %114
    %117 = bitcast [8 x i8]* %sigkeyID to i8*
    %118 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %119 = icmp slt i8 %kc.2, 0
    %120 = select i1 %119, i32 99, i32 32
    %121 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %118, i8* nonnull getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8, i32 0, i32 0), i32 signext %120, i8* nonnull getelementptr inbounds ([0 x i8], [0 x i8]* @blankkeyID, i32 0, i32 0))
    %122 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %123 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %124 = zext i8 %kc.2 to i32
    %125 = and i32 %124, 7
    %126 = getelementptr inbounds [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 %125, i32 0
    %127 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %122, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i32 signext %123, i8* %126)
    %128 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %129 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %130 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %128, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), i32 signext %129, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0))
    %131 = call i8* @user_from_keyID(i8* %117)
    %132 = icmp eq i8* %131, null
    %133 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %132, label %134, label %138
  
  ; <label>:134                                     ; preds = %116
    %135 = bitcast [8 x i8]* %sigkeyID to i8*
    %136 = call i8* @keyIDstring(i8* %135) #6
    %137 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %136)
    br label %.outer
  
  ; <label>:138                                     ; preds = %116
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %133, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* nonnull %131)
    br label %.outer
  
  .loopexit:                                        ; preds = %68, %34
    %status.0 = phi i32 [ %38, %34 ], [ -7, %68 ]
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %140 = load i8, i8* @verbose, align 1, !tbaa !6
    %141 = icmp eq i8 %140, 0
    br i1 %141, label %147, label %142
  
  ; <label>:142                                     ; preds = %.loopexit
    %143 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %144 = load i32, i32* @totalsize, align 4, !tbaa !10
    %145 = sdiv i32 %144, 1024
    %146 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %143, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %145) #6
    br label %147
  
  ; <label>:147                                     ; preds = %142, %.loopexit
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %148 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %149 = icmp eq %struct.bufpool* %148, null
    br i1 %149, label %endkrent.exit, label %.lr.ph.i.i
  
  .lr.ph.i.i:                                       ; preds = %147, %.lr.ph.i.i
    %150 = phi %struct.bufpool* [ %154, %.lr.ph.i.i ], [ %148, %147 ]
    %151 = bitcast %struct.bufpool* %150 to i32*
    %152 = load i32, i32* %151, align 4, !tbaa !12
    store i32 %152, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %153 = bitcast %struct.bufpool* %150 to i8*
    call void @free(i8* %153) #6
    %154 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %155 = icmp eq %struct.bufpool* %154, null
    br i1 %155, label %endkrent.exit, label %.lr.ph.i.i
  
  endkrent.exit:                                    ; preds = %.lr.ph.i.i, %147
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    %156 = call i32 @fclose(%struct._IO_FILE* nonnull %4)
    %157 = icmp slt i32 %status.0, -1
    %status.0. = select i1 %157, i32 %status.0, i32 0
    br label %158
  
  ; <label>:158                                     ; preds = %endkrent.exit, %6
    %.0 = phi i32 [ -1, %6 ], [ %status.0., %endkrent.exit ]
    %159 = bitcast [8 x i8]* %sigkeyID to i8*
    %160 = bitcast [8 x i8]* %keyID to i8*
    %161 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %159) #6
    call void @llvm.lifetime.end(i64 8, i8* %160) #6
    call void @llvm.lifetime.end(i64 256, i8* %161) #6
    ret i32 %.0
  }
  
  declare i32 @close_more() #3
  
  declare zeroext i8 @getyesno(i8 signext) #3
  
  declare i8* @tempfile(i32 signext) #3
  
  declare i32 @copyfiles_by_name(i8*, i8*) #3
  
  declare i32 @savetempbak(i8*, i8*) #3
  
  declare void @rmtemp(i8*) #3
  
  ; Function Attrs: nounwind
  define void @init_trust_lst() #0 {
    %.b = load i1, i1* @init_trust_lst.initialized, align 1
    br i1 %.b, label %25, label %.preheader1
  
  .preheader1:                                      ; preds = %0, %13
    %lsr.iv = phi i32 [ %lsr.iv.next, %13 ], [ 0, %0 ]
    %scevgep = getelementptr [8 x [16 x i8]], [8 x [16 x i8]]* @trust_lst, i32 0, i32 0, i32 %lsr.iv
    %1 = load i8, i8* %scevgep, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %13, label %3
  
  ; <label>:3                                       ; preds = %.preheader1
    %4 = tail call i8* @LANG(i8* %scevgep) #6
    %5 = icmp eq i8* %scevgep, %4
    br i1 %5, label %8, label %6
  
  ; <label>:6                                       ; preds = %3
    %7 = tail call i8* @strncpy(i8* %scevgep, i8* %4, i32 signext 15) #6
    br label %8
  
  ; <label>:8                                       ; preds = %6, %3
    %9 = tail call i32 @strlen(i8* %4) #7
    %10 = load i32, i32* @trustlst_len, align 4, !tbaa !7
    %11 = icmp sgt i32 %9, %10
    br i1 %11, label %12, label %13
  
  ; <label>:12                                      ; preds = %8
    store i32 %9, i32* @trustlst_len, align 4, !tbaa !7
    br label %13
  
  ; <label>:13                                      ; preds = %12, %8, %.preheader1
    %lsr.iv.next = add nuw nsw i32 %lsr.iv, 16
    %exitcond4 = icmp eq i32 %lsr.iv.next, 128
    br i1 %exitcond4, label %.preheader.preheader, label %.preheader1
  
  .preheader.preheader:                             ; preds = %13
    %14 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)) #6
    %15 = icmp eq i8* %14, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0)
    br i1 %15, label %18, label %16
  
  ; <label>:16                                      ; preds = %.preheader.preheader
    %17 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 0, i32 0), i8* %14, i32 signext 15) #6
    br label %18
  
  ; <label>:18                                      ; preds = %16, %.preheader.preheader
    %19 = tail call i32 @strlen(i8* %14) #7
    %20 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %21 = icmp sgt i32 %19, %20
    br i1 %21, label %22, label %.preheader.15
  
  ; <label>:22                                      ; preds = %18
    store i32 %19, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.15
  
  .preheader.15:                                    ; preds = %22, %18
    %23 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)) #6
    %24 = icmp eq i8* %23, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0)
    br i1 %24, label %28, label %26
  
  ; <label>:25                                      ; preds = %51, %0
    ret void
  
  ; <label>:26                                      ; preds = %.preheader.15
    %27 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 1, i32 0), i8* %23, i32 signext 15) #6
    br label %28
  
  ; <label>:28                                      ; preds = %26, %.preheader.15
    %29 = tail call i32 @strlen(i8* %23) #7
    %30 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %31 = icmp sgt i32 %29, %30
    br i1 %31, label %32, label %.preheader.26
  
  ; <label>:32                                      ; preds = %28
    store i32 %29, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.26
  
  .preheader.26:                                    ; preds = %32, %28
    %33 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)) #6
    %34 = icmp eq i8* %33, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0)
    br i1 %34, label %37, label %35
  
  ; <label>:35                                      ; preds = %.preheader.26
    %36 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 2, i32 0), i8* %33, i32 signext 15) #6
    br label %37
  
  ; <label>:37                                      ; preds = %35, %.preheader.26
    %38 = tail call i32 @strlen(i8* %33) #7
    %39 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %40 = icmp sgt i32 %38, %39
    br i1 %40, label %41, label %.preheader.37
  
  ; <label>:41                                      ; preds = %37
    store i32 %38, i32* @legitlst_len, align 4, !tbaa !7
    br label %.preheader.37
  
  .preheader.37:                                    ; preds = %41, %37
    %42 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)) #6
    %43 = icmp eq i8* %42, getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0)
    br i1 %43, label %46, label %44
  
  ; <label>:44                                      ; preds = %.preheader.37
    %45 = tail call i8* @strncpy(i8* nonnull getelementptr inbounds ([4 x [16 x i8]], [4 x [16 x i8]]* @legit_lst, i32 0, i32 3, i32 0), i8* %42, i32 signext 15) #6
    br label %46
  
  ; <label>:46                                      ; preds = %44, %.preheader.37
    %47 = tail call i32 @strlen(i8* %42) #7
    %48 = load i32, i32* @legitlst_len, align 4, !tbaa !7
    %49 = icmp sgt i32 %47, %48
    br i1 %49, label %50, label %51
  
  ; <label>:50                                      ; preds = %46
    store i32 %47, i32* @legitlst_len, align 4, !tbaa !7
    br label %51
  
  ; <label>:51                                      ; preds = %50, %46
    store i1 true, i1* @init_trust_lst.initialized, align 1
    br label %25
  }
  
  ; Function Attrs: nounwind
  define i32 @setkrent(i8* readonly %keyring) #0 {
    %1 = load i32, i32* @nkr, align 4, !tbaa !7
    %2 = icmp slt i32 %1, 8
    br i1 %2, label %4, label %3
  
  ; <label>:3                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 1447, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.setkrent, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:4                                       ; preds = %0
    %5 = icmp eq i8* %keyring, null
    %.keyring = select i1 %5, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @globalPubringName, i32 0, i32 0), i8* %keyring
    %6 = icmp sgt i32 %1, 0
    br i1 %6, label %.lr.ph, label %._crit_edge
  
  ; <label>:7                                       ; preds = %.lr.ph
    %scevgep = getelementptr [8 x i8*], [8 x i8*]* %lsr.iv, i32 0, i32 1
    %8 = bitcast i8** %scevgep to [8 x i8*]*
    %9 = icmp slt i32 %13, %1
    br i1 %9, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %4, %7
    %lsr.iv = phi [8 x i8*]* [ %8, %7 ], [ @krnames, %4 ]
    %i.02 = phi i32 [ %13, %7 ], [ 0, %4 ]
    %lsr.iv1 = bitcast [8 x i8*]* %lsr.iv to i8**
    %10 = load i8*, i8** %lsr.iv1, align 4, !tbaa !9
    %11 = tail call i32 @strcmp(i8* %.keyring, i8* %10) #6
    %12 = icmp eq i32 %11, 0
    %13 = add nuw nsw i32 %i.02, 1
    br i1 %12, label %.loopexit, label %7
  
  ._crit_edge:                                      ; preds = %7, %4
    %14 = tail call fastcc i8* @store_str(i8* %.keyring)
    %15 = load i32, i32* @nkr, align 4, !tbaa !7
    %16 = add nsw i32 %15, 1
    store i32 %16, i32* @nkr, align 4, !tbaa !7
    %17 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %15
    store i8* %14, i8** %17, align 4, !tbaa !9
    br label %.loopexit
  
  .loopexit:                                        ; preds = %.lr.ph, %._crit_edge
    ret i32 0
  }
  
  ; Function Attrs: nounwind
  define i32 @readkpacket(%struct._IO_FILE* %f, i8* %ctb, i8* %userid, i8* %keyID, i8* %sigkeyID) #0 {
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %1 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %n to i16*
    %4 = bitcast [128 x i16]* %e to i16*
    %5 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* %ctb, i8* null, i8* %userid, i16* %3, i16* %4, i16* null, i16* null, i16* null, i16* null, i8* %sigkeyID, i8* null) #6
    %6 = icmp slt i16 %5, 0
    br i1 %6, label %7, label %9
  
  ; <label>:7                                       ; preds = %0
    %8 = sext i16 %5 to i32
    br label %23
  
  ; <label>:9                                       ; preds = %0
    %10 = icmp eq i8* %keyID, null
    br i1 %10, label %17, label %11
  
  ; <label>:11                                      ; preds = %9
    %12 = load i8, i8* %ctb, align 1, !tbaa !6
    %13 = call i32 @is_key_ctb(i8 zeroext %12) #6
    %14 = icmp eq i32 %13, 0
    br i1 %14, label %17, label %15
  
  ; <label>:15                                      ; preds = %11
    %16 = bitcast [128 x i16]* %n to i16*
    call void @extract_keyID(i8* nonnull %keyID, i16* %16) #6
    br label %17
  
  ; <label>:17                                      ; preds = %15, %11, %9
    %18 = icmp eq i8* %userid, null
    br i1 %18, label %23, label %19
  
  ; <label>:19                                      ; preds = %17
    %20 = load i8, i8* %ctb, align 1, !tbaa !6
    %21 = icmp eq i8 %20, -76
    br i1 %21, label %22, label %23
  
  ; <label>:22                                      ; preds = %19
    call void @PascalToC(i8* nonnull %userid) #6
    br label %23
  
  ; <label>:23                                      ; preds = %22, %19, %17, %7
    %.0 = phi i32 [ %8, %7 ], [ 0, %17 ], [ 0, %22 ], [ 0, %19 ]
    %24 = bitcast [128 x i16]* %e to i8*
    %25 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.end(i64 256, i8* %24) #6
    call void @llvm.lifetime.end(i64 256, i8* %25) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  define i32 @read_trust(%struct._IO_FILE* nocapture %f, i8* %keyctrl) #0 {
    %buf = alloca [3 x i8], align 4
    %1 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 3, i8* %1) #6
    %2 = call i32 @fread(i8* %1, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f)
    %3 = icmp eq i32 %2, 3
    br i1 %3, label %4, label %23
  
  ; <label>:4                                       ; preds = %0
    %5 = bitcast [3 x i8]* %buf to i32*
    %6 = load i32, i32* %5, align 4
    %7 = lshr i32 %6, 24
    %8 = trunc i32 %7 to i8
    %9 = icmp eq i8 %8, -80
    %10 = lshr i32 %6, 8
    br i1 %9, label %16, label %11
  
  ; <label>:11                                      ; preds = %4
    %12 = trunc i32 %7 to i8
    %13 = icmp slt i8 %12, 0
    br i1 %13, label %14, label %23
  
  ; <label>:14                                      ; preds = %11
    %15 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1)
    br label %23
  
  ; <label>:16                                      ; preds = %4
    %17 = and i32 %6, 16711680
    %18 = icmp eq i32 %17, 65536
    br i1 %18, label %19, label %23
  
  ; <label>:19                                      ; preds = %16
    %20 = icmp eq i8* %keyctrl, null
    br i1 %20, label %23, label %21
  
  ; <label>:21                                      ; preds = %19
    %22 = trunc i32 %10 to i8
    store i8 %22, i8* %keyctrl, align 1, !tbaa !6
    br label %23
  
  ; <label>:23                                      ; preds = %21, %19, %16, %14, %11, %0
    %.0 = phi i32 [ -7, %14 ], [ -1, %0 ], [ -3, %11 ], [ -3, %16 ], [ 0, %19 ], [ 0, %21 ]
    %24 = bitcast [3 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 3, i8* %24) #6
    ret i32 %.0
  }
  
  declare i8* @keyIDstring(i8*) #3
  
  ; Function Attrs: nounwind
  declare i32 @_IO_putc(i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define i8* @user_from_keyID(i8* nocapture readonly %keyID) #0 {
    %keyID.i = alloca [8 x i8], align 1
    %ctb.i = alloca i8, align 4
    %1 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %2 = icmp eq %struct.hashent** %1, null
    br i1 %2, label %3, label %34
  
  ; <label>:3                                       ; preds = %0
    %4 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb.i) #6
    %5 = load i32, i32* @nkr, align 4
    %6 = icmp sgt i32 %5, 0
    br i1 %6, label %.lr.ph.i, label %_user_from_keyID.exit
  
  .lr.ph.i:                                         ; preds = %3, %27
    %found.08.i = phi i32 [ %found.4.i, %27 ], [ 0, %3 ]
    %i.07.i = phi i32 [ %28, %27 ], [ 0, %3 ]
    %7 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.07.i
    %8 = load i8*, i8** %7, align 4, !tbaa !9
    %9 = call %struct._IO_FILE* @fopen(i8* %8, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0)) #6
    %10 = icmp eq %struct._IO_FILE* %9, null
    br i1 %10, label %27, label %.preheader.i
  
  .preheader.i:                                     ; preds = %.lr.ph.i, %21
    %found.1.i = phi i32 [ %found.2.i, %21 ], [ %found.08.i, %.lr.ph.i ]
    %11 = bitcast [8 x i8]* %keyID.i to i8*
    %12 = call i32 @readkpacket(%struct._IO_FILE* nonnull %9, i8* nonnull %ctb.i, i8* nonnull getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* %11, i8* null) #6
    %switch.i = icmp ugt i32 %12, -4
    br i1 %switch.i, label %25, label %13
  
  ; <label>:13                                      ; preds = %.preheader.i
    %14 = load i8, i8* %ctb.i, align 4, !tbaa !6
    %15 = call i32 @is_key_ctb(i8 zeroext %14) #6
    %16 = icmp eq i32 %15, 0
    br i1 %16, label %21, label %17
  
  ; <label>:17                                      ; preds = %13
    %18 = bitcast [8 x i8]* %keyID.i to i8*
    %19 = call i32 @memcmp(i8* %18, i8* %keyID, i32 signext 8) #7
    %20 = icmp eq i32 %19, 0
    %.found.1.i = select i1 %20, i32 1, i32 %found.1.i
    br label %21
  
  ; <label>:21                                      ; preds = %17, %13
    %found.2.i = phi i32 [ %found.1.i, %13 ], [ %.found.1.i, %17 ]
    %22 = icmp ne i32 %found.2.i, 0
    %23 = load i8, i8* %ctb.i, align 4
    %24 = icmp eq i8 %23, -76
    %or.cond6.i = and i1 %22, %24
    br i1 %or.cond6.i, label %25, label %.preheader.i
  
  ; <label>:25                                      ; preds = %21, %.preheader.i
    %found.3.i = phi i32 [ %found.2.i, %21 ], [ %found.1.i, %.preheader.i ]
    %26 = call i32 @fclose(%struct._IO_FILE* nonnull %9) #6
    br label %27
  
  ; <label>:27                                      ; preds = %25, %.lr.ph.i
    %found.4.i = phi i32 [ %found.08.i, %.lr.ph.i ], [ %found.3.i, %25 ]
    %28 = add nuw nsw i32 %i.07.i, 1
    %29 = icmp ne i32 %found.4.i, 0
    %.not.i = xor i1 %29, true
    %30 = load i32, i32* @nkr, align 4
    %31 = icmp slt i32 %28, %30
    %or.cond.i = and i1 %31, %.not.i
    br i1 %or.cond.i, label %.lr.ph.i, label %.critedge.loopexit.i
  
  .critedge.loopexit.i:                             ; preds = %27
    %32 = icmp ne i32 %found.4.i, 0
    %phitmp.i = select i1 %32, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @_user_from_keyID.userid, i32 0, i32 0), i8* null
    br label %_user_from_keyID.exit
  
  _user_from_keyID.exit:                            ; preds = %.critedge.loopexit.i, %3
    %.lcssa.i = phi i8* [ null, %3 ], [ %phitmp.i, %.critedge.loopexit.i ]
    %33 = bitcast [8 x i8]* %keyID.i to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb.i) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    br label %.loopexit
  
  ; <label>:34                                      ; preds = %0
    %35 = load i8, i8* %keyID, align 1, !tbaa !6
    %36 = zext i8 %35 to i32
    %37 = getelementptr inbounds %struct.hashent*, %struct.hashent** %1, i32 %36
    %p.02 = load %struct.hashent*, %struct.hashent** %37, align 4, !tbaa !9
    %38 = icmp eq %struct.hashent* %p.02, null
    br i1 %38, label %.loopexit, label %.lr.ph
  
  .lr.ph:                                           ; preds = %34, %45
    %p.03 = phi %struct.hashent* [ %p.0, %45 ], [ %p.02, %34 ]
    %39 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 1, i32 0
    %40 = tail call i32 @memcmp(i8* %keyID, i8* %39, i32 signext 8) #7
    %41 = icmp eq i32 %40, 0
    br i1 %41, label %42, label %45
  
  ; <label>:42                                      ; preds = %.lr.ph
    %43 = getelementptr inbounds %struct.hashent, %struct.hashent* %p.03, i32 0, i32 2
    %44 = load i8*, i8** %43, align 4, !tbaa !32
    br label %.loopexit
  
  ; <label>:45                                      ; preds = %.lr.ph
    %46 = bitcast %struct.hashent* %p.03 to %struct.hashent**
    %p.0 = load %struct.hashent*, %struct.hashent** %46, align 4, !tbaa !9
    %47 = icmp eq %struct.hashent* %p.0, null
    br i1 %47, label %.loopexit, label %.lr.ph
  
  .loopexit:                                        ; preds = %45, %42, %34, %_user_from_keyID.exit
    %.0 = phi i8* [ %44, %42 ], [ %.lcssa.i, %_user_from_keyID.exit ], [ null, %34 ], [ null, %45 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  declare i8* @strncpy(i8*, i8* nocapture readonly, i32 signext) #0
  
  ; Function Attrs: nounwind readonly
  declare i32 @strlen(i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define i32 @ask_owntrust(i8* %userid, i8 zeroext %cur_trust) #0 {
    %buf = alloca [8 x i8], align 4
    %1 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %.b = load i1, i1* @check_only, align 1
    %.b.not = xor i1 %.b, true
    %2 = load i8, i8* @filter_mode, align 1
    %3 = load i8, i8* @batchmode, align 1
    %4 = or i8 %3, %2
    %5 = icmp eq i8 %4, 0
    %6 = and i1 %5, %.b.not
    br i1 %6, label %10, label %7
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @undefined_trust, align 4, !tbaa !7
    %9 = add nsw i32 %8, 1
    store i32 %9, i32* @undefined_trust, align 4, !tbaa !7
    br label %27
  
  ; <label>:10                                      ; preds = %0
    %11 = bitcast [8 x i8]* %buf to i8*
    %12 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %13 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([290 x i8], [290 x i8]* @.str.15, i32 0, i32 0)) #6
    %14 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* %13)
    %15 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %16 = tail call i8* @LANG(i8* nonnull getelementptr inbounds ([146 x i8], [146 x i8]* @.str.16, i32 0, i32 0)) #6
    %17 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* %16, i8* %userid)
    %18 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %19 = tail call i32 @fflush(%struct._IO_FILE* %18)
    %20 = call i32 @getstring(i8* %11, i32 signext 7, i32 signext 1) #6
    %21 = load i8, i8* %11, align 4, !tbaa !6
    %22 = sext i8 %21 to i32
    %switch.tableidx = add nsw i32 %22, -49
    %23 = icmp ult i32 %switch.tableidx, 4
    br i1 %23, label %switch.lookup, label %24
  
  ; <label>:24                                      ; preds = %10
    %25 = zext i8 %cur_trust to i32
    %26 = and i32 %25, 7
    br label %27
  
  switch.lookup:                                    ; preds = %10
    %switch.gep = getelementptr inbounds [4 x i32], [4 x i32]* @switch.table, i32 0, i32 %switch.tableidx
    %switch.load = load i32, i32* %switch.gep, align 4
    br label %27
  
  ; <label>:27                                      ; preds = %switch.lookup, %24, %7
    %.0 = phi i32 [ 0, %7 ], [ %26, %24 ], [ %switch.load, %switch.lookup ]
    %28 = bitcast [8 x i8]* %buf to i8*
    call void @llvm.lifetime.end(i64 8, i8* %28) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare i32 @fflush(%struct._IO_FILE* nocapture) #0
  
  declare i32 @getstring(i8*, i32 signext, i32 signext) #3
  
  ; Function Attrs: nounwind
  define i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* nocapture readonly %srch_keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %keyID = alloca [8 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    tail call void @rewind(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .thread.outer:                                    ; preds = %29, %0
    %keypos.0.ph = phi i32 [ %30, %29 ], [ 0, %0 ]
    br label %.thread
  
  .thread:                                          ; preds = %readkpacket.exit, %.thread.outer
    %2 = bitcast [128 x i16]* %e.i to i16*
    %3 = bitcast [128 x i16]* %n.i to i16*
    %4 = bitcast [128 x i16]* %e.i to i8*
    %5 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.start(i64 256, i8* %5) #6
    call void @llvm.lifetime.start(i64 256, i8* %4) #6
    %6 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* null, i16* %3, i16* %2, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %7 = icmp slt i16 %6, 0
    br i1 %7, label %readkpacket.exit, label %8
  
  ; <label>:8                                       ; preds = %.thread
    %9 = load i8, i8* %ctb, align 4, !tbaa !6
    %10 = call i32 @is_key_ctb(i8 zeroext %9) #6
    %11 = icmp eq i32 %10, 0
    br i1 %11, label %17, label %12
  
  ; <label>:12                                      ; preds = %8
    %13 = bitcast [128 x i16]* %n.i to i16*
    %14 = bitcast [8 x i8]* %keyID to i8*
    call void @extract_keyID(i8* nonnull %14, i16* %13) #6
    br label %17
  
  readkpacket.exit:                                 ; preds = %.thread
    %15 = bitcast [128 x i16]* %e.i to i8*
    %16 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %15) #6
    call void @llvm.lifetime.end(i64 256, i8* %16) #6
    %switch = icmp ugt i16 %6, -4
    br i1 %switch, label %.loopexit, label %.thread
  
  ; <label>:17                                      ; preds = %12, %8
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    %20 = load i8, i8* %ctb, align 4, !tbaa !6
    %21 = call i32 @is_key_ctb(i8 zeroext %20) #6
    %22 = icmp eq i32 %21, 0
    br i1 %22, label %29, label %23
  
  ; <label>:23                                      ; preds = %17
    %24 = bitcast [8 x i8]* %keyID to i8*
    %25 = call i32 @memcmp(i8* %24, i8* %srch_keyID, i32 signext 8) #7
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %27, label %29
  
  ; <label>:27                                      ; preds = %23
    %28 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos.0.ph, i32 signext 0)
    br label %32
  
  ; <label>:29                                      ; preds = %23, %17
    %30 = call i32 @ftell(%struct._IO_FILE* %f)
    br label %.thread.outer
  
  .loopexit:                                        ; preds = %readkpacket.exit
    %31 = sext i16 %6 to i32
    br label %32
  
  ; <label>:32                                      ; preds = %.loopexit, %27
    %.0 = phi i32 [ %keypos.0.ph, %27 ], [ %31, %.loopexit ]
    %33 = bitcast [8 x i8]* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 8, i8* %33) #6
    ret i32 %.0
  }
  
  ; Function Attrs: nounwind
  declare void @rewind(%struct._IO_FILE* nocapture) #0
  
  declare i32 @is_key_ctb(i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fseek(%struct._IO_FILE* nocapture, i32 signext, i32 signext) #0
  
  ; Function Attrs: nounwind
  declare i32 @ftell(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define void @show_userid(%struct._IO_FILE* %f, i8* %keyID) #0 {
    %n.i = alloca [128 x i16], align 2
    %e.i = alloca [128 x i16], align 2
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %2 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %3 = tail call i32 @lookup_by_keyID(%struct._IO_FILE* %f, i8* %keyID)
    %4 = icmp sgt i32 %3, -1
    br i1 %4, label %.preheader, label %.loopexit
  
  .preheader:                                       ; preds = %0
    br label %5
  
  ; <label>:5                                       ; preds = %23, %.preheader
    %6 = bitcast [128 x i16]* %e.i to i16*
    %7 = bitcast [128 x i16]* %n.i to i16*
    %8 = bitcast [128 x i16]* %e.i to i8*
    %9 = bitcast [128 x i16]* %n.i to i8*
    %10 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %9) #6
    call void @llvm.lifetime.start(i64 256, i8* %8) #6
    %11 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* null, i8* %10, i16* %7, i16* %6, i16* null, i16* null, i16* null, i16* null, i8* null, i8* null) #6
    %12 = icmp slt i16 %11, 0
    br i1 %12, label %readkpacket.exit, label %13
  
  ; <label>:13                                      ; preds = %5
    %14 = load i8, i8* %ctb, align 4, !tbaa !6
    %15 = icmp eq i8 %14, -76
    br i1 %15, label %16, label %readkpacket.exit.thread
  
  ; <label>:16                                      ; preds = %13
    %17 = bitcast [256 x i8]* %userid to i8*
    call void @PascalToC(i8* nonnull %17) #6
    br label %readkpacket.exit.thread
  
  readkpacket.exit.thread:                          ; preds = %16, %13
    %18 = bitcast [128 x i16]* %e.i to i8*
    %19 = bitcast [128 x i16]* %n.i to i8*
    call void @llvm.lifetime.end(i64 256, i8* %18) #6
    call void @llvm.lifetime.end(i64 256, i8* %19) #6
    br label %23
  
  readkpacket.exit:                                 ; preds = %5
    %20 = bitcast [128 x i16]* %e.i to i8*
    %21 = bitcast [128 x i16]* %n.i to i8*
    %22 = sext i16 %11 to i32
    call void @llvm.lifetime.end(i64 256, i8* %20) #6
    call void @llvm.lifetime.end(i64 256, i8* %21) #6
    switch i32 %22, label %23 [
      i32 -1, label %.loopexit
      i32 -3, label %.loopexit
    ]
  
  ; <label>:23                                      ; preds = %readkpacket.exit, %readkpacket.exit.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = icmp eq i8 %24, -76
    br i1 %25, label %26, label %5
  
  ; <label>:26                                      ; preds = %23
    %27 = bitcast [256 x i8]* %userid to i8*
    %28 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %29 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %28, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %27)
    %30 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  .loopexit:                                        ; preds = %readkpacket.exit, %readkpacket.exit, %0
    %31 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %32 = call i8* @keyIDstring(i8* %keyID) #6
    %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %31, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14, i32 0, i32 0), i8* %32)
    %34 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %2, i32 signext 0)
    br label %35
  
  ; <label>:35                                      ; preds = %.loopexit, %26
    %36 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %36) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @show_key(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext %what) #0 {
    %buf.i = alloca [3 x i8], align 4
    %userid = alloca [256 x i8], align 1
    %n = alloca [128 x i16], align 2
    %e = alloca [128 x i16], align 2
    %sigkeyID = alloca [8 x i8], align 1
    %timestamp = alloca i32, align 4
    %ctb = alloca i8, align 4
    %keyctrl = alloca i8, align 4
    %savekeyID = alloca [8 x i8], align 1
    %hash = alloca [16 x i8], align 1
    %1 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %1) #6
    %2 = bitcast [128 x i16]* %n to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    %3 = bitcast [128 x i16]* %e to i8*
    call void @llvm.lifetime.start(i64 256, i8* %3) #6
    %4 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %4) #6
    %5 = bitcast i32* %timestamp to i8*
    call void @llvm.lifetime.start(i64 4, i8* %5) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %keyctrl) #6
    %6 = bitcast [8 x i8]* %savekeyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %6) #6
    %7 = bitcast [16 x i8]* %hash to i8*
    call void @llvm.lifetime.start(i64 16, i8* %7) #6
    %8 = load i16, i16* @global_precision, align 2, !tbaa !34
    %9 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %10 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %keypos, i32 signext 0)
    %11 = and i32 %what, 16
    %12 = and i32 %what, 2
    %13 = and i32 %what, 1
    %14 = and i32 %what, 8
    %15 = and i32 %what, 4
    br label %.thread
  
  .thread:                                          ; preds = %37, %49, %140, %163, %read_trust.exit, %194, %205, %243, %0
    %keystatus.0 = phi i32 [ -1, %0 ], [ %22, %37 ], [ %keystatus.0, %read_trust.exit ], [ %keystatus.0, %163 ], [ %keystatus.0, %243 ], [ %keystatus.0, %205 ], [ %keystatus.0, %194 ], [ %keystatus.0, %49 ], [ %keystatus.0, %140 ]
    %keyctb.0 = phi i8 [ 0, %0 ], [ %38, %37 ], [ %keyctb.0, %read_trust.exit ], [ %keyctb.0, %163 ], [ %keyctb.0, %243 ], [ %keyctb.0, %205 ], [ %keyctb.0, %194 ], [ %keyctb.0, %49 ], [ %keyctb.0, %140 ]
    %userids.0 = phi i32 [ 0, %0 ], [ %userids.0, %37 ], [ %userids.115, %read_trust.exit ], [ %userids.1, %163 ], [ %userids.0, %243 ], [ %userids.0, %205 ], [ %userids.0, %194 ], [ %userids.0, %49 ], [ 1, %140 ]
    %keyids.0 = phi i32 [ 0, %0 ], [ 1, %37 ], [ %keyids.0, %read_trust.exit ], [ %keyids.0, %163 ], [ %keyids.0, %243 ], [ %keyids.0, %205 ], [ %keyids.0, %194 ], [ %keyids.0, %49 ], [ %keyids.0, %140 ]
    %print_trust.0 = phi i8 [ 0, %0 ], [ %print_trust.0, %37 ], [ %print_trust.0, %read_trust.exit ], [ 0, %163 ], [ %print_trust.0, %243 ], [ %print_trust.0, %205 ], [ %print_trust.0, %194 ], [ %print_trust.0., %49 ], [ 0, %140 ]
    %compromised.0 = phi i32 [ 0, %0 ], [ %compromised.0, %37 ], [ %compromised.0, %read_trust.exit ], [ %compromised.0, %163 ], [ %.compromised.0, %243 ], [ %.compromised.0, %205 ], [ %compromised.0, %194 ], [ %compromised.0, %49 ], [ %compromised.0, %140 ]
    %disabled.0 = phi i32 [ 0, %0 ], [ %disabled.0, %37 ], [ %disabled.0, %read_trust.exit ], [ %disabled.0, %163 ], [ %disabled.0, %243 ], [ %disabled.0, %205 ], [ %disabled.0, %194 ], [ %disabled.1, %49 ], [ %disabled.0, %140 ]
    %16 = bitcast [128 x i16]* %e to i16*
    %17 = bitcast [128 x i16]* %n to i16*
    %18 = bitcast i32* %timestamp to i8*
    %19 = bitcast [8 x i8]* %sigkeyID to i8*
    %20 = bitcast [256 x i8]* %userid to i8*
    %21 = call signext i16 @readkeypacket(%struct._IO_FILE* %f, %struct.IdeaCfbContext* null, i8* nonnull %ctb, i8* %18, i8* %20, i16* %17, i16* %16, i16* null, i16* null, i16* null, i16* null, i8* %19, i8* nonnull %keyctrl) #6
    %22 = sext i16 %21 to i32
    %switch = icmp ugt i16 %21, -4
    br i1 %switch, label %.loopexit, label %23
  
  ; <label>:23                                      ; preds = %.thread
    %24 = load i8, i8* %ctb, align 4, !tbaa !6
    %25 = call i32 @is_key_ctb(i8 zeroext %24) #6
    %26 = icmp eq i32 %25, 0
    br i1 %26, label %39, label %27
  
  ; <label>:27                                      ; preds = %23
    %28 = icmp eq i32 %keyids.0, 0
    br i1 %28, label %29, label %.loopexit
  
  ; <label>:29                                      ; preds = %27
    %30 = icmp eq i32 %15, 0
    %31 = bitcast [128 x i16]* %n to i16*
    %32 = bitcast [8 x i8]* %savekeyID to i8*
    call void @extract_keyID(i8* %32, i16* %31) #6
    br i1 %30, label %37, label %33
  
  ; <label>:33                                      ; preds = %29
    %34 = bitcast [128 x i16]* %e to i16*
    %35 = bitcast [128 x i16]* %n to i16*
    %36 = bitcast [16 x i8]* %hash to i8*
    call void @getKeyHash(i8* %36, i16* %35, i16* %34) #6
    br label %37
  
  ; <label>:37                                      ; preds = %33, %29
    %38 = load i8, i8* %ctb, align 4, !tbaa !6
    br label %.thread
  
  ; <label>:39                                      ; preds = %23
    %40 = load i8, i8* %ctb, align 4, !tbaa !6
    %41 = zext i8 %40 to i32
    switch i32 %41, label %194 [
      i32 176, label %42
      i32 180, label %51
    ]
  
  ; <label>:42                                      ; preds = %39
    %43 = icmp slt i32 %keystatus.0, 0
    %44 = icmp ne i32 %userids.0, 0
    %or.cond3 = or i1 %43, %44
    br i1 %or.cond3, label %49, label %45
  
  ; <label>:45                                      ; preds = %42
    %46 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %47 = and i8 %46, 32
    %48 = icmp eq i8 %47, 0
    %disabled.0. = select i1 %48, i32 %disabled.0, i32 1
    br label %49
  
  ; <label>:49                                      ; preds = %45, %42
    %disabled.1 = phi i32 [ %disabled.0, %42 ], [ %disabled.0., %45 ]
    %50 = icmp eq i32 %13, 0
    %print_trust.0. = select i1 %50, i8 %print_trust.0, i8 1
    br label %.thread
  
  ; <label>:51                                      ; preds = %39
    %52 = bitcast [256 x i8]* %userid to i8*
    %53 = icmp eq i32 %userids.0, 0
    call void @PascalToC(i8* %52) #6
    br i1 %53, label %54, label %154
  
  ; <label>:54                                      ; preds = %51
    %55 = icmp eq i32 %11, 0
    br i1 %55, label %61, label %56
  
  ; <label>:56                                      ; preds = %54
    %57 = bitcast [128 x i16]* %n to i16*
    %58 = call i8* @key2IDstring(i16* %57) #6
    %59 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %60 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %58) #6
    br label %.loopexit
  
  ; <label>:61                                      ; preds = %54
    %62 = icmp eq i32 %14, 0
    br i1 %62, label %104, label %63
  
  ; <label>:63                                      ; preds = %61
    %64 = zext i8 %keyctb.0 to i32
    %65 = and i32 %64, 124
    %66 = icmp eq i32 %65, 24
    br i1 %66, label %67, label %70
  
  ; <label>:67                                      ; preds = %63
    %68 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %69 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %68)
    br label %77
  
  ; <label>:70                                      ; preds = %63
    %71 = icmp eq i32 %65, 20
    %72 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %71, label %73, label %75
  
  ; <label>:73                                      ; preds = %70
    %74 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:75                                      ; preds = %70
    %76 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 3, i32 1, %struct._IO_FILE* %72)
    br label %77
  
  ; <label>:77                                      ; preds = %75, %73, %67
    %78 = icmp slt i32 %keystatus.0, 0
    br i1 %78, label %79, label %82
  
  ; <label>:79                                      ; preds = %77
    %80 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %81 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %80)
    br label %94
  
  ; <label>:82                                      ; preds = %77
    %83 = icmp eq i32 %compromised.0, 0
    br i1 %83, label %87, label %84
  
  ; <label>:84                                      ; preds = %82
    %85 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %86 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %85)
    br label %94
  
  ; <label>:87                                      ; preds = %82
    %88 = icmp eq i32 %disabled.0, 0
    %89 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    br i1 %88, label %92, label %90
  
  ; <label>:90                                      ; preds = %87
    %91 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.22, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:92                                      ; preds = %87
    %93 = call i32 @fwrite(i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i32 0, i32 0), i32 2, i32 1, %struct._IO_FILE* %89)
    br label %94
  
  ; <label>:94                                      ; preds = %92, %90, %84, %79
    %95 = bitcast [128 x i16]* %n to i16*
    %96 = bitcast [256 x i8]* %userid to i8*
    %97 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %98 = call i32 @countbits(i16* %95) #6
    %99 = call i8* @key2IDstring(i16* %95) #6
    %100 = call i8* @cdate(i32* nonnull %timestamp) #6
    %101 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %97, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.24, i32 0, i32 0), i32 signext %98, i8* %99, i8* %100)
    %102 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %103 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %102, i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* %96)
    br label %.loopexit
  
  ; <label>:104                                     ; preds = %61
    %105 = bitcast [128 x i16]* %n to i16*
    %106 = bitcast [256 x i8]* %userid to i8*
    %107 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %108 = call i8* @LANG(i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.25, i32 0, i32 0)) #6
    %109 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %107, i8* %108, i8* %106)
    %110 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %111 = call i8* @LANG(i8* nonnull getelementptr inbounds ([35 x i8], [35 x i8]* @.str.26, i32 0, i32 0)) #6
    %112 = call i32 @countbits(i16* %105) #6
    %113 = call i8* @key2IDstring(i16* %105) #6
    %114 = call i8* @cdate(i32* nonnull %timestamp) #6
    %115 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %110, i8* %111, i32 signext %112, i8* %113, i8* %114)
    switch i32 %keystatus.0, label %124 [
      i32 -4, label %116
      i32 -6, label %120
    ]
  
  ; <label>:116                                     ; preds = %104
    %117 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %118 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)) #6
    %119 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %117, i8* %118)
    br label %128
  
  ; <label>:120                                     ; preds = %104
    %121 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %122 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.28, i32 0, i32 0)) #6
    %123 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %121, i8* %122)
    br label %128
  
  ; <label>:124                                     ; preds = %104
    %125 = icmp eq i32 %15, 0
    br i1 %125, label %128, label %126
  
  ; <label>:126                                     ; preds = %124
    %127 = bitcast [16 x i8]* %hash to i8*
    call void @printKeyHash(i8* %127, i8 zeroext 0) #6
    br label %128
  
  ; <label>:128                                     ; preds = %126, %124, %120, %116
    %129 = icmp eq i32 %compromised.0, 0
    br i1 %129, label %134, label %130
  
  ; <label>:130                                     ; preds = %128
    %131 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %132 = call i8* @LANG(i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.29, i32 0, i32 0)) #6
    %133 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %131, i8* %132)
    br label %134
  
  ; <label>:134                                     ; preds = %130, %128
    %135 = icmp eq i32 %disabled.0, 0
    br i1 %135, label %140, label %136
  
  ; <label>:136                                     ; preds = %134
    %137 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %138 = call i8* @LANG(i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0)) #6
    %139 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %137, i8* %138)
    br label %140
  
  ; <label>:140                                     ; preds = %136, %134
    %141 = icmp eq i8 %print_trust.0, 0
    br i1 %141, label %.thread, label %142
  
  ; <label>:142                                     ; preds = %140
    %143 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %144 = zext i8 %143 to i32
    %145 = and i32 %144, 7
    %146 = getelementptr inbounds [8 x i8*], [8 x i8*]* @owntrust_msg, i32 0, i32 %145
    %147 = load i8*, i8** %146, align 4, !tbaa !9
    %148 = load i8, i8* %147, align 1, !tbaa !6
    %149 = icmp eq i8 %148, 0
    br i1 %149, label %.thread14, label %150
  
  ; <label>:150                                     ; preds = %142
    %151 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %152 = call i8* @LANG(i8* %147) #6
    %153 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %151, i8* %152)
    br label %163
  
  ; <label>:154                                     ; preds = %51
    %155 = icmp eq i32 %what, 0
    br i1 %155, label %158, label %156
  
  ; <label>:156                                     ; preds = %154
    %157 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %157)
    br label %158
  
  ; <label>:158                                     ; preds = %156, %154
    %159 = bitcast [256 x i8]* %userid to i8*
    %160 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %161 = call i8* @LANG(i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0)) #6
    %162 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %160, i8* %161, i8* %159)
    br label %163
  
  ; <label>:163                                     ; preds = %158, %150
    %userids.1 = phi i32 [ 1, %150 ], [ %userids.0, %158 ]
    %164 = icmp eq i8 %print_trust.0, 0
    br i1 %164, label %.thread, label %.thread14
  
  .thread14:                                        ; preds = %163, %142
    %userids.115 = phi i32 [ %userids.1, %163 ], [ 1, %142 ]
    %165 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %165) #6
    %166 = call i32 @fread(i8* %165, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %167 = icmp eq i32 %166, 3
    br i1 %167, label %168, label %read_trust.exit
  
  ; <label>:168                                     ; preds = %.thread14
    %169 = bitcast [3 x i8]* %buf.i to i32*
    %170 = load i32, i32* %169, align 4
    %171 = lshr i32 %170, 24
    %172 = trunc i32 %171 to i8
    %173 = icmp eq i8 %172, -80
    %174 = lshr i32 %170, 8
    br i1 %173, label %180, label %175
  
  ; <label>:175                                     ; preds = %168
    %176 = trunc i32 %171 to i8
    %177 = icmp slt i8 %176, 0
    br i1 %177, label %178, label %read_trust.exit
  
  ; <label>:178                                     ; preds = %175
    %179 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit
  
  ; <label>:180                                     ; preds = %168
    %181 = and i32 %170, 16711680
    %182 = icmp eq i32 %181, 65536
    br i1 %182, label %183, label %read_trust.exit
  
  ; <label>:183                                     ; preds = %180
    %184 = trunc i32 %174 to i8
    store i8 %184, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit
  
  read_trust.exit:                                  ; preds = %183, %180, %178, %175, %.thread14
    %185 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %185) #6
    %186 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %187 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %188 = zext i8 %187 to i32
    %189 = and i32 %188, 3
    %190 = getelementptr inbounds [4 x i8*], [4 x i8*]* @keylegit_msg, i32 0, i32 %189
    %191 = load i8*, i8** %190, align 4, !tbaa !9
    %192 = call i8* @LANG(i8* %191) #6
    %193 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %186, i8* %192)
    br label %.thread
  
  ; <label>:194                                     ; preds = %39
    %195 = and i8 %40, 124
    %196 = icmp eq i8 %195, 8
    br i1 %196, label %197, label %.thread
  
  ; <label>:197                                     ; preds = %194
    %198 = icmp eq i32 %11, 0
    %199 = icmp eq i32 %userids.0, 0
    %.compromised.0 = select i1 %199, i32 1, i32 %compromised.0
    br i1 %198, label %205, label %200
  
  ; <label>:200                                     ; preds = %197
    %201 = bitcast [128 x i16]* %n to i16*
    %202 = call i8* @key2IDstring(i16* %201) #6
    %203 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %204 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %203, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %202) #6
    br label %.loopexit
  
  ; <label>:205                                     ; preds = %197
    %206 = icmp eq i32 %12, 0
    br i1 %206, label %.thread, label %207
  
  ; <label>:207                                     ; preds = %205
    %208 = icmp eq i8 %print_trust.0, 0
    br i1 %208, label %239, label %209
  
  ; <label>:209                                     ; preds = %207
    %210 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.start(i64 3, i8* %210) #6
    %211 = call i32 @fread(i8* %210, i32 signext 1, i32 signext 3, %struct._IO_FILE* %f) #6
    %212 = icmp eq i32 %211, 3
    br i1 %212, label %213, label %read_trust.exit13
  
  ; <label>:213                                     ; preds = %209
    %214 = bitcast [3 x i8]* %buf.i to i32*
    %215 = load i32, i32* %214, align 4
    %216 = lshr i32 %215, 24
    %217 = trunc i32 %216 to i8
    %218 = icmp eq i8 %217, -80
    %219 = lshr i32 %215, 8
    br i1 %218, label %225, label %220
  
  ; <label>:220                                     ; preds = %213
    %221 = trunc i32 %216 to i8
    %222 = icmp slt i8 %221, 0
    br i1 %222, label %223, label %read_trust.exit13
  
  ; <label>:223                                     ; preds = %220
    %224 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext -3, i32 signext 1) #6
    br label %read_trust.exit13
  
  ; <label>:225                                     ; preds = %213
    %226 = and i32 %215, 16711680
    %227 = icmp eq i32 %226, 65536
    br i1 %227, label %228, label %read_trust.exit13
  
  ; <label>:228                                     ; preds = %225
    %229 = trunc i32 %219 to i8
    store i8 %229, i8* %keyctrl, align 4, !tbaa !6
    br label %read_trust.exit13
  
  read_trust.exit13:                                ; preds = %228, %225, %223, %220, %209
    %230 = bitcast [3 x i8]* %buf.i to i8*
    call void @llvm.lifetime.end(i64 3, i8* %230) #6
    %231 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %232 = load i8, i8* %keyctrl, align 4, !tbaa !6
    %233 = zext i8 %232 to i32
    %234 = and i32 %233, 7
    %235 = getelementptr inbounds [8 x i8*], [8 x i8*]* @sigtrust_msg, i32 0, i32 %234
    %236 = load i8*, i8** %235, align 4, !tbaa !9
    %237 = call i8* @LANG(i8* %236) #6
    %238 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %231, i8* %237)
    br label %243
  
  ; <label>:239                                     ; preds = %207
    %240 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %241 = call i8* @LANG(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0)) #6
    %242 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %240, i8* %241)
    br label %243
  
  ; <label>:243                                     ; preds = %239, %read_trust.exit13
    %244 = bitcast [8 x i8]* %sigkeyID to i8*
    call void @show_userid(%struct._IO_FILE* %f, i8* %244)
    br label %.thread
  
  .loopexit:                                        ; preds = %.thread, %27, %200, %94, %56
    %userids.2 = phi i32 [ 1, %56 ], [ 1, %94 ], [ %userids.0, %200 ], [ %userids.0, %27 ], [ %userids.0, %.thread ]
    %compromised.2 = phi i32 [ %compromised.0, %56 ], [ %compromised.0, %94 ], [ %.compromised.0, %200 ], [ %compromised.0, %27 ], [ %compromised.0, %.thread ]
    %245 = icmp eq i16 %21, -1
    %246 = icmp ne i32 %userids.2, 0
    %or.cond5 = and i1 %245, %246
    %. = select i1 %or.cond5, i32 0, i32 %22
    %247 = or i32 %compromised.2, %userids.2
    %or.cond7.not = icmp eq i32 %247, 0
    %248 = icmp ne i32 %what, 16
    %or.cond9 = and i1 %248, %or.cond7.not
    br i1 %or.cond9, label %249, label %258
  
  ; <label>:249                                     ; preds = %.loopexit
    %250 = bitcast [128 x i16]* %n to i16*
    %251 = bitcast [8 x i8]* %savekeyID to i8*
    %252 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %253 = call i8* @LANG(i8* nonnull getelementptr inbounds ([44 x i8], [44 x i8]* @.str.34, i32 0, i32 0)) #6
    %254 = call i32 @countbits(i16* %250) #6
    %255 = call i8* @keyIDstring(i8* %251) #6
    %256 = call i8* @cdate(i32* nonnull %timestamp) #6
    %257 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %252, i8* %253, i32 signext %254, i8* %255, i8* %256)
    br label %258
  
  ; <label>:258                                     ; preds = %249, %.loopexit
    %status.1 = phi i32 [ -1, %249 ], [ %., %.loopexit ]
    %259 = bitcast [16 x i8]* %hash to i8*
    %260 = bitcast [8 x i8]* %savekeyID to i8*
    %261 = bitcast i32* %timestamp to i8*
    %262 = bitcast [8 x i8]* %sigkeyID to i8*
    %263 = bitcast [128 x i16]* %e to i8*
    %264 = bitcast [128 x i16]* %n to i8*
    %265 = bitcast [256 x i8]* %userid to i8*
    store i16 %8, i16* @global_precision, align 2, !tbaa !34
    %266 = call i32 @fseek(%struct._IO_FILE* %f, i32 signext %9, i32 signext 0)
    call void @llvm.lifetime.end(i64 16, i8* %259) #6
    call void @llvm.lifetime.end(i64 8, i8* %260) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %keyctrl) #6
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 4, i8* %261) #6
    call void @llvm.lifetime.end(i64 8, i8* %262) #6
    call void @llvm.lifetime.end(i64 256, i8* %263) #6
    call void @llvm.lifetime.end(i64 256, i8* %264) #6
    call void @llvm.lifetime.end(i64 256, i8* %265) #6
    ret i32 %status.1
  }
  
  declare signext i16 @readkeypacket(%struct._IO_FILE*, %struct.IdeaCfbContext*, i8*, i8*, i8*, i16*, i16*, i16*, i16*, i16*, i16*, i8*, i8*) #3
  
  declare void @extract_keyID(i8*, i16*) #3
  
  declare void @getKeyHash(i8*, i16*, i16*) #3
  
  declare void @PascalToC(i8*) #3
  
  ; Function Attrs: nounwind
  define void @show_update(i8* %s) #0 {
    %1 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %2 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.35, i32 0, i32 0), i8* %s)
    ret void
  }
  
  declare i8* @key2IDstring(i16*) #3
  
  declare i32 @countbits(i16*) #3
  
  declare i8* @cdate(i32*) #3
  
  declare void @printKeyHash(i8*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  define void @write_trust_pos(%struct._IO_FILE* %f, i8 zeroext %keyctrl, i32 signext %pos) #0 {
    %1 = tail call i32 @ftell(%struct._IO_FILE* %f)
    %2 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %pos, i32 signext 0)
    tail call void @write_trust(%struct._IO_FILE* %f, i8 zeroext %keyctrl) #6
    %3 = tail call i32 @fseek(%struct._IO_FILE* %f, i32 signext %1, i32 signext 0)
    ret void
  }
  
  declare void @write_trust(%struct._IO_FILE*, i8 zeroext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fread(i8* nocapture, i32 signext, i32 signext, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: noreturn nounwind
  declare void @__assert_fail(i8*, i8*, i32 signext, i8*) #4
  
  ; Function Attrs: nounwind readonly
  declare i32 @strcmp(i8* nocapture, i8* nocapture) #2
  
  ; Function Attrs: nounwind
  define internal fastcc i8* @store_str(i8* nocapture readonly %str) unnamed_addr #0 {
    %1 = tail call i32 @strlen(i8* %str) #7
    %2 = add i32 %1, 1
    %3 = icmp sgt i32 %2, 4000
    br i1 %3, label %4, label %7
  
  ; <label>:4                                       ; preds = %0
    %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 4, !tbaa !9
    %6 = tail call i32 @fwrite(i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.82, i32 0, i32 0), i32 27, i32 1, %struct._IO_FILE* %5) #9
    br label %26
  
  ; <label>:7                                       ; preds = %0
    %8 = load i32, i32* @strleft, align 4, !tbaa !7
    %9 = icmp sgt i32 %2, %8
    br i1 %9, label %10, label %._crit_edge
  
  ._crit_edge:                                      ; preds = %7
    %.pre = load i8*, i8** @strptr, align 4, !tbaa !9
    br label %17
  
  ; <label>:10                                      ; preds = %7
    %11 = tail call i8* @xmalloc(i32 signext 4004) #6
    %12 = load i32, i32* @totalsize, align 4, !tbaa !10
    %13 = add nsw i32 %12, 4000
    store i32 %13, i32* @totalsize, align 4, !tbaa !10
    %14 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %15 = bitcast i8* %11 to i32*
    store i32 %14, i32* %15, align 4, !tbaa !12
    store i8* %11, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %16 = getelementptr inbounds i8, i8* %11, i32 4
    store i8* %16, i8** @strptr, align 4, !tbaa !9
    store i32 4000, i32* @strleft, align 4, !tbaa !7
    br label %17
  
  ; <label>:17                                      ; preds = %10, %._crit_edge
    %18 = phi i8* [ %.pre, %._crit_edge ], [ %16, %10 ]
    %19 = tail call i8* @strcpy(i8* %18, i8* %str) #6
    %20 = load i8*, i8** @strptr, align 4, !tbaa !9
    %21 = getelementptr inbounds i8, i8* %20, i32 %2
    store i8* %21, i8** @strptr, align 4, !tbaa !9
    %22 = load i32, i32* @strleft, align 4, !tbaa !7
    %23 = sub nsw i32 %22, %2
    store i32 %23, i32* @strleft, align 4, !tbaa !7
    %24 = xor i32 %1, -1
    %25 = getelementptr inbounds i8, i8* %21, i32 %24
    br label %26
  
  ; <label>:26                                      ; preds = %17, %4
    %.0 = phi i8* [ null, %4 ], [ %25, %17 ]
    ret i8* %.0
  }
  
  ; Function Attrs: nounwind
  define void @endkrent() #0 {
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store %struct.hashent** null, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    store i32 0, i32* @nkr, align 4, !tbaa !7
    %1 = load i8, i8* @verbose, align 1, !tbaa !6
    %2 = icmp eq i8 %1, 0
    br i1 %2, label %8, label %3
  
  ; <label>:3                                       ; preds = %0
    %4 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %5 = load i32, i32* @totalsize, align 4, !tbaa !10
    %6 = sdiv i32 %5, 1024
    %7 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %4, i8* nonnull getelementptr inbounds ([20 x i8], [20 x i8]* @.str.83, i32 0, i32 0), i32 signext %6) #6
    br label %8
  
  ; <label>:8                                       ; preds = %3, %0
    store i32 0, i32* @totalsize, align 4, !tbaa !10
    %9 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %10 = icmp eq %struct.bufpool* %9, null
    br i1 %10, label %freebufpool.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %8, %.lr.ph.i
    %11 = phi %struct.bufpool* [ %15, %.lr.ph.i ], [ %9, %8 ]
    %12 = bitcast %struct.bufpool* %11 to i32*
    %13 = load i32, i32* %12, align 4, !tbaa !12
    store i32 %13, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %14 = bitcast %struct.bufpool* %11 to i8*
    tail call void @free(i8* %14) #6
    %15 = load %struct.bufpool*, %struct.bufpool** @bufpool, align 4, !tbaa !9
    %16 = icmp eq %struct.bufpool* %15, null
    br i1 %16, label %freebufpool.exit, label %.lr.ph.i
  
  freebufpool.exit:                                 ; preds = %.lr.ph.i, %8
    store i32 0, i32* @hashleft, align 4, !tbaa !7
    store i32 0, i32* @strleft, align 4, !tbaa !7
    store i32 0, i32* @nleft, align 4, !tbaa !7
    ret void
  }
  
  ; Function Attrs: nounwind
  define i32 @init_userhash() #0 {
    %keyID = alloca i64, align 8
    %userid = alloca [256 x i8], align 1
    %ctb = alloca i8, align 4
    %1 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.start(i64 8, i8* %1) #6
    %2 = bitcast [256 x i8]* %userid to i8*
    call void @llvm.lifetime.start(i64 256, i8* %2) #6
    call void @llvm.lifetime.start(i64 1, i8* nonnull %ctb) #6
    %3 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %4 = icmp eq %struct.hashent** %3, null
    br i1 %4, label %5, label %.preheader2
  
  ; <label>:5                                       ; preds = %0
    %6 = tail call i8* @xmalloc(i32 signext 1028) #6
    %7 = load i32, i32* @totalsize, align 4, !tbaa !10
    %8 = add nsw i32 %7, 1024
    store i32 %8, i32* @totalsize, align 4, !tbaa !10
    %9 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %10 = bitcast i8* %6 to i32*
    store i32 %9, i32* %10, align 4, !tbaa !12
    store i8* %6, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %11 = getelementptr inbounds i8, i8* %6, i32 4
    store i8* %11, i8** bitcast (%struct.hashent*** @hashtbl to i8**), align 4, !tbaa !9
    tail call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 1024, i32 4, i1 false)
    br label %.preheader2
  
  .preheader2:                                      ; preds = %5, %0
    %12 = load i32, i32* @nkr, align 4, !tbaa !7
    %13 = icmp sgt i32 %12, 0
    br i1 %13, label %.lr.ph5, label %._crit_edge6
  
  .lr.ph5:                                          ; preds = %.preheader2, %73
    %i.04 = phi i32 [ %74, %73 ], [ 0, %.preheader2 ]
    %14 = getelementptr inbounds [8 x i8*], [8 x i8*]* @krnames, i32 0, i32 %i.04
    %15 = load i8*, i8** %14, align 4, !tbaa !9
    %16 = call %struct._IO_FILE* @fopen(i8* %15, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0))
    %17 = icmp eq %struct._IO_FILE* %16, null
    br i1 %17, label %73, label %.preheader
  
  .preheader:                                       ; preds = %.lr.ph5
    %18 = bitcast [256 x i8]* %userid to i8*
    %19 = bitcast i64* %keyID to i8*
    %20 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %18, i8* %19, i8* null)
    %21 = icmp eq i32 %20, -1
    br i1 %21, label %._crit_edge, label %.lr.ph
  
  .lr.ph:                                           ; preds = %.preheader, %.backedge
    %keyflag.03 = phi i32 [ %keyflag.0.be, %.backedge ], [ 0, %.preheader ]
    %22 = load i8, i8* %ctb, align 4, !tbaa !6
    %23 = call i32 @is_key_ctb(i8 zeroext %22) #6
    %24 = icmp eq i32 %23, 0
    br i1 %24, label %29, label %25
  
  ; <label>:25                                      ; preds = %.lr.ph
    %26 = bitcast i64* %keyID to i8*
    %27 = call i8* @user_from_keyID(i8* %26)
    %28 = icmp eq i8* %27, null
    %.keyflag.0 = select i1 %28, i32 1, i32 %keyflag.03
    br label %29
  
  ; <label>:29                                      ; preds = %25, %.lr.ph
    %keyflag.1 = phi i32 [ %keyflag.03, %.lr.ph ], [ %.keyflag.0, %25 ]
    %30 = icmp ne i32 %keyflag.1, 0
    %31 = load i8, i8* %ctb, align 4
    %32 = icmp eq i8 %31, -76
    %or.cond = and i1 %30, %32
    br i1 %or.cond, label %33, label %.backedge
  
  ; <label>:33                                      ; preds = %29
    %34 = load i32, i32* @hashleft, align 4, !tbaa !7
    %35 = icmp eq i32 %34, 0
    br i1 %35, label %36, label %._crit_edge7
  
  ._crit_edge7:                                     ; preds = %33
    %.pre = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    br label %44
  
  ; <label>:36                                      ; preds = %33
    %37 = call i8* @xmalloc(i32 signext 4004) #6
    %38 = load i32, i32* @totalsize, align 4, !tbaa !10
    %39 = add nsw i32 %38, 4000
    store i32 %39, i32* @totalsize, align 4, !tbaa !10
    %40 = load i32, i32* bitcast (%struct.bufpool** @bufpool to i32*), align 4, !tbaa !9
    %41 = bitcast i8* %37 to i32*
    store i32 %40, i32* %41, align 4, !tbaa !12
    store i8* %37, i8** bitcast (%struct.bufpool** @bufpool to i8**), align 4, !tbaa !9
    %42 = getelementptr inbounds i8, i8* %37, i32 4
    store i8* %42, i8** bitcast (%struct.hashent** @hashptr to i8**), align 4, !tbaa !9
    store i32 250, i32* @hashleft, align 4, !tbaa !7
    %43 = bitcast i8* %42 to %struct.hashent*
    br label %44
  
  ; <label>:44                                      ; preds = %36, %._crit_edge7
    %45 = phi %struct.hashent* [ %.pre, %._crit_edge7 ], [ %43, %36 ]
    %46 = bitcast [256 x i8]* %userid to i8*
    %47 = bitcast i64* %keyID to i8*
    %48 = getelementptr inbounds %struct.hashent, %struct.hashent* %45, i32 0, i32 1, i32 0
    %49 = bitcast i8* %48 to i64*
    %50 = load i64, i64* %keyID, align 8
    store i64 %50, i64* %49, align 1
    %51 = call fastcc i8* @store_str(i8* %46)
    %52 = load %struct.hashent*, %struct.hashent** @hashptr, align 4, !tbaa !9
    %53 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 0, i32 2
    store i8* %51, i8** %53, align 4, !tbaa !32
    %54 = load i8, i8* %47, align 8, !tbaa !6
    %55 = zext i8 %54 to i32
    %56 = load %struct.hashent**, %struct.hashent*** @hashtbl, align 4, !tbaa !9
    %57 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %55
    %58 = bitcast %struct.hashent** %57 to i32*
    %59 = load i32, i32* %58, align 4, !tbaa !9
    %60 = bitcast %struct.hashent* %52 to i32*
    store i32 %59, i32* %60, align 4, !tbaa !36
    %.cast = ptrtoint %struct.hashent* %52 to i32
    %61 = load i8, i8* %47, align 8, !tbaa !6
    %62 = zext i8 %61 to i32
    %63 = getelementptr inbounds %struct.hashent*, %struct.hashent** %56, i32 %62
    %64 = bitcast %struct.hashent** %63 to i32*
    store i32 %.cast, i32* %64, align 4, !tbaa !9
    %65 = getelementptr inbounds %struct.hashent, %struct.hashent* %52, i32 1
    store %struct.hashent* %65, %struct.hashent** @hashptr, align 4, !tbaa !9
    %66 = load i32, i32* @hashleft, align 4, !tbaa !7
    %67 = add nsw i32 %66, -1
    store i32 %67, i32* @hashleft, align 4, !tbaa !7
    br label %.backedge
  
  .backedge:                                        ; preds = %44, %29
    %keyflag.0.be = phi i32 [ 0, %44 ], [ %keyflag.1, %29 ]
    %68 = bitcast [256 x i8]* %userid to i8*
    %69 = bitcast i64* %keyID to i8*
    %70 = call i32 @readkpacket(%struct._IO_FILE* nonnull %16, i8* nonnull %ctb, i8* %68, i8* %69, i8* null)
    %71 = icmp eq i32 %70, -1
    br i1 %71, label %._crit_edge, label %.lr.ph
  
  ._crit_edge:                                      ; preds = %.backedge, %.preheader
    %72 = call i32 @fclose(%struct._IO_FILE* nonnull %16)
    br label %73
  
  ; <label>:73                                      ; preds = %._crit_edge, %.lr.ph5
    %74 = add nuw nsw i32 %i.04, 1
    %75 = load i32, i32* @nkr, align 4, !tbaa !7
    %76 = icmp slt i32 %74, %75
    br i1 %76, label %.lr.ph5, label %._crit_edge6
  
  ._crit_edge6:                                     ; preds = %73, %.preheader2
    %77 = bitcast [256 x i8]* %userid to i8*
    %78 = bitcast i64* %keyID to i8*
    call void @llvm.lifetime.end(i64 1, i8* nonnull %ctb) #6
    call void @llvm.lifetime.end(i64 256, i8* %77) #6
    call void @llvm.lifetime.end(i64 8, i8* %78) #6
    ret i32 0
  }
  
  ; Function Attrs: argmemonly nounwind
  declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1
  
  declare signext i16 @mp_compare(i16*, i16*) #3
  
  ; Function Attrs: nounwind
  declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  declare i32 @_IO_getc(%struct._IO_FILE* nocapture) #0
  
  ; Function Attrs: nounwind
  define internal fastcc void @trace_sig_chain(%struct.pubkey* nocapture %pk, i32 signext %depth) unnamed_addr #0 {
    %counts = alloca [8 x i32], align 4
    %1 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.start(i64 32, i8* %1) #6
    %2 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %3 = icmp slt i32 %2, %depth
    br i1 %3, label %4, label %5
  
  ; <label>:4                                       ; preds = %0
    tail call void @__assert_fail(i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.60, i32 0, i32 0), i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i32 signext 543, i8* nonnull getelementptr inbounds ([42 x i8], [42 x i8]* @__PRETTY_FUNCTION__.trace_sig_chain, i32 0, i32 0)) #8
    unreachable
  
  ; <label>:5                                       ; preds = %0
    %6 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 6
    %7 = load i8, i8* %6, align 1, !tbaa !37
    %8 = icmp eq i8 %7, 0
    %9 = zext i8 %7 to i32
    %10 = icmp sgt i32 %9, %depth
    %or.cond = or i1 %8, %10
    br i1 %or.cond, label %11, label %.loopexit4
  
  ; <label>:11                                      ; preds = %5
    %12 = trunc i32 %depth to i8
    %sunkaddr = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr2 = add i32 %sunkaddr, 25
    %sunkaddr3 = inttoptr i32 %sunkaddr2 to i8*
    store i8 %12, i8* %sunkaddr3, align 1, !tbaa !37
    %13 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 5
    %14 = load i8, i8* %13, align 4, !tbaa !16
    %15 = and i8 %14, 7
    %16 = icmp eq i8 %15, 0
    br i1 %16, label %17, label %.loopexit5
  
  ; <label>:17                                      ; preds = %11
    %18 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 2
    %id.014 = load %struct.userid*, %struct.userid** %18, align 4, !tbaa !9
    %19 = icmp eq %struct.userid* %id.014, null
    br i1 %19, label %.loopexit5, label %.lr.ph17
  
  .lr.ph17:                                         ; preds = %17
    %20 = load i32, i32* @marginal_min, align 4
    %21 = load i32, i32* @complete_min, align 4
    br label %25
  
  ; <label>:22                                      ; preds = %compute_legit.exit
    %23 = bitcast %struct.userid* %id.015 to %struct.userid**
    %id.0 = load %struct.userid*, %struct.userid** %23, align 4, !tbaa !9
    %24 = icmp eq %struct.userid* %id.0, null
    br i1 %24, label %.loopexit5, label %25
  
  ; <label>:25                                      ; preds = %22, %.lr.ph17
    %id.015 = phi %struct.userid* [ %id.014, %.lr.ph17 ], [ %id.0, %22 ]
    %26 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 1
    %27 = load %struct.pubkey*, %struct.pubkey** %26, align 4, !tbaa !22
    %28 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %27, i32 0, i32 5
    %29 = load i8, i8* %28, align 4, !tbaa !16
    %30 = icmp slt i8 %29, 0
    br i1 %30, label %compute_legit.exit, label %31
  
  ; <label>:31                                      ; preds = %25
    %32 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 2
    %s.01.i = load %struct.signature*, %struct.signature** %32, align 4, !tbaa !9
    %33 = icmp eq %struct.signature* %s.01.i, null
    br i1 %33, label %compute_legit.exit, label %.lr.ph.i
  
  .lr.ph.i:                                         ; preds = %31, %.lr.ph.i
    %s.03.i = phi %struct.signature* [ %s.0.i, %.lr.ph.i ], [ %s.01.i, %31 ]
    %trust_count.02.i = phi i32 [ %40, %.lr.ph.i ], [ 0, %31 ]
    %34 = getelementptr inbounds %struct.signature, %struct.signature* %s.03.i, i32 0, i32 4
    %35 = load i8, i8* %34, align 4, !tbaa !31
    %36 = zext i8 %35 to i32
    %37 = and i32 %36, 7
    %38 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %37
    %39 = load i32, i32* %38, align 4, !tbaa !7
    %40 = add nsw i32 %39, %trust_count.02.i
    %41 = bitcast %struct.signature* %s.03.i to %struct.signature**
    %s.0.i = load %struct.signature*, %struct.signature** %41, align 4, !tbaa !9
    %42 = icmp eq %struct.signature* %s.0.i, null
    br i1 %42, label %._crit_edge.i, label %.lr.ph.i
  
  ._crit_edge.i:                                    ; preds = %.lr.ph.i
    %43 = icmp eq i32 %40, 0
    br i1 %43, label %compute_legit.exit, label %44
  
  ; <label>:44                                      ; preds = %._crit_edge.i
    %45 = icmp slt i32 %40, %20
    br i1 %45, label %compute_legit.exit, label %46
  
  ; <label>:46                                      ; preds = %44
    %47 = icmp slt i32 %40, %21
    %..i = select i1 %47, i32 2, i32 3
    br label %compute_legit.exit
  
  compute_legit.exit:                               ; preds = %46, %44, %._crit_edge.i, %31, %25
    %legit.0.i = phi i32 [ 3, %25 ], [ 0, %._crit_edge.i ], [ 1, %44 ], [ %..i, %46 ], [ 0, %31 ]
    %48 = getelementptr inbounds %struct.userid, %struct.userid* %id.015, i32 0, i32 4
    %49 = load i8, i8* %48, align 4, !tbaa !23
    %50 = zext i8 %49 to i32
    %51 = and i32 %50, 252
    %52 = or i32 %51, %legit.0.i
    %53 = trunc i32 %52 to i8
    store i8 %53, i8* %48, align 4, !tbaa !23
    %54 = and i8 %53, 3
    %55 = icmp eq i8 %54, 3
    br i1 %55, label %56, label %22
  
  ; <label>:56                                      ; preds = %compute_legit.exit
    %sunkaddr4 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr5 = add i32 %sunkaddr4, 24
    %sunkaddr6 = inttoptr i32 %sunkaddr5 to i8*
    %57 = load i8, i8* %sunkaddr6, align 4, !tbaa !6
    %58 = zext i8 %57 to i32
    %59 = and i32 %58, 248
    %60 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 4, i32 0
    %61 = tail call i8* @user_from_keyID(i8* %60)
    %62 = load i8, i8* %sunkaddr6, align 4, !tbaa !16
    %63 = tail call i32 @ask_owntrust(i8* %61, i8 zeroext %62)
    %64 = or i32 %63, %59
    %65 = trunc i32 %64 to i8
    store i8 %65, i8* %sunkaddr6, align 4, !tbaa !6
    br label %.loopexit5
  
  .loopexit5:                                       ; preds = %22, %56, %17, %11
    %66 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %pk, i32 0, i32 3
    %67 = load %struct.signature*, %struct.signature** %66, align 4, !tbaa !29
    %68 = icmp eq %struct.signature* %67, null
    br i1 %68, label %.loopexit4, label %.lr.ph13
  
  .lr.ph13:                                         ; preds = %.loopexit5
    %69 = shl nsw i32 %depth, 1
    %70 = add nsw i32 %depth, 1
    br label %71
  
  ; <label>:71                                      ; preds = %.loopexit, %.lr.ph13
    %sig.012 = phi %struct.signature* [ %67, %.lr.ph13 ], [ %167, %.loopexit ]
    %72 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 4
    %73 = load i8, i8* %72, align 4, !tbaa !31
    %74 = zext i8 %73 to i32
    %75 = and i32 %74, 64
    %76 = icmp eq i32 %75, 0
    %77 = and i32 %74, 120
    br i1 %76, label %94, label %78
  
  ; <label>:78                                      ; preds = %71
    %sunkaddr7 = ptrtoint %struct.pubkey* %pk to i32
    %sunkaddr8 = add i32 %sunkaddr7, 24
    %sunkaddr9 = inttoptr i32 %sunkaddr8 to i8*
    %79 = load i8, i8* %sunkaddr9, align 4, !tbaa !16
    %80 = zext i8 %79 to i32
    %81 = and i32 %80, 7
    %82 = or i32 %77, %81
    %83 = or i32 %82, 128
    %84 = trunc i32 %83 to i8
    %sunkaddr10 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr11 = add i32 %sunkaddr10, 16
    %sunkaddr12 = inttoptr i32 %sunkaddr11 to i8*
    store i8 %84, i8* %sunkaddr12, align 4, !tbaa !31
    %85 = load i8, i8* @mverbose, align 4, !tbaa !6
    %86 = icmp eq i8 %85, 0
    br i1 %86, label %106, label %87
  
  ; <label>:87                                      ; preds = %78
    %88 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %89 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %90 = load %struct.userid*, %struct.userid** %89, align 4, !tbaa !27
    %91 = getelementptr inbounds %struct.userid, %struct.userid* %90, i32 0, i32 3
    %92 = load i8*, i8** %91, align 4, !tbaa !21
    %93 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %88, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %92)
    br label %106
  
  ; <label>:94                                      ; preds = %71
    %95 = or i32 %77, 2
    %96 = trunc i32 %95 to i8
    %sunkaddr13 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr14 = add i32 %sunkaddr13, 16
    %sunkaddr15 = inttoptr i32 %sunkaddr14 to i8*
    store i8 %96, i8* %sunkaddr15, align 4, !tbaa !31
    %97 = load i8, i8* @mverbose, align 4, !tbaa !6
    %98 = icmp eq i8 %97, 0
    br i1 %98, label %106, label %99
  
  ; <label>:99                                      ; preds = %94
    %100 = load %struct._IO_FILE*, %struct._IO_FILE** @pgpout, align 4, !tbaa !9
    %101 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %102 = load %struct.userid*, %struct.userid** %101, align 4, !tbaa !27
    %103 = getelementptr inbounds %struct.userid, %struct.userid* %102, i32 0, i32 3
    %104 = load i8*, i8** %103, align 4, !tbaa !21
    %105 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %100, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 signext %69, i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.11, i32 0, i32 0), i8* %104)
    br label %106
  
  ; <label>:106                                     ; preds = %99, %94, %87, %78
    %sunkaddr16 = ptrtoint %struct.signature* %sig.012 to i32
    %sunkaddr17 = add i32 %sunkaddr16, 16
    %sunkaddr18 = inttoptr i32 %sunkaddr17 to i8*
    %107 = load i8, i8* %sunkaddr18, align 4, !tbaa !31
    %108 = zext i8 %107 to i32
    %109 = and i32 %108, 7
    %110 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %109
    %111 = load i32, i32* %110, align 4, !tbaa !7
    %112 = icmp eq i32 %111, 0
    br i1 %112, label %.loopexit, label %113
  
  ; <label>:113                                     ; preds = %106
    %114 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 1
    %115 = load %struct.userid*, %struct.userid** %114, align 4, !tbaa !27
    %116 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 1
    %117 = load %struct.pubkey*, %struct.pubkey** %116, align 4, !tbaa !22
    %118 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %117, i32 0, i32 5
    %119 = bitcast i8* %118 to i16*
    %120 = load i16, i16* %119, align 4
    %121 = lshr i16 %120, 8
    %122 = trunc i16 %121 to i8
    %123 = icmp slt i8 %122, 0
    br i1 %123, label %.loopexit, label %124
  
  ; <label>:124                                     ; preds = %113
    %125 = trunc i16 %120 to i8
    %126 = icmp eq i8 %125, 0
    %.mask = and i16 %120, 255
    %127 = zext i16 %.mask to i32
    %128 = icmp sgt i32 %127, %70
    %or.cond19 = or i1 %126, %128
    br i1 %or.cond19, label %.preheader2, label %.loopexit
  
  .preheader2:                                      ; preds = %124
    %129 = load i32, i32* @max_cert_depth, align 4, !tbaa !7
    %130 = icmp sgt i32 %129, 0
    br i1 %130, label %.lr.ph, label %._crit_edge
  
  .lr.ph:                                           ; preds = %.preheader2
    %131 = bitcast [8 x i32]* %counts to i8*
    %132 = icmp sgt i32 %129, 1
    %smax = select i1 %132, i32 %129, i32 1
    %133 = shl i32 %smax, 2
    call void @llvm.memset.p0i8.i32(i8* %131, i8 0, i32 %133, i32 4, i1 false)
    br label %._crit_edge
  
  ._crit_edge:                                      ; preds = %.lr.ph, %.preheader2
    %134 = getelementptr inbounds %struct.userid, %struct.userid* %115, i32 0, i32 2
    %s.08 = load %struct.signature*, %struct.signature** %134, align 4, !tbaa !9
    %135 = icmp eq %struct.signature* %s.08, null
    br i1 %135, label %.preheader, label %.lr.ph11
  
  .preheader:                                       ; preds = %153, %._crit_edge
    %136 = load i32, i32* @complete_min, align 4
    br label %156
  
  .lr.ph11:                                         ; preds = %._crit_edge, %153
    %s.09 = phi %struct.signature* [ %s.0, %153 ], [ %s.08, %._crit_edge ]
    %137 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 2
    %138 = load %struct.pubkey*, %struct.pubkey** %137, align 4, !tbaa !28
    %139 = getelementptr inbounds %struct.pubkey, %struct.pubkey* %138, i32 0, i32 6
    %140 = load i8, i8* %139, align 1, !tbaa !37
    %141 = zext i8 %140 to i32
    %142 = icmp slt i32 %141, %129
    br i1 %142, label %143, label %153
  
  ; <label>:143                                     ; preds = %.lr.ph11
    %144 = getelementptr inbounds %struct.signature, %struct.signature* %s.09, i32 0, i32 4
    %145 = load i8, i8* %144, align 4, !tbaa !31
    %146 = zext i8 %145 to i32
    %147 = and i32 %146, 7
    %148 = getelementptr inbounds [8 x i32], [8 x i32]* @trust_tbl, i32 0, i32 %147
    %149 = load i32, i32* %148, align 4, !tbaa !7
    %150 = getelementptr inbounds [8 x i32], [8 x i32]* %counts, i32 0, i32 %141
    %151 = load i32, i32* %150, align 4, !tbaa !7
    %152 = add nsw i32 %151, %149
    store i32 %152, i32* %150, align 4, !tbaa !7
    br label %153
  
  ; <label>:153                                     ; preds = %143, %.lr.ph11
    %154 = bitcast %struct.signature* %s.09 to %struct.signature**
    %s.0 = load %struct.signature*, %struct.signature** %154, align 4, !tbaa !9
    %155 = icmp eq %struct.signature* %s.0, null
    br i1 %155, label %.preheader, label %.lr.ph11
  
  ; <label>:156                                     ; preds = %158, %.preheader
    %lsr.iv = phi [8 x i32]* [ %164, %158 ], [ %counts, %.preheader ]
    %d.1 = phi i32 [ %163, %158 ], [ 0, %.preheader ]
    %trust_count.0 = phi i32 [ %161, %158 ], [ 0, %.preheader ]
    %157 = icmp slt i32 %d.1, %129
    br i1 %157, label %158, label %.loopexit
  
  ; <label>:158                                     ; preds = %156
    %159 = bitcast [8 x i32]* %lsr.iv to i32*
    %160 = load i32, i32* %159, align 4, !tbaa !7
    %161 = add nsw i32 %160, %trust_count.0
    %162 = icmp slt i32 %161, %136
    %163 = add nuw nsw i32 %d.1, 1
    %scevgep = getelementptr [8 x i32], [8 x i32]* %lsr.iv, i32 0, i32 1
    %164 = bitcast i32* %scevgep to [8 x i32]*
    br i1 %162, label %156, label %165
  
  ; <label>:165                                     ; preds = %158
    tail call fastcc void @trace_sig_chain(%struct.pubkey* %117, i32 signext %163)
    br label %.loopexit
  
  .loopexit:                                        ; preds = %156, %165, %124, %113, %106
    %166 = getelementptr inbounds %struct.signature, %struct.signature* %sig.012, i32 0, i32 3
    %167 = load %struct.signature*, %struct.signature** %166, align 4, !tbaa !30
    %168 = icmp eq %struct.signature* %167, null
    br i1 %168, label %.loopexit4, label %71
  
  .loopexit4:                                       ; preds = %.loopexit, %.loopexit5, %5
    %169 = bitcast [8 x i32]* %counts to i8*
    call void @llvm.lifetime.end(i64 32, i8* %169) #6
    ret void
  }
  
  ; Function Attrs: nounwind
  declare i8* @strcpy(i8*, i8* nocapture readonly) #0
  
  declare i8* @xmalloc(i32 signext) #3
  
  ; Function Attrs: nounwind
  declare i32 @fwrite(i8* nocapture, i32, i32, %struct._IO_FILE* nocapture) #5
  
  ; Function Attrs: nounwind
  declare i32 @fputc(i32, %struct._IO_FILE* nocapture) #5
  
  attributes #0 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { argmemonly nounwind "target-cpu"="mips32" }
  attributes #2 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #3 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="mips32" "target-features"="+mips32r2" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #5 = { nounwind "target-cpu"="mips32" }
  attributes #6 = { nounwind }
  attributes #7 = { nounwind readonly }
  attributes #8 = { noreturn nounwind }
  attributes #9 = { cold }
  
  !llvm.ident = !{!0}
  
  !0 = !{!"clang version 3.8.0 (http://llvm.org/git/clang.git 2d49f0a0ae8366964a93e3b7b26e29679bee7160) (http://llvm.org/git/llvm.git 60bc66b44837125843b58ed3e0fd2e6bb948d839)"}
  !1 = !{!2, !5, i64 8}
  !2 = !{!"newkey", !3, i64 0, !5, i64 8}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C/C++ TBAA"}
  !5 = !{!"any pointer", !3, i64 0}
  !6 = !{!3, !3, i64 0}
  !7 = !{!8, !8, i64 0}
  !8 = !{!"int", !3, i64 0}
  !9 = !{!5, !5, i64 0}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"long", !3, i64 0}
  !12 = !{!13, !5, i64 0}
  !13 = !{!"bufpool", !5, i64 0, !3, i64 4}
  !14 = !{!15, !5, i64 8}
  !15 = !{!"pubkey", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16, !3, i64 24, !3, i64 25}
  !16 = !{!15, !3, i64 24}
  !17 = !{!15, !5, i64 4}
  !18 = !{!15, !5, i64 0}
  !19 = !{!20, !5, i64 0}
  !20 = !{!"userid", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !21 = !{!20, !5, i64 12}
  !22 = !{!20, !5, i64 4}
  !23 = !{!20, !3, i64 16}
  !24 = !{!20, !5, i64 8}
  !25 = !{!26, !5, i64 0}
  !26 = !{!"signature", !5, i64 0, !5, i64 4, !5, i64 8, !5, i64 12, !3, i64 16}
  !27 = !{!26, !5, i64 4}
  !28 = !{!26, !5, i64 8}
  !29 = !{!15, !5, i64 12}
  !30 = !{!26, !5, i64 12}
  !31 = !{!26, !3, i64 16}
  !32 = !{!33, !5, i64 12}
  !33 = !{!"hashent", !5, i64 0, !3, i64 4, !5, i64 12}
  !34 = !{!35, !35, i64 0}
  !35 = !{!"short", !3, i64 0}
  !36 = !{!33, !5, i64 0}
  !37 = !{!15, !3, i64 25}

...
---
name:            show_key
alignment:       2
exposesReturnsTwice: false
hasInlineAsm:    false
isSSA:           true
tracksRegLiveness: true
tracksSubRegLiveness: false
registers:       
  - { id: 0, class: gpr32 }
  - { id: 1, class: gpr32 }
  - { id: 2, class: gpr32 }
  - { id: 3, class: gpr32 }
  - { id: 4, class: gpr32 }
  - { id: 5, class: gpr32 }
  - { id: 6, class: gpr32 }
  - { id: 7, class: gpr32 }
  - { id: 8, class: gpr32 }
  - { id: 9, class: gpr32 }
  - { id: 10, class: gpr32 }
  - { id: 11, class: gpr32 }
  - { id: 12, class: gpr32 }
  - { id: 13, class: gpr32 }
  - { id: 14, class: gpr32 }
  - { id: 15, class: gpr32 }
  - { id: 16, class: gpr32 }
  - { id: 17, class: gpr32 }
  - { id: 18, class: gpr32 }
  - { id: 19, class: gpr32 }
  - { id: 20, class: gpr32 }
  - { id: 21, class: gpr32 }
  - { id: 22, class: gpr32 }
  - { id: 23, class: gpr32 }
  - { id: 24, class: gpr32 }
  - { id: 25, class: gpr32 }
  - { id: 26, class: gpr32 }
  - { id: 27, class: gpr32 }
  - { id: 28, class: gpr32 }
  - { id: 29, class: gpr32 }
  - { id: 30, class: gpr32 }
  - { id: 31, class: gpr32 }
  - { id: 32, class: gpr32 }
  - { id: 33, class: gpr32 }
  - { id: 34, class: gpr32 }
  - { id: 35, class: gpr32 }
  - { id: 36, class: gpr32 }
  - { id: 37, class: gpr32 }
  - { id: 38, class: gpr32 }
  - { id: 39, class: gpr32 }
  - { id: 40, class: gpr32 }
  - { id: 41, class: gpr32 }
  - { id: 42, class: gpr32 }
  - { id: 43, class: gpr32 }
  - { id: 44, class: gpr32 }
  - { id: 45, class: gpr32 }
  - { id: 46, class: gpr32 }
  - { id: 47, class: gpr32 }
  - { id: 48, class: gpr32 }
  - { id: 49, class: gpr32 }
  - { id: 50, class: gpr32 }
  - { id: 51, class: gpr32 }
  - { id: 52, class: gpr32 }
  - { id: 53, class: gpr32 }
  - { id: 54, class: gpr32 }
  - { id: 55, class: gpr32 }
  - { id: 56, class: gpr32 }
  - { id: 57, class: gpr32 }
  - { id: 58, class: gpr32 }
  - { id: 59, class: gpr32 }
  - { id: 60, class: gpr32 }
  - { id: 61, class: gpr32 }
  - { id: 62, class: gpr32 }
  - { id: 63, class: gpr32 }
  - { id: 64, class: gpr32 }
  - { id: 65, class: gpr32 }
  - { id: 66, class: gpr32 }
  - { id: 67, class: gpr32 }
  - { id: 68, class: gpr32 }
  - { id: 69, class: gpr32 }
  - { id: 70, class: gpr32 }
  - { id: 71, class: gpr32 }
  - { id: 72, class: gpr32 }
  - { id: 73, class: gpr32 }
  - { id: 74, class: gpr32 }
  - { id: 75, class: gpr32 }
  - { id: 76, class: gpr32 }
  - { id: 77, class: gpr32 }
  - { id: 78, class: gpr32 }
  - { id: 79, class: gpr32 }
  - { id: 80, class: gpr32 }
  - { id: 81, class: gpr32 }
  - { id: 82, class: gpr32 }
  - { id: 83, class: gpr32 }
  - { id: 84, class: gpr32 }
  - { id: 85, class: gpr32 }
  - { id: 86, class: gpr32 }
  - { id: 87, class: gpr32 }
  - { id: 88, class: gpr32 }
  - { id: 89, class: gpr32 }
  - { id: 90, class: gpr32 }
  - { id: 91, class: gpr32 }
  - { id: 92, class: gpr32 }
  - { id: 93, class: gpr32 }
  - { id: 94, class: gpr32 }
  - { id: 95, class: gpr32 }
  - { id: 96, class: gpr32 }
  - { id: 97, class: gpr32 }
  - { id: 98, class: gpr32 }
  - { id: 99, class: gpr32 }
  - { id: 100, class: gpr32 }
  - { id: 101, class: gpr32 }
  - { id: 102, class: gpr32 }
  - { id: 103, class: gpr32 }
  - { id: 104, class: gpr32 }
  - { id: 105, class: gpr32 }
  - { id: 106, class: gpr32 }
  - { id: 107, class: gpr32 }
  - { id: 108, class: gpr32 }
  - { id: 109, class: gpr32 }
  - { id: 110, class: gpr32 }
  - { id: 111, class: gpr32 }
  - { id: 112, class: gpr32 }
  - { id: 113, class: gpr32 }
  - { id: 114, class: gpr32 }
  - { id: 115, class: gpr32 }
  - { id: 116, class: gpr32 }
  - { id: 117, class: gpr32 }
  - { id: 118, class: gpr32 }
  - { id: 119, class: gpr32 }
  - { id: 120, class: gpr32 }
  - { id: 121, class: gpr32 }
  - { id: 122, class: gpr32 }
  - { id: 123, class: gpr32 }
  - { id: 124, class: gpr32 }
  - { id: 125, class: gpr32 }
  - { id: 126, class: gpr32 }
  - { id: 127, class: gpr32 }
  - { id: 128, class: gpr32 }
  - { id: 129, class: gpr32 }
  - { id: 130, class: gpr32 }
  - { id: 131, class: gpr32 }
  - { id: 132, class: gpr32 }
  - { id: 133, class: gpr32 }
  - { id: 134, class: gpr32 }
  - { id: 135, class: gpr32 }
  - { id: 136, class: gpr32 }
  - { id: 137, class: gpr32 }
  - { id: 138, class: gpr32 }
  - { id: 139, class: gpr32 }
  - { id: 140, class: gpr32 }
  - { id: 141, class: gpr32 }
  - { id: 142, class: gpr32 }
  - { id: 143, class: gpr32 }
  - { id: 144, class: gpr32 }
  - { id: 145, class: gpr32 }
  - { id: 146, class: gpr32 }
  - { id: 147, class: gpr32 }
  - { id: 148, class: gpr32 }
  - { id: 149, class: gpr32 }
  - { id: 150, class: gpr32 }
  - { id: 151, class: gpr32 }
  - { id: 152, class: gpr32 }
  - { id: 153, class: gpr32 }
  - { id: 154, class: gpr32 }
  - { id: 155, class: gpr32 }
  - { id: 156, class: gpr32 }
  - { id: 157, class: gpr32 }
  - { id: 158, class: gpr32 }
  - { id: 159, class: gpr32 }
  - { id: 160, class: gpr32 }
  - { id: 161, class: gpr32 }
  - { id: 162, class: gpr32 }
  - { id: 163, class: gpr32 }
  - { id: 164, class: gpr32 }
  - { id: 165, class: gpr32 }
  - { id: 166, class: gpr32 }
  - { id: 167, class: gpr32 }
  - { id: 168, class: gpr32 }
  - { id: 169, class: gpr32 }
  - { id: 170, class: gpr32 }
  - { id: 171, class: gpr32 }
  - { id: 172, class: gpr32 }
  - { id: 173, class: gpr32 }
  - { id: 174, class: gpr32 }
  - { id: 175, class: gpr32 }
  - { id: 176, class: gpr32 }
  - { id: 177, class: gpr32 }
  - { id: 178, class: gpr32 }
  - { id: 179, class: gpr32 }
  - { id: 180, class: gpr32 }
  - { id: 181, class: gpr32 }
  - { id: 182, class: gpr32 }
  - { id: 183, class: gpr32 }
  - { id: 184, class: gpr32 }
  - { id: 185, class: gpr32 }
  - { id: 186, class: gpr32 }
  - { id: 187, class: gpr32 }
  - { id: 188, class: gpr32 }
  - { id: 189, class: gpr32 }
  - { id: 190, class: gpr32 }
  - { id: 191, class: gpr32 }
  - { id: 192, class: gpr32 }
  - { id: 193, class: gpr32 }
  - { id: 194, class: gpr32 }
  - { id: 195, class: gpr32 }
  - { id: 196, class: gpr32 }
  - { id: 197, class: gpr32 }
  - { id: 198, class: gpr32 }
  - { id: 199, class: gpr32 }
  - { id: 200, class: gpr32 }
  - { id: 201, class: gpr32 }
  - { id: 202, class: gpr32 }
  - { id: 203, class: gpr32 }
  - { id: 204, class: gpr32 }
  - { id: 205, class: gpr32 }
  - { id: 206, class: gpr32 }
  - { id: 207, class: gpr32 }
  - { id: 208, class: gpr32 }
  - { id: 209, class: gpr32 }
  - { id: 210, class: gpr32 }
  - { id: 211, class: gpr32 }
  - { id: 212, class: gpr32 }
  - { id: 213, class: gpr32 }
  - { id: 214, class: gpr32 }
  - { id: 215, class: gpr32 }
  - { id: 216, class: gpr32 }
  - { id: 217, class: gpr32 }
  - { id: 218, class: gpr32 }
  - { id: 219, class: gpr32 }
  - { id: 220, class: gpr32 }
  - { id: 221, class: gpr32 }
  - { id: 222, class: gpr32 }
  - { id: 223, class: gpr32 }
  - { id: 224, class: gpr32 }
  - { id: 225, class: gpr32 }
  - { id: 226, class: gpr32 }
  - { id: 227, class: gpr32 }
  - { id: 228, class: gpr32 }
  - { id: 229, class: gpr32 }
  - { id: 230, class: gpr32 }
  - { id: 231, class: gpr32 }
  - { id: 232, class: gpr32 }
  - { id: 233, class: gpr32 }
  - { id: 234, class: gpr32 }
  - { id: 235, class: gpr32 }
  - { id: 236, class: gpr32 }
  - { id: 237, class: gpr32 }
  - { id: 238, class: gpr32 }
  - { id: 239, class: gpr32 }
  - { id: 240, class: gpr32 }
  - { id: 241, class: gpr32 }
  - { id: 242, class: gpr32 }
  - { id: 243, class: gpr32 }
  - { id: 244, class: gpr32 }
  - { id: 245, class: gpr32 }
  - { id: 246, class: gpr32 }
  - { id: 247, class: gpr32 }
  - { id: 248, class: gpr32 }
  - { id: 249, class: gpr32 }
  - { id: 250, class: gpr32 }
  - { id: 251, class: gpr32 }
  - { id: 252, class: gpr32 }
  - { id: 253, class: gpr32 }
  - { id: 254, class: gpr32 }
  - { id: 255, class: gpr32 }
  - { id: 256, class: gpr32 }
  - { id: 257, class: gpr32 }
  - { id: 258, class: gpr32 }
  - { id: 259, class: gpr32 }
  - { id: 260, class: gpr32 }
  - { id: 261, class: gpr32 }
  - { id: 262, class: gpr32 }
  - { id: 263, class: gpr32 }
  - { id: 264, class: gpr32 }
  - { id: 265, class: gpr32 }
  - { id: 266, class: gpr32 }
  - { id: 267, class: gpr32 }
  - { id: 268, class: gpr32 }
  - { id: 269, class: gpr32 }
  - { id: 270, class: gpr32 }
  - { id: 271, class: gpr32 }
  - { id: 272, class: gpr32 }
  - { id: 273, class: gpr32 }
  - { id: 274, class: gpr32 }
  - { id: 275, class: gpr32 }
  - { id: 276, class: gpr32 }
  - { id: 277, class: gpr32 }
  - { id: 278, class: gpr32 }
  - { id: 279, class: gpr32 }
  - { id: 280, class: gpr32 }
  - { id: 281, class: gpr32 }
  - { id: 282, class: gpr32 }
  - { id: 283, class: gpr32 }
  - { id: 284, class: gpr32 }
  - { id: 285, class: gpr32 }
  - { id: 286, class: gpr32 }
  - { id: 287, class: gpr32 }
  - { id: 288, class: gpr32 }
  - { id: 289, class: gpr32 }
  - { id: 290, class: gpr32 }
  - { id: 291, class: gpr32 }
  - { id: 292, class: gpr32 }
  - { id: 293, class: gpr32 }
  - { id: 294, class: gpr32 }
  - { id: 295, class: gpr32 }
  - { id: 296, class: gpr32 }
  - { id: 297, class: gpr32 }
  - { id: 298, class: gpr32 }
  - { id: 299, class: gpr32 }
  - { id: 300, class: gpr32 }
  - { id: 301, class: gpr32 }
  - { id: 302, class: gpr32 }
  - { id: 303, class: gpr32 }
  - { id: 304, class: gpr32 }
  - { id: 305, class: gpr32 }
  - { id: 306, class: gpr32 }
  - { id: 307, class: gpr32 }
  - { id: 308, class: gpr32 }
  - { id: 309, class: gpr32 }
  - { id: 310, class: gpr32 }
  - { id: 311, class: gpr32 }
  - { id: 312, class: gpr32 }
  - { id: 313, class: gpr32 }
  - { id: 314, class: gpr32 }
  - { id: 315, class: gpr32 }
  - { id: 316, class: gpr32 }
  - { id: 317, class: gpr32 }
  - { id: 318, class: gpr32 }
  - { id: 319, class: gpr32 }
  - { id: 320, class: gpr32 }
  - { id: 321, class: gpr32 }
  - { id: 322, class: gpr32 }
  - { id: 323, class: gpr32 }
  - { id: 324, class: gpr32 }
  - { id: 325, class: gpr32 }
  - { id: 326, class: gpr32 }
  - { id: 327, class: gpr32 }
  - { id: 328, class: gpr32 }
  - { id: 329, class: gpr32 }
  - { id: 330, class: gpr32 }
  - { id: 331, class: gpr32 }
  - { id: 332, class: gpr32 }
  - { id: 333, class: gpr32 }
  - { id: 334, class: gpr32 }
  - { id: 335, class: gpr32 }
  - { id: 336, class: gpr32 }
  - { id: 337, class: gpr32 }
  - { id: 338, class: gpr32 }
  - { id: 339, class: gpr32 }
  - { id: 340, class: gpr32 }
  - { id: 341, class: gpr32 }
  - { id: 342, class: gpr32 }
  - { id: 343, class: gpr32 }
  - { id: 344, class: gpr32 }
  - { id: 345, class: gpr32 }
  - { id: 346, class: gpr32 }
  - { id: 347, class: gpr32 }
  - { id: 348, class: gpr32 }
  - { id: 349, class: gpr32 }
  - { id: 350, class: gpr32 }
  - { id: 351, class: gpr32 }
  - { id: 352, class: gpr32 }
  - { id: 353, class: gpr32 }
  - { id: 354, class: gpr32 }
  - { id: 355, class: gpr32 }
  - { id: 356, class: gpr32 }
  - { id: 357, class: gpr32 }
  - { id: 358, class: gpr32 }
  - { id: 359, class: gpr32 }
  - { id: 360, class: gpr32 }
  - { id: 361, class: gpr32 }
  - { id: 362, class: gpr32 }
  - { id: 363, class: gpr32 }
  - { id: 364, class: gpr32 }
  - { id: 365, class: gpr32 }
  - { id: 366, class: gpr32 }
  - { id: 367, class: gpr32 }
  - { id: 368, class: gpr32 }
  - { id: 369, class: gpr32 }
  - { id: 370, class: gpr32 }
  - { id: 371, class: gpr32 }
liveins:         
  - { reg: '%a0', virtual-reg: '%38' }
  - { reg: '%a1', virtual-reg: '%39' }
  - { reg: '%a2', virtual-reg: '%40' }
  - { reg: '%t9' }
  - { reg: '%v0' }
frameInfo:       
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
stack:           
  - { id: 0, name: buf.i, offset: 0, size: 3, alignment: 4 }
  - { id: 1, name: userid, offset: 0, size: 256, alignment: 4 }
  - { id: 2, name: n, offset: 0, size: 256, alignment: 4 }
  - { id: 3, name: e, offset: 0, size: 256, alignment: 4 }
  - { id: 4, name: sigkeyID, offset: 0, size: 8, alignment: 4 }
  - { id: 5, name: timestamp, offset: 0, size: 4, alignment: 4 }
  - { id: 6, name: ctb, offset: 0, size: 1, alignment: 4 }
  - { id: 7, name: keyctrl, offset: 0, size: 1, alignment: 4 }
  - { id: 8, name: savekeyID, offset: 0, size: 8, alignment: 4 }
  - { id: 9, name: hash, offset: 0, size: 16, alignment: 4 }
body:             |
  bb.0 (%ir-block.0, freq 3632):
    successors: %bb.1..thread(100)
    liveins: %a0, %a1, %a2, %t9, %v0
  
    %41 = ADDu %v0, %t9
    %40 = COPY %a2
    %39 = COPY %a1
    %38 = COPY %a0
    %45 = LW %41, target-flags(<unknown>) @global_precision, <0x461f8d0> = !{!"unison-memory-partition", i32 6} :: (load 4 from got)
    %0 = LHu %45, 0, <0x4777c50> = !{!"unison-memory-partition", i32 7} :: (load 2 from @global_precision, !tbaa !34)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %46 = LW %41, target-flags(<unknown>) @ftell, <0x4633c30> = !{!"unison-memory-partition", i32 8} :: (load 4 from call-entry @ftell)
    %a0 = COPY %38
    %gp = COPY %41
    %t9 = COPY %46
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %47 = COPY %v0
    %44 = ADDiu %zero, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %48 = LW %41, target-flags(<unknown>) @fseek, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fseek)
    %a0 = COPY %38
    %a1 = COPY %39
    %a2 = COPY %44
    %gp = COPY %41
    %t9 = COPY %48
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %6 = ANDi %40, 4
    %5 = ANDi %40, 8
    %4 = ANDi %40, 1
    %3 = ANDi %40, 2
    %2 = ANDi %40, 16
    %42 = ADDiu %zero, -1
    %43 = COPY %44
    %1 = COPY %47
    %50 = LEA_ADDiu %stack.3.e, 0
    %51 = LEA_ADDiu %stack.4.sigkeyID, 0
    %52 = LEA_ADDiu %stack.7.keyctrl, 0
    %54 = LEA_ADDiu %stack.2.n, 0
    %55 = LEA_ADDiu %stack.1.userid, 0
    %58 = LEA_ADDiu %stack.6.ctb, 0
    %59 = LEA_ADDiu %stack.5.timestamp, 0
    %62 = ORi %zero, 65532
    %76 = ADDiu %zero, 180
    %178 = LW %41, target-flags(<unknown>) @pgpout, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %180 = LW %41, target-flags(<unknown>) @.str.25, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %181 = ADDiu %180, target-flags(<unknown>) @.str.25
    %187 = LW %41, target-flags(<unknown>) @.str.26, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %188 = ADDiu %187, target-flags(<unknown>) @.str.26
    %203 = ADDiu %zero, -6
    %207 = LW %41, target-flags(<unknown>) @.str.28, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from got)
    %208 = ADDiu %207, target-flags(<unknown>) @.str.28
    %244 = LW %41, target-flags(<unknown>) @owntrust_msg, <0x48723d0> = !{!"unison-memory-partition", i32 10} :: (load 4 from got)
    %245 = ADDiu %244, target-flags(<unknown>) @owntrust_msg
    %234 = LW %41, target-flags(<unknown>) @.str.30, <0x468acb0> = !{!"unison-memory-partition", i32 9} :: (load 4 from got)
    %235 = ADDiu %234, target-flags(<unknown>) @.str.30
    %226 = LW %41, target-flags(<unknown>) @.str.29, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from got)
    %227 = ADDiu %226, target-flags(<unknown>) @.str.29
    %204 = ADDiu %zero, -4
    %261 = ADDiu %zero, 1
    %262 = ADDiu %zero, 3
    %265 = ADDiu %zero, 176
    %271 = LUi 255
    %273 = LUi 1
    %268 = ADDiu %zero, -3
    %83 = ADDiu %zero, 10
    %292 = ADDiu %zero, 8
  
  bb.1..thread (freq 66211):
    successors: %bb.65..loopexit(3), %bb.2(96)
  
    %7 = PHI %42, %bb.0, %15, %bb.6, %7, %bb.37, %7, %bb.43, %7, %bb.50.read_trust.exit, %7, %bb.10, %7, %bb.51, %7, %bb.54, %7, %bb.64
    %8 = PHI %43, %bb.0, %16, %bb.6, %8, %bb.37, %8, %bb.43, %8, %bb.50.read_trust.exit, %8, %bb.10, %8, %bb.51, %8, %bb.54, %8, %bb.64
    %9 = PHI %44, %bb.0, %9, %bb.6, %240, %bb.37, %25, %bb.43, %26, %bb.50.read_trust.exit, %9, %bb.10, %9, %bb.51, %9, %bb.54, %9, %bb.64
    %10 = PHI %44, %bb.0, %74, %bb.6, %10, %bb.37, %10, %bb.43, %10, %bb.50.read_trust.exit, %10, %bb.10, %10, %bb.51, %10, %bb.54, %10, %bb.64
    %11 = PHI %43, %bb.0, %11, %bb.6, %241, %bb.37, %258, %bb.43, %11, %bb.50.read_trust.exit, %20, %bb.10, %11, %bb.51, %11, %bb.54, %11, %bb.64
    %12 = PHI %44, %bb.0, %12, %bb.6, %12, %bb.37, %12, %bb.43, %12, %bb.50.read_trust.exit, %12, %bb.10, %12, %bb.51, %30, %bb.54, %30, %bb.64
    %13 = PHI %44, %bb.0, %13, %bb.6, %13, %bb.37, %13, %bb.43, %13, %bb.50.read_trust.exit, %19, %bb.10, %13, %bb.51, %13, %bb.54, %13, %bb.64
    ADJCALLSTACKDOWN 56, implicit-def dead %sp, implicit %sp
    %53 = COPY %sp
    SW %52, %53, 48, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %51, %53, 44, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %50, %53, 24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %54, %53, 20, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %55, %53, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %53, 40, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %53, 36, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %53, 32, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    SW %zero, %53, 28, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %56 = LW %41, target-flags(<unknown>) @readkeypacket, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @readkeypacket)
    %a0 = COPY %38
    %a1 = COPY %44
    %a2 = COPY %58
    %a3 = COPY %59
    %gp = COPY %41
    %t9 = COPY %56
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 56, 0, implicit-def dead %sp, implicit %sp
    %60 = COPY %v0
    %61 = ANDi %60, 65535
    %63 = SLTu %62, %61
    BNE killed %63, %zero, %bb.65..loopexit, implicit-def dead %at
    B %bb.2, implicit-def dead %at
  
  bb.2 (%ir-block.23, freq 64142):
    successors: %bb.7(37), %bb.3(62)
  
    %64 = LBu %stack.6.ctb, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %65 = LW %41, target-flags(<unknown>) @is_key_ctb, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @is_key_ctb)
    %a0 = COPY %64
    %gp = COPY %41
    %t9 = COPY %65
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %66 = COPY %v0
    BEQ %66, %zero, %bb.7, implicit-def dead %at
    B %bb.3, implicit-def dead %at
  
  bb.3 (%ir-block.27, freq 40088):
    successors: %bb.4(96), %bb.65..loopexit(3)
  
    BNE %10, %zero, %bb.65..loopexit, implicit-def dead %at
    B %bb.4, implicit-def dead %at
  
  bb.4 (%ir-block.29, freq 38836):
    successors: %bb.6(50), %bb.5(50)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %67 = LW %41, target-flags(<unknown>) @extract_keyID, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @extract_keyID)
    %68 = LEA_ADDiu %stack.8.savekeyID, 0
    %69 = LEA_ADDiu %stack.2.n, 0
    %a0 = COPY %68
    %a1 = COPY %69
    %gp = COPY %41
    %t9 = COPY %67
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    BEQ %6, %zero, %bb.6, implicit-def dead %at
    B %bb.5, implicit-def dead %at
  
  bb.5 (%ir-block.33, freq 19418):
    successors: %bb.6(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %70 = LW %41, target-flags(<unknown>) @getKeyHash, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @getKeyHash)
    %71 = LEA_ADDiu %stack.9.hash, 0
    %72 = LEA_ADDiu %stack.2.n, 0
    %73 = LEA_ADDiu %stack.3.e, 0
    %a0 = COPY %71
    %a1 = COPY %72
    %a2 = COPY %73
    %gp = COPY %41
    %t9 = COPY %70
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.6 (%ir-block.37, freq 38836):
    successors: %bb.1..thread(100)
  
    %15 = COPY %60
    %74 = ADDiu %zero, 1
    %16 = LBu %stack.6.ctb, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    B %bb.1..thread, implicit-def dead %at
  
  bb.7 (%ir-block.39, freq 24053):
    successors: %bb.11(33), %bb.68(66)
  
    %75 = LBu %stack.6.ctb, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.ctb, align 4, !tbaa !6)
    BEQ %75, %76, %bb.11, implicit-def dead %at
    B %bb.68, implicit-def dead %at
  
  bb.68 (%ir-block.39, freq 16035):
    successors: %bb.8(50), %bb.51(49)
  
    BNE %75, %265, %bb.51, implicit-def dead %at
    B %bb.8, implicit-def dead %at
  
  bb.8 (%ir-block.42, freq 8017):
    successors: %bb.10(25), %bb.70(75)
  
    BLTZ %7, %bb.10, implicit-def dead %at
    B %bb.70, implicit-def dead %at
  
  bb.70 (%ir-block.42, freq 6013):
    successors: %bb.10(33), %bb.9(66)
  
    BNE %9, %zero, %bb.10, implicit-def dead %at
    B %bb.9, implicit-def dead %at
  
  bb.9 (%ir-block.45, freq 4008):
    successors: %bb.10(100)
  
    %287 = LBu %stack.7.keyctrl, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.keyctrl, align 4, !tbaa !6)
    %288 = ANDi killed %287, 32
    %18 = MOVZ_I_I %13, killed %288, %261
  
  bb.10 (%ir-block.49, freq 8017):
    successors: %bb.1..thread(100)
  
    %19 = PHI %13, %bb.8, %13, %bb.70, %18, %bb.9
    %20 = MOVZ_I_I %11, %4, %261
    B %bb.1..thread, implicit-def dead %at
  
  bb.11 (%ir-block.51, freq 8017):
    successors: %bb.12(37), %bb.40(62)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %78 = LW %41, target-flags(<unknown>) @PascalToC, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @PascalToC)
    %a0 = COPY %55
    %gp = COPY %41
    %t9 = COPY %78
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    BNE %9, %zero, %bb.40, implicit-def dead %at
    B %bb.12, implicit-def dead %at
  
  bb.12 (%ir-block.54, freq 3006):
    successors: %bb.14(96), %bb.13(3)
  
    BEQ %2, %zero, %bb.14, implicit-def dead %at
    B %bb.13, implicit-def dead %at
  
  bb.13 (%ir-block.56, freq 93):
    successors: %bb.65..loopexit(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %95 = LW %41, target-flags(<unknown>) @key2IDstring, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @key2IDstring)
    %96 = LEA_ADDiu %stack.2.n, 0
    %a0 = COPY %96
    %gp = COPY %41
    %t9 = COPY %95
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %97 = COPY %v0
    %99 = LW %178, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %100 = LW %41, target-flags(<unknown>) @.str.35, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %101 = ADDiu killed %100, target-flags(<unknown>) @.str.35
    %102 = LW %41, target-flags(<unknown>) @fprintf, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %99
    %a1 = COPY %101
    %a2 = COPY %97
    %gp = COPY %41
    %t9 = COPY %102
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %94 = ADDiu %zero, 1
    B %bb.65..loopexit, implicit-def dead %at
  
  bb.14 (%ir-block.61, freq 2912):
    successors: %bb.28(96), %bb.15(3)
  
    BEQ %5, %zero, %bb.28, implicit-def dead %at
    B %bb.15, implicit-def dead %at
  
  bb.15 (%ir-block.63, freq 91):
    successors: %bb.16(50), %bb.17(50)
  
    %21 = ANDi %8, 124
    %104 = ADDiu %zero, 24
    BNE %21, killed %104, %bb.17, implicit-def dead %at
    B %bb.16, implicit-def dead %at
  
  bb.16 (%ir-block.67, freq 45):
    successors: %bb.20(100)
  
    %120 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %121 = LW %41, target-flags(<unknown>) @.str.17, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %122 = ADDiu killed %121, target-flags(<unknown>) @.str.17
    %123 = LW %41, target-flags(<unknown>) @fwrite, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @fwrite)
    %124 = ADDiu %zero, 3
    %125 = ADDiu %zero, 1
    %a0 = COPY %122
    %a1 = COPY %124
    %a2 = COPY %125
    %a3 = COPY %120
    %gp = COPY %41
    %t9 = COPY %123
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.20, implicit-def dead %at
  
  bb.17 (%ir-block.70, freq 45):
    successors: %bb.18(50), %bb.19(50)
  
    %22 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    %106 = ADDiu %zero, 20
    BNE %21, killed %106, %bb.19, implicit-def dead %at
    B %bb.18, implicit-def dead %at
  
  bb.18 (%ir-block.73, freq 22):
    successors: %bb.20(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %113 = LW %41, target-flags(<unknown>) @.str.18, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %114 = ADDiu killed %113, target-flags(<unknown>) @.str.18
    %115 = LW %41, target-flags(<unknown>) @fwrite, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fwrite)
    %116 = ADDiu %zero, 3
    %117 = ADDiu %zero, 1
    %a0 = COPY %114
    %a1 = COPY %116
    %a2 = COPY %117
    %a3 = COPY %22
    %gp = COPY %41
    %t9 = COPY %115
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.20, implicit-def dead %at
  
  bb.19 (%ir-block.75, freq 22):
    successors: %bb.20(100)
  
    %107 = LW %41, target-flags(<unknown>) @.str.19, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %108 = ADDiu killed %107, target-flags(<unknown>) @.str.19
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %109 = LW %41, target-flags(<unknown>) @fwrite, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fwrite)
    %110 = ADDiu %zero, 3
    %111 = ADDiu %zero, 1
    %a0 = COPY %108
    %a1 = COPY %110
    %a2 = COPY %111
    %a3 = COPY %22
    %gp = COPY %41
    %t9 = COPY %109
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.20 (%ir-block.77, freq 91):
    successors: %bb.21(37), %bb.22(62)
  
    BGEZ %7, %bb.22, implicit-def dead %at
    B %bb.21, implicit-def dead %at
  
  bb.21 (%ir-block.79, freq 34):
    successors: %bb.27(100)
  
    %149 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %150 = LW %41, target-flags(<unknown>) @.str.20, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %151 = ADDiu killed %150, target-flags(<unknown>) @.str.20
    %152 = LW %41, target-flags(<unknown>) @fwrite, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @fwrite)
    %153 = ADDiu %zero, 2
    %154 = ADDiu %zero, 1
    %a0 = COPY %151
    %a1 = COPY %153
    %a2 = COPY %154
    %a3 = COPY %149
    %gp = COPY %41
    %t9 = COPY %152
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.27, implicit-def dead %at
  
  bb.22 (%ir-block.82, freq 56):
    successors: %bb.24(37), %bb.23(62)
  
    BEQ %12, %zero, %bb.24, implicit-def dead %at
    B %bb.23, implicit-def dead %at
  
  bb.23 (%ir-block.84, freq 35):
    successors: %bb.27(100)
  
    %128 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %129 = LW %41, target-flags(<unknown>) @.str.21, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %130 = ADDiu killed %129, target-flags(<unknown>) @.str.21
    %131 = LW %41, target-flags(<unknown>) @fwrite, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @fwrite)
    %132 = ADDiu %zero, 2
    %133 = ADDiu %zero, 1
    %a0 = COPY %130
    %a1 = COPY %132
    %a2 = COPY %133
    %a3 = COPY %128
    %gp = COPY %41
    %t9 = COPY %131
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.27, implicit-def dead %at
  
  bb.24 (%ir-block.87, freq 21):
    successors: %bb.26(37), %bb.25(62)
  
    %23 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    BEQ %13, %zero, %bb.26, implicit-def dead %at
    B %bb.25, implicit-def dead %at
  
  bb.25 (%ir-block.90, freq 13):
    successors: %bb.27(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %136 = LW %41, target-flags(<unknown>) @.str.22, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %137 = ADDiu killed %136, target-flags(<unknown>) @.str.22
    %138 = LW %41, target-flags(<unknown>) @fwrite, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fwrite)
    %139 = ADDiu %zero, 2
    %140 = ADDiu %zero, 1
    %a0 = COPY %137
    %a1 = COPY %139
    %a2 = COPY %140
    %a3 = COPY %23
    %gp = COPY %41
    %t9 = COPY %138
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.27, implicit-def dead %at
  
  bb.26 (%ir-block.92, freq 8):
    successors: %bb.27(100)
  
    %142 = LW %41, target-flags(<unknown>) @.str.23, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %143 = ADDiu killed %142, target-flags(<unknown>) @.str.23
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %144 = LW %41, target-flags(<unknown>) @fwrite, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fwrite)
    %145 = ADDiu %zero, 2
    %146 = ADDiu %zero, 1
    %a0 = COPY %143
    %a1 = COPY %145
    %a2 = COPY %146
    %a3 = COPY %23
    %gp = COPY %41
    %t9 = COPY %144
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.27 (%ir-block.94, freq 91):
    successors: %bb.65..loopexit(100)
  
    %158 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %159 = LW %41, target-flags(<unknown>) @countbits, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @countbits)
    %160 = LEA_ADDiu %stack.2.n, 0
    %a0 = COPY %160
    %gp = COPY %41
    %t9 = COPY %159
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %161 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %162 = LW %41, target-flags(<unknown>) @key2IDstring, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @key2IDstring)
    %a0 = COPY %160
    %gp = COPY %41
    %t9 = COPY %162
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %163 = COPY %v0
    %164 = LEA_ADDiu %stack.5.timestamp, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %165 = LW %41, target-flags(<unknown>) @cdate, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cdate)
    %a0 = COPY %164
    %gp = COPY %41
    %t9 = COPY %165
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %166 = COPY %v0
    %167 = LW %41, target-flags(<unknown>) @.str.24, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %168 = ADDiu killed %167, target-flags(<unknown>) @.str.24
    ADJCALLSTACKDOWN 24, implicit-def dead %sp, implicit %sp
    %169 = COPY %sp
    SW %166, %169, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %170 = LW %41, target-flags(<unknown>) @fprintf, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %158
    %a1 = COPY %168
    %a2 = COPY %161
    %a3 = COPY %163
    %gp = COPY %41
    %t9 = COPY %170
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 24, 0, implicit-def dead %sp, implicit %sp
    %172 = LW %41, target-flags(<unknown>) @.str.12, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %173 = ADDiu killed %172, target-flags(<unknown>) @.str.12
    %174 = LEA_ADDiu %stack.1.userid, 0
    %175 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %176 = LW %41, target-flags(<unknown>) @fprintf, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %175
    %a1 = COPY %173
    %a2 = COPY %174
    %t9 = COPY %176
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %156 = ADDiu %zero, 1
    B %bb.65..loopexit, implicit-def dead %at
  
  bb.28 (%ir-block.104, freq 2821):
    successors: %bb.30(33), %bb.69(66)
  
    %179 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %182 = LW %41, target-flags(<unknown>) @LANG, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @LANG)
    %a0 = COPY %181
    %gp = COPY %41
    %t9 = COPY %182
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %183 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %185 = LW %41, target-flags(<unknown>) @fprintf, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %179
    %a1 = COPY %183
    %a2 = COPY %55
    %gp = COPY %41
    %t9 = COPY %185
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %189 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %190 = LW %41, target-flags(<unknown>) @LANG, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @LANG)
    %a0 = COPY %188
    %t9 = COPY %190
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %191 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %193 = LW %41, target-flags(<unknown>) @countbits, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @countbits)
    %a0 = COPY %54
    %gp = COPY %41
    %t9 = COPY %193
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %194 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %195 = LW %41, target-flags(<unknown>) @key2IDstring, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @key2IDstring)
    %a0 = COPY %54
    %gp = COPY %41
    %t9 = COPY %195
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %196 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %198 = LW %41, target-flags(<unknown>) @cdate, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cdate)
    %a0 = COPY %59
    %gp = COPY %41
    %t9 = COPY %198
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %199 = COPY %v0
    ADJCALLSTACKDOWN 24, implicit-def dead %sp, implicit %sp
    %200 = COPY %sp
    SW %199, %200, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %201 = LW %41, target-flags(<unknown>) @fprintf, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %189
    %a1 = COPY %191
    %a2 = COPY %194
    %a3 = COPY %196
    %t9 = COPY %201
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 24, 0, implicit-def dead %sp, implicit %sp
    BEQ %7, %203, %bb.30, implicit-def dead %at
    B %bb.69, implicit-def dead %at
  
  bb.69 (%ir-block.104, freq 1881):
    successors: %bb.29(50), %bb.31(49)
  
    BNE %7, %204, %bb.31, implicit-def dead %at
    B %bb.29, implicit-def dead %at
  
  bb.29 (%ir-block.116, freq 940):
    successors: %bb.33(100)
  
    %214 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %215 = LW %41, target-flags(<unknown>) @.str.27, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %216 = ADDiu killed %215, target-flags(<unknown>) @.str.27
    %217 = LW %41, target-flags(<unknown>) @LANG, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @LANG)
    %a0 = COPY %216
    %t9 = COPY %217
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %218 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %219 = LW %41, target-flags(<unknown>) @fprintf, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %214
    %a1 = COPY %218
    %t9 = COPY %219
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.33, implicit-def dead %at
  
  bb.30 (%ir-block.120, freq 940):
    successors: %bb.33(100)
  
    %206 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %209 = LW %41, target-flags(<unknown>) @LANG, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @LANG)
    %a0 = COPY %208
    %t9 = COPY %209
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %210 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %211 = LW %41, target-flags(<unknown>) @fprintf, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %206
    %a1 = COPY %210
    %t9 = COPY %211
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.33, implicit-def dead %at
  
  bb.31 (%ir-block.124, freq 940):
    successors: %bb.33(50), %bb.32(50)
  
    BEQ %6, %zero, %bb.33, implicit-def dead %at
    B %bb.32, implicit-def dead %at
  
  bb.32 (%ir-block.126, freq 470):
    successors: %bb.33(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %221 = LW %41, target-flags(<unknown>) @printKeyHash, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @printKeyHash)
    %223 = LEA_ADDiu %stack.9.hash, 0
    %a0 = COPY %223
    %a1 = COPY %44
    %gp = COPY %41
    %t9 = COPY %221
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.33 (%ir-block.128, freq 2821):
    successors: %bb.35(37), %bb.34(62)
  
    BEQ %12, %zero, %bb.35, implicit-def dead %at
    B %bb.34, implicit-def dead %at
  
  bb.34 (%ir-block.130, freq 1763):
    successors: %bb.35(100)
  
    %225 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %228 = LW %41, target-flags(<unknown>) @LANG, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @LANG)
    %a0 = COPY %227
    %t9 = COPY %228
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %229 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %230 = LW %41, target-flags(<unknown>) @fprintf, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %225
    %a1 = COPY %229
    %t9 = COPY %230
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.35 (%ir-block.134, freq 2821):
    successors: %bb.37(37), %bb.36(62)
  
    BEQ %13, %zero, %bb.37, implicit-def dead %at
    B %bb.36, implicit-def dead %at
  
  bb.36 (%ir-block.136, freq 1763):
    successors: %bb.37(100)
  
    %233 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %236 = LW %41, target-flags(<unknown>) @LANG, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @LANG)
    %a0 = COPY %235
    %t9 = COPY %236
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %237 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %238 = LW %41, target-flags(<unknown>) @fprintf, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %233
    %a1 = COPY %237
    %t9 = COPY %238
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.37 (%ir-block.140, freq 2821):
    successors: %bb.1..thread(50), %bb.38(50)
  
    %242 = ANDi %11, 255
    %241 = ADDiu %zero, 0
    %240 = ADDiu %zero, 1
    BEQ killed %242, %zero, %bb.1..thread, implicit-def dead %at
    B %bb.38, implicit-def dead %at
  
  bb.38 (%ir-block.142, freq 1410):
    successors: %bb.44..thread14(37), %bb.39(62)
  
    %246 = LBu %stack.7.keyctrl, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.keyctrl, align 4, !tbaa !6)
    %247 = ANDi killed %246, 7
    %248 = SLL killed %247, 2
    %249 = ADDu %245, killed %248
    %24 = LW killed %249, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.146, !tbaa !9)
    %243 = ADDiu %zero, 1
    %250 = LBu %24, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 1 from %ir.147, !tbaa !6)
    BEQ killed %250, %zero, %bb.44..thread14, implicit-def dead %at
    B %bb.39, implicit-def dead %at
  
  bb.39 (%ir-block.150, freq 881):
    successors: %bb.43(100)
  
    %253 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %254 = LW %41, target-flags(<unknown>) @LANG, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @LANG)
    %a0 = COPY %24
    %t9 = COPY %254
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %255 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %256 = LW %41, target-flags(<unknown>) @fprintf, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %253
    %a1 = COPY %255
    %t9 = COPY %256
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %251 = ADDiu %zero, 1
    B %bb.43, implicit-def dead %at
  
  bb.40 (%ir-block.154, freq 5011):
    successors: %bb.42(37), %bb.41(62)
  
    BEQ %40, %zero, %bb.42, implicit-def dead %at
    B %bb.41, implicit-def dead %at
  
  bb.41 (%ir-block.156, freq 3131):
    successors: %bb.42(100)
  
    %81 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %82 = LW %41, target-flags(<unknown>) @fputc, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from call-entry @fputc)
    %a0 = COPY %83
    %a1 = COPY %81
    %gp = COPY %41
    %t9 = COPY %82
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.42 (%ir-block.158, freq 5011):
    successors: %bb.43(100)
  
    %86 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %87 = LW %41, target-flags(<unknown>) @.str.32, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %88 = ADDiu killed %87, target-flags(<unknown>) @.str.32
    %89 = LW %41, target-flags(<unknown>) @LANG, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @LANG)
    %a0 = COPY %88
    %gp = COPY %41
    %t9 = COPY %89
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %90 = COPY %v0
    %91 = LEA_ADDiu %stack.1.userid, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %92 = LW %41, target-flags(<unknown>) @fprintf, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %86
    %a1 = COPY %90
    %a2 = COPY %91
    %gp = COPY %41
    %t9 = COPY %92
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.43 (%ir-block.163, freq 5892):
    successors: %bb.1..thread(50), %bb.44..thread14(50)
  
    %25 = PHI %9, %bb.42, %251, %bb.39
    %259 = ANDi %11, 255
    %258 = ADDiu %zero, 0
    BEQ killed %259, %zero, %bb.1..thread, implicit-def dead %at
    B %bb.44..thread14, implicit-def dead %at
  
  bb.44..thread14 (freq 3475):
    successors: %bb.45(50), %bb.50.read_trust.exit(50)
  
    %26 = PHI %243, %bb.38, %25, %bb.43
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %260 = LW %41, target-flags(<unknown>) @fread, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fread)
    %263 = LEA_ADDiu %stack.0.buf.i, 0
    %a0 = COPY %263
    %a1 = COPY %261
    %a2 = COPY %262
    %a3 = COPY %38
    %gp = COPY %41
    %t9 = COPY %260
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %264 = COPY %v0
    BNE %264, %262, %bb.50.read_trust.exit, implicit-def dead %at
    B %bb.45, implicit-def dead %at
  
  bb.45 (%ir-block.168, freq 1737):
    successors: %bb.48(50), %bb.46(50)
  
    %27 = LW %stack.0.buf.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.169)
    %28 = SRL %27, 24
    BEQ %28, %265, %bb.48, implicit-def dead %at
    B %bb.46, implicit-def dead %at
  
  bb.46 (%ir-block.175, freq 868):
    successors: %bb.47(37), %bb.50.read_trust.exit(62)
  
    %266 = SEB %28
    BGEZ killed %266, %bb.50.read_trust.exit, implicit-def dead %at
    B %bb.47, implicit-def dead %at
  
  bb.47 (%ir-block.178, freq 325):
    successors: %bb.50.read_trust.exit(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %267 = LW %41, target-flags(<unknown>) @fseek, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fseek)
    %a0 = COPY %38
    %a1 = COPY %268
    %a2 = COPY %261
    %t9 = COPY %267
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.50.read_trust.exit, implicit-def dead %at
  
  bb.48 (%ir-block.180, freq 868):
    successors: %bb.49(50), %bb.50.read_trust.exit(50)
  
    %272 = AND %27, %271
    BNE killed %272, %273, %bb.50.read_trust.exit, implicit-def dead %at
    B %bb.49, implicit-def dead %at
  
  bb.49 (%ir-block.183, freq 434):
    successors: %bb.50.read_trust.exit(100)
  
    %29 = SRL %27, 8
    SB %29, %stack.7.keyctrl, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.keyctrl, align 4, !tbaa !6)
  
  bb.50.read_trust.exit (freq 3475):
    successors: %bb.1..thread(100)
  
    %274 = LW %41, target-flags(<unknown>) @keylegit_msg, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %275 = ADDiu killed %274, target-flags(<unknown>) @keylegit_msg
    %276 = LBu %stack.7.keyctrl, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 1 from %ir.keyctrl, align 4, !tbaa !6)
    %277 = ANDi killed %276, 3
    %278 = SLL killed %277, 2
    %279 = ADDu killed %275, killed %278
    %281 = LW killed %279, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from %ir.190, !tbaa !9)
    %282 = LW %178, 0, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %283 = LW %41, target-flags(<unknown>) @LANG, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @LANG)
    %a0 = COPY %281
    %gp = COPY %41
    %t9 = COPY %283
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %284 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %285 = LW %41, target-flags(<unknown>) @fprintf, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %282
    %a1 = COPY %284
    %gp = COPY %41
    %t9 = COPY %285
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.1..thread, implicit-def dead %at
  
  bb.51 (%ir-block.194, freq 8017):
    successors: %bb.52(50), %bb.1..thread(50)
  
    %291 = ANDi %75, 124
    BNE killed %291, %292, %bb.1..thread, implicit-def dead %at
    B %bb.52, implicit-def dead %at
  
  bb.52 (%ir-block.197, freq 4008):
    successors: %bb.54(96), %bb.53(3)
  
    %30 = MOVZ_I_I %261, %9, %12
    BEQ %2, %zero, %bb.54, implicit-def dead %at
    B %bb.53, implicit-def dead %at
  
  bb.53 (%ir-block.200, freq 125):
    successors: %bb.65..loopexit(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %294 = LW %41, target-flags(<unknown>) @key2IDstring, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @key2IDstring)
    %295 = LEA_ADDiu %stack.2.n, 0
    %a0 = COPY %295
    %gp = COPY %41
    %t9 = COPY %294
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %296 = COPY %v0
    %298 = LW %178, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %299 = LW %41, target-flags(<unknown>) @.str.35, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from got)
    %300 = ADDiu killed %299, target-flags(<unknown>) @.str.35
    %301 = LW %41, target-flags(<unknown>) @fprintf, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %298
    %a1 = COPY %300
    %a2 = COPY %296
    %gp = COPY %41
    %t9 = COPY %301
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.65..loopexit, implicit-def dead %at
  
  bb.54 (%ir-block.205, freq 3883):
    successors: %bb.1..thread(50), %bb.55(50)
  
    BEQ %3, %zero, %bb.1..thread, implicit-def dead %at
    B %bb.55, implicit-def dead %at
  
  bb.55 (%ir-block.207, freq 1941):
    successors: %bb.63(37), %bb.56(62)
  
    %303 = ANDi %11, 255
    BEQ killed %303, %zero, %bb.63, implicit-def dead %at
    B %bb.56, implicit-def dead %at
  
  bb.56 (%ir-block.209, freq 1213):
    successors: %bb.57(50), %bb.62.read_trust.exit13(50)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %304 = LW %41, target-flags(<unknown>) @fread, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fread)
    %307 = LEA_ADDiu %stack.0.buf.i, 0
    %a0 = COPY %307
    %a1 = COPY %261
    %a2 = COPY %262
    %a3 = COPY %38
    %gp = COPY %41
    %t9 = COPY %304
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %308 = COPY %v0
    BNE %308, %262, %bb.62.read_trust.exit13, implicit-def dead %at
    B %bb.57, implicit-def dead %at
  
  bb.57 (%ir-block.213, freq 606):
    successors: %bb.60(50), %bb.58(50)
  
    %31 = LW %stack.0.buf.i, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from %ir.214)
    %32 = SRL %31, 24
    BEQ %32, %265, %bb.60, implicit-def dead %at
    B %bb.58, implicit-def dead %at
  
  bb.58 (%ir-block.220, freq 303):
    successors: %bb.59(37), %bb.62.read_trust.exit13(62)
  
    %310 = SEB %32
    BGEZ killed %310, %bb.62.read_trust.exit13, implicit-def dead %at
    B %bb.59, implicit-def dead %at
  
  bb.59 (%ir-block.223, freq 113):
    successors: %bb.62.read_trust.exit13(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %311 = LW %41, target-flags(<unknown>) @fseek, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fseek)
    %a0 = COPY %38
    %a1 = COPY %268
    %a2 = COPY %261
    %t9 = COPY %311
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.62.read_trust.exit13, implicit-def dead %at
  
  bb.60 (%ir-block.225, freq 303):
    successors: %bb.61(50), %bb.62.read_trust.exit13(50)
  
    %316 = AND %31, %271
    BNE killed %316, %273, %bb.62.read_trust.exit13, implicit-def dead %at
    B %bb.61, implicit-def dead %at
  
  bb.61 (%ir-block.228, freq 151):
    successors: %bb.62.read_trust.exit13(100)
  
    %33 = SRL %31, 8
    SB %33, %stack.7.keyctrl, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 1 into %ir.keyctrl, align 4, !tbaa !6)
  
  bb.62.read_trust.exit13 (freq 1213):
    successors: %bb.64(100)
  
    %318 = LW %41, target-flags(<unknown>) @sigtrust_msg, <0x47438e0> = !{!"unison-memory-partition", i32 5} :: (load 4 from got)
    %319 = ADDiu killed %318, target-flags(<unknown>) @sigtrust_msg
    %320 = LBu %stack.7.keyctrl, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 1 from %ir.keyctrl, align 4, !tbaa !6)
    %321 = ANDi killed %320, 7
    %322 = SLL killed %321, 2
    %323 = ADDu killed %319, killed %322
    %325 = LW killed %323, 0, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from %ir.235, !tbaa !9)
    %326 = LW %178, 0, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %327 = LW %41, target-flags(<unknown>) @LANG, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @LANG)
    %a0 = COPY %325
    %gp = COPY %41
    %t9 = COPY %327
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %328 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %329 = LW %41, target-flags(<unknown>) @fprintf, <0x476a0f0> = !{!"unison-memory-partition", i32 4} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %326
    %a1 = COPY %328
    %gp = COPY %41
    %t9 = COPY %329
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.64, implicit-def dead %at
  
  bb.63 (%ir-block.239, freq 728):
    successors: %bb.64(100)
  
    %332 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %333 = LW %41, target-flags(<unknown>) @.str.33, <0x451aac0> = !{!"unison-memory-partition", i32 1} :: (load 4 from got)
    %334 = ADDiu killed %333, target-flags(<unknown>) @.str.33
    %335 = LW %41, target-flags(<unknown>) @LANG, <0x46ad630> = !{!"unison-memory-partition", i32 2} :: (load 4 from call-entry @LANG)
    %a0 = COPY %334
    %gp = COPY %41
    %t9 = COPY %335
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %336 = COPY %v0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %337 = LW %41, target-flags(<unknown>) @fprintf, <0x469aea0> = !{!"unison-memory-partition", i32 3} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %332
    %a1 = COPY %336
    %gp = COPY %41
    %t9 = COPY %337
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
  
  bb.64 (%ir-block.243, freq 1941):
    successors: %bb.1..thread(100)
  
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %339 = LW %41, target-flags(<unknown>) @show_userid, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @show_userid)
    %340 = LEA_ADDiu %stack.4.sigkeyID, 0
    %a0 = COPY %38
    %a1 = COPY %340
    %gp = COPY %41
    %t9 = COPY %339
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %gp, implicit-def %sp
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    B %bb.1..thread, implicit-def dead %at
  
  bb.65..loopexit (freq 3632):
    successors: %bb.71..loopexit(75), %bb.67(25)
  
    %34 = PHI %9, %bb.1..thread, %9, %bb.3, %94, %bb.13, %156, %bb.27, %9, %bb.53
    %35 = PHI %12, %bb.1..thread, %12, %bb.3, %12, %bb.13, %12, %bb.27, %30, %bb.53
    %343 = MOVN_I_I killed %zero, %34, %60
    %345 = XORi %61, 65535
    %36 = MOVZ_I_I killed %343, killed %345, %60
    %346 = ADDiu %zero, 16
    BEQ %40, killed %346, %bb.67, implicit-def dead %at
    B %bb.71..loopexit, implicit-def dead %at
  
  bb.71..loopexit (freq 2724):
    successors: %bb.66(66), %bb.67(33)
  
    %341 = OR %35, %34
    BNE %341, %zero, %bb.67, implicit-def dead %at
    B %bb.66, implicit-def dead %at
  
  bb.66 (%ir-block.249, freq 1816):
    successors: %bb.67(100)
  
    %349 = LW %178, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from @pgpout, !tbaa !9)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %350 = LW %41, target-flags(<unknown>) @.str.34, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from got)
    %351 = ADDiu killed %350, target-flags(<unknown>) @.str.34
    %352 = LW %41, target-flags(<unknown>) @LANG, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @LANG)
    %a0 = COPY %351
    %gp = COPY %41
    %t9 = COPY %352
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %353 = COPY %v0
    %354 = LEA_ADDiu %stack.2.n, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %355 = LW %41, target-flags(<unknown>) @countbits, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @countbits)
    %a0 = COPY %354
    %gp = COPY %41
    %t9 = COPY %355
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %356 = COPY %v0
    %357 = LEA_ADDiu %stack.8.savekeyID, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %358 = LW %41, target-flags(<unknown>) @keyIDstring, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @keyIDstring)
    %a0 = COPY %357
    %gp = COPY %41
    %t9 = COPY %358
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %359 = COPY %v0
    %360 = LEA_ADDiu %stack.5.timestamp, 0
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %361 = LW %41, target-flags(<unknown>) @cdate, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @cdate)
    %a0 = COPY %360
    %gp = COPY %41
    %t9 = COPY %361
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %362 = COPY %v0
    ADJCALLSTACKDOWN 24, implicit-def dead %sp, implicit %sp
    %363 = COPY %sp
    SW %362, %363, 16, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 4 into unknown)
    %364 = LW %41, target-flags(<unknown>) @fprintf, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fprintf)
    %a0 = COPY %349
    %a1 = COPY %353
    %a2 = COPY %356
    %a3 = COPY %359
    %gp = COPY %41
    %t9 = COPY %364
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit %a3, implicit %gp, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 24, 0, implicit-def dead %sp, implicit %sp
    %347 = ADDiu %zero, -1
  
  bb.67 (%ir-block.258, freq 3632):
    liveouts: %v0
  
    %37 = PHI %36, %bb.65..loopexit, %36, %bb.71..loopexit, %347, %bb.66
    SH %0, %45, 0, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (store 2 into @global_precision, !tbaa !34)
    ADJCALLSTACKDOWN 16, implicit-def dead %sp, implicit %sp
    %367 = LW %41, target-flags(<unknown>) @fseek, <0x4587d30> = !{!"unison-memory-partition", i32 0} :: (load 4 from call-entry @fseek)
    %368 = ADDiu %zero, 0
    %a0 = COPY %38
    %a1 = COPY %1
    %a2 = COPY %368
    %t9 = COPY %367
    JALRPseudo killed %t9, csr_o32, implicit-def dead %ra, implicit %a0, implicit %a1, implicit %a2, implicit-def %sp, implicit-def %v0
    ADJCALLSTACKUP 16, 0, implicit-def dead %sp, implicit %sp
    %v0 = COPY %37
    RetRA implicit %v0

...
